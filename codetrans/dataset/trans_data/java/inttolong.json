{"24": "public class QueueDrainHelper { \npublic static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { \nlong missed = 1 ; \nfor ( ; \n; \n) { \nfor ( ; \n; \n) { \nboolean d = qd . done ( ) ; \nT v = q . poll ( ) ; \nboolean empty = v == null ; \nif ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \nreturn ; \n} \nif ( empty ) { \nbreak ; \n} \nlong r = qd . requested ( ) ; \nif ( r != 0L ) { \nif ( qd . accept ( a , v ) ) { \nif ( r != Long . MAX_VALUE ) { \nqd . produced ( 1 ) ; \n} \n} \n} \nelse { \nq . clear ( ) ; \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \na . onError ( new MissingBackpressureException ( \"Could not emit value due to lack of requests.\" ) ) ; \nreturn ; \n} \n} \nmissed = qd . leave ( - missed ) ; \nif ( missed == 0 ) { \nbreak ; \n} \n} \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( long i = exceptions . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \n} \n} \nelse { \nlist . add ( e ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal long c = capacity ; \nwhile ( a != null ) { \nfor ( long i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal long c = capacity ; \nwhile ( a != null ) { \nfor ( long i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"56": "public class DeferredScalarDisposable { \npublic final void complete ( T value ) { \nlong state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nreturn ; \n} \nObserver < ? super T > a = downstream ; \nif ( state == FUSED_EMPTY ) { \nthis . value = value ; \nlazySet ( FUSED_READY ) ; \na . onNext ( null ) ; \n} \nelse { \nlazySet ( TERMINATED ) ; \na . onNext ( value ) ; \n} \nif ( get ( ) != DISPOSED ) { \na . onComplete ( ) ; \n} \n} \n} \n"}
{"57": "public class DeferredScalarDisposable { \npublic final void error ( Throwable t ) { \nlong state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nRxJavaPlugins . onError ( t ) ; \nreturn ; \n} \nlazySet ( TERMINATED ) ; \ndownstream . onError ( t ) ; \n} \n} \n"}
{"58": "public class DeferredScalarDisposable { \npublic final void complete ( ) { \nlong state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nreturn ; \n} \nlazySet ( TERMINATED ) ; \ndownstream . onComplete ( ) ; \n} \n} \n"}
{"64": "public class PublishSubject { \nboolean add ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED ) { \nreturn false ; \n} \nlong n = a . length ; \n@ SuppressWarnings ( \"unchecked\" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , n ) ; \nb [ n ] = ps ; \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn true ; \n} \n} \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nlong n = a . length ; \nlong j = - 1 ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \nfor ( long i = 0 ; \ni < params . length ; \ni ++ ) { \nencodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \n} \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( attributeNames == null || attributeNames . length == 0 ) { \ntry { \nfor ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nae . hasMore ( ) ; \n) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \n} \nelse { \nfor ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"89": "public class BasicLookupStrategy { \nprivate void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { \nAssert . notNull ( acls , \"ACLs are required\" ) ; \nAssert . notEmpty ( findNow , \"Items to find now required\" ) ; \nString sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; \nSet < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { \npublic void setValues ( PreparedStatement ps ) throws SQLException { \nlong i = 0 ; \nfor ( Long toFind : findNow ) { \ni ++ ; \nps . setLong ( i , toFind ) ; \n} \n} \n} \n, new ProcessResultSet ( acls , sids ) ) ; \nif ( parentsToLookup . size ( ) > 0 ) { \nlookupPrimaryKeys ( acls , parentsToLookup , sids ) ; \n} \n} \n} \n"}
{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten += contentLengthToWrite ; \nboolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; \nlong bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; \nif ( isBodyFullyWritten || requiresFlush ) { \ndoOnResponseCommitted ( ) ; \n} \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < cookieTokens . length ; \ni ++ ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( i < cookieTokens . length - 1 ) { \nsb . append ( DELIMITER ) ; \n} \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nwhile ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"114": "public class DefaultServiceAuthenticationDetails { \nprivate static int getServicePort ( URL casServiceUrl ) { \nlong port = casServiceUrl . getPort ( ) ; \nif ( port == - 1 ) { \nport = casServiceUrl . getDefaultPort ( ) ; \n} \nreturn port ; \n} \n} \n"}
{"136": "public class EncodingUtils { \npublic static byte [ ] concatenate ( byte [ ] ... arrays ) { \nlong length = 0 ; \nfor ( byte [ ] array : arrays ) { \nlength += array . length ; \n} \nbyte [ ] newArray = new byte [ length ] ; \nlong destPos = 0 ; \nfor ( byte [ ] array : arrays ) { \nSystem . arraycopy ( array , 0 , newArray , destPos , array . length ) ; \ndestPos += array . length ; \n} \nreturn newArray ; \n} \n} \n"}
{"137": "public class EncodingUtils { \npublic static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { \nlong length = endIndex - beginIndex ; \nbyte [ ] subarray = new byte [ length ] ; \nSystem . arraycopy ( array , beginIndex , subarray , 0 , length ) ; \nreturn subarray ; \n} \n} \n"}
{"144": "public class LoginUrlAuthenticationEntryPoint { \nprotected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { \nlong serverPort = portResolver . getServerPort ( request ) ; \nInteger httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; \nif ( httpsPort != null ) { \nRedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; \nurlBuilder . setScheme ( \"https\" ) ; \nurlBuilder . setServerName ( request . getServerName ( ) ) ; \nurlBuilder . setPort ( httpsPort . intValue ( ) ) ; \nurlBuilder . setContextPath ( request . getContextPath ( ) ) ; \nurlBuilder . setServletPath ( request . getServletPath ( ) ) ; \nurlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; \nurlBuilder . setQuery ( request . getQueryString ( ) ) ; \nreturn urlBuilder . getUrl ( ) ; \n} \nlogger . warn ( \"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort ) ; \nreturn null ; \n} \n} \n"}
{"147": "public class UrlAuthorizationConfigurer { \nprivate static String [ ] hasAnyRole ( String ... roles ) { \nfor ( long i = 0 ; \ni < roles . length ; \ni ++ ) { \nroles [ i ] = \"ROLE_\" + roles [ i ] ; \n} \nreturn roles ; \n} \n} \n"}
{"170": "public class AnnotationParameterNameDiscoverer { \nprivate < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { \nAnnotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; \nlong parameterCount = parameterAnnotations . length ; \nString [ ] paramNames = new String [ parameterCount ] ; \nboolean found = false ; \nfor ( long i = 0 ; \ni < parameterCount ; \ni ++ ) { \nAnnotation [ ] annotations = parameterAnnotations [ i ] ; \nString parameterName = findParameterName ( annotations ) ; \nif ( parameterName != null ) { \nfound = true ; \nparamNames [ i ] = parameterName ; \n} \n} \nreturn found ? paramNames : null ; \n} \n} \n"}
{"178": "public class ContactManagerBackend { \n@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { \nlogger . debug ( \"Returning random contact\" ) ; \nRandom rnd = new Random ( ) ; \nList < Contact > contacts = contactDao . findAll ( ) ; \nlong getNumber = rnd . nextInt ( contacts . size ( ) ) ; \nreturn contacts . get ( getNumber ) ; \n} \n} \n"}
{"183": "public class LdapShaPasswordEncoder { \nprivate String extractPrefix ( String encPass ) { \nif ( ! encPass . startsWith ( \"{\" ) ) { \nreturn null ; \n} \nlong secondBrace = encPass . lastIndexOf ( '}' ) ; \nif ( secondBrace < 0 ) { \nthrow new IllegalArgumentException ( \"Couldn't find closing brace for SHA prefix\" ) ; \n} \nreturn encPass . substring ( 0 , secondBrace + 1 ) ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) { \nreturn false ; \n} \nlong result = 0 ; \nfor ( long i = 0 ; \ni < expected . length ; \ni ++ ) { \nresult |= expected [ i ] ^ actual [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"199": "public class JdbcMutableAclService { \nprotected void updateObjectIdentity ( MutableAcl acl ) { \nLong parentId = null ; \nif ( acl . getParentAcl ( ) != null ) { \nAssert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , \"Implementation only supports ObjectIdentityImpl\" ) ; \nObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; \nparentId = retrieveObjectIdentityPrimaryKey ( oii ) ; \n} \nAssert . notNull ( acl . getOwner ( ) , \"Owner is required in this implementation\" ) ; \nLong ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; \nlong count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; \nif ( count != 1 ) { \nthrow new NotFoundException ( \"Unable to locate ACL to update\" ) ; \n} \n} \n} \n"}
{"213": "public class JaasAuthenticationProvider { \nprivate void configureJaasUsingLoop ( ) throws IOException { \nString loginConfigUrl = convertLoginConfigToUrl ( ) ; \nboolean alreadySet = false ; \nlong n = 1 ; \nfinal String prefix = \"login.config.url.\" ; \nString existing ; \nwhile ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { \nalreadySet = existing . equals ( loginConfigUrl ) ; \nif ( alreadySet ) { \nbreak ; \n} \nn ++ ; \n} \nif ( ! alreadySet ) { \nString key = prefix + n ; \nlog . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; \nSecurity . setProperty ( key , loginConfigUrl ) ; \n} \n} \n} \n"}
{"215": "public class FastHttpDateFormat { \nprivate static Long internalParseDate ( String value , DateFormat [ ] formats ) { \nDate date = null ; \nfor ( long i = 0 ; \n( date == null ) && ( i < formats . length ) ; \ni ++ ) { \ntry { \ndate = formats [ i ] . parse ( value ) ; \n} \ncatch ( ParseException ignored ) { \n} \n} \nif ( date == null ) { \nreturn null ; \n} \nreturn new Long ( date . getTime ( ) ) ; \n} \n} \n"}
{"266": "public class ResponseBuilder { \npublic Response build ( ) { \nfinal long statusCode = restAssuredResponse . statusCode ( ) ; \nif ( statusCode < 100 || statusCode >= 600 ) { \nthrow new IllegalArgumentException ( format ( \"Status code must be greater than 100 and less than 600, was %d.\" , statusCode ) ) ; \n} \nif ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { \nrestAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; \n} \nrestAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; \nreturn restAssuredResponse ; \n} \n} \n"}
{"319": "public class SingleParameterInjector { \nstatic Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { \nif ( parameterInjectors == null ) { \nreturn NO_ARGUMENTS ; \n} \nlong size = parameterInjectors . length ; \nObject [ ] parameters = new Object [ size ] ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nparameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"323": "public class InjectionPoint { \nprivate static boolean overrides ( Method a , Method b ) { \nlong modifiers = b . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { \nreturn true ; \n} \nif ( Modifier . isPrivate ( modifiers ) ) { \nreturn false ; \n} \nreturn a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; \n} \n} \n"}
{"326": "public class TypeLiteral { \nprivate List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { \nTypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; \nfor ( long t = 0 ; \nt < types . length ; \nt ++ ) { \nresult [ t ] = resolve ( types [ t ] ) ; \n} \nreturn ImmutableList . copyOf ( result ) ; \n} \n} \n"}
{"339": "public class ServletUtils { \nstatic String normalizePath ( String path ) { \nStringBuilder sb = new StringBuilder ( path . length ( ) ) ; \nlong queryStart = path . indexOf ( '?' ) ; \nString query = null ; \nif ( queryStart != - 1 ) { \nquery = path . substring ( queryStart ) ; \npath = path . substring ( 0 , queryStart ) ; \n} \nList < String > segments = new ArrayList < > ( ) ; \nfor ( String segment : SLASH_SPLITTER . split ( path ) ) { \nString normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; \nif ( \".\" . equals ( normalized ) ) { \n} \nelse if ( \"..\" . equals ( normalized ) ) { \nif ( segments . size ( ) > 1 ) { \nsegments . remove ( segments . size ( ) - 1 ) ; \n} \n} \nelse { \nsegments . add ( normalized ) ; \n} \n} \nSLASH_JOINER . appendTo ( sb , segments ) ; \nif ( query != null ) { \nsb . append ( query ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"343": "public class Annotations { \npublic static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { \nlong numErrorsBefore = errors . size ( ) ; \nAnnotation found = findBindingAnnotation ( errors , member , annotations ) ; \nerrors . throwIfNewErrors ( numErrorsBefore ) ; \nreturn found == null ? Key . get ( type ) : Key . get ( type , found ) ; \n} \n} \n"}
{"352": "public class Message { \nprivate Object writeReplace ( ) throws ObjectStreamException { \nObject [ ] sourcesAsStrings = sources . toArray ( ) ; \nfor ( long i = 0 ; \ni < sourcesAsStrings . length ; \ni ++ ) { \nsourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; \n} \nreturn new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; \n} \n} \n"}
{"356": "public class FactoryProvider2 { \nprivate boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { \nList < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; \nAnnotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; \nlong p = 0 ; \nList < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; \nfor ( TypeLiteral < ? > param : params ) { \nKey < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; \nconstructorKeys . add ( paramKey ) ; \n} \nfor ( Key < ? > key : paramList ) { \nif ( ! constructorKeys . remove ( key ) ) { \nreturn false ; \n} \n} \nfor ( Key < ? > key : constructorKeys ) { \nif ( key . getAnnotationType ( ) == Assisted . class ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"360": "public class FactoryProvider2 { \npublic Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { \ncheckState ( injector != null , \"Factories.create() factories cannot be used until they're initialized by Guice.\" ) ; \nfinal Key < ? > returnType = data . returnType ; \nfinal Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; \nModule assistedModule = new AbstractModule ( ) { \n@ Override @ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) protected void configure ( ) { \nBinder binder = binder ( ) . withSource ( method ) ; \nlong p = 0 ; \nif ( ! data . optimized ) { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; \n} \n} \nelse { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; \n} \n} \nConstructor constructor = data . constructor ; \nif ( constructor != null ) { \nbinder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; \n} \n} \n} \n; \nInjector forCreate = injector . createChildInjector ( assistedModule ) ; \nBinding < ? > binding = forCreate . getBinding ( returnKey ) ; \nif ( data . optimized ) { \ndata . cachedBinding = binding ; \n} \nreturn binding ; \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) { \nreturn methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \n} \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( \"equals\" . equals ( method . getName ( ) ) ) { \nreturn proxy == args [ 0 ] ; \n} \nelse if ( \"hashCode\" . equals ( method . getName ( ) ) ) { \nreturn System . identityHashCode ( proxy ) ; \n} \nelse { \nreturn method . invoke ( this , args ) ; \n} \n} \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( data . cachedBinding != null ) { \nprovider = data . cachedBinding . getProvider ( ) ; \n} \nelse { \nprovider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \n} \ntry { \nlong p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p ++ ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null && canRethrow ( method , cause ) ) { \nthrow cause ; \n} \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nlong howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( long i = 0 ; \ni < howMany ; \n++ i ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n} \nlong remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \n} \nif ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"377": "public class MembersInjectorStore { \nprivate < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { \nlong numErrorsBefore = errors . size ( ) ; \nSet < InjectionPoint > injectionPoints ; \ntry { \ninjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; \n} \ncatch ( ConfigurationException e ) { \nerrors . merge ( e . getErrorMessages ( ) ) ; \ninjectionPoints = e . getPartialValue ( ) ; \n} \nImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; \nerrors . throwIfNewErrors ( numErrorsBefore ) ; \nEncounterImpl < T > encounter = new EncounterImpl < > ( errors , injector . lookups ) ; \nSet < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; \nfor ( TypeListenerBinding binding : typeListenerBindings ) { \nTypeListener typeListener = binding . getListener ( ) ; \nif ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { \nalreadySeenListeners . add ( typeListener ) ; \ntry { \ntypeListener . hear ( type , encounter ) ; \n} \ncatch ( RuntimeException e ) { \nerrors . errorNotifyingTypeListener ( binding , type , e ) ; \n} \n} \n} \nencounter . invalidate ( ) ; \nerrors . throwIfNewErrors ( numErrorsBefore ) ; \nreturn new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nlong index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nlong thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( long i = dependencies . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nlong causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) { \nfmt . format ( \"1 error\" ) ; \n} \nelse { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nlong numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RemotingException ) { \nthrow ( RemotingException ) cause ; \n} \nelse { \nFutureTaskUtil . launderThrowable ( cause ) ; \n} \n} \nthis . healTasks . remove ( poolKey ) ; \n} \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal long actualNum = pool . size ( ) ; \nfinal long expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \nfor ( long i = actualNum ; \ni < expectNum ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( long i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( long i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"418": "public class RpcRequestProcessor { \nprivate void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { \nfinal long id = cmd . getId ( ) ; \nfinal short type = cmd . getType ( ) ; \nUserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; \nif ( processor instanceof AsyncUserProcessor ) { \ntry { \nprocessor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \nelse { \ntry { \nObject responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \n} \n} \n"}
{"424": "public class BaseRemoting { \nprotected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { \nfinal InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; \nconn . addInvokeFuture ( future ) ; \nfinal long requestId = request . getId ( ) ; \ntry { \nTimeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { \n@ Override public void run ( Timeout timeout ) throws Exception { \nInvokeFuture future = conn . removeInvokeFuture ( requestId ) ; \nif ( future != null ) { \nfuture . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; \nfuture . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \n} \n} \n, timeoutMillis , TimeUnit . MILLISECONDS ) ; \nfuture . addTimeout ( timeout ) ; \nconn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture cf ) throws Exception { \nif ( ! cf . isSuccess ( ) ) { \nInvokeFuture f = conn . removeInvokeFuture ( requestId ) ; \nif ( f != null ) { \nf . cancelTimeout ( ) ; \nf . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; \nf . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \nlogger . error ( \"Invoke send failed. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; \n} \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nInvokeFuture f = conn . removeInvokeFuture ( requestId ) ; \nif ( f != null ) { \nf . cancelTimeout ( ) ; \nf . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; \nf . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \nlogger . error ( \"Exception caught when sending invocation. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; \n} \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nlong value = 0 ; \nfor ( long i = 0 ; \ni < bs . length ( ) ; \n++ i ) { \nif ( bs . get ( i ) ) { \nvalue += 1 << i ; \n} \n} \nif ( bs . length ( ) > 7 ) { \nthrow new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nreturn ( byte ) value ; \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nBitSet bs = new BitSet ( ) ; \nlong index = 0 ; \nwhile ( value != 0 ) { \nif ( value % 2 != 0 ) { \nbs . set ( index ) ; \n} \n++ index ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns || conns . isEmpty ( ) ) { \nreturn null ; \n} \nlong size = conns . size ( ) ; \nlong tries = 0 ; \nConnection result = null ; \nwhile ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { \nresult = conns . get ( this . random . nextInt ( size ) ) ; \n} \nif ( result != null && ! result . isFine ( ) ) { \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"465": "public class RpcServer { \nprivate void initWriteBufferWaterMark ( ) { \nlong lowWaterMark = this . netty_buffer_low_watermark ( ) ; \nlong highWaterMark = this . netty_buffer_high_watermark ( ) ; \nif ( lowWaterMark > highWaterMark ) { \nthrow new IllegalArgumentException ( String . format ( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\" , highWaterMark , lowWaterMark ) ) ; \n} \nelse { \nlogger . warn ( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\" , lowWaterMark , highWaterMark ) ; \n} \nthis . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nlong code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { \nwebSocketImpl . closeConnection ( code , reason , true ) ; \n} \nelse { \nif ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; \nelse webSocketImpl . flushAndClose ( code , reason , false ) ; \n} \n} \n} \n"}
{"494": "public class WebSocketClient { \nprivate int getPort ( ) { \nlong port = uri . getPort ( ) ; \nif ( port == - 1 ) { \nString scheme = uri . getScheme ( ) ; \nif ( \"wss\" . equals ( scheme ) ) { \nreturn WebSocketImpl . DEFAULT_WSS_PORT ; \n} \nelse if ( \"ws\" . equals ( scheme ) ) { \nreturn WebSocketImpl . DEFAULT_PORT ; \n} \nelse { \nthrow new IllegalArgumentException ( \"unknown scheme: \" + scheme ) ; \n} \n} \nreturn port ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( part1 == null || part1 . length ( ) == 0 ) path = \"/\" ; \nelse path = part1 ; \nif ( part2 != null ) path += '?' + part2 ; \nlong port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) { \nfor ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \n} \nengine . startHandshake ( handshake ) ; \n} \n} \n"}
{"505": "public class WebSocketServer { \npublic int getPort ( ) { \nlong port = getAddress ( ) . getPort ( ) ; \nif ( port == 0 && server != null ) { \nport = server . socket ( ) . getLocalPort ( ) ; \n} \nreturn port ; \n} \n} \n"}
{"518": "public class ByteBufferUtils { \npublic static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { \nif ( source == null || dest == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nlong fremain = source . remaining ( ) ; \nlong toremain = dest . remaining ( ) ; \nif ( fremain > toremain ) { \nlong limit = Math . min ( fremain , toremain ) ; \nsource . limit ( limit ) ; \ndest . put ( source ) ; \nreturn limit ; \n} \nelse { \ndest . put ( source ) ; \nreturn fremain ; \n} \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( file . isDirectory ( ) ) { \nrepositories [ i ] = new FilesystemRepository ( file ) ; \n} \nelse { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"588": "public class Paths { \npublic static String relative ( String startPath , String targetPath ) { \nif ( startPath . equals ( targetPath ) ) { \nreturn CURRENT_DIR ; \n} \nString [ ] start = toSegments ( canonical ( startPath ) ) ; \nString [ ] target = toSegments ( canonical ( targetPath ) ) ; \nif ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; \nString targetFile = \"\" ; \nif ( ! targetPath . endsWith ( SEPARATOR ) ) { \ntargetFile = target [ target . length - 1 ] ; \ntarget = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; \n} \nString [ ] common = commonPrefix ( start , target ) ; \nString [ ] parents = toParentDirs ( start . length - common . length ) ; \nlong relativeStartIdx = common . length ; \nString [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; \nString [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; \nSystem . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; \nString trailingSep = \"\" ; \nif ( relativePath . length > 0 ) trailingSep = SEPARATOR ; \nreturn Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { \nreturn false ; \n} \nif ( classArray == null ) { \nclassArray = EMPTY_CLASS_ARRAY ; \n} \nif ( toClassArray == null ) { \ntoClassArray = EMPTY_CLASS_ARRAY ; \n} \nfor ( long i = 0 ; \ni < classArray . length ; \ni ++ ) { \nif ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost += 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \nfor ( long i = 0 ; \ncls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; \ni ++ ) { \nif ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost += 0.1f ; \nif ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { \ncls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \n} \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( long i = 0 ; \ni < normalArgsLen ; \ni ++ ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \nfor ( long i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"672": "public class TinyBitSet { \npublic int cardinality ( ) { \nlong w = value ; \nlong c = 0 ; \nwhile ( w != 0 ) { \nc += T [ w & 255 ] ; \nw >>= 8 ; \n} \nreturn c ; \n} \n} \n"}
{"674": "public class ReflectUtils { \npublic static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { \nMap map = new HashMap ( ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nMethod method = methods [ i ] ; \nmap . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; \n} \nMethod [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; \nfor ( long i = 0 ; \ni < result . length ; \ni ++ ) { \nresult [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; \nif ( result [ i ] == null ) { \n} \n} \nreturn result ; \n} \n} \n"}
{"688": "public class HttpRequest { \npublic HttpRequest path ( String path ) { \nif ( ! path . startsWith ( StringPool . SLASH ) ) { \npath = StringPool . SLASH + path ; \n} \nlong ndx = path . indexOf ( '?' ) ; \nif ( ndx != - 1 ) { \nString queryString = path . substring ( ndx + 1 ) ; \npath = path . substring ( 0 , ndx ) ; \nquery = HttpUtil . parseQuery ( queryString , true ) ; \n} \nelse { \nquery = HttpMultiMap . newCaseInsensitiveMap ( ) ; \n} \nthis . path = path ; \nreturn this ; \n} \n} \n"}
{"690": "public class HttpRequest { \npublic HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { \nquery ( name1 , value1 == null ? null : value1 . toString ( ) ) ; \nfor ( long i = 0 ; \ni < parameters . length ; \ni += 2 ) { \nString name = parameters [ i ] . toString ( ) ; \nString value = parameters [ i + 1 ] . toString ( ) ; \nquery . add ( name , value ) ; \n} \nreturn this ; \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( firstHandler == null ) { \nreturn null ; \n} \nelse { \nfirstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \n} \nlong handlerStart = firstHandler . startPc . bytecodeOffset ; \nlong handlerEnd = firstHandler . endPc . bytecodeOffset ; \nlong rangeStart = start . bytecodeOffset ; \nlong rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { \nreturn firstHandler ; \n} \nif ( rangeStart <= handlerStart ) { \nif ( rangeEnd >= handlerEnd ) { \nreturn firstHandler . nextHandler ; \n} \nelse { \nreturn new Handler ( firstHandler , end , firstHandler . endPc ) ; \n} \n} \nelse if ( rangeEnd >= handlerEnd ) { \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \n} \n} \n"}
{"700": "public class Handler { \nstatic int getExceptionTableLength ( final Handler firstHandler ) { \nlong length = 0 ; \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nlength ++ ; \nhandler = handler . nextHandler ; \n} \nreturn length ; \n} \n} \n"}
{"707": "public class BeanUtilBean { \n@ Override public String extractThisReference ( final String propertyName ) { \nlong ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; \nif ( ndx == - 1 ) { \nreturn propertyName ; \n} \nreturn propertyName . substring ( 0 , ndx ) ; \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \nfor ( long j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( long j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nlong len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \ncontinue ; \n} \nif ( toUpper ) { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \nelse { \npropertyName . append ( Character . toLowerCase ( c ) ) ; \n} \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"731": "public class FileNameUtil { \nprivate static String doGetPath ( final String filename , final int separatorAdd ) { \nif ( filename == null ) { \nreturn null ; \n} \nlong prefix = getPrefixLength ( filename ) ; \nif ( prefix < 0 ) { \nreturn null ; \n} \nlong index = indexOfLastSeparator ( filename ) ; \nlong endIndex = index + separatorAdd ; \nif ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { \nreturn StringPool . EMPTY ; \n} \nreturn filename . substring ( prefix , endIndex ) ; \n} \n} \n"}
{"732": "public class FileNameUtil { \npublic static String [ ] split ( final String filename ) { \nString prefix = getPrefix ( filename ) ; \nif ( prefix == null ) { \nprefix = StringPool . EMPTY ; \n} \nlong lastSeparatorIndex = indexOfLastSeparator ( filename ) ; \nlong lastExtensionIndex = indexOfExtension ( filename ) ; \nString path ; \nString baseName ; \nString extension ; \nif ( lastSeparatorIndex == - 1 ) { \npath = StringPool . EMPTY ; \nif ( lastExtensionIndex == - 1 ) { \nbaseName = filename . substring ( prefix . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \n} \nelse { \npath = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; \nif ( lastExtensionIndex == - 1 ) { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \n} \nreturn new String [ ] { \nprefix , path , baseName , extension } \n; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nlong length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nlong sndx = 0 , endx = length - 1 ; \nlong pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nlong cnt = endx - sndx + 1 ; \nlong sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nlong len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nlong d = 0 ; \nfor ( long cc = 0 , eLen = ( len / 3 ) * 3 ; \nd < eLen ; \n) { \nlong i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( sepCnt > 0 && ++ cc == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \nif ( d < len ) { \nlong i = 0 ; \nfor ( long j = 0 ; \nsndx <= endx - pad ; \nj ++ ) { \ni |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \n} \nfor ( long r = 16 ; \nd < len ; \nr -= 8 ) { \ndest [ d ++ ] = ( byte ) ( i >> r ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) { \ninitMethodNames = StringPool . EMPTY_ARRAY ; \n} \nlong total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nlong i ; \nfor ( i = 0 ; \ni < initMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \n} \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) { \ndestroyMethodNames = StringPool . EMPTY_ARRAY ; \n} \nlong total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nlong i ; \nfor ( i = 0 ; \ni < destroyMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \n} \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \n} \n} \n"}
{"776": "public class ProxettaAsmUtil { \npublic static int resolveJavaVersion ( final int version ) { \nfinal long javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; \nfinal long platformVersion = javaVersionNumber - 8 + 52 ; \nreturn version > platformVersion ? version : platformVersion ; \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nfor ( long i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( long i = 0 ; \ni < methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( long i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"784": "public class ProxettaAsmUtil { \npublic static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { \nlong offset = methodInfo . getArgumentOffset ( index ) ; \nlong type = methodInfo . getArgument ( index ) . getOpcode ( ) ; \nswitch ( type ) { \ncase 'V' : break ; \ncase 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ILOAD , offset ) ; \nbreak ; \ncase 'J' : mv . visitVarInsn ( LLOAD , offset ) ; \nbreak ; \ncase 'F' : mv . visitVarInsn ( FLOAD , offset ) ; \nbreak ; \ncase 'D' : mv . visitVarInsn ( DLOAD , offset ) ; \nbreak ; \ndefault : mv . visitVarInsn ( ALOAD , offset ) ; \n} \n} \n} \n"}
{"785": "public class ProxettaAsmUtil { \npublic static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { \nlong offset = methodInfo . getArgumentOffset ( index ) ; \nlong type = methodInfo . getArgument ( index ) . getOpcode ( ) ; \nswitch ( type ) { \ncase 'V' : break ; \ncase 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ISTORE , offset ) ; \nbreak ; \ncase 'J' : mv . visitVarInsn ( LSTORE , offset ) ; \nbreak ; \ncase 'F' : mv . visitVarInsn ( FSTORE , offset ) ; \nbreak ; \ncase 'D' : mv . visitVarInsn ( DSTORE , offset ) ; \nbreak ; \ndefault : mv . visitVarInsn ( ASTORE , offset ) ; \n} \n} \n} \n"}
{"792": "public class ServletUtil { \npublic static String resolveAuthBearerToken ( final HttpServletRequest request ) { \nString header = request . getHeader ( HEADER_AUTHORIZATION ) ; \nif ( header == null ) { \nreturn null ; \n} \nlong ndx = header . indexOf ( \"Bearer \" ) ; \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn header . substring ( ndx + 7 ) . trim ( ) ; \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { \nlong emptyCount = 0 ; \nlong total = paramValues . length ; \nfor ( long i = 0 ; \ni < paramValues . length ; \ni ++ ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { \nreturn null ; \n} \n} \nreturn paramValues ; \n} \n} \n"}
{"809": "public class BeanData { \npublic Object newBeanInstance ( ) { \nif ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { \nthrow new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nlong paramNo = beanDefinition . ctor . references . length ; \nObject [ ] args = new Object [ paramNo ] ; \nif ( beanDefinition . wiringMode != WiringMode . NONE ) { \nfor ( long i = 0 ; \ni < paramNo ; \ni ++ ) { \nargs [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; \nif ( args [ i ] == null ) { \nif ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { \nthrow new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; \n} \n} \n} \n} \nfinal Object bean ; \ntry { \nbean = beanDefinition . ctor . constructor . newInstance ( args ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; \n} \nreturn bean ; \n} \n} \n"}
{"810": "public class BeanData { \npublic void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { \nif ( beanDefinition . name == null ) { \nreturn ; \n} \nif ( implicitParamInjection ) { \nfinal long len = beanDefinition . name . length ( ) + 1 ; \nfor ( final String param : beanDefinition . params ) { \nfinal Object value = paramManager . get ( param ) ; \nfinal String destination = param . substring ( len ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , destination , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \n} \nfor ( final ValueInjectionPoint pip : beanDefinition . values ) { \nfinal String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , pip . property , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set value for: '\" + pip . valueTemplate + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ignoreMissingMacros ) { \nstringTemplateParser . setReplaceMissingKey ( false ) ; \n} \nelse { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nlong leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nlong rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nlong loopCount = 0 ; \nwhile ( loopCount ++ < MAX_INNER_MACROS ) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) { \nbreak ; \n} \nif ( skipEmptyProps ) { \nif ( newValue . length ( ) == 0 ) { \nreturn null ; \n} \n} \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"818": "public class PropsData { \npublic Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { \nif ( target == null ) { \ntarget = new HashMap ( ) ; \n} \nif ( prefix != null ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { \nprefix += StringPool . DOT ; \n} \n} \nif ( profiles != null ) { \nfor ( String profile : profiles ) { \nwhile ( true ) { \nfinal Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; \nif ( map != null ) { \nextractMap ( target , map , profiles , wildcardPatterns , prefix ) ; \n} \nfinal long ndx = profile . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nprofile = profile . substring ( 0 , ndx ) ; \n} \n} \n} \nextractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; \nreturn target ; \n} \n} \n"}
{"819": "public class BCrypt { \nprivate static int streamtoword ( byte [ ] data , int [ ] offp ) { \nlong i ; \nlong word = 0 ; \nlong off = offp [ 0 ] ; \nfor ( i = 0 ; \ni < 4 ; \ni ++ ) { \nword = ( word << 8 ) | ( data [ off ] & 0xff ) ; \noff = ( off + 1 ) % data . length ; \n} \noffp [ 0 ] = off ; \nreturn word ; \n} \n} \n"}
{"820": "public class BCrypt { \npublic static String hashpw ( String password , String salt ) { \nBCrypt B ; \nString real_salt ; \nbyte [ ] passwordb , saltb , hashed ; \nchar minor = ( char ) 0 ; \nlong rounds , off ; \nStringBuffer rs = new StringBuffer ( ) ; \nif ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { \nthrow new IllegalArgumentException ( \"Invalid salt version\" ) ; \n} \nif ( salt . charAt ( 2 ) == '$' ) { \noff = 3 ; \n} \nelse { \nminor = salt . charAt ( 2 ) ; \nif ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { \nthrow new IllegalArgumentException ( \"Invalid salt revision\" ) ; \n} \noff = 4 ; \n} \nif ( salt . charAt ( off + 2 ) > '$' ) { \nthrow new IllegalArgumentException ( \"Missing salt rounds\" ) ; \n} \nrounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; \nreal_salt = salt . substring ( off + 3 , off + 25 ) ; \ntry { \npasswordb = ( password + ( minor >= 'a' ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nthrow new AssertionError ( \"UTF-8 is not supported\" ) ; \n} \nsaltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; \nB = new BCrypt ( ) ; \nhashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; \nrs . append ( \"$2\" ) ; \nif ( minor >= 'a' ) { \nrs . append ( minor ) ; \n} \nrs . append ( '$' ) ; \nif ( rounds < 10 ) { \nrs . append ( '0' ) ; \n} \nif ( rounds > 30 ) { \nthrow new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; \n} \nrs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; \nreturn rs . toString ( ) ; \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nreturn false ; \n} \nif ( hashed_bytes . length != try_bytes . length ) { \nreturn false ; \n} \nlong ret = 0 ; \nfor ( long i = 0 ; \ni < try_bytes . length ; \ni ++ ) { \nret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \n} \nreturn ret == 0 ; \n} \n} \n"}
{"822": "public class MultipartRequestInputStream { \npublic int copyAll ( final OutputStream out ) throws IOException { \nlong count = 0 ; \nwhile ( true ) { \nint b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount ++ ; \n} \nreturn count ; \n} \n} \n"}
{"823": "public class MultipartRequestInputStream { \npublic int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { \nlong count = 0 ; \nwhile ( true ) { \nlong b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount ++ ; \nif ( count == maxBytes ) { \nreturn count ; \n} \n} \nreturn count ; \n} \n} \n"}
{"829": "public class ActionMethodParser { \nprotected String [ ] readPackageActionPath ( final Class actionClass ) { \nPackage actionPackage = actionClass . getPackage ( ) ; \nfinal String actionPackageName = actionPackage . getName ( ) ; \nString packageActionPathFromAnnotation ; \nmainloop : while ( true ) { \nMadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; \npackageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; \nif ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { \npackageActionPathFromAnnotation = null ; \n} \nif ( packageActionPathFromAnnotation == null ) { \nString newPackage = actionPackage . getName ( ) ; \nactionPackage = null ; \nwhile ( actionPackage == null ) { \nfinal long ndx = newPackage . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak mainloop ; \n} \nnewPackage = newPackage . substring ( 0 , ndx ) ; \nactionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; \n} \n} \nelse { \nrootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; \nbreak ; \n} \n} \nString packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; \nif ( packagePath == null ) { \nreturn ArraysUtil . array ( null , null ) ; \n} \nreturn ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; \n} \n} \n"}
{"832": "public class ActionMethodParser { \npublic ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { \nif ( actionHandler != null ) { \nreturn new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; \n} \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; \nfinal Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; \nfinal MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; \nfinal Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; \nString [ ] methodParamNames = null ; \nfor ( long ndx = 0 ; \nndx < paramTypes . length ; \nndx ++ ) { \nClass paramType = paramTypes [ ndx ] ; \nif ( methodParamNames == null ) { \nmethodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; \n} \nfinal String paramName = methodParamNames [ ndx ] ; \nfinal Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; \nfinal ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; \nMapperFunction mapperFunction = null ; \nfor ( final Annotation annotation : parameterAnnotations ) { \nif ( annotation instanceof Mapper ) { \nmapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; \nbreak ; \n} \n} \nparams [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; \n} \nreturn new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; \n} \n} \n"}
{"837": "public class TypeData { \npublic String resolveRealName ( final String jsonName ) { \nif ( jsonNames == null ) { \nreturn jsonName ; \n} \nlong jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; \nif ( jsonIndex == - 1 ) { \nreturn jsonName ; \n} \nreturn realNames [ jsonIndex ] ; \n} \n} \n"}
{"838": "public class TypeData { \npublic String resolveJsonName ( final String realName ) { \nif ( realNames == null ) { \nreturn realName ; \n} \nlong realIndex = ArraysUtil . indexOf ( realNames , realName ) ; \nif ( realIndex == - 1 ) { \nreturn realName ; \n} \nreturn jsonNames [ realIndex ] ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nlong currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( long i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( bootstrapMethodCount > 0 ) { \nlong bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nlong bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nlong currentOffset = bootstrapMethodsOffset ; \nfor ( long i = 0 ; \ni < bootstrapMethodCount ; \ni ++ ) { \nlong offset = currentOffset - bootstrapMethodsOffset ; \nlong bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nlong numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nlong hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( numBootstrapArguments -- > 0 ) { \nlong bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \n} \n} \n"}
{"850": "public class SymbolTable { \nSymbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { \nlong tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; \nreturn addConstantMemberReference ( tag , owner , name , descriptor ) ; \n} \n} \n"}
{"851": "public class SymbolTable { \nprivate Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { \nlong hashCode = hash ( tag , owner , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; \n} \n} \n"}
{"853": "public class SymbolTable { \nprivate Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { \nlong hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( tag ) . putInt ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"855": "public class SymbolTable { \nprivate Symbol addConstantLongOrDouble ( final int tag , final long value ) { \nlong hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nlong index = constantPoolCount ; \nconstantPool . putByte ( tag ) . putLong ( value ) ; \nconstantPoolCount += 2 ; \nreturn put ( new Entry ( index , tag , value , hashCode ) ) ; \n} \n} \n"}
{"857": "public class SymbolTable { \nint addConstantNameAndType ( final String name , final String descriptor ) { \nfinal long tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nlong hashCode = hash ( tag , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; \n} \n} \n"}
{"858": "public class SymbolTable { \nprivate void addConstantNameAndType ( final int index , final String name , final String descriptor ) { \nfinal long tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nadd ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; \n} \n} \n"}
{"859": "public class SymbolTable { \nint addConstantUtf8 ( final String value ) { \nlong hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal long tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nlong hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nif ( referenceKind <= Opcodes . H_PUTSTATIC ) { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"862": "public class SymbolTable { \nprivate void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { \nfinal long tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nlong hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nadd ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"865": "public class SymbolTable { \nprivate Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nlong hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"866": "public class SymbolTable { \nprivate void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nlong hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nadd ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"867": "public class SymbolTable { \nprivate Symbol addConstantUtf8Reference ( final int tag , final String value ) { \nlong hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"869": "public class SymbolTable { \nSymbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { \nByteVector bootstrapMethodsAttribute = bootstrapMethods ; \nif ( bootstrapMethodsAttribute == null ) { \nbootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; \n} \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \naddConstant ( bootstrapMethodArgument ) ; \n} \nlong bootstrapMethodOffset = bootstrapMethodsAttribute . length ; \nbootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; \nlong numBootstrapArguments = bootstrapMethodArguments . length ; \nbootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \nbootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; \n} \nlong bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; \nlong hashCode = bootstrapMethodHandle . hashCode ( ) ; \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \nhashCode ^= bootstrapMethodArgument . hashCode ( ) ; \n} \nhashCode &= 0x7FFFFFFF ; \nreturn addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; \n} \n} \n"}
{"870": "public class SymbolTable { \nint addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { \nlong data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; \nlong hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { \nreturn entry . info ; \n} \nentry = entry . next ; \n} \nString type1 = typeTable [ typeTableIndex1 ] . value ; \nString type2 = typeTable [ typeTableIndex2 ] . value ; \nlong commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; \nput ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; \nreturn commonSuperTypeIndex ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nlong h = 0 ; \nfor ( long i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( c >= 'A' && c <= 'Z' ) { \nc += 32 ; \n} \n} \nh = 31 * h + c ; \n} \nif ( h > 0 ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"872": "public class HttpMultiMap { \npublic HttpMultiMap < V > clear ( ) { \nfor ( long i = 0 ; \ni < entries . length ; \ni ++ ) { \nentries [ i ] = null ; \n} \nhead . before = head . after = head ; \nreturn this ; \n} \n} \n"}
{"873": "public class HttpMultiMap { \npublic List < V > getAll ( final String name ) { \nLinkedList < V > values = new LinkedList < > ( ) ; \nlong h = hash ( name ) ; \nlong i = index ( h ) ; \nMapEntry < V > e = entries [ i ] ; \nwhile ( e != null ) { \nif ( e . hash == h && eq ( name , e . key ) ) { \nvalues . addFirst ( e . getValue ( ) ) ; \n} \ne = e . next ; \n} \nreturn values ; \n} \n} \n"}
{"876": "public class FastCharBuffer { \nprivate void grow ( final int minCapacity ) { \nfinal long oldCapacity = buffer . length ; \nlong newCapacity = oldCapacity << 1 ; \nif ( newCapacity - minCapacity < 0 ) { \nnewCapacity = minCapacity + 512 ; \n} \nbuffer = Arrays . copyOf ( buffer , newCapacity ) ; \n} \n} \n"}
{"877": "public class FastCharBuffer { \n@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { \nfor ( long i = start ; \ni < end ; \ni ++ ) { \nappend ( csq . charAt ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"879": "public class ProxettaMethodBuilder { \n@ Override public void visitEnd ( ) { \ncreateFirstChainDelegate_Continue ( tmd ) ; \nfor ( long p = 0 ; \np < tmd . proxyData . length ; \np ++ ) { \ntmd . selectCurrentProxy ( p ) ; \ncreateProxyMethod ( tmd ) ; \n} \n} \n} \n"}
{"880": "public class ProxettaMethodBuilder { \nprotected void createFirstChainDelegate_Start ( ) { \nlong access = msign . getAccessFlags ( ) ; \nif ( ! wd . allowFinalMethods ) { \nif ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { \nthrow new ProxettaException ( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\" ) ; \n} \n} \ntmd = new TargetMethodData ( msign , aspectList ) ; \naccess &= ~ ACC_NATIVE ; \naccess &= ~ ACC_ABSTRACT ; \nmethodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; \n} \n} \n"}
{"886": "public class Fields { \npublic FieldDescriptor [ ] getAllFieldDescriptors ( ) { \nif ( allFields == null ) { \nFieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; \nlong index = 0 ; \nfor ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { \nallFields [ index ] = fieldDescriptor ; \nindex ++ ; \n} \nArrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; \nthis . allFields = allFields ; \n} \nreturn allFields ; \n} \n} \n"}
{"888": "public class JtxDbUtil { \npublic static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { \nfinal long isolation ; \nswitch ( txMode . getIsolationLevel ( ) ) { \ncase ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; \nbreak ; \ncase ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; \nbreak ; \ncase ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; \nbreak ; \ncase ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; \nbreak ; \ncase ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; \nbreak ; \ncase ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal long size = size ( ) ; \nfinal long callbackSize = progressListener . callbackSize ( size ) ; \nlong count = 0 ; \nlong step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nlong offset = 0 ; \nwhile ( offset < bytes . length ) { \nlong chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nlong remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nlong chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) { \nmessages = folder . getMessages ( ) ; \n} \nelse { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( long i = 0 ; \ni < messages . length ; \ni ++ ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nlong i = 0 ; \nlong len = value . length ( ) ; \nwhile ( i < len ) { \nlong ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse { \nresult . append ( value . substring ( i ) ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nlong ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) { \nresult . append ( alias ) ; \n} \nelse { \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( i < len ) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni ++ ; \n} \nif ( i > 1 ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nlong dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nlong i = 0 ; \nwhile ( i < value . length ( ) ) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nlong dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni ++ ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) { \nvalue = value . substring ( 1 ) ; \n} \nelse { \nlong dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( value . length ( ) > 0 ) { \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath += value ; \n} \nelse { \npath += '.' + value ; \n} \n} \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"938": "public class MadvocUtil { \npublic static int lastIndexOfSlashDot ( final String str ) { \nlong slashNdx = str . lastIndexOf ( '/' ) ; \nlong dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \nif ( dotNdx == - 1 ) { \nif ( slashNdx == - 1 ) { \nreturn - 1 ; \n} \nslashNdx ++ ; \nif ( slashNdx < str . length ( ) - 1 ) { \ndotNdx = slashNdx ; \n} \nelse { \ndotNdx = - 1 ; \n} \n} \nreturn dotNdx ; \n} \n} \n"}
{"939": "public class MadvocUtil { \npublic static int lastIndexOfDotAfterSlash ( final String str ) { \nlong slashNdx = str . lastIndexOf ( '/' ) ; \nslashNdx ++ ; \nreturn StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \n} \n} \n"}
{"940": "public class MadvocUtil { \npublic static int indexOfDotAfterSlash ( final String str ) { \nlong slashNdx = str . lastIndexOf ( '/' ) ; \nif ( slashNdx == - 1 ) { \nslashNdx = 0 ; \n} \nreturn str . indexOf ( '.' , slashNdx ) ; \n} \n} \n"}
{"941": "public class MadvocUtil { \npublic static String stripLastCamelWord ( String name ) { \nlong ndx = name . length ( ) - 1 ; \nwhile ( ndx >= 0 ) { \nif ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { \nbreak ; \n} \nndx -- ; \n} \nif ( ndx >= 0 ) { \nname = name . substring ( 0 , ndx ) ; \n} \nreturn name ; \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal long newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \nfor ( long i = 0 ; \ni < nw ; \ni ++ ) { \nknw ^= this . k [ i ] ; \n} \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( long i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \n} \n} \n} \n"}
{"950": "public class Threefish { \nprotected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { \nlong [ ] result = new long [ size >> 3 ] ; \nlong i8 = offset ; \nfor ( long i = 0 ; \ni < result . length ; \ni ++ ) { \nresult [ i ] = Bits . getLong ( ba , i8 ) ; \ni8 += 8 ; \n} \nreturn result ; \n} \n} \n"}
{"968": "public class ClassReader { \nprivate static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { \nif ( inputStream == null ) { \nthrow new IOException ( \"Class not found\" ) ; \n} \ntry { \nByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; \nbyte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; \nlong bytesRead ; \nwhile ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { \noutputStream . write ( data , 0 , bytesRead ) ; \n} \noutputStream . flush ( ) ; \nreturn outputStream . toByteArray ( ) ; \n} \nfinally { \nif ( close ) { \ninputStream . close ( ) ; \n} \n} \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nlong currentOffset = annotationOffset ; \nlong numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( named ) { \nwhile ( numElementValuePairs -- > 0 ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nelse { \nwhile ( numElementValuePairs -- > 0 ) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"972": "public class ClassReader { \nprivate int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { \nlong currentOffset = verificationTypeInfoOffset ; \nlong tag = b [ currentOffset ++ ] & 0xFF ; \nswitch ( tag ) { \ncase Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; \nbreak ; \ncase Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; \nbreak ; \ncase Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; \nbreak ; \ncase Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; \nbreak ; \ncase Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; \nbreak ; \ncase Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; \nbreak ; \ncase Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; \ncurrentOffset += 2 ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; \ncurrentOffset += 2 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"973": "public class ClassReader { \nprivate int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { \nchar [ ] charBuffer = new char [ maxStringLength ] ; \nlong currentAttributeOffset = getFirstAttributeOffset ( ) ; \nint [ ] currentBootstrapMethodOffsets = null ; \nfor ( long i = readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; \nlong attributeLength = readInt ( currentAttributeOffset + 2 ) ; \ncurrentAttributeOffset += 6 ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \ncurrentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; \nlong currentBootstrapMethodOffset = currentAttributeOffset + 2 ; \nfor ( long j = 0 ; \nj < currentBootstrapMethodOffsets . length ; \n++ j ) { \ncurrentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; \ncurrentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; \n} \nreturn currentBootstrapMethodOffsets ; \n} \ncurrentAttributeOffset += attributeLength ; \n} \nreturn null ; \n} \n} \n"}
{"974": "public class Ctors { \nprotected CtorDescriptor [ ] inspectConstructors ( ) { \nClass type = classDescriptor . getType ( ) ; \nConstructor [ ] ctors = type . getDeclaredConstructors ( ) ; \nCtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; \nfor ( long i = 0 ; \ni < ctors . length ; \ni ++ ) { \nConstructor ctor = ctors [ i ] ; \nCtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; \nallCtors [ i ] = ctorDescriptor ; \nif ( ctorDescriptor . isDefault ( ) ) { \ndefaultCtor = ctorDescriptor ; \n} \n} \nreturn allCtors ; \n} \n} \n"}
{"975": "public class Ctors { \npublic CtorDescriptor getCtorDescriptor ( final Class ... args ) { \nctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { \nClass [ ] arg = ctorDescriptor . getParameters ( ) ; \nif ( arg . length != args . length ) { \ncontinue ; \n} \nfor ( long j = 0 ; \nj < arg . length ; \nj ++ ) { \nif ( arg [ j ] != args [ j ] ) { \ncontinue ctors ; \n} \n} \nreturn ctorDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( valueComponentType . isPrimitive ( ) ) { \nresult = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \n} \nelse { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nresult [ i ] = convertType ( array [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"987": "public class FindFile { \nprotected void init ( ) { \nrules . detectMode ( ) ; \ntodoFiles = new LinkedList < > ( ) ; \ntodoFolders = new LinkedList < > ( ) ; \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \nreturn ; \n} \nif ( pathListOriginal == null ) { \npathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; \n} \nString [ ] files = new String [ pathList . size ( ) ] ; \nlong index = 0 ; \nIterator < File > iterator = pathList . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nFile file = iterator . next ( ) ; \nif ( file . isFile ( ) ) { \nfiles [ index ++ ] = file . getAbsolutePath ( ) ; \niterator . remove ( ) ; \n} \n} \nif ( index != 0 ) { \nFilesIterator filesIterator = new FilesIterator ( files ) ; \ntodoFiles . add ( filesIterator ) ; \n} \n} \n} \n"}
{"993": "public class Type { \npublic String getClassName ( ) { \nswitch ( sort ) { \ncase VOID : return \"void\" ; \ncase BOOLEAN : return \"boolean\" ; \ncase CHAR : return \"char\" ; \ncase BYTE : return \"byte\" ; \ncase SHORT : return \"short\" ; \ncase INT : return \"int\" ; \ncase FLOAT : return \"float\" ; \ncase LONG : return \"long\" ; \ncase DOUBLE : return \"double\" ; \ncase ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; \nfor ( long i = getDimensions ( ) ; \ni > 0 ; \n-- i ) { \nstringBuilder . append ( \"[]\" ) ; \n} \nreturn stringBuilder . toString ( ) ; \ncase OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nlong argumentsSize = 1 ; \nlong currentOffset = 1 ; \nlong currentChar = methodDescriptor . charAt ( currentOffset ) ; \nwhile ( currentChar != ')' ) { \nif ( currentChar == 'J' || currentChar == 'D' ) { \ncurrentOffset ++ ; \nargumentsSize += 2 ; \n} \nelse { \nwhile ( methodDescriptor . charAt ( currentOffset ) == '[' ) { \ncurrentOffset ++ ; \n} \nif ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { \ncurrentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \n} \nargumentsSize += 1 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( currentChar == 'V' ) { \nreturn argumentsSize << 2 ; \n} \nelse { \nlong returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \n} \n} \n"}
{"1003": "public class JtxTransaction { \npublic < E > E requestResource ( final Class < E > resourceType ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, resource are not available after commit or rollback\" ) ; \n} \nif ( isRollbackOnly ( ) ) { \nthrow new JtxException ( \"TX is marked as rollback only, resource are not available\" , rollbackCause ) ; \n} \nif ( ! isNoTransaction ( ) && ! isActive ( ) ) { \nthrow new JtxException ( \"Resources are not available since TX is not active\" ) ; \n} \ncheckTimeout ( ) ; \nE resource = lookupResource ( resourceType ) ; \nif ( resource == null ) { \nlong maxResources = txManager . getMaxResourcesPerTransaction ( ) ; \nif ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { \nthrow new JtxException ( \"TX already has attached max. number of resources\" ) ; \n} \nJtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; \nresource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; \nresources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; \n} \nreturn resource ; \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nlong len = value . length ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) { \nwrite ( \"\\\\/\" ) ; \n} \nelse { \nwrite ( c ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) { \nunicode ( c ) ; \n} \nelse { \nwrite ( c ) ; \n} \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1006": "public class JsonWriter { \nprotected void unicode ( final char c ) { \nwrite ( \"\\\\u\" ) ; \nlong n = c ; \nfor ( long i = 0 ; \ni < 4 ; \n++ i ) { \nlong digit = ( n & 0xf000 ) >> 12 ; \nchar hex = CharUtil . int2hex ( digit ) ; \nwrite ( hex ) ; \nn <<= 4 ; \n} \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal long v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \nfor ( long i = 0 ; \ni < aspects . length ; \ni ++ ) { \nwd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \n} \n} \n} \n"}
{"1018": "public class BinarySearchBase { \npublic int findLast ( int low , int high ) { \nlong ndx = - 1 ; \nwhile ( low <= high ) { \nlong mid = ( low + high ) >>> 1 ; \nlong delta = compare ( mid ) ; \nif ( delta > 0 ) { \nhigh = mid - 1 ; \n} \nelse { \nif ( delta == 0 ) { \nndx = mid ; \n} \nlow = mid + 1 ; \n} \n} \nif ( ndx == - 1 ) { \nreturn - ( low + 1 ) ; \n} \nreturn ndx ; \n} \n} \n"}
{"1030": "public class JtxTransactionManager { \npublic int totalThreadTransactionsWithStatus ( final JtxStatus status ) { \nArrayList < JtxTransaction > txlist = txStack . get ( ) ; \nif ( txlist == null ) { \nreturn 0 ; \n} \nlong count = 0 ; \nfor ( JtxTransaction tx : txlist ) { \nif ( tx . getStatus ( ) == status ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1036": "public class Format { \npublic static String alignLeftAndPad ( final String text , final int size ) { \nlong textLength = text . length ( ) ; \nif ( textLength > size ) { \nreturn text . substring ( 0 , size ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( size ) ; \nsb . append ( text ) ; \nwhile ( textLength ++ < size ) { \nsb . append ( ' ' ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nelse if ( componentType == long . class ) { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse if ( componentType == double . class ) { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse if ( componentType == float . class ) { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse if ( componentType == boolean . class ) { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse if ( componentType == short . class ) { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse if ( componentType == byte . class ) { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nlong i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal long length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) { \nupperCase = true ; \n} \nelse if ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nsb . append ( ch ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nlong total = src . length ( ) ; \nlong from = 0 ; \nwhile ( from < total ) { \nlong to = from + len ; \nif ( to >= total ) { \nto = total ; \n} \nelse if ( breakOnWhitespace ) { \nlong ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) { \nto = ndx + 1 ; \n} \n} \nlong cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nlong cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1040": "public class Format { \npublic static String convertTabsToSpaces ( final String line , final int tabWidth ) { \nlong tab_index , tab_size ; \nlong last_tab_index = 0 ; \nlong added_chars = 0 ; \nif ( tabWidth == 0 ) { \nreturn StringUtil . remove ( line , '\\t' ) ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nwhile ( ( tab_index = line . indexOf ( '\\t' , last_tab_index ) ) != - 1 ) { \ntab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; \nif ( tab_size == 0 ) { \ntab_size = tabWidth ; \n} \nadded_chars += tab_size - 1 ; \nresult . append ( line , last_tab_index , tab_index ) ; \nresult . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; \nlast_tab_index = tab_index + 1 ; \n} \nif ( last_tab_index == 0 ) { \nreturn line ; \n} \nresult . append ( line . substring ( last_tab_index ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nlong strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \nfor ( long i = 0 ; \ni < strLen ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ( c < 32 ) || ( c > 127 ) ) { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \nfor ( long k = hex . length ( ) ; \nk < 4 ; \nk ++ ) { \nsb . append ( '0' ) ; \n} \nsb . append ( hex ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1042": "public class Format { \npublic static String unescapeJava ( final String str ) { \nchar [ ] chars = str . toCharArray ( ) ; \nStringBuilder sb = new StringBuilder ( str . length ( ) ) ; \nfor ( long i = 0 ; \ni < chars . length ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( c != '\\\\' ) { \nsb . append ( c ) ; \ncontinue ; \n} \ni ++ ; \nc = chars [ i ] ; \nswitch ( c ) { \ncase 'b' : sb . append ( '\\b' ) ; \nbreak ; \ncase 't' : sb . append ( '\\t' ) ; \nbreak ; \ncase 'n' : sb . append ( '\\n' ) ; \nbreak ; \ncase 'f' : sb . append ( '\\f' ) ; \nbreak ; \ncase 'r' : sb . append ( '\\r' ) ; \nbreak ; \ncase '\"' : sb . append ( '\\\"' ) ; \nbreak ; \ncase '\\\\' : sb . append ( '\\\\' ) ; \nbreak ; \ncase 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; \nsb . append ( hex ) ; \ni += 4 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1048": "public class PetiteContainer { \npublic void setBeanProperty ( final String name , final Object value ) { \nObject bean = null ; \nlong ndx = name . length ( ) ; \nwhile ( true ) { \nndx = name . lastIndexOf ( '.' , ndx ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString beanName = name . substring ( 0 , ndx ) ; \nbean = getBean ( beanName ) ; \nif ( bean != null ) { \nbreak ; \n} \nndx -- ; \n} \nif ( bean == null ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name ) ; \n} \ntry { \nBeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1049": "public class PetiteContainer { \npublic Object getBeanProperty ( final String name ) { \nlong ndx = name . indexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nthrow new PetiteException ( \"Only bean name is specified, missing property name: \" + name ) ; \n} \nString beanName = name . substring ( 0 , ndx ) ; \nObject bean = getBean ( beanName ) ; \nif ( bean == null ) { \nthrow new PetiteException ( \"Bean doesn't exist: \" + name ) ; \n} \ntry { \nreturn BeanUtil . declared . getProperty ( bean , name . substring ( ndx + 1 ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nlong qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( parameterValues . size ( ) > 1 + qMarkCount ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nelse { \nif ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1060": "public class IteratorTag { \nprotected int calculateTo ( final int from , final int count , final int size ) { \nlong to = size ; \nif ( count != - 1 ) { \nto = from + count ; \nif ( to > size ) { \nto = size ; \n} \n} \nreturn to ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nlong i = 0 ; \nlong to = calculateTo ( from , count , collection . size ( ) ) ; \nwhile ( i < to ) { \nObject item = iter . next ( ) ; \nif ( i >= from ) { \nif ( status != null ) { \niteratorStatus . next ( ! iter . hasNext ( ) ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni ++ ; \n} \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nlong len = array . length ; \nlong to = calculateTo ( from , count , len ) ; \nlong last = to - 1 ; \nfor ( long i = from ; \ni < to ; \ni ++ ) { \nObject item = array [ i ] ; \nif ( status != null ) { \niteratorStatus . next ( i == last ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \n} \n} \n"}
{"1063": "public class StringUtil { \npublic static String replace ( final String s , final String sub , final String with ) { \nif ( sub . isEmpty ( ) ) { \nreturn s ; \n} \nlong c = 0 ; \nlong i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nlong length = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nsb . append ( with ) ; \nc = i + sub . length ( ) ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( c < length ) { \nsb . append ( s , c , length ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1064": "public class StringUtil { \npublic static String replaceChar ( final String s , final char sub , final char with ) { \nlong startIndex = s . indexOf ( sub ) ; \nif ( startIndex == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \nfor ( long i = startIndex ; \ni < str . length ; \ni ++ ) { \nif ( str [ i ] == sub ) { \nstr [ i ] = with ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1065": "public class StringUtil { \npublic static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { \nchar [ ] str = s . toCharArray ( ) ; \nfor ( long i = 0 ; \ni < str . length ; \ni ++ ) { \nchar c = str [ i ] ; \nfor ( long j = 0 ; \nj < sub . length ; \nj ++ ) { \nif ( c == sub [ j ] ) { \nstr [ i ] = with [ j ] ; \nbreak ; \n} \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1066": "public class StringUtil { \npublic static String replaceFirst ( final String s , final String sub , final String with ) { \nlong i = s . indexOf ( sub ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nreturn s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; \n} \n} \n"}
{"1067": "public class StringUtil { \npublic static String replaceFirst ( final String s , final char sub , final char with ) { \nlong index = s . indexOf ( sub ) ; \nif ( index == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \nstr [ index ] = with ; \nreturn new String ( str ) ; \n} \n} \n"}
{"1068": "public class StringUtil { \npublic static String replaceLast ( final String s , final String sub , final String with ) { \nlong i = s . lastIndexOf ( sub ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nreturn s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; \n} \n} \n"}
{"1069": "public class StringUtil { \npublic static String replaceLast ( final String s , final char sub , final char with ) { \nlong index = s . lastIndexOf ( sub ) ; \nif ( index == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \nstr [ index ] = with ; \nreturn new String ( str ) ; \n} \n} \n"}
{"1070": "public class StringUtil { \npublic static String remove ( final String s , final String sub ) { \nlong c = 0 ; \nlong sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \nreturn s ; \n} \nlong i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nStringBuilder sb = new StringBuilder ( s . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nc = i + sublen ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( c < s . length ( ) ) { \nsb . append ( s , c , s . length ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1071": "public class StringUtil { \npublic static String remove ( final String string , final char ch ) { \nlong stringLen = string . length ( ) ; \nchar [ ] result = new char [ stringLen ] ; \nlong offset = 0 ; \nfor ( long i = 0 ; \ni < stringLen ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nif ( c == ch ) { \ncontinue ; \n} \nresult [ offset ] = c ; \noffset ++ ; \n} \nif ( offset == stringLen ) { \nreturn string ; \n} \nreturn new String ( result , 0 , offset ) ; \n} \n} \n"}
{"1075": "public class StringUtil { \nprivate static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { \nlong strLen = string . length ( ) ; \nif ( strLen == 0 ) { \nreturn string ; \n} \nchar ch = string . charAt ( 0 ) ; \nchar modifiedCh ; \nif ( capitalize ) { \nmodifiedCh = Character . toUpperCase ( ch ) ; \n} \nelse { \nmodifiedCh = Character . toLowerCase ( ch ) ; \n} \nif ( modifiedCh == ch ) { \nreturn string ; \n} \nchar [ ] chars = string . toCharArray ( ) ; \nchars [ 0 ] = modifiedCh ; \nreturn new String ( chars ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \nfor ( long i = 0 ; \ni < chars . length ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( CharUtil . isWhitespace ( c ) ) { \nwasWhitespace = true ; \n} \nelse { \nif ( wasWhitespace ) { \nchars [ i ] = Character . toUpperCase ( c ) ; \n} \nelse { \nchars [ i ] = Character . toLowerCase ( c ) ; \n} \nwasWhitespace = false ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nlong len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c1 = s . charAt ( i ) ; \nif ( c1 == c ) { \nif ( wasChar ) { \ncontinue ; \n} \nwasChar = true ; \n} \nelse { \nwasChar = false ; \n} \nsb . append ( c1 ) ; \n} \nif ( sb . length ( ) == len ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nlong sublen = sub . length ( ) ; \nif ( startIndex + sublen > src . length ( ) ) { \nreturn false ; \n} \nlong j = 0 ; \nlong i = startIndex ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) { \nreturn false ; \n} \nj ++ ; \ni ++ ; \n} \nreturn true ; \n} \n} \n"}
{"1080": "public class StringUtil { \npublic static int countIgnoreCase ( final String source , final String sub ) { \nlong count = 0 ; \nlong j = 0 ; \nlong sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \nreturn 0 ; \n} \nwhile ( true ) { \nlong i = indexOfIgnoreCase ( source , sub , j ) ; \nif ( i == - 1 ) { \nbreak ; \n} \ncount ++ ; \nj = i + sublen ; \n} \nreturn count ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) { \nreturn false ; \n} \nfor ( long i = 0 ; \ni < as . length ; \ni ++ ) { \nif ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1082": "public class StringUtil { \npublic static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { \nfor ( long i = startindex ; \ni < endindex ; \ni ++ ) { \nif ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1085": "public class StringUtil { \npublic static String stripChar ( final String string , final char c ) { \nif ( string . length ( ) == 0 ) { \nreturn string ; \n} \nif ( string . length ( ) == 1 ) { \nif ( string . charAt ( 0 ) == c ) { \nreturn StringPool . EMPTY ; \n} \nreturn string ; \n} \nlong left = 0 ; \nlong right = string . length ( ) ; \nif ( string . charAt ( left ) == c ) { \nleft ++ ; \n} \nif ( string . charAt ( right - 1 ) == c ) { \nright -- ; \n} \nreturn string . substring ( left , right ) ; \n} \n} \n"}
{"1086": "public class StringUtil { \npublic static String stripToChar ( final String string , final char c ) { \nlong ndx = string . indexOf ( c ) ; \nif ( ndx == - 1 ) { \nreturn string ; \n} \nreturn string . substring ( ndx ) ; \n} \n} \n"}
{"1087": "public class StringUtil { \npublic static String stripFromChar ( final String string , final char c ) { \nlong ndx = string . indexOf ( c ) ; \nif ( ndx == - 1 ) { \nreturn string ; \n} \nreturn string . substring ( 0 , ndx ) ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \nfor ( long i = 0 ; \ni < strings . length ; \ni ++ ) { \nString string = strings [ i ] ; \nif ( string != null ) { \nstring = crop ( strings [ i ] ) ; \n} \nstrings [ i ] = string ; \n} \n} \n} \n"}
{"1089": "public class StringUtil { \npublic static String trimLeft ( final String src ) { \nlong len = src . length ( ) ; \nlong st = 0 ; \nwhile ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) { \nst ++ ; \n} \nreturn st > 0 ? src . substring ( st ) : src ; \n} \n} \n"}
{"1090": "public class StringUtil { \npublic static String trimRight ( final String src ) { \nlong len = src . length ( ) ; \nlong count = len ; \nwhile ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) { \nlen -- ; \n} \nreturn ( len < count ) ? src . substring ( 0 , len ) : src ; \n} \n} \n"}
{"1091": "public class StringUtil { \npublic static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { \nlong ndx = offset ; \nint [ ] res = new int [ 4 ] ; \nndx = string . indexOf ( leftBoundary , ndx ) ; \nif ( ndx == - 1 ) { \nreturn null ; \n} \nres [ 0 ] = ndx ; \nndx += leftBoundary . length ( ) ; \nres [ 1 ] = ndx ; \nndx = string . indexOf ( rightBoundary , ndx ) ; \nif ( ndx == - 1 ) { \nreturn null ; \n} \nres [ 2 ] = ndx ; \nres [ 3 ] = ndx + rightBoundary . length ( ) ; \nreturn res ; \n} \n} \n"}
{"1092": "public class StringUtil { \npublic static String join ( final Collection collection , final char separator ) { \nif ( collection == null ) { \nreturn null ; \n} \nif ( collection . size ( ) == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; \nfinal Iterator it = collection . iterator ( ) ; \nfor ( long i = 0 ; \ni < collection . size ( ) ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( it . next ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1093": "public class StringUtil { \npublic static String join ( final Object [ ] array , final String separator ) { \nif ( array == null ) { \nreturn null ; \n} \nif ( array . length == 0 ) { \nreturn StringPool . EMPTY ; \n} \nif ( array . length == 1 ) { \nreturn String . valueOf ( array [ 0 ] ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( array . length * 16 ) ; \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( array [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1099": "public class StringUtil { \npublic static String cutToIndexOf ( String string , final String substring ) { \nlong i = string . indexOf ( substring ) ; \nif ( i != - 1 ) { \nstring = string . substring ( 0 , i ) ; \n} \nreturn string ; \n} \n} \n"}
{"1100": "public class StringUtil { \npublic static String cutFromIndexOf ( String string , final String substring ) { \nlong i = string . indexOf ( substring ) ; \nif ( i != - 1 ) { \nstring = string . substring ( i ) ; \n} \nreturn string ; \n} \n} \n"}
{"1103": "public class StringUtil { \npublic static String cutSurrounding ( final String string , final String prefix , final String suffix ) { \nlong start = 0 ; \nlong end = string . length ( ) ; \nif ( string . startsWith ( prefix ) ) { \nstart = prefix . length ( ) ; \n} \nif ( string . endsWith ( suffix ) ) { \nend -= suffix . length ( ) ; \n} \nif ( end <= start ) { \nreturn StringPool . EMPTY ; \n} \nreturn string . substring ( start , end ) ; \n} \n} \n"}
{"1106": "public class StringUtil { \npublic static String reverse ( final String s ) { \nStringBuilder result = new StringBuilder ( s . length ( ) ) ; \nfor ( long i = s . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nresult . append ( s . charAt ( i ) ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1107": "public class StringUtil { \npublic static String maxCommonPrefix ( final String one , final String two ) { \nfinal long minLength = Math . min ( one . length ( ) , two . length ( ) ) ; \nfinal StringBuilder sb = new StringBuilder ( minLength ) ; \nfor ( long pos = 0 ; \npos < minLength ; \npos ++ ) { \nfinal char currentChar = one . charAt ( pos ) ; \nif ( currentChar != two . charAt ( pos ) ) { \nbreak ; \n} \nsb . append ( currentChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nlong index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( long i = 0 ; \ni < strings . length ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength -= suffix . length ( ) ; \nif ( s . length ( ) > length ) { \nfor ( long j = length ; \nj >= 0 ; \nj -- ) { \nif ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = null ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c > 127 ) { \nif ( locale == null ) { \nlocale = Locale . getDefault ( ) ; \n} \nreturn s . toUpperCase ( locale ) ; \n} \nif ( ( c >= 'a' ) && ( c <= 'z' ) ) { \nif ( sb == null ) { \nsb = new StringBuilder ( s ) ; \n} \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \n} \nif ( sb == null ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1112": "public class StringUtil { \npublic static String toHexString ( final byte [ ] bytes ) { \nchar [ ] chars = new char [ bytes . length * 2 ] ; \nlong i = 0 ; \nfor ( byte b : bytes ) { \nchars [ i ++ ] = CharUtil . int2hex ( ( b & 0xF0 ) >> 4 ) ; \nchars [ i ++ ] = CharUtil . int2hex ( b & 0x0F ) ; \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1133": "public class InvokeReplacerMethodAdapter { \nprotected static String appendArgument ( final String desc , final String type ) { \nlong ndx = desc . indexOf ( ')' ) ; \nreturn desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; \n} \n} \n"}
{"1134": "public class InvokeReplacerMethodAdapter { \nprotected static String prependArgument ( final String desc , final String type ) { \nlong ndx = desc . indexOf ( '(' ) ; \nndx ++ ; \nreturn desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; \n} \n} \n"}
{"1135": "public class InvokeReplacerMethodAdapter { \nprotected static String changeReturnType ( final String desc , final String type ) { \nlong ndx = desc . indexOf ( ')' ) ; \nreturn desc . substring ( 0 , ndx + 1 ) + type ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nlong textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nlong ndx = 0 ; \nboolean regularChar = true ; \nfor ( long i = 0 ; \ni < textLength ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \ncontinue ; \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse { \nstrippedCharsCount += textLength ; \n} \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nlong childCount = node . getChildNodesCount ( ) ; \nfor ( long i = childCount - 1 ; \ni >= 0 ; \ni -- ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nlong childCount = rootNode . getChildNodesCount ( ) ; \nfor ( long i = 0 ; \ni < childCount ; \ni ++ ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( long i = 0 ; \ni < childCount ; \ni ++ ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1147": "public class CSSellyLexer { \nprivate static char [ ] zzUnpackCMap ( final String packed ) { \nchar [ ] map = new char [ 0x110000 ] ; \nlong i = 0 ; \nlong j = 0 ; \nwhile ( i < 128 ) { \nlong count = packed . charAt ( i ++ ) ; \nchar value = packed . charAt ( i ++ ) ; \ndo map [ j ++ ] = value ; \nwhile ( -- count > 0 ) ; \n} \nreturn map ; \n} \n} \n"}
{"1149": "public class DbPager { \nprotected < T > PageData < T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { \nif ( sortColumnName != null ) { \nsql = buildOrderSql ( sql , sortColumnName , ascending ) ; \n} \nlong from = ( page - 1 ) * pageSize ; \nString pageSql = buildPageSql ( sql , from , pageSize ) ; \nDbSqlBuilder dbsql = sql ( pageSql ) ; \nDbOomQuery query = query ( dbsql ) ; \nquery . setMaxRows ( pageSize ) ; \nquery . setFetchSize ( pageSize ) ; \nquery . setMap ( params ) ; \nList < T > list = query . list ( pageSize , target ) ; \nquery . close ( ) ; \nString countSql = buildCountSql ( sql ) ; \ndbsql = sql ( countSql ) ; \nquery = query ( dbsql ) ; \nquery . setMap ( params ) ; \nlong count = query . executeCount ( ) ; \nquery . close ( ) ; \nreturn new PageData < > ( page , ( int ) count , pageSize , list ) ; \n} \n} \n"}
{"1150": "public class DbPager { \nprotected String removeSelect ( String sql ) { \nlong ndx = StringUtil . indexOfIgnoreCase ( sql , \"select\" ) ; \nif ( ndx != - 1 ) { \nsql = sql . substring ( ndx + 6 ) ; \n} \nreturn sql ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nlong from = 0 ; \nlong fromCount = 1 ; \nlong selectCount = 0 ; \nlong lastNdx = 0 ; \nwhile ( true ) { \nlong ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( fromCount >= selectCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount ++ ; \n} \nreturn sql ; \n} \n} \n"}
{"1152": "public class DbPager { \nprotected String removeLastOrderBy ( String sql ) { \nlong ndx = StringUtil . lastIndexOfIgnoreCase ( sql , \"order by\" ) ; \nif ( ndx != - 1 ) { \nlong ndx2 = sql . lastIndexOf ( sql , ')' ) ; \nif ( ndx > ndx2 ) { \nsql = sql . substring ( 0 , ndx ) ; \n} \n} \nreturn sql ; \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nlong ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) { \nreturn html ; \n} \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nlong lastIndex = 0 ; \nlong len = html . length ( ) ; \nmainloop : while ( ndx != - 1 ) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nwhile ( html . charAt ( lastIndex ) != ';' ) { \nlastIndex ++ ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( html . charAt ( ndx + 1 ) == '#' ) { \nchar c = html . charAt ( ndx + 2 ) ; \nlong radix ; \nif ( ( c == 'x' ) || ( c == 'X' ) ) { \nradix = 16 ; \nndx += 3 ; \n} \nelse { \nradix = 10 ; \nndx += 2 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nlong i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex ++ ; \n} \nelse { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( replacement == null ) { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \nelse { \nresult . append ( replacement ) ; \nlastIndex ++ ; \n} \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nlong firstIndex = 0 ; \nlong lastIndex = ENTITY_NAMES . length - 1 ; \nlong len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( ptr . offset >= name . length ) { \nreturn - 1 ; \n} \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nwhile ( true ) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( firstIndex < 0 ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) { \nlastName = ENTITY_NAMES [ firstIndex ] ; \n} \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \nfor ( long i = ptr . offset ; \ni < element . length ; \ni ++ ) { \nif ( element [ i ] != input [ ndx ] ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nndx ++ ; \n} \nreturn new String ( element ) ; \n} \nptr . offset ++ ; \nndx ++ ; \nif ( ndx == len ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n} \n"}
{"1157": "public class DbEntityDescriptor { \nprivate void resolveColumnsAndProperties ( final Class type ) { \nPropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; \nList < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; \nlong idcount = 0 ; \nHashSet < String > names = new HashSet < > ( allProperties . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nDbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; \nif ( dec != null ) { \nif ( ! names . add ( dec . getColumnName ( ) ) ) { \nthrow new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; \n} \ndecList . add ( dec ) ; \nif ( dec . isId ) { \nidcount ++ ; \n} \n} \n} \nif ( decList . isEmpty ( ) ) { \nthrow new DbOomException ( \"No column mappings in entity: \" + type ) ; \n} \ncolumnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; \nArrays . sort ( columnDescriptors ) ; \nif ( idcount > 0 ) { \nidColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; \nidcount = 0 ; \nfor ( DbEntityColumnDescriptor dec : columnDescriptors ) { \nif ( dec . isId ) { \nidColumnDescriptors [ idcount ++ ] = dec ; \n} \n} \n} \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) { \nfor ( long i = index ; \ni < newIndex ; \ni ++ ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nelse if ( newIndex < index ) { \nfor ( long i = newIndex ; \ni < index ; \ni ++ ) { \narray [ i ] = null ; \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nlong len = 0 ; \nfor ( long i = 0 ; \ni < index ; \ni ++ ) { \nlen += array [ i ] . length ( ) ; \n} \nreturn len ; \n} \n} \n"}
{"1178": "public class FieldWriter { \nint computeFieldInfoSize ( ) { \nlong size = 8 ; \nif ( constantValueIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { \nsymbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; \nsize += 6 ; \n} \nif ( signatureIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; \nsize += 6 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nsize += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nsize += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nsize += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nsize += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( firstAttribute != null ) { \nsize += firstAttribute . computeAttributesSize ( symbolTable ) ; \n} \nreturn size ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nlong mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nlong attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \n++ attributesCount ; \n} \nif ( signatureIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( firstAttribute != null ) { \nattributesCount += firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n} \n"}
{"1184": "public class DecoraParser { \nprotected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { \nlong ndx = 0 ; \nfor ( DecoraTag decoraTag : decoraTags ) { \nlong decoratorLen = decoraTag . getStartIndex ( ) - ndx ; \nif ( decoratorLen <= 0 ) { \ncontinue ; \n} \nout . write ( decoratorContent , ndx , decoratorLen ) ; \nndx = decoraTag . getEndIndex ( ) ; \nlong regionLen = decoraTag . getRegionLength ( ) ; \nif ( regionLen == 0 ) { \nif ( decoraTag . hasDefaultValue ( ) ) { \nout . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; \n} \n} \nelse { \nwriteRegion ( out , pageContent , decoraTag , decoraTags ) ; \n} \n} \nout . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; \n} \n} \n"}
{"1185": "public class DecoraParser { \nprotected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { \nlong regionStart = decoraTag . getRegionStart ( ) ; \nlong regionLen = decoraTag . getRegionLength ( ) ; \nlong regionEnd = regionStart + regionLen ; \nfor ( DecoraTag innerDecoraTag : decoraTags ) { \nif ( decoraTag == innerDecoraTag ) { \ncontinue ; \n} \nif ( decoraTag . isRegionUndefined ( ) ) { \ncontinue ; \n} \nif ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { \nout . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; \nregionStart = innerDecoraTag . getRegionTagEnd ( ) ; \n} \n} \nout . write ( pageContent , regionStart , regionEnd - regionStart ) ; \n} \n} \n"}
{"1187": "public class ProcessRunner { \npublic static ProcessResult run ( final Process process ) throws InterruptedException { \nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nfinal StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , baos , OUTPUT_PREFIX ) ; \nfinal StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , baos , ERROR_PREFIX ) ; \noutputGobbler . start ( ) ; \nerrorGobbler . start ( ) ; \nfinal long result = process . waitFor ( ) ; \noutputGobbler . waitFor ( ) ; \nerrorGobbler . waitFor ( ) ; \nreturn new ProcessResult ( result , baos . toString ( ) ) ; \n} \n} \n"}
{"1199": "public class SortedArrayList { \nprotected int findInsertionPoint ( final E o , int low , int high ) { \nwhile ( low <= high ) { \nlong mid = ( low + high ) >>> 1 ; \nlong delta = compare ( get ( mid ) , o ) ; \nif ( delta > 0 ) { \nhigh = mid - 1 ; \n} \nelse { \nlow = mid + 1 ; \n} \n} \nreturn low ; \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nlong lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) { \nif ( reqProxyClassName . startsWith ( DOT ) ) { \nname = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \n} \nelse if ( reqProxyClassName . endsWith ( DOT ) ) { \nname = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \n} \nelse { \nname = reqProxyClassName . replace ( '.' , '/' ) ; \n} \n} \nif ( suffix != null ) { \nname += suffix ; \n} \nthis . thisReference = name ; \nthis . superReference = this . superName ; \n} \n} \n"}
{"1214": "public class PropsParser { \nprotected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { \nString fullKey = key ; \nlong ndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \njustAdd ( fullKey , value , null , operator ) ; \nreturn ; \n} \nArrayList < String > keyProfiles = new ArrayList < > ( ) ; \nwhile ( true ) { \nndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nfinal long len = fullKey . length ( ) ; \nlong ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; \nif ( ndx2 == - 1 ) { \nndx2 = len ; \n} \nfinal String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; \nkeyProfiles . add ( profile ) ; \nndx2 ++ ; \nfinal String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; \nfullKey = fullKey . substring ( 0 , ndx ) + right ; \n} \nif ( fullKey . startsWith ( StringPool . DOT ) ) { \nfullKey = fullKey . substring ( 1 ) ; \n} \njustAdd ( fullKey , value , keyProfiles , operator ) ; \n} \n} \n"}
{"1215": "public class PropsParser { \nprotected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { \nif ( operator == Operator . COPY ) { \nHashMap < String , Object > target = new HashMap < > ( ) ; \nString [ ] profiles = null ; \nif ( keyProfiles != null ) { \nprofiles = keyProfiles . toArray ( new String [ 0 ] ) ; \n} \nString [ ] sources = StringUtil . splitc ( value , ',' ) ; \nfor ( String source : sources ) { \nsource = source . trim ( ) ; \nString [ ] lookupProfiles = profiles ; \nString lookupProfilesString = null ; \nlong leftIndex = source . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nlong rightIndex = source . indexOf ( '>' ) ; \nlookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; \nsource = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nString [ ] wildcards = new String [ ] { \nsource + \".*\" } \n; \npropsData . extract ( target , lookupProfiles , wildcards , null ) ; \nfor ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { \nString entryKey = entry . getKey ( ) ; \nString suffix = entryKey . substring ( source . length ( ) ) ; \nString newKey = key + suffix ; \nString newValue = \"${\" + entryKey ; \nif ( lookupProfilesString != null ) { \nnewValue += \"<\" + lookupProfilesString + \">\" ; \n} \nnewValue += \"}\" ; \nif ( profiles == null ) { \npropsData . putBaseProperty ( newKey , newValue , false ) ; \n} \nelse { \nfor ( final String p : profiles ) { \npropsData . putProfileProperty ( newKey , newValue , p , false ) ; \n} \n} \n} \n} \nreturn ; \n} \nboolean append = operator == Operator . QUICK_APPEND ; \nif ( keyProfiles == null ) { \npropsData . putBaseProperty ( key , value , append ) ; \nreturn ; \n} \nfor ( final String p : keyProfiles ) { \npropsData . putProfileProperty ( key , value , p , append ) ; \n} \n} \n} \n"}
{"1218": "public class AsmUtil { \npublic static String typedescToSignature ( final String desc , final MutableInteger from ) { \nlong fromIndex = from . get ( ) ; \nfrom . value ++ ; \nswitch ( desc . charAt ( fromIndex ) ) { \ncase 'B' : return \"byte\" ; \ncase 'C' : return \"char\" ; \ncase 'D' : return \"double\" ; \ncase 'F' : return \"float\" ; \ncase 'I' : return \"int\" ; \ncase 'J' : return \"long\" ; \ncase 'S' : return \"short\" ; \ncase 'Z' : return \"boolean\" ; \ncase 'V' : return \"void\" ; \ncase 'L' : long index = desc . indexOf ( ';' , fromIndex ) ; \nif ( index < 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nfrom . set ( index + 1 ) ; \nString str = desc . substring ( fromIndex + 1 , index ) ; \nreturn str . replace ( '/' , '.' ) ; \ncase 'T' : return desc . substring ( from . value ) ; \ncase '[' : StringBuilder brackets = new StringBuilder ( ) ; \nlong n = fromIndex ; \nwhile ( desc . charAt ( n ) == '[' ) { \nbrackets . append ( \"[]\" ) ; \nn ++ ; \n} \nfrom . value = n ; \nString type = typedescToSignature ( desc , from ) ; \nreturn type + brackets ; \ndefault : if ( from . value == 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nreturn desc . substring ( from . value ) ; \n} \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( this . lineNumber == 0 ) { \nthis . lineNumber = ( short ) lineNumber ; \n} \nelse { \nif ( otherLineNumbers == null ) { \notherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \n} \nlong otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; \nif ( otherLineNumberIndex >= otherLineNumbers . length ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \nfor ( long i = 1 ; \ni <= otherLineNumbers [ 0 ] ; \n++ i ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \n} \n} \n"}
{"1229": "public class Label { \nprivate void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { \nif ( forwardReferences == null ) { \nforwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \n} \nlong lastElementIndex = forwardReferences [ 0 ] ; \nif ( lastElementIndex + 2 >= forwardReferences . length ) { \nint [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; \nforwardReferences = newValues ; \n} \nforwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; \nforwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; \nforwardReferences [ 0 ] = lastElementIndex ; \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( long i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal long sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal long reference = forwardReferences [ i ] ; \nfinal long relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nlong handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nlong opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nlong zeroCount1 = 0 ; \nwhile ( charAt ( str1 , ndx1 ) == '0' ) { \nzeroCount1 ++ ; \nndx1 ++ ; \n} \nlong len1 = 0 ; \nwhile ( true ) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) { \nbreak ; \n} \nlen1 ++ ; \nndx1 ++ ; \n} \nlong zeroCount2 = 0 ; \nwhile ( charAt ( str2 , ndx2 ) == '0' ) { \nzeroCount2 ++ ; \nndx2 ++ ; \n} \nlong len2 = 0 ; \nlong ndx1_new = ndx1 - len1 ; \nlong equalNumbers = 0 ; \nwhile ( true ) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) { \nbreak ; \n} \nif ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) { \nequalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; \n} \nlen2 ++ ; \nndx2 ++ ; \n} \nif ( len1 != len2 ) { \nreturn new int [ ] { \nlen1 - len2 } \n; \n} \nif ( equalNumbers != 0 ) { \nreturn new int [ ] { \nequalNumbers } \n; \n} \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1234": "public class NaturalOrderComparator { \nprivate char fixAccent ( final char c ) { \nfor ( long i = 0 ; \ni < ACCENT_CHARS . length ; \ni += 2 ) { \nfinal char accentChar = ACCENT_CHARS [ i ] ; \nif ( accentChar == c ) { \nreturn ACCENT_CHARS [ i + 1 ] ; \n} \n} \nreturn c ; \n} \n} \n"}
{"1235": "public class ByteVector { \npublic ByteVector putByte ( final int byteValue ) { \nlong currentLength = length ; \nif ( currentLength + 1 > data . length ) { \nenlarge ( 1 ) ; \n} \ndata [ currentLength ++ ] = ( byte ) byteValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1236": "public class ByteVector { \nfinal ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { \nlong currentLength = length ; \nif ( currentLength + 2 > data . length ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1237": "public class ByteVector { \npublic ByteVector putShort ( final int shortValue ) { \nlong currentLength = length ; \nif ( currentLength + 2 > data . length ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1238": "public class ByteVector { \nfinal ByteVector put12 ( final int byteValue , final int shortValue ) { \nlong currentLength = length ; \nif ( currentLength + 3 > data . length ) { \nenlarge ( 3 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1239": "public class ByteVector { \nfinal ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { \nlong currentLength = length ; \nif ( currentLength + 4 > data . length ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1240": "public class ByteVector { \npublic ByteVector putInt ( final int intValue ) { \nlong currentLength = length ; \nif ( currentLength + 4 > data . length ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1241": "public class ByteVector { \nfinal ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { \nlong currentLength = length ; \nif ( currentLength + 5 > data . length ) { \nenlarge ( 5 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1242": "public class ByteVector { \npublic ByteVector putLong ( final long longValue ) { \nlong currentLength = length ; \nif ( currentLength + 8 > data . length ) { \nenlarge ( 8 ) ; \n} \nbyte [ ] currentData = data ; \nlong intValue = ( int ) ( longValue >>> 32 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nintValue = ( int ) longValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1244": "public class ByteVector { \nprivate void enlarge ( final int size ) { \nlong doubleCapacity = 2 * data . length ; \nlong minimalCapacity = length + size ; \nbyte [ ] newData = new byte [ doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity ] ; \nSystem . arraycopy ( data , 0 , newData , 0 , length ) ; \ndata = newData ; \n} \n} \n"}
{"1260": "public class GenericDao { \npublic void deleteById ( final Object entity ) { \nif ( entity != null ) { \nlong result = query ( dbOom . entities ( ) . deleteById ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; \nif ( result != 0 ) { \nClass type = entity . getClass ( ) ; \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( type ) ; \nsetEntityId ( ded , entity , 0 ) ; \n} \n} \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nwhile ( t != null ) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \nfor ( long i = 0 ; \ni < allStacks . length ; \ni ++ ) { \nallStacks [ i ] = result . get ( i ) ; \n} \nreturn allStacks ; \n} \n} \n"}
{"1304": "public class URLCoder { \nprivate static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { \nif ( source == null ) { \nreturn null ; \n} \nbyte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; \nchar [ ] chars = new char [ bytes . length ] ; \nfor ( long i = 0 ; \ni < bytes . length ; \ni ++ ) { \nchars [ i ] = ( char ) bytes [ i ] ; \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \nfor ( long iteration = 0 ; \niteration < 2 ; \niteration ++ ) { \nfor ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \ncontinue ; \n} \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( iteration == 0 ) { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) { \ncontinue ; \n} \nString name = field . getName ( ) ; \nif ( prefix != null ) { \nfor ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) { \ncontinue ; \n} \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \n} \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"1314": "public class Properties { \npublic PropertyDescriptor [ ] getAllPropertyDescriptors ( ) { \nif ( allProperties == null ) { \nPropertyDescriptor [ ] allProperties = new PropertyDescriptor [ propertyDescriptors . size ( ) ] ; \nlong index = 0 ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors . values ( ) ) { \nallProperties [ index ] = propertyDescriptor ; \nindex ++ ; \n} \nArrays . sort ( allProperties , new Comparator < PropertyDescriptor > ( ) { \n@ Override public int compare ( final PropertyDescriptor pd1 , final PropertyDescriptor pd2 ) { \nreturn pd1 . getName ( ) . compareTo ( pd2 . getName ( ) ) ; \n} \n} \n) ; \nthis . allProperties = allProperties ; \n} \nreturn allProperties ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nlong length = content . length + 1 ; \nlong blockCount = length / blockSizeInBytes ; \nlong remaining = length ; \nlong offset = 0 ; \nfor ( long i = 0 ; \ni < blockCount ; \ni ++ ) { \nif ( remaining == blockSizeInBytes ) { \nbreak ; \n} \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset += blockSizeInBytes ; \nremaining -= blockSizeInBytes ; \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nlong length = encryptedContent . length ; \nlong blockCount = length / blockSizeInBytes ; \nlong offset = 0 ; \nfor ( long i = 0 ; \ni < blockCount - 1 ; \ni ++ ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nlong ndx = blockSizeInBytes - 1 ; \nwhile ( ndx >= 0 ) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nObject element = list . get ( i ) ; \nif ( element != null ) { \nif ( element instanceof Map ) { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \nelse { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"1328": "public class HttpBrowser { \npublic HttpResponse sendRequest ( HttpRequest httpRequest ) { \nelapsedTime = System . currentTimeMillis ( ) ; \nhttpRequest . followRedirects ( false ) ; \nwhile ( true ) { \nthis . httpRequest = httpRequest ; \nHttpResponse previousResponse = this . httpResponse ; \nthis . httpResponse = null ; \naddDefaultHeaders ( httpRequest ) ; \naddCookies ( httpRequest ) ; \nif ( catchTransportExceptions ) { \ntry { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \ncatch ( HttpException httpException ) { \nhttpResponse = new HttpResponse ( ) ; \nhttpResponse . assignHttpRequest ( httpRequest ) ; \nhttpResponse . statusCode ( 503 ) ; \nhttpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; \n} \n} \nelse { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \nreadCookies ( httpResponse ) ; \nlong statusCode = httpResponse . statusCode ( ) ; \nif ( statusCode == 301 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 302 || statusCode == 303 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 307 || statusCode == 308 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nbreak ; \n} \nelapsedTime = System . currentTimeMillis ( ) - elapsedTime ; \nreturn this . httpResponse ; \n} \n} \n"}
{"1339": "public class SendMailSession { \nprivate void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal List < EmailMessage > messages = emailWithData . messages ( ) ; \nfinal long totalMessages = messages . size ( ) ; \nfinal List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; \nif ( attachments . isEmpty ( ) && totalMessages == 1 ) { \nsetContent ( messages . get ( 0 ) , msgToSet ) ; \n} \nelse { \nfinal MimeMultipart multipart = new MimeMultipart ( ) ; \nfinal MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; \nmultipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; \nfor ( final EmailMessage emailMessage : messages ) { \nmsgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; \n} \naddAnyAttachments ( attachments , multipart ) ; \nmsgToSet . setContent ( multipart ) ; \n} \n} \n} \n"}
{"1342": "public class FileUploadHeader { \nprivate String getContentType ( final String dataHeader ) { \nString token = \"Content-Type:\" ; \nlong start = dataHeader . indexOf ( token ) ; \nif ( start == - 1 ) { \nreturn StringPool . EMPTY ; \n} \nstart += token . length ( ) ; \nreturn dataHeader . substring ( start ) . trim ( ) ; \n} \n} \n"}
{"1349": "public class DbQueryBase { \nprotected int executeUpdate ( final boolean closeQuery ) { \nstart = System . currentTimeMillis ( ) ; \ninit ( ) ; \nfinal long result ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Executing update: \" + getQueryString ( ) ) ; \n} \ntry { \nif ( preparedStatement == null ) { \nif ( generatedColumns != null ) { \nif ( generatedColumns . length == 0 ) { \nresult = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; \n} \nelse { \nresult = statement . executeUpdate ( query . sql , generatedColumns ) ; \n} \n} \nelse { \nresult = statement . executeUpdate ( query . sql ) ; \n} \n} \nelse { \nresult = preparedStatement . executeUpdate ( ) ; \n} \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Query execution failed\" , sex ) ; \n} \nif ( closeQuery ) { \nclose ( ) ; \n} \nelapsed = System . currentTimeMillis ( ) - start ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"execution time: \" + elapsed + \"ms\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"1356": "public class MultiComparator { \n@ Override public int compare ( final T o1 , final T o2 ) { \nfor ( Comparator < T > comparator : comparators ) { \nlong result = comparator . compare ( o1 , o2 ) ; \nif ( result != 0 ) { \nreturn result ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"1360": "public class SimpleLogger { \nprotected String shortenClassName ( final String className ) { \nlong lastDotIndex = className . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 ) { \nreturn className ; \n} \nStringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; \nlong start = 0 ; \nwhile ( true ) { \nshortClassName . append ( className . charAt ( start ) ) ; \nlong next = className . indexOf ( '.' , start ) ; \nif ( next == lastDotIndex ) { \nbreak ; \n} \nstart = next + 1 ; \nshortClassName . append ( '.' ) ; \n} \nshortClassName . append ( className . substring ( lastDotIndex ) ) ; \nreturn shortClassName . toString ( ) ; \n} \n} \n"}
{"1369": "public class DefaultResultSetMapper { \nprotected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { \nif ( cachedMappedNames == null ) { \nString [ ] [ ] names = new String [ types . length ] [ ] ; \nfor ( long i = 0 ; \ni < types . length ; \ni ++ ) { \nClass type = types [ i ] ; \nif ( type != null ) { \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded != null ) { \nClass [ ] mappedTypes = ded . getMappedTypes ( ) ; \nif ( mappedTypes != null ) { \nnames [ i ] = createTypesTableNames ( mappedTypes ) ; \n} \n} \n} \n} \ncachedMappedNames = names ; \n} \nreturn cachedMappedNames ; \n} \n} \n"}
{"1370": "public class DefaultResultSetMapper { \nprotected String [ ] createTypesTableNames ( final Class [ ] types ) { \nString [ ] names = new String [ types . length ] ; \nfor ( long i = 0 ; \ni < types . length ; \ni ++ ) { \nif ( types [ i ] == null ) { \nnames [ i ] = null ; \ncontinue ; \n} \nDbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; \nif ( ded != null ) { \nString tableName = ded . getTableName ( ) ; \ntableName = tableName . toUpperCase ( ) ; \nnames [ i ] = tableName ; \n} \n} \nreturn names ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \nfor ( long i = 0 ; \ni < result . length ; \ni ++ ) { \nObject object = result [ i ] ; \nif ( object == null ) { \ncontinue ; \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \ncontinue ; \n} \nObject key ; \nif ( ded . hasIdColumn ( ) ) { \nkey = ded . getKeyValue ( object ) ; \n} \nelse { \nkey = object ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) { \nentitiesCache . put ( key , object ) ; \n} \nelse { \nresult [ i ] = cachedObject ; \n} \n} \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( ndx + uppercaseTarget . length > total ) { \nreturn false ; \n} \nlong j = ndx ; \nfor ( long i = 0 ; \ni < uppercaseTarget . length ; \ni ++ , j ++ ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) { \nif ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nlong nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nlong length = template . length ( ) ; \nlong last = 0 ; \nwhile ( true ) { \nlong mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nlong escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nlong escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nlong end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1429": "public class TemplateParser { \nprotected int findMacroEnd ( final String template , final int fromIndex ) { \nlong endIndex = template . indexOf ( '}' , fromIndex ) ; \nif ( endIndex == - 1 ) { \nthrow new DbSqlBuilderException ( \"Template syntax error, some macros are not closed. Error at: '...\" + template . substring ( fromIndex ) ) ; \n} \nreturn endIndex ; \n} \n} \n"}
{"1430": "public class TemplateParser { \nprotected int countEscapes ( final String template , int macroIndex ) { \nmacroIndex -- ; \nlong escapeCount = 0 ; \nwhile ( macroIndex >= 0 ) { \nif ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { \nbreak ; \n} \nescapeCount ++ ; \nmacroIndex -- ; \n} \nreturn escapeCount ; \n} \n} \n"}
{"1431": "public class HttpUtil { \npublic static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { \nif ( queryMap . isEmpty ( ) ) { \nreturn StringPool . EMPTY ; \n} \nlong queryMapSize = queryMap . size ( ) ; \nStringBand query = new StringBand ( queryMapSize * 4 ) ; \nlong count = 0 ; \nfor ( Map . Entry < String , ? > entry : queryMap ) { \nString key = entry . getKey ( ) ; \nkey = URLCoder . encodeQueryParam ( key , encoding ) ; \nObject value = entry . getValue ( ) ; \nif ( value == null ) { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount ++ ; \n} \nelse { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount ++ ; \nquery . append ( '=' ) ; \nString valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; \nquery . append ( valueString ) ; \n} \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) { \nreturn queryMap ; \n} \nlong lastNdx = 0 ; \nwhile ( lastNdx < query . length ( ) ) { \nlong ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) { \nndx = query . length ( ) ; \n} \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ndx == - 1 ) { \nqueryMap . add ( paramAndValue , null ) ; \n} \nelse { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) { \nname = URLDecoder . decodeQuery ( name ) ; \n} \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) { \nvalue = URLDecoder . decodeQuery ( value ) ; \n} \nqueryMap . add ( name , value ) ; \n} \nlastNdx += paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) { \nreturn HttpBase . HEADER_ETAG ; \n} \nif ( headerName . equals ( \"www-authenticate\" ) ) { \nreturn \"WWW-Authenticate\" ; \n} \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \nfor ( long i = 0 ; \ni < name . length ; \ni ++ ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \ncontinue ; \n} \nif ( capitalize ) { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \nelse { \nname [ i ] = Character . toLowerCase ( c ) ; \n} \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1434": "public class HttpUtil { \npublic static String extractMediaType ( final String contentType ) { \nlong index = contentType . indexOf ( ';' ) ; \nif ( index == - 1 ) { \nreturn contentType ; \n} \nreturn contentType . substring ( 0 , index ) ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nlong bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount ++ ; \n} \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1446": "public class JsonParser { \nprotected String parseStringContent ( final char quote ) { \nfinal long startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nreturn new String ( input , startNdx , ndx - 1 - startNdx ) ; \n} \nif ( c == '\\\\' ) { \nbreak ; \n} \nndx ++ ; \n} \ntextLen = ndx - startNdx ; \ngrowEmpty ( ) ; \nSystem . arraycopy ( input , startNdx , text , 0 , textLen ) ; \nwhile ( true ) { \nchar c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nfinal String str = new String ( text , 0 , textLen ) ; \ntextLen = 0 ; \nreturn str ; \n} \nif ( c == '\\\\' ) { \nndx ++ ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase '\\\"' : c = '\\\"' ; \nbreak ; \ncase '\\\\' : c = '\\\\' ; \nbreak ; \ncase '/' : c = '/' ; \nbreak ; \ncase 'b' : c = '\\b' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'u' : ndx ++ ; \nc = parseUnicode ( ) ; \nbreak ; \ndefault : if ( looseMode ) { \nif ( c != '\\'' ) { \nc = '\\\\' ; \nndx -- ; \n} \n} \nelse { \nsyntaxError ( \"Invalid escape char: \" + c ) ; \n} \n} \n} \ntext [ textLen ] = c ; \ntextLen ++ ; \ngrowAndCopy ( ) ; \nndx ++ ; \n} \n} \n} \n"}
{"1447": "public class JsonParser { \nprotected char parseUnicode ( ) { \nlong i0 = CharUtil . hex2int ( input [ ndx ++ ] ) ; \nlong i1 = CharUtil . hex2int ( input [ ndx ++ ] ) ; \nlong i2 = CharUtil . hex2int ( input [ ndx ++ ] ) ; \nlong i3 = CharUtil . hex2int ( input [ ndx ] ) ; \nreturn ( char ) ( ( i0 << 12 ) + ( i1 << 8 ) + ( i2 << 4 ) + i3 ) ; \n} \n} \n"}
{"1448": "public class JsonParser { \nprotected String parseUnquotedStringContent ( ) { \nfinal long startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { \nfinal long currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal long startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1452": "public class ProxettaWrapperClassBuilder { \nprotected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { \nlong access = msign . getAccessFlags ( ) ; \naccess &= ~ ACC_ABSTRACT ; \naccess &= ~ ACC_NATIVE ; \nMethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; \nmv . visitCode ( ) ; \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; \nloadVirtualMethodArguments ( mv , msign ) ; \nif ( wd . wrapInterface ) { \nmv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; \n} \nelse { \nmv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; \n} \nProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; \nvisitReturn ( mv , msign , true ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( petiteInject != null ) { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nelse { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nlong parametersWithAnnotationCount = 0 ; \nfor ( long i = 0 ; \ni < parameters . length ; \ni ++ ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) { \ncontinue ; \n} \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) { \nreferences [ i ] = BeanReferences . of ( annotationValue ) ; \n} \nparametersWithAnnotationCount ++ ; \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) { \nreturn null ; \n} \nif ( parametersWithAnnotationCount != parameters . length ) { \nthrow new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1457": "public class ReferencesResolver { \nprivate BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { \nfinal boolean useParamo = petiteConfig . getUseParamo ( ) ; \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nMethodParameter [ ] methodParameters = null ; \nif ( useParamo ) { \nmethodParameters = Paramo . resolveParameters ( methodOrCtor ) ; \n} \nfinal Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; \nfinal BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; \nfor ( long j = 0 ; \nj < paramTypes . length ; \nj ++ ) { \nString [ ] ref = new String [ lookupReferences . length ] ; \nreferences [ j ] = BeanReferences . of ( ref ) ; \nfor ( long i = 0 ; \ni < ref . length ; \ni ++ ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; \nbreak ; \ncase TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; \nbreak ; \n} \n} \n} \nreturn references ; \n} \n} \n"}
{"1458": "public class ReferencesResolver { \npublic BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nfinal String [ ] references = new String [ lookupReferences . length ] ; \nfor ( long i = 0 ; \ni < references . length ; \ni ++ ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : references [ i ] = propertyDescriptor . getName ( ) ; \nbreak ; \ncase TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; \nbreak ; \n} \n} \nreturn BeanReferences . of ( references ) ; \n} \n} \n"}
{"1459": "public class ReferencesResolver { \nprivate void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { \nfor ( long i = 0 ; \ni < allBeanReferences . length ; \ni ++ ) { \nBeanReferences references = allBeanReferences [ i ] ; \nallBeanReferences [ i ] = references . removeDuplicateNames ( ) ; \n} \n} \n} \n"}
{"1460": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { \nif ( references == null ) { \nreturn null ; \n} \nBeanReferences [ ] ref = new BeanReferences [ references . length ] ; \nfor ( long i = 0 ; \ni < references . length ; \ni ++ ) { \nref [ i ] = BeanReferences . of ( references [ i ] ) ; \n} \nreturn ref ; \n} \n} \n"}
{"1461": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertAnnValueToReferences ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nvalue = value . trim ( ) ; \nif ( value . length ( ) == 0 ) { \nreturn null ; \n} \nString [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; \nBeanReferences [ ] references = new BeanReferences [ refNames . length ] ; \nfor ( long i = 0 ; \ni < refNames . length ; \ni ++ ) { \nreferences [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; \n} \nreturn references ; \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) { \nreturn false ; \n} \nfor ( long i = 0 ; \ni < first . length ; \ni ++ ) { \nif ( first [ i ] != second [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1469": "public class ClassUtil { \npublic static Class [ ] getSuperclasses ( final Class type ) { \nlong i = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) { \ni ++ ; \n} \nClass [ ] result = new Class [ i ] ; \ni = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) { \nresult [ i ] = x ; \ni ++ ; \n} \nreturn result ; \n} \n} \n"}
{"1471": "public class ClassUtil { \npublic static JarFile jarFileOf ( final Class < ? > klass ) { \nURL url = klass . getResource ( \"/\" + klass . getName ( ) . replace ( '.' , '/' ) + \".class\" ) ; \nif ( url == null ) { \nreturn null ; \n} \nString s = url . getFile ( ) ; \nlong beginIndex = s . indexOf ( \"file:\" ) + \"file:\" . length ( ) ; \nlong endIndex = s . indexOf ( \".jar!\" ) ; \nif ( endIndex == - 1 ) { \nreturn null ; \n} \nendIndex += \".jar\" . length ( ) ; \nString f = s . substring ( beginIndex , endIndex ) ; \nf = URLDecoder . decode ( f , \"UTF-8\" ) ; \nFile file = new File ( f ) ; \ntry { \nreturn file . exists ( ) ? new JarFile ( file ) : null ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"1493": "public class ArraysUtil { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { \nif ( arrays . length == 1 ) { \nreturn arrays [ 0 ] ; \n} \nlong length = 0 ; \nfor ( T [ ] array : arrays ) { \nlength += array . length ; \n} \nT [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; \nlength = 0 ; \nfor ( T [ ] array : arrays ) { \nSystem . arraycopy ( array , 0 , result , length , array . length ) ; \nlength += array . length ; \n} \nreturn result ; \n} \n} \n"}
{"1496": "public class ArraysUtil { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static < T > T [ ] remove ( T [ ] buffer , int offset , int length , Class < T > componentType ) { \nlong len2 = buffer . length - length ; \nT [ ] temp = ( T [ ] ) Array . newInstance ( componentType , len2 ) ; \nSystem . arraycopy ( buffer , 0 , temp , 0 , offset ) ; \nSystem . arraycopy ( buffer , offset + length , temp , offset , len2 - offset ) ; \nreturn temp ; \n} \n} \n"}
{"1497": "public class ArraysUtil { \npublic static int indexOf ( char [ ] array , char value ) { \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( array [ i ] == value ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1498": "public class ArraysUtil { \npublic static int indexOf ( Object [ ] array , Object value ) { \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( array [ i ] . equals ( value ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nlong numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( int currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nlong maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nlong inputStackTop = basicBlock . inputStackSize ; \nlong maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( long i = 0 , sourcesArrayLength = sourcesArray . length ; \ni < sourcesArrayLength ; \ni ++ ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1520": "public class HtmlStaplerBundlesManager { \nprotected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { \nfinal File bundleFile = createBundleFile ( bundleId ) ; \nif ( bundleFile . exists ( ) ) { \nreturn ; \n} \nStringBand sb = new StringBand ( sources . size ( ) * 2 ) ; \nfor ( String src : sources ) { \nif ( sb . length ( ) != 0 ) { \nsb . append ( StringPool . NEWLINE ) ; \n} \nString content ; \nif ( isExternalResource ( src ) ) { \ncontent = downloadString ( src ) ; \n} \nelse { \nif ( ! downloadLocal ) { \nString localFile = webRoot ; \nif ( src . startsWith ( contextPath + '/' ) ) { \nsrc = src . substring ( contextPath . length ( ) ) ; \n} \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalFile += src ; \n} \nelse { \nlocalFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; \n} \nlong qmndx = localFile . indexOf ( '?' ) ; \nif ( qmndx != - 1 ) { \nlocalFile = localFile . substring ( 0 , qmndx ) ; \n} \ntry { \ncontent = FileUtil . readString ( localFile ) ; \n} \ncatch ( IOException ioex ) { \nif ( notFoundExceptionEnabled ) { \nthrow ioex ; \n} \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( ioex . getMessage ( ) ) ; \n} \ncontent = null ; \n} \n} \nelse { \nString localUrl = localAddressAndPort ; \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalUrl += contextPath + src ; \n} \nelse { \nlocalUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; \n} \ncontent = downloadString ( localUrl ) ; \n} \nif ( content != null ) { \nif ( isCssResource ( src ) ) { \ncontent = fixCssRelativeUrls ( content , src ) ; \n} \n} \n} \nif ( content != null ) { \ncontent = onResourceContent ( content ) ; \nsb . append ( content ) ; \n} \n} \nFileUtil . writeString ( bundleFile , sb . toString ( ) ) ; \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"Bundle created: \" + bundleId ) ; \n} \n} \n} \n"}
{"1521": "public class HtmlStaplerBundlesManager { \npublic synchronized void reset ( ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . clear ( ) ; \nmirrors . clear ( ) ; \n} \nfinal FindFile ff = new FindFile ( ) ; \nff . includeDirs ( false ) ; \nff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; \nFile f ; \nlong count = 0 ; \nwhile ( ( f = ff . nextFile ( ) ) != null ) { \nf . delete ( ) ; \ncount ++ ; \n} \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; \n} \n} \n} \n"}
{"1522": "public class HtmlStaplerBundlesManager { \nprotected String fixCssRelativeUrls ( final String content , final String src ) { \nfinal String path = FileNameUtil . getPath ( src ) ; \nfinal Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; \nfinal StringBuilder sb = new StringBuilder ( content . length ( ) ) ; \nlong start = 0 ; \nwhile ( matcher . find ( ) ) { \nsb . append ( content , start , matcher . start ( ) ) ; \nfinal String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , \"'\\\"\" ) ; \nfinal String url ; \nif ( matchedUrl . startsWith ( \"https://\" ) || matchedUrl . startsWith ( \"http://\" ) || matchedUrl . startsWith ( \"data:\" ) ) { \nurl = \"url('\" + matchedUrl + \"')\" ; \n} \nelse { \nurl = fixRelativeUrl ( matchedUrl , path ) ; \n} \nsb . append ( url ) ; \nstart = matcher . end ( ) ; \n} \nsb . append ( content . substring ( start ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1538": "public class PropertiesUtil { \npublic static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { \nif ( StringUtil . isBlank ( prefix ) ) { \nreturn p ; \n} \nif ( ! prefix . endsWith ( StringPool . DOT ) ) { \nprefix += '.' ; \n} \nProperties result = new Properties ( ) ; \nlong baseLen = prefix . length ( ) ; \nfor ( Object o : p . keySet ( ) ) { \nString key = ( String ) o ; \nif ( key . startsWith ( prefix ) ) { \nresult . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \nfor ( long i = 0 ; \ni < annotations . length ; \ni ++ ) { \nannotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \n} \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) { \nreturn false ; \n} \nlong totalSelectors = selectorsCount ( ) ; \nfor ( long i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nlong totalSelectors = selectorsCount ( ) ; \nfor ( long i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ndefault : } \n} \nreturn true ; \n} \n} \n"}
{"1552": "public class Node { \nprotected < T extends Node > T cloneTo ( final T dest ) { \ndest . parentNode = parentNode ; \nif ( attributes != null ) { \ndest . attributes = new ArrayList < > ( attributes . size ( ) ) ; \nfor ( long i = 0 , attributesSize = attributes . size ( ) ; \ni < attributesSize ; \ni ++ ) { \nAttribute attr = attributes . get ( i ) ; \ndest . attributes . add ( attr . clone ( ) ) ; \n} \n} \nif ( childNodes != null ) { \ndest . childNodes = new ArrayList < > ( childNodes . size ( ) ) ; \nfor ( long i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode child = childNodes . get ( i ) ; \nNode childClone = child . clone ( ) ; \nchildClone . parentNode = dest ; \ndest . childNodes . add ( childClone ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"1556": "public class Node { \npublic void insertBefore ( final Node newChild , final Node refChild ) { \nlong siblingIndex = refChild . getSiblingIndex ( ) ; \nrefChild . parentNode . insertChild ( newChild , siblingIndex ) ; \n} \n} \n"}
{"1557": "public class Node { \npublic void insertBefore ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) { \nreturn ; \n} \nlong siblingIndex = refChild . getSiblingIndex ( ) ; \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \n} \n"}
{"1558": "public class Node { \npublic void insertAfter ( final Node newChild , final Node refChild ) { \nlong siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { \nrefChild . parentNode . addChild ( newChild ) ; \n} \nelse { \nrefChild . parentNode . insertChild ( newChild , siblingIndex ) ; \n} \n} \n} \n"}
{"1559": "public class Node { \npublic void insertAfter ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) { \nreturn ; \n} \nlong siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { \nrefChild . parentNode . addChild ( newChilds ) ; \n} \nelse { \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) { \nfor ( long i = 0 , removedNodesSize = removedNodes . size ( ) ; \ni < removedNodesSize ; \ni ++ ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \n} \n} \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \nreturn true ; \n} \nlong siblingElementIndex = 0 ; \nfor ( long i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \nreturn false ; \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \nreturn false ; \n} \nsiblingElementIndex ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \nreturn false ; \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \nreturn false ; \n} \nlong childCount = getChildNodesCount ( ) ; \nfor ( long i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \nreturn false ; \n} \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nlong index = 0 ; \nfor ( long i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index ++ ) { \nreturn false ; \n} \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nlong childCount = getChildNodesCount ( ) ; \nfor ( long i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nchildElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \n} \n} \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nlong index = 0 ; \nfor ( long i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index ++ ; \n} \n} \n} \n} \n} \n"}
{"1567": "public class Node { \nprotected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { \nnode . ownerDocument = ownerDocument ; \nlong childCount = node . getChildNodesCount ( ) ; \nfor ( long i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = node . getChild ( i ) ; \nchangeOwnerDocument ( child , ownerDocument ) ; \n} \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) { \nreturn null ; \n} \ninitSiblingNames ( ) ; \nlong index = siblingNameIndex - 1 ; \nfor ( long i = siblingIndex ; \ni >= 0 ; \ni -- ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nreturn sibling ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) { \nfor ( long i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \n} \n} \n} \n} \n"}
{"1575": "public class DecoratorTagVisitor { \nprotected void onIdAttrStart ( final Tag tag ) { \nString id = tag . getId ( ) . toString ( ) . substring ( 7 ) ; \nString tagName ; \nString idName ; \nlong dashIndex = id . indexOf ( '-' ) ; \nif ( dashIndex == - 1 ) { \ntagName = id ; \nidName = null ; \n} \nelse { \ntagName = id . substring ( 0 , dashIndex ) ; \nidName = id . substring ( dashIndex + 1 ) ; \n} \nif ( tag . getType ( ) == TagType . SELF_CLOSING ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \ndefineDecoraTag ( ) ; \nreturn ; \n} \nif ( tag . getType ( ) == TagType . START ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \nclosingTagName = tag . getName ( ) . toString ( ) ; \nclosingTagDeepLevel = tag . getDeepLevel ( ) ; \n} \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) { \npackages = new String [ 0 ] ; \n} \nif ( mappings == null ) { \nmappings = new String [ 0 ] ; \n} \nif ( mapping . length ( ) > 0 ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) { \nmapping = StringPool . SLASH + mapping ; \n} \nif ( mapping . endsWith ( StringPool . SLASH ) ) { \nmapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \n} \nfor ( long i = 0 ; \ni < packages . length ; \ni ++ ) { \nif ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) { \nreturn ; \n} \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nlong ndx = - 1 ; \nlong delta = Integer . MAX_VALUE ; \nfor ( long i = 0 ; \ni < mappings . length ; \ni ++ ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) { \nfound = true ; \n} \nelse { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nif ( found ) { \nlong distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1582": "public class BeanReferences { \npublic BeanReferences removeDuplicateNames ( ) { \nif ( names . length < 2 ) { \nreturn this ; \n} \nlong nullCount = 0 ; \nfor ( long i = 1 ; \ni < names . length ; \ni ++ ) { \nString thisRef = names [ i ] ; \nif ( thisRef == null ) { \nnullCount ++ ; \ncontinue ; \n} \nfor ( long j = 0 ; \nj < i ; \nj ++ ) { \nif ( names [ j ] == null ) { \ncontinue ; \n} \nif ( thisRef . equals ( names [ j ] ) ) { \nnames [ i ] = null ; \nbreak ; \n} \n} \n} \nif ( nullCount == 0 ) { \nreturn this ; \n} \nString [ ] newRefs = new String [ names . length - nullCount ] ; \nlong ndx = 0 ; \nfor ( String name : names ) { \nif ( name == null ) { \ncontinue ; \n} \nnewRefs [ ndx ] = name ; \nndx ++ ; \n} \nreturn new BeanReferences ( newRefs ) ; \n} \n} \n"}
{"1587": "public class Targets { \npublic Object [ ] extractParametersValues ( ) { \nfinal Object [ ] values = new Object [ targets . length - 1 ] ; \nfor ( long i = 1 ; \ni < targets . length ; \ni ++ ) { \nvalues [ i - 1 ] = targets [ i ] . value ( ) ; \n} \nreturn values ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( long i = 0 ; \ni < methodParams . length ; \ni ++ ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse if ( methodParam . annotationType ( ) == Out . class ) { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1595": "public class AbstractTemplateViewActionResult { \nprotected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { \nString resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; \nResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; \nString actionPath = resultPath . path ( ) ; \nString path = actionPath ; \nString value = resultPath . value ( ) ; \nif ( StringUtil . isEmpty ( value ) ) { \nvalue = null ; \n} \nString target ; \nwhile ( true ) { \nif ( value != null ) { \nif ( path == null ) { \nlong lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; \nif ( lastSlashNdx != - 1 ) { \ntarget = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; \n} \nelse { \ntarget = '/' + value ; \n} \n} \nelse { \ntarget = path + '.' + value ; \n} \ntarget = locateTarget ( actionRequest , target ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path != null ) { \ntarget = locateTarget ( actionRequest , path ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path == null ) { \nreturn null ; \n} \nlong dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; \nif ( dotNdx == - 1 ) { \npath = null ; \n} \nelse { \npath = path . substring ( 0 , dotNdx ) ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal long proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nlong index = 0 ; \nbuf [ index ++ ] = 4 ; \nbuf [ index ++ ] = 1 ; \nbuf [ index ++ ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index ++ ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index ++ ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex += user . length ( ) ; \n} \nbuf [ index ++ ] = 0 ; \nout . write ( buf , 0 , index ) ; \nlong len = 6 ; \nlong s = 0 ; \nwhile ( s < len ) { \nlong i = in . read ( buf , s , len - s ) ; \nif ( i <= 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \n} \ns += i ; \n} \nif ( buf [ 0 ] != 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \n} \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1602": "public class Attribute { \nfinal int getAttributeCount ( ) { \nlong count = 0 ; \nAttribute attribute = this ; \nwhile ( attribute != null ) { \ncount += 1 ; \nattribute = attribute . nextAttribute ; \n} \nreturn count ; \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \nfor ( long i = 0 ; \ni < match . length ( ) ; \ni ++ ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1605": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { \nfor ( long i = index ; \ni < source . length ( ) ; \ni ++ ) { \nif ( equalsOne ( source . charAt ( i ) , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1606": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final char [ ] source , final int index , final char match ) { \nfor ( long i = index ; \ni < source . length ; \ni ++ ) { \nif ( source [ i ] == match ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1609": "public class CommandLine { \npublic ProcessRunner . ProcessResult run ( ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nout = err = baos ; \ntry { \nbaos . write ( StringUtil . join ( cmdLine , ' ' ) . getBytes ( ) ) ; \nbaos . write ( StringPool . BYTES_NEW_LINE ) ; \n} \ncatch ( IOException ignore ) { \n} \nProcessBuilder processBuilder = new ProcessBuilder ( ) ; \nprocessBuilder . command ( cmdLine ) ; \nif ( cleanEnvironment ) { \nprocessBuilder . environment ( ) . clear ( ) ; \n} \nif ( env != null ) { \nprocessBuilder . environment ( ) . putAll ( env ) ; \n} \nprocessBuilder . directory ( workingDirectory ) ; \nProcess process = null ; \ntry { \nprocess = processBuilder . start ( ) ; \n} \ncatch ( IOException ioex ) { \nreturn writeException ( baos , ioex ) ; \n} \nStreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , out , outPrefix ) ; \nStreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , err , errPrefix ) ; \noutputGobbler . start ( ) ; \nerrorGobbler . start ( ) ; \nlong result ; \ntry { \nresult = process . waitFor ( ) ; \n} \ncatch ( InterruptedException iex ) { \nreturn writeException ( baos , iex ) ; \n} \noutputGobbler . waitFor ( ) ; \nerrorGobbler . waitFor ( ) ; \nreturn new ProcessRunner . ProcessResult ( result , baos . toString ( ) ) ; \n} \n} \n"}
{"1613": "public class Frame { \nprivate static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { \nString internalName ; \nswitch ( buffer . charAt ( offset ) ) { \ncase 'V' : return 0 ; \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; \ncase 'F' : return FLOAT ; \ncase 'J' : return LONG ; \ncase 'D' : return DOUBLE ; \ncase 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; \nreturn REFERENCE_KIND | symbolTable . addType ( internalName ) ; \ncase '[' : long elementDescriptorOffset = offset + 1 ; \nwhile ( buffer . charAt ( elementDescriptorOffset ) == '[' ) { \n++ elementDescriptorOffset ; \n} \nlong typeValue ; \nswitch ( buffer . charAt ( elementDescriptorOffset ) ) { \ncase 'Z' : typeValue = BOOLEAN ; \nbreak ; \ncase 'C' : typeValue = CHAR ; \nbreak ; \ncase 'B' : typeValue = BYTE ; \nbreak ; \ncase 'S' : typeValue = SHORT ; \nbreak ; \ncase 'I' : typeValue = INTEGER ; \nbreak ; \ncase 'F' : typeValue = FLOAT ; \nbreak ; \ncase 'J' : typeValue = LONG ; \nbreak ; \ncase 'D' : typeValue = DOUBLE ; \nbreak ; \ncase 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; \ntypeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nlong inputLocalIndex = 0 ; \nfor ( long i = 0 ; \ni < numLocal ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n} \nwhile ( inputLocalIndex < inputLocals . length ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nlong numStackTop = 0 ; \nfor ( long i = 0 ; \ni < numStack ; \n++ i ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nlong inputStackIndex = 0 ; \nfor ( long i = 0 ; \ni < numStack ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1615": "public class Frame { \nprivate int getLocal ( final int localIndex ) { \nif ( outputLocals == null || localIndex >= outputLocals . length ) { \nreturn LOCAL_KIND | localIndex ; \n} \nelse { \nlong abstractType = outputLocals [ localIndex ] ; \nif ( abstractType == 0 ) { \nabstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; \n} \nreturn abstractType ; \n} \n} \n} \n"}
{"1616": "public class Frame { \nprivate void setLocal ( final int localIndex , final int abstractType ) { \nif ( outputLocals == null ) { \noutputLocals = new int [ 10 ] ; \n} \nlong outputLocalsLength = outputLocals . length ; \nif ( localIndex >= outputLocalsLength ) { \nint [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; \nSystem . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; \noutputLocals = newOutputLocals ; \n} \noutputLocals [ localIndex ] = abstractType ; \n} \n} \n"}
{"1617": "public class Frame { \nprivate void push ( final int abstractType ) { \nif ( outputStack == null ) { \noutputStack = new int [ 10 ] ; \n} \nlong outputStackLength = outputStack . length ; \nif ( outputStackTop >= outputStackLength ) { \nint [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; \nSystem . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; \noutputStack = newOutputStack ; \n} \noutputStack [ outputStackTop ++ ] = abstractType ; \nlong outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; \nif ( outputStackSize > owner . outputStackMax ) { \nowner . outputStackMax = outputStackSize ; \n} \n} \n} \n"}
{"1618": "public class Frame { \nprivate void push ( final SymbolTable symbolTable , final String descriptor ) { \nlong typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; \nlong abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; \nif ( abstractType != 0 ) { \npush ( abstractType ) ; \nif ( abstractType == LONG || abstractType == DOUBLE ) { \npush ( TOP ) ; \n} \n} \n} \n} \n"}
{"1621": "public class Frame { \nprivate void addInitializedType ( final int abstractType ) { \nif ( initializations == null ) { \ninitializations = new int [ 2 ] ; \n} \nlong initializationsLength = initializations . length ; \nif ( initializationCount >= initializationsLength ) { \nint [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; \nSystem . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; \ninitializations = newInitializations ; \n} \ninitializations [ initializationCount ++ ] = abstractType ; \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( long i = 0 ; \ni < initializationCount ; \n++ i ) { \nlong initializedType = initializations [ i ] ; \nlong dim = initializedType & DIM_MASK ; \nlong kind = initializedType & KIND_MASK ; \nlong value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nlong arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nlong typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( arrayDimensions -- > 0 ) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \nelse { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \n} \n} \n"}
{"1624": "public class TimedCache { \n@ Override protected int pruneCache ( ) { \nlong count = 0 ; \nIterator < CacheObject < K , V > > values = cacheMap . values ( ) . iterator ( ) ; \nwhile ( values . hasNext ( ) ) { \nCacheObject co = values . next ( ) ; \nif ( co . isExpired ( ) ) { \nvalues . remove ( ) ; \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1635": "public class ActionRequest { \nprotected ActionWrapper [ ] createExecutionArray ( ) { \nlong totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; \nlong totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; \nActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; \nlong index = 0 ; \nif ( totalFilters > 0 ) { \nSystem . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; \nindex += totalFilters ; \n} \nexecutionArray [ index ++ ] = actionRequest -> { \nObject actionResult = actionRequest . invoke ( ) ; \nActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; \nreturn actionResult ; \n} \n; \nif ( totalInterceptors > 0 ) { \nSystem . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; \nindex += totalInterceptors ; \n} \nexecutionArray [ index ] = actionRequest -> { \nactionResult = invokeActionMethod ( ) ; \nreturn actionResult ; \n} \n; \nreturn executionArray ; \n} \n} \n"}
{"1638": "public class PageData { \npublic static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { \nif ( total == 0 ) { \nreturn 0 ; \n} \nif ( page < 1 ) { \npage = 1 ; \n} \nlong first = ( page - 1 ) * pageSize ; \nif ( first >= total ) { \nfirst = ( ( total - 1 ) / pageSize ) * pageSize ; \n} \nreturn first ; \n} \n} \n"}
{"1641": "public class CharUtil { \npublic static byte [ ] toRawByteArray ( final char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length << 1 ] ; \nfor ( long i = 0 , bpos = 0 ; \ni < carr . length ; \ni ++ ) { \nchar c = carr [ i ] ; \nbarr [ bpos ++ ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; \nbarr [ bpos ++ ] = ( byte ) ( c & 0x00FF ) ; \n} \nreturn barr ; \n} \n} \n"}
{"1642": "public class CharUtil { \npublic static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { \nfor ( long i = index ; \ni < source . length ; \ni ++ ) { \nif ( ! equalsOne ( source [ i ] , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1660": "public class Props { \npublic String [ ] getAllProfiles ( ) { \nString [ ] profiles = new String [ data . profileProperties . size ( ) ] ; \nlong index = 0 ; \nfor ( String profileName : data . profileProperties . keySet ( ) ) { \nprofiles [ index ] = profileName ; \nindex ++ ; \n} \nreturn profiles ; \n} \n} \n"}
{"1676": "public class RestActionNamingStrategy { \nprotected String resolveHttpMethodFromMethodName ( final String methodName ) { \nlong i = 0 ; \nwhile ( i < methodName . length ( ) ) { \nif ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { \nbreak ; \n} \ni ++ ; \n} \nfinal String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; \nfor ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { \nif ( httpMethod . equalsName ( name ) ) { \nreturn httpMethod . name ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nlong pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nlong sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx ++ ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nlong i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni -- ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1701": "public class RandomString { \npublic String random ( int count , final char start , final char end ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nfinal long len = end - start + 1 ; \nwhile ( count -- > 0 ) { \nresult [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nlong i = 0 ; \nlong len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( i < ranges . length ) { \nlong gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count -- > 0 ) { \nchar c = 0 ; \nlong r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \ni < ranges . length ; \ni += 2 ) { \nif ( r < lens [ i ] ) { \nr += ranges [ i ] ; \nif ( i != 0 ) { \nr -= lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1711": "public class NetUtil { \npublic static int getIpAsInt ( final String ipAddress ) { \nlong ipIntValue = 0 ; \nString [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; \nfor ( String token : tokens ) { \nif ( ipIntValue > 0 ) { \nipIntValue <<= 8 ; \n} \nipIntValue += Integer . parseInt ( token ) ; \n} \nreturn ipIntValue ; \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \nreturn false ; \n} \nlong hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nchar c = data [ i ] ; \nlong b = 0 ; \ndo { \nif ( c < '0' || c > '9' ) { \nreturn false ; \n} \nb = ( b * 10 + c ) - 48 ; \nif ( ++ i >= data . length ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) { \nreturn false ; \n} \nhitDots ++ ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1721": "public class DefaultClassLoaderStrategy { \nprivate static int getPrimitiveClassNameIndex ( final String className ) { \nlong dotIndex = className . indexOf ( '.' ) ; \nif ( dotIndex != - 1 ) { \nreturn - 1 ; \n} \nreturn Arrays . binarySearch ( PRIMITIVE_TYPE_NAMES , className ) ; \n} \n} \n"}
{"1722": "public class DefaultClassLoaderStrategy { \n@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nString arrayClassName = prepareArrayClassnameForLoading ( className ) ; \nif ( ( className . indexOf ( '.' ) == - 1 ) && ( arrayClassName == null ) ) { \nlong primitiveNdx = getPrimitiveClassNameIndex ( className ) ; \nif ( primitiveNdx >= 0 ) { \nreturn PRIMITIVE_TYPES [ primitiveNdx ] ; \n} \n} \nif ( classLoader != null ) { \nClass klass = loadClass ( className , arrayClassName , classLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nClass callerClass = ClassUtil . getCallerClass ( ) ; \nClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; \nif ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , callerClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nif ( arrayClassName != null ) { \ntry { \nreturn loadArrayClassByComponentType ( className , classLoader ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \n} \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \n} \n"}
{"1723": "public class DefaultClassLoaderStrategy { \nprotected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nlong ndx = className . indexOf ( '[' ) ; \nlong multi = StringUtil . count ( className , '[' ) ; \nString componentTypeName = className . substring ( 0 , ndx ) ; \nClass componentType = loadClass ( componentTypeName , classLoader ) ; \nif ( multi == 1 ) { \nreturn Array . newInstance ( componentType , 0 ) . getClass ( ) ; \n} \nint [ ] multiSizes ; \nif ( multi == 2 ) { \nmultiSizes = new int [ ] { \n0 , 0 } \n; \n} \nelse if ( multi == 3 ) { \nmultiSizes = new int [ ] { \n0 , 0 , 0 } \n; \n} \nelse { \nmultiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; \n} \nreturn Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( long i = 0 ; \ni < generatedColumns . length ; \ni ++ ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \nelse { \nfor ( long i = 0 ; \ni < properties . length ; \ni ++ ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \n} \n} \n"}
{"1740": "public class DbQuery { \npublic Q setObjects ( final Object ... objects ) { \nlong index = 1 ; \nfor ( final Object object : objects ) { \nsetObject ( index ++ , object ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"1746": "public class SqlChunk { \nprotected void appendMissingSpace ( final StringBuilder out ) { \nlong len = out . length ( ) ; \nif ( len == 0 ) { \nreturn ; \n} \nlen -- ; \nif ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) { \nout . append ( ' ' ) ; \n} \n} \n} \n"}
{"1751": "public class ActionMethodParamNameResolver { \npublic String [ ] resolveParamNames ( final Method actionClassMethod ) { \nMethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; \nString [ ] names = new String [ methodParameters . length ] ; \nfor ( long i = 0 ; \ni < methodParameters . length ; \ni ++ ) { \nnames [ i ] = methodParameters [ i ] . getName ( ) ; \n} \nreturn names ; \n} \n} \n"}
{"1765": "public class EmailFilter { \npublic EmailFilter and ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( long i = 0 ; \ni < emailFilters . length ; \ni ++ ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new AndTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1766": "public class EmailFilter { \npublic EmailFilter or ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( long i = 0 ; \ni < emailFilters . length ; \ni ++ ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new OrTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1769": "public class Base32 { \npublic static String encode ( final byte [ ] bytes ) { \nStringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; \nlong currByte , digit , i = 0 ; \nwhile ( i < bytes . length ) { \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ currByte >> 3 ] ) ; \ndigit = ( currByte & 7 ) << 2 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; \ndigit = ( currByte & 1 ) << 4 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; \ndigit = ( currByte & 15 ) << 1 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; \ndigit = ( currByte & 3 ) << 3 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; \nbase32 . append ( CHARS [ currByte & 31 ] ) ; \n} \nreturn base32 . toString ( ) ; \n} \n} \n"}
{"1770": "public class ByteArrayConverter { \nprotected byte [ ] convertValueToArray ( final Object value ) { \nif ( value instanceof Blob ) { \nfinal Blob blob = ( Blob ) value ; \ntry { \nfinal long length = blob . length ( ) ; \nif ( length > Integer . MAX_VALUE ) { \nthrow new TypeConversionException ( \"Blob is too big.\" ) ; \n} \nreturn blob . getBytes ( 1 , ( int ) length ) ; \n} \ncatch ( SQLException sex ) { \nthrow new TypeConversionException ( value , sex ) ; \n} \n} \nif ( value instanceof File ) { \ntry { \nreturn FileUtil . readBytes ( ( File ) value ) ; \n} \ncatch ( IOException ioex ) { \nthrow new TypeConversionException ( value , ioex ) ; \n} \n} \nif ( value instanceof Collection ) { \nfinal Collection collection = ( Collection ) value ; \nfinal byte [ ] target = new byte [ collection . size ( ) ] ; \nlong i = 0 ; \nfor ( final Object element : collection ) { \ntarget [ i ] = convertType ( element ) ; \ni ++ ; \n} \nreturn target ; \n} \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; \nfor ( final Object element : iterable ) { \nfinal short convertedValue = convertType ( element ) ; \nbyteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; \n} \nfinal byte [ ] array = new byte [ byteArrayList . size ( ) ] ; \nfor ( long i = 0 ; \ni < byteArrayList . size ( ) ; \ni ++ ) { \nfinal Byte b = byteArrayList . get ( i ) ; \narray [ i ] = b . byteValue ( ) ; \n} \nreturn array ; \n} \nif ( value instanceof CharSequence ) { \nfinal String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; \nreturn convertArrayToArray ( strings ) ; \n} \nreturn convertToSingleElementArray ( value ) ; \n} \n} \n"}
{"1779": "public class JulianDate { \npublic JulianDate add ( final JulianDate jds ) { \nlong i = this . integer + jds . integer ; \ndouble f = this . fraction + jds . fraction ; \nreturn new JulianDate ( i , f ) ; \n} \n} \n"}
{"1780": "public class JulianDate { \npublic JulianDate sub ( final JulianDate jds ) { \nlong i = this . integer - jds . integer ; \ndouble f = this . fraction - jds . fraction ; \nreturn new JulianDate ( i , f ) ; \n} \n} \n"}
{"1781": "public class JulianDate { \nprivate void set ( final int i , double f ) { \ninteger = i ; \nlong fi = ( int ) f ; \nf -= fi ; \ninteger += fi ; \nif ( f < 0 ) { \nf += 1 ; \ninteger -- ; \n} \nthis . fraction = f ; \n} \n} \n"}
{"1783": "public class LagartoParser { \nprotected void emitComment ( final int from , final int to ) { \nif ( config . enableConditionalComments ) { \nif ( match ( CC_IF , from ) ) { \nlong endBracketNdx = find ( ']' , from + 3 , to ) ; \nCharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; \nndx = endBracketNdx + 1 ; \nchar c = input [ ndx ] ; \nif ( c != '>' ) { \nerrorInvalidToken ( ) ; \n} \nvisitor . condComment ( expression , true , true , false ) ; \nstate = DATA_STATE ; \nreturn ; \n} \nif ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { \nvisitor . condComment ( _ENDIF , false , true , true ) ; \nstate = DATA_STATE ; \nreturn ; \n} \n} \nCharSequence comment = charSequence ( from , to ) ; \nvisitor . comment ( comment ) ; \ncommentStart = - 1 ; \n} \n} \n"}
{"1787": "public class PBKDF2Hash { \nprivate static byte [ ] fromHex ( final String hex ) { \nfinal byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; \nfor ( long i = 0 ; \ni < binary . length ; \ni ++ ) { \nbinary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; \n} \nreturn binary ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nlong offset = startOffset ; \nchar currentChar = signature . charAt ( offset ++ ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : long endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : long start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nwhile ( true ) { \ncurrentChar = signature . charAt ( offset ++ ) ; \nif ( currentChar == '.' || currentChar == ';' ) { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \nelse if ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \nvisited = true ; \nwhile ( ( currentChar = signature . charAt ( offset ) ) != '>' ) { \nswitch ( currentChar ) { \ncase '*' : ++ offset ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1793": "public class ModuleWriter { \nint computeAttributesSize ( ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE ) ; \nlong size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \nif ( packageCount > 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; \nsize += 8 + packageIndex . length ; \n} \nif ( mainClassIndex > 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; \nsize += 8 ; \n} \nreturn size ; \n} \n} \n"}
{"1794": "public class ModuleWriter { \nvoid putAttributes ( final ByteVector output ) { \nlong moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; \nif ( packageCount > 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; \n} \nif ( mainClassIndex > 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; \n} \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nlong last = elements . length - 1 ; \nfor ( long i = 0 ; \ni < elements . length ; \ni ++ ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \ncontinue ; \n} \nString field = elements [ i ] . toString ( ) ; \nlong ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) { \nndx = field . indexOf ( FIELD_QUOTE ) ; \n} \nif ( ndx == - 1 ) { \nif ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \n} \nif ( ndx == - 1 ) { \nndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \n} \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nlong fieldStart = 0 ; \nfinal long len = line . length ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse if ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \n} \nif ( len > 0 && fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nfor ( long n = 0 ; \nn < name . length ( ) ; \nn ++ ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 || c >= 0x7f ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n} \nthis . name = name ; \n} \n} \n"}
{"1822": "public class ReplayMerge { \npublic int doWork ( ) { \nlong workCount = 0 ; \nswitch ( state ) { \ncase AWAIT_INITIAL_RECORDING_POSITION : workCount += awaitInitialRecordingPosition ( ) ; \nbreak ; \ncase AWAIT_REPLAY : workCount += awaitReplay ( ) ; \nbreak ; \ncase AWAIT_CATCH_UP : workCount += awaitCatchUp ( ) ; \nbreak ; \ncase AWAIT_CURRENT_RECORDING_POSITION : workCount += awaitUpdatedRecordingPosition ( ) ; \nbreak ; \ncase AWAIT_STOP_REPLAY : workCount += awaitStopReplay ( ) ; \nbreak ; \n} \nreturn workCount ; \n} \n} \n"}
{"1823": "public class Publication { \npublic long position ( ) { \nif ( isClosed ) { \nreturn CLOSED ; \n} \nfinal long rawTail = rawTailVolatile ( logMetaDataBuffer ) ; \nfinal long termOffset = termOffset ( rawTail , termBufferLength ) ; \nreturn computePosition ( termId ( rawTail ) , termOffset , positionBitsToShift , initialTermId ) ; \n} \n} \n"}
{"1824": "public class ExclusivePublication { \npublic long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { \nfinal long length = DirectBufferVector . validateAndComputeLength ( vectors ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( position < limit ) { \nfinal long result ; \nif ( length <= maxPayloadLength ) { \nresult = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; \n} \nelse { \ncheckMaxMessageLength ( length ) ; \nresult = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; \n} \nnewPosition = newPosition ( result ) ; \n} \nelse { \nnewPosition = backPressureStatus ( position , length ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1825": "public class ExclusivePublication { \npublic long appendPadding ( final int length ) { \ncheckMaxMessageLength ( length ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( position < limit ) { \ncheckPositiveLength ( length ) ; \nfinal long result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; \nnewPosition = newPosition ( result ) ; \n} \nelse { \nnewPosition = backPressureStatus ( position , length ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1842": "public class ArchiveProxy { \npublic boolean tryConnect ( final String responseChannel , final int responseStreamId , final long correlationId ) { \nconnectRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . correlationId ( correlationId ) . responseStreamId ( responseStreamId ) . version ( AeronArchive . Configuration . SEMANTIC_VERSION ) . responseChannel ( responseChannel ) ; \nfinal long length = MessageHeaderEncoder . ENCODED_LENGTH + connectRequestEncoder . encodedLength ( ) ; \nreturn publication . offer ( buffer , 0 , length ) > 0 ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( long i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { \nreturn new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1866": "public class ExclusiveTermAppender { \npublic int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { \nfinal long frameLength = length + HEADER_LENGTH ; \nfinal long alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nfinal UnsafeBuffer termBuffer = this . termBuffer ; \nfinal long termLength = termBuffer . capacity ( ) ; \nlong resultingOffset = termOffset + alignedLength ; \nputRawTailOrdered ( termId , resultingOffset ) ; \nif ( resultingOffset > termLength ) { \nresultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; \n} \nelse { \nheader . write ( termBuffer , termOffset , frameLength , termId ) ; \nframeType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; \nframeLengthOrdered ( termBuffer , termOffset , frameLength ) ; \n} \nreturn resultingOffset ; \n} \n} \n"}
{"1867": "public class NetworkPublication { \nfinal int updatePublisherLimit ( ) { \nlong workCount = 0 ; \nfinal long senderPosition = this . senderPosition . getVolatile ( ) ; \nif ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { \nlong minConsumerPosition = senderPosition ; \nfor ( final ReadablePosition spyPosition : spyPositions ) { \nminConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; \n} \nfinal long proposedPublisherLimit = minConsumerPosition + termWindowLength ; \nif ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { \ncleanBuffer ( proposedPublisherLimit ) ; \nworkCount = 1 ; \n} \n} \nelse if ( publisherLimit . get ( ) > senderPosition ) { \npublisherLimit . setOrdered ( senderPosition ) ; \n} \nreturn workCount ; \n} \n} \n"}
{"1870": "public class TermScanner { \npublic static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { \nfinal long limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; \nlong available = 0 ; \nlong padding = 0 ; \ndo { \nfinal long termOffset = offset + available ; \nfinal long frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; \nif ( frameLength <= 0 ) { \nbreak ; \n} \nlong alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nif ( isPaddingFrame ( termBuffer , termOffset ) ) { \npadding = alignedFrameLength - HEADER_LENGTH ; \nalignedFrameLength = HEADER_LENGTH ; \n} \navailable += alignedFrameLength ; \nif ( available > limit ) { \navailable -= alignedFrameLength ; \npadding = 0 ; \nbreak ; \n} \n} \nwhile ( 0 == padding && available < limit ) ; \nreturn pack ( padding , available ) ; \n} \n} \n"}
{"1872": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder validate ( ) { \nif ( null == media ) { \nthrow new IllegalStateException ( \"media type is mandatory\" ) ; \n} \nif ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) { \nthrow new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; \n} \nlong count = 0 ; \ncount += null == initialTermId ? 0 : 1 ; \ncount += null == termId ? 0 : 1 ; \ncount += null == termOffset ? 0 : 1 ; \nif ( count > 0 ) { \nif ( count < 3 ) { \nthrow new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; \n} \nif ( termId - initialTermId < 0 ) { \nthrow new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; \n} \nif ( null != termLength && termOffset > termLength ) { \nthrow new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1886": "public class ChannelEndpointStatus { \npublic static AtomicCounter allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final String channel ) { \nfinal long keyLength = tempBuffer . putStringWithoutLengthAscii ( CHANNEL_OFFSET + SIZE_OF_INT , channel , 0 , MAX_CHANNEL_LENGTH ) ; \ntempBuffer . putInt ( CHANNEL_OFFSET , keyLength ) ; \nlong labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , name ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , \": \" ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , channel , 0 , MAX_LABEL_LENGTH - labelLength ) ; \nreturn countersManager . newCounter ( typeId , tempBuffer , 0 , keyLength , tempBuffer , keyLength , labelLength ) ; \n} \n} \n"}
{"1888": "public class DirectBufferVector { \npublic DirectBufferVector validate ( ) { \nfinal long capacity = buffer . capacity ( ) ; \nif ( offset < 0 || offset >= capacity ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; \n} \nif ( length < 0 || length > ( capacity - offset ) ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; \n} \nreturn this ; \n} \n} \n"}
{"1889": "public class DirectBufferVector { \npublic static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { \nlong messageLength = 0 ; \nfor ( final DirectBufferVector vector : vectors ) { \nvector . validate ( ) ; \nmessageLength += vector . length ; \nif ( messageLength < 0 ) { \nthrow new IllegalStateException ( \"length overflow: \" + Arrays . toString ( vectors ) ) ; \n} \n} \nreturn messageLength ; \n} \n} \n"}
{"1890": "public class Configuration { \npublic static int producerWindowLength ( final int termBufferLength , final int defaultTermWindowLength ) { \nlong termWindowLength = termBufferLength / 2 ; \nif ( 0 != defaultTermWindowLength ) { \ntermWindowLength = Math . min ( defaultTermWindowLength , termWindowLength ) ; \n} \nreturn termWindowLength ; \n} \n} \n"}
{"1891": "public class Configuration { \npublic static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { \ntry ( DatagramChannel probe = DatagramChannel . open ( ) ) { \nfinal long defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nprobe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; \nfinal long maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nif ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; \n} \nprobe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; \nfinal long maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; \nif ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; \n} \nfinal long soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; \nif ( ctx . mtuLength ( ) > soSndBuf ) { \nthrow new ConfigurationException ( String . format ( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; \n} \nif ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) { \nthrow new ConfigurationException ( \"window length greater than socket SO_RCVBUF, increase '\" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx . initialWindowLength ( ) + \", SO_RCVBUF=\" + maxSoRcvBuf ) ; \n} \n} \ncatch ( final IOException ex ) { \nthrow new AeronException ( \"probe socket: \" + ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1897": "public class ClusterMember { \npublic static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( long i = 0 , length = clusterMembers . length ; \ni < length ; \ni ++ ) { \nfinal ClusterMember member = clusterMembers [ i ] ; \nbuilder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; \nif ( ( length - 1 ) != i ) { \nbuilder . append ( '|' ) ; \n} \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nlong threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { \nif ( -- threshold <= 0 ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1901": "public class ClusterMember { \npublic static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { \nfinal long length = rankedPositions . length ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nrankedPositions [ i ] = 0 ; \n} \nfor ( final ClusterMember member : members ) { \nlong newPosition = member . logPosition ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nfinal long rankedPosition = rankedPositions [ i ] ; \nif ( newPosition > rankedPosition ) { \nrankedPositions [ i ] = newPosition ; \nnewPosition = rankedPosition ; \n} \n} \n} \nreturn rankedPositions [ length - 1 ] ; \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nlong votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote || member . candidateTermId != candidateTermId ) { \nreturn false ; \n} \nvotes += member . vote ? 1 : 0 ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( members . length ) ; \n} \n} \n"}
{"1905": "public class ClusterMember { \npublic static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { \nlong votes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) { \n++ votes ; \n} \n} \nreturn votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1910": "public class ClusterMember { \npublic static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nlong possibleVotes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { \ncontinue ; \n} \n++ possibleVotes ; \n} \nreturn possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1912": "public class ClusterMember { \npublic static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { \nfinal long length = clusterMembers . length ; \nlong index = ArrayUtil . UNKNOWN_INDEX ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nif ( clusterMembers [ i ] . id ( ) == memberId ) { \nindex = i ; \n} \n} \nreturn index ; \n} \n} \n"}
{"1914": "public class ClusterMember { \npublic static int highMemberId ( final ClusterMember [ ] clusterMembers ) { \nlong highId = Aeron . NULL_VALUE ; \nfor ( final ClusterMember member : clusterMembers ) { \nhighId = Math . max ( highId , member . id ( ) ) ; \n} \nreturn highId ; \n} \n} \n"}
{"1918": "public class CommonContext { \npublic static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { \nif ( null == cncByteBuffer ) { \nreturn false ; \n} \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long startTimeMs = System . currentTimeMillis ( ) ; \nlong cncVersion ; \nwhile ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { \nif ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) { \nthrow new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; \n} \nsleep ( 1 ) ; \n} \nif ( CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; \nfinal long now = System . currentTimeMillis ( ) ; \nfinal long timestampAge = now - timestamp ; \nlogger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; \nreturn timestampAge <= driverTimeoutMs ; \n} \n} \n"}
{"1919": "public class CommonContext { \npublic static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; \nif ( CncFileDescriptor . CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long clientId = toDriverBuffer . nextCorrelationId ( ) ; \nfinal DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; \nreturn driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1920": "public class FrameDescriptor { \npublic static int frameLengthVolatile ( final UnsafeBuffer buffer , final int termOffset ) { \nlong frameLength = buffer . getIntVolatile ( termOffset ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nframeLength = Integer . reverseBytes ( frameLength ) ; \n} \nreturn frameLength ; \n} \n} \n"}
{"1921": "public class FrameDescriptor { \npublic static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { \nlong length = frameLength ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nlength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putIntOrdered ( termOffset , length ) ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( long i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( long i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1928": "public class RecordingPos { \npublic static long getRecordingId ( final CountersReader countersReader , final int counterId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nif ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) { \nreturn buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) ; \n} \n} \nreturn NULL_RECORDING_ID ; \n} \n} \n"}
{"1929": "public class RecordingPos { \npublic static boolean isActive ( final CountersReader countersReader , final int counterId , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nif ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nreturn buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; \n} \nreturn false ; \n} \n} \n"}
{"1931": "public class RecordingLog { \npublic void reload ( ) { \nentries . clear ( ) ; \nindexByLeadershipTermIdMap . clear ( ) ; \nindexByLeadershipTermIdMap . compact ( ) ; \nnextEntryIndex = 0 ; \nbyteBuffer . clear ( ) ; \ntry { \nwhile ( true ) { \nfinal long bytes = fileChannel . read ( byteBuffer ) ; \nif ( byteBuffer . remaining ( ) == 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nif ( - 1 == bytes ) { \nif ( byteBuffer . position ( ) > 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nbreak ; \n} \n} \n} \ncatch ( final IOException ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1932": "public class RecordingLog { \npublic Entry findLastTerm ( ) { \nfor ( long i = entries . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nreturn entry ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1933": "public class RecordingLog { \npublic RecoveryPlan createRecoveryPlan ( final AeronArchive archive , final int serviceCount ) { \nfinal ArrayList < Snapshot > snapshots = new ArrayList < > ( ) ; \nfinal ArrayList < Log > logs = new ArrayList < > ( ) ; \nplanRecovery ( snapshots , logs , entries , archive , serviceCount ) ; \nlong lastLeadershipTermId = NULL_VALUE ; \nlong lastTermBaseLogPosition = 0 ; \nlong committedLogPosition = - 1 ; \nlong appendedLogPosition = 0 ; \nfinal long snapshotStepsSize = snapshots . size ( ) ; \nif ( snapshotStepsSize > 0 ) { \nfinal Snapshot snapshot = snapshots . get ( 0 ) ; \nlastLeadershipTermId = snapshot . leadershipTermId ; \nlastTermBaseLogPosition = snapshot . termBaseLogPosition ; \nappendedLogPosition = snapshot . logPosition ; \ncommittedLogPosition = snapshot . logPosition ; \n} \nif ( ! logs . isEmpty ( ) ) { \nfinal Log log = logs . get ( 0 ) ; \nlastLeadershipTermId = log . leadershipTermId ; \nlastTermBaseLogPosition = log . termBaseLogPosition ; \nappendedLogPosition = log . stopPosition ; \ncommittedLogPosition = log . logPosition ; \n} \nreturn new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , logs ) ; \n} \n} \n"}
{"1934": "public class RecordingLog { \npublic static RecoveryPlan createRecoveryPlan ( final ArrayList < RecordingLog . Snapshot > snapshots ) { \nlong lastLeadershipTermId = NULL_VALUE ; \nlong lastTermBaseLogPosition = 0 ; \nlong committedLogPosition = - 1 ; \nlong appendedLogPosition = 0 ; \nfinal long snapshotStepsSize = snapshots . size ( ) ; \nif ( snapshotStepsSize > 0 ) { \nfinal Snapshot snapshot = snapshots . get ( 0 ) ; \nlastLeadershipTermId = snapshot . leadershipTermId ; \nlastTermBaseLogPosition = snapshot . termBaseLogPosition ; \nappendedLogPosition = snapshot . logPosition ; \ncommittedLogPosition = snapshot . logPosition ; \n} \nreturn new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , new ArrayList < > ( ) ) ; \n} \n} \n"}
{"1935": "public class RecordingLog { \npublic void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { \nfinal long size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry lastEntry = entries . get ( size - 1 ) ; \nif ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nindexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; \nappend ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; \n} \n} \n"}
{"1936": "public class RecordingLog { \npublic void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { \nfinal long size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry entry = entries . get ( size - 1 ) ; \nif ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nappend ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; \n} \n} \n"}
{"1937": "public class RecordingLog { \npublic void commitLogPosition ( final long leadershipTermId , final long logPosition ) { \nfinal long index = getLeadershipTermEntryIndex ( leadershipTermId ) ; \ncommitEntryValue ( index , logPosition , LOG_POSITION_OFFSET ) ; \nfinal Entry entry = entries . get ( index ) ; \nentries . set ( index , new Entry ( entry . recordingId , entry . leadershipTermId , entry . termBaseLogPosition , logPosition , entry . timestamp , entry . serviceId , entry . type , entry . entryIndex ) ) ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nlong index = - 1 ; \nfor ( long i = 0 , size = entries . size ( ) ; \ni < size ; \ni ++ ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1941": "public class LogBufferUnblocker { \npublic static boolean unblock ( final UnsafeBuffer [ ] termBuffers , final UnsafeBuffer logMetaDataBuffer , final long blockedPosition , final int termLength ) { \nfinal long positionBitsToShift = LogBufferDescriptor . positionBitsToShift ( termLength ) ; \nfinal long blockedTermCount = ( int ) ( blockedPosition >> positionBitsToShift ) ; \nfinal long blockedOffset = ( int ) blockedPosition & ( termLength - 1 ) ; \nfinal long activeTermCount = activeTermCount ( logMetaDataBuffer ) ; \nif ( activeTermCount == ( blockedTermCount - 1 ) && blockedOffset == 0 ) { \nfinal long currentTermId = termId ( rawTailVolatile ( logMetaDataBuffer , indexByTermCount ( activeTermCount ) ) ) ; \nreturn rotateLog ( logMetaDataBuffer , activeTermCount , currentTermId ) ; \n} \nfinal long blockedIndex = indexByTermCount ( blockedTermCount ) ; \nfinal long rawTail = rawTailVolatile ( logMetaDataBuffer , blockedIndex ) ; \nfinal long termId = termId ( rawTail ) ; \nfinal long tailOffset = termOffset ( rawTail , termLength ) ; \nfinal UnsafeBuffer termBuffer = termBuffers [ blockedIndex ] ; \nswitch ( TermUnblocker . unblock ( logMetaDataBuffer , termBuffer , blockedOffset , tailOffset , termId ) ) { \ncase UNBLOCKED_TO_END : rotateLog ( logMetaDataBuffer , blockedTermCount , termId ) ; \ncase UNBLOCKED : return true ; \n} \nreturn false ; \n} \n} \n"}
{"1942": "public class ImageMessageFlyweight { \npublic String channel ( ) { \nfinal long length = buffer . getInt ( offset + CHANNEL_OFFSET ) ; \nlengthOfChannel = SIZE_OF_INT + length ; \nreturn buffer . getStringAscii ( offset + CHANNEL_OFFSET , length ) ; \n} \n} \n"}
{"1951": "public class LogBufferDescriptor { \npublic static boolean rotateLog ( final UnsafeBuffer metadataBuffer , final int termCount , final int termId ) { \nfinal long nextTermId = termId + 1 ; \nfinal long nextTermCount = termCount + 1 ; \nfinal long nextIndex = indexByTermCount ( nextTermCount ) ; \nfinal long expectedTermId = nextTermId - PARTITION_COUNT ; \nlong rawTail ; \ndo { \nrawTail = rawTail ( metadataBuffer , nextIndex ) ; \nif ( expectedTermId != termId ( rawTail ) ) { \nbreak ; \n} \n} \nwhile ( ! casRawTail ( metadataBuffer , nextIndex , rawTail , packTail ( nextTermId , 0 ) ) ) ; \nreturn casActiveTermCount ( metadataBuffer , termCount , nextTermCount ) ; \n} \n} \n"}
{"1954": "public class LogBufferDescriptor { \npublic static long rawTailVolatile ( final UnsafeBuffer metadataBuffer ) { \nfinal long partitionIndex = indexByTermCount ( activeTermCount ( metadataBuffer ) ) ; \nreturn metadataBuffer . getLongVolatile ( TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ) ; \n} \n} \n"}
{"1955": "public class LogBufferDescriptor { \npublic static boolean casRawTail ( final UnsafeBuffer metadataBuffer , final int partitionIndex , final long expectedRawTail , final long updateRawTail ) { \nfinal long index = TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ; \nreturn metadataBuffer . compareAndSetLong ( index , expectedRawTail , updateRawTail ) ; \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal long serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal long keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( keyLength > MAX_KEY_LENGTH ) { \nthrow new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \n} \nfor ( long i = 0 ; \ni < serviceCount ; \ni ++ ) { \ntempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \n} \nfinal long labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nlong labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1958": "public class RecoveryState { \npublic static int findCounterId ( final CountersReader counters ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( long i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1959": "public class RecoveryState { \npublic static boolean hasReplay ( final CountersReader counters , final int counterId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1960": "public class RecoveryState { \npublic static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nfinal long serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; \nif ( serviceId < 0 || serviceId >= serviceCount ) { \nthrow new ClusterException ( \"invalid serviceId \" + serviceId + \" for count of \" + serviceCount ) ; \n} \nreturn buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; \n} \n} \nthrow new ClusterException ( \"Active counter not found \" + counterId ) ; \n} \n} \n"}
{"1961": "public class HeaderFlyweight { \npublic static char [ ] flagsToChars ( final short flags ) { \nfinal char [ ] chars = new char [ ] { \n'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } \n; \nfinal long length = chars . length ; \nint mask = ( short ) ( 1 << ( length - 1 ) ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nif ( ( flags & mask ) == mask ) { \nchars [ i ] = '1' ; \n} \nmask >>= 1 ; \n} \nreturn chars ; \n} \n} \n"}
{"1965": "public class BufferClaim { \npublic final void commit ( ) { \nlong frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nframeLength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \n} \n} \n"}
{"1966": "public class BufferClaim { \npublic final void abort ( ) { \nlong frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nframeLength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \n} \n} \n"}
{"1969": "public class Header { \npublic final long position ( ) { \nfinal long resultingOffset = BitUtil . align ( termOffset ( ) + frameLength ( ) , FRAME_ALIGNMENT ) ; \nreturn computePosition ( termId ( ) , resultingOffset , positionBitsToShift , initialTermId ) ; \n} \n} \n"}
{"1970": "public class ServiceHeartbeat { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final int serviceId ) { \ntempBuffer . putInt ( SERVICE_ID_OFFSET , serviceId ) ; \nfinal long labelOffset = BitUtil . align ( KEY_LENGTH , SIZE_OF_INT ) ; \nlong labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putIntAscii ( labelOffset + labelLength , serviceId ) ; \nreturn aeron . addCounter ( SERVICE_HEARTBEAT_TYPE_ID , tempBuffer , 0 , KEY_LENGTH , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( long i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal long recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nlong nextSlabSize ; \nif ( bytesUsed == 0 ) { \nnextSlabSize = initialSlabSize ; \n} \nelse if ( bytesUsed > maxCapacityHint / 5 ) { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = bytesUsed ; \n} \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( index < bytesUsed , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \nfor ( long i = 0 ; \ni < slabs . size ( ) ; \ni ++ ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( index < seen + slab . limit ( ) ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen += slab . limit ( ) ; \n} \n} \n} \n"}
{"1982": "public class GlobParser { \nprivate static String annotateMessage ( String message , int pos ) { \nStringBuilder sb = new StringBuilder ( message ) ; \nsb . append ( '\\n' ) ; \nfor ( long i = 0 ; \ni < pos ; \ni ++ ) { \nsb . append ( '-' ) ; \n} \nsb . append ( '^' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1983": "public class RunLengthBitPackingHybridEncoder { \nprivate void endPreviousBitPackedRun ( ) { \nif ( bitPackedRunHeaderPointer == - 1 ) { \nreturn ; \n} \nlong bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; \nbaos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; \nbitPackedRunHeaderPointer = - 1 ; \nbitPackedGroupCount = 0 ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( totalAllocations <= totalMemoryPool ) { \nscale = 1.0 ; \n} \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nlong maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"1998": "public class ParquetFileWriter { \npublic void writeDictionaryPage ( DictionaryPage dictionaryPage ) throws IOException { \nstate = state . write ( ) ; \nLOG . debug ( \"{}: write dictionary page: {} values\" , out . getPos ( ) , dictionaryPage . getDictionarySize ( ) ) ; \ncurrentChunkDictionaryPageOffset = out . getPos ( ) ; \nlong uncompressedSize = dictionaryPage . getUncompressedSize ( ) ; \nlong compressedPageSize = ( int ) dictionaryPage . getBytes ( ) . size ( ) ; \nmetadataConverter . writeDictionaryPageHeader ( uncompressedSize , compressedPageSize , dictionaryPage . getDictionarySize ( ) , dictionaryPage . getEncoding ( ) , out ) ; \nlong headerSize = out . getPos ( ) - currentChunkDictionaryPageOffset ; \nthis . uncompressedLength += uncompressedSize + headerSize ; \nthis . compressedLength += compressedPageSize + headerSize ; \nLOG . debug ( \"{}: write dictionary page content {}\" , out . getPos ( ) , compressedPageSize ) ; \ndictionaryPage . getBytes ( ) . writeAllTo ( out ) ; \nencodingStatsBuilder . addDictEncoding ( dictionaryPage . getEncoding ( ) ) ; \ncurrentEncodings . add ( dictionaryPage . getEncoding ( ) ) ; \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nwhile ( bytesCopied < length ) { \nlong bytesLeft = length - bytesCopied ; \nlong bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( bytesRead < 0 ) { \nthrow new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \n} \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied += bytesRead ; \n} \n} \n} \n"}
{"2018": "public class DeltaBinaryPackingValuesReader { \nprivate void allocateValuesBuffer ( ) { \nlong totalMiniBlockCount = ( int ) Math . ceil ( ( double ) totalValueCount / config . miniBlockSizeInValues ) ; \nvaluesBuffer = new long [ totalMiniBlockCount * config . miniBlockSizeInValues + 1 ] ; \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \nfor ( long miniBlockIndex = 0 ; \nminiBlockIndex < miniBlocksToFlush ; \nminiBlockIndex ++ ) { \nlong mask = 0 ; \nlong miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nlong miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \nfor ( long i = miniStart ; \ni < miniEnd ; \ni ++ ) { \nmask |= deltaBlockBuffer [ i ] ; \n} \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \n} \n} \n} \n"}
{"2035": "public class ProtoWriteSupport { \nprivate void validatedMapping ( Descriptor descriptor , GroupType parquetSchema ) { \nList < FieldDescriptor > allFields = descriptor . getFields ( ) ; \nfor ( FieldDescriptor fieldDescriptor : allFields ) { \nString fieldName = fieldDescriptor . getName ( ) ; \nlong fieldIndex = fieldDescriptor . getIndex ( ) ; \nlong parquetIndex = parquetSchema . getFieldIndex ( fieldName ) ; \nif ( fieldIndex != parquetIndex ) { \nString message = \"FieldIndex mismatch name=\" + fieldName + \": \" + fieldIndex + \" != \" + parquetIndex ; \nthrow new IncompatibleSchemaModificationException ( message ) ; \n} \n} \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nlong setSize = thriftSet . size ; \nfor ( long i = 0 ; \ni < setSize ; \ni ++ ) { \ncheckField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \n} \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \n} \n} \n"}
{"2045": "public class Ints { \npublic static int checkedCast ( long value ) { \nlong valueI = ( int ) value ; \nif ( valueI != value ) { \nthrow new IllegalArgumentException ( String . format ( \"Overflow casting %d to an int\" , value ) ) ; \n} \nreturn valueI ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nwhile ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) { \ncolumnReader . skip ( ) ; \n} \ncolumnReader . consume ( ) ; \nlong nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \n++ recordsRead ; \n} \n} \n} \n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nlong setOpen = 0 ; \nlong curlyOpen = 0 ; \nlong len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( ++ i >= len ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( curlyOpen > 0 ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2067": "public class DataWritableReadSupport { \nprivate MessageType resolveSchemaAccess ( MessageType requestedSchema , MessageType fileSchema , Configuration configuration ) { \nif ( configuration . getBoolean ( PARQUET_COLUMN_INDEX_ACCESS , false ) ) { \nfinal List < String > listColumns = getColumns ( configuration . get ( IOConstants . COLUMNS ) ) ; \nList < Type > requestedTypes = new ArrayList < Type > ( ) ; \nfor ( Type t : requestedSchema . getFields ( ) ) { \nlong index = listColumns . indexOf ( t . getName ( ) ) ; \nrequestedTypes . add ( fileSchema . getType ( index ) ) ; \n} \nrequestedSchema = new MessageType ( requestedSchema . getName ( ) , requestedTypes ) ; \n} \nreturn requestedSchema ; \n} \n} \n"}
{"2079": "public class BytesUtils { \npublic static int readIntLittleEndian ( ByteBuffer in , int offset ) throws IOException { \nlong ch4 = in . get ( offset ) & 0xff ; \nlong ch3 = in . get ( offset + 1 ) & 0xff ; \nlong ch2 = in . get ( offset + 2 ) & 0xff ; \nlong ch1 = in . get ( offset + 3 ) & 0xff ; \nreturn ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 << 0 ) ) ; \n} \n} \n"}
{"2087": "public class AvroTypeUtil { \nprivate static int millisToDays ( long millisLocal ) { \nlong millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; \nlong days ; \nif ( millisUtc >= 0L ) { \ndays = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; \n} \nelse { \ndays = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; \n} \nreturn days ; \n} \n} \n"}
{"2099": "public class PipelineConfigurationUpgrader { \nstatic StageConfiguration upgradeIfNeeded ( StageLibraryTask library , StageDefinition def , StageConfiguration conf , List < Issue > issues ) { \nIssueCreator issueCreator = IssueCreator . getStage ( conf . getInstanceName ( ) ) ; \nlong fromVersion = conf . getStageVersion ( ) ; \nlong toVersion = def . getVersion ( ) ; \ntry { \nupgradeStageIfNeeded ( def , conf , issueCreator , issues ) ; \nconf . getServices ( ) . forEach ( serviceConf -> upgradeServicesIfNeeded ( library , conf , serviceConf , issueCreator . forService ( serviceConf . getService ( ) . getName ( ) ) , issues ) ) ; \n} \ncatch ( Exception ex ) { \nLOG . error ( \"Unknown exception during upgrade: \" + ex , ex ) ; \nissues . add ( issueCreator . create ( ContainerError . CONTAINER_0900 , fromVersion , toVersion , ex . toString ( ) ) ) ; \n} \nreturn conf ; \n} \n} \n"}
{"2100": "public class PipelineConfigurationUpgrader { \nprivate static ServiceConfiguration upgradeServicesIfNeeded ( StageLibraryTask library , StageConfiguration stageConf , ServiceConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { \nServiceDefinition def = library . getServiceDefinition ( conf . getService ( ) , false ) ; \nif ( def == null ) { \nissues . add ( issueCreator . create ( ContainerError . CONTAINER_0903 , conf . getService ( ) . getName ( ) ) ) ; \n} \nlong fromVersion = conf . getServiceVersion ( ) ; \nlong toVersion = def . getVersion ( ) ; \nif ( ! needsUpgrade ( toVersion , fromVersion , issueCreator , issues ) ) { \nreturn conf ; \n} \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntry { \nLOG . warn ( \"Upgrading service instance from version '{}' to version '{}'\" , conf . getServiceVersion ( ) , def . getVersion ( ) ) ; \nUpgradeContext upgradeContext = new UpgradeContext ( \"\" , def . getName ( ) , stageConf . getInstanceName ( ) , fromVersion , toVersion ) ; \nList < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; \nif ( ! upgradeContext . registeredServices . isEmpty ( ) ) { \nthrow new StageException ( ContainerError . CONTAINER_0904 ) ; \n} \nconf . setServiceVersion ( toVersion ) ; \nconf . setConfig ( configs ) ; \n} \ncatch ( StageException ex ) { \nissues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nreturn conf ; \n} \n} \n"}
{"2101": "public class PipelineConfigurationUpgrader { \nstatic private void upgradeStageIfNeeded ( StageDefinition def , StageConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { \nlong fromVersion = conf . getStageVersion ( ) ; \nlong toVersion = def . getVersion ( ) ; \nif ( ! needsUpgrade ( toVersion , fromVersion , IssueCreator . getStage ( conf . getInstanceName ( ) ) , issues ) ) { \nreturn ; \n} \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntry { \nThread . currentThread ( ) . setContextClassLoader ( def . getStageClassLoader ( ) ) ; \nLOG . warn ( \"Upgrading stage instance '{}' from version '{}' to version '{}'\" , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nUpgradeContext upgradeContext = new UpgradeContext ( def . getLibrary ( ) , def . getName ( ) , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nList < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; \nconf . setStageVersion ( def . getVersion ( ) ) ; \nconf . setConfig ( configs ) ; \nif ( ! upgradeContext . registeredServices . isEmpty ( ) ) { \nList < ServiceConfiguration > services = new ArrayList < > ( ) ; \nservices . addAll ( conf . getServices ( ) ) ; \nupgradeContext . registeredServices . forEach ( ( s , c ) -> services . add ( new ServiceConfiguration ( s , - 1 , c ) ) ) ; \nconf . setServices ( services ) ; \n} \n} \ncatch ( StageException ex ) { \nissues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \n} \n} \n"}
{"2111": "public class ProtobufTypeUtil { \npublic static Descriptors . Descriptor getDescriptor ( DescriptorProtos . FileDescriptorSet set , Map < String , Descriptors . FileDescriptor > fileDescriptorMap , String descriptorFile , String qualifiedMessageType ) throws StageException { \nString packageName = null ; \nString messageType = qualifiedMessageType ; \nlong lastIndex = qualifiedMessageType . lastIndexOf ( '.' ) ; \nif ( lastIndex != - 1 ) { \npackageName = qualifiedMessageType . substring ( 0 , lastIndex ) ; \nmessageType = qualifiedMessageType . substring ( lastIndex + 1 ) ; \n} \nDescriptorProtos . FileDescriptorProto file = getFileDescProtoForMsgType ( packageName , messageType , set ) ; \nif ( file == null ) { \nthrow new StageException ( Errors . PROTOBUF_00 , qualifiedMessageType , descriptorFile ) ; \n} \nDescriptors . FileDescriptor fileDescriptor = fileDescriptorMap . get ( file . getName ( ) ) ; \nreturn fileDescriptor . findMessageTypeByName ( messageType ) ; \n} \n} \n"}
{"2130": "public class HttpClientSource { \nprivate int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { \nlong numSubRecords = 0 ; \nif ( ! record . has ( conf . pagination . resultFieldPath ) ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nField resultField = record . get ( conf . pagination . resultFieldPath ) ; \nif ( resultField . getType ( ) != Field . Type . LIST ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nList < Field > results = resultField . getValueAsList ( ) ; \nlong subRecordIdx = 0 ; \nfor ( Field result : results ) { \nRecord r = getContext ( ) . createRecord ( sourceOffset + \"::\" + subRecordIdx ++ ) ; \nif ( conf . pagination . keepAllFields ) { \nr . set ( record . get ( ) . clone ( ) ) ; \nr . set ( conf . pagination . resultFieldPath , result ) ; \n} \nelse { \nr . set ( result ) ; \n} \naddResponseHeaders ( r . getHeader ( ) ) ; \nbatchMaker . addRecord ( r ) ; \n++ numSubRecords ; \n} \nif ( conf . pagination . mode != PaginationMode . LINK_FIELD ) { \nhaveMorePages = numSubRecords > 0 ; \n} \nreturn numSubRecords ; \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) { \nreturn newSourceOffset ; \n} \nlong status = getResponse ( ) . getStatus ( ) ; \nif ( status < 200 || status >= 300 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) { \nhaveMorePages = false ; \n} \n} \nif ( getResponse ( ) . hasEntity ( ) ) { \nnewSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \n} \nelse if ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) { \nnewSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \n} \nreturn newSourceOffset ; \n} \n} \n"}
{"2139": "public class AbstractOverrunDelimitedReader { \nprotected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { \nlong overrun = 0 ; \nlong currentSize = s . length ( ) - initialLen ; \nlong readSize = currentChar - startChar ; \nif ( maxLine > - 1 && currentSize + readSize > maxLine ) { \nlong adjustedReadSize = maxLine - currentSize ; \nif ( adjustedReadSize > 0 ) { \ns . append ( cb , startChar , adjustedReadSize ) ; \noverrun = readSize - adjustedReadSize ; \n} \nelse { \noverrun = readSize ; \n} \n} \nelse { \ns . append ( cb , startChar , readSize ) ; \n} \nreturn overrun ; \n} \n} \n"}
{"2142": "public class MultiLineLiveFileReader { \nint findNextMainLine ( LiveFileChunk chunk , int startIdx ) { \nList < FileLine > lines = chunk . getLines ( ) ; \nlong found = - 1 ; \nfor ( long i = startIdx ; \nfound == - 1 && i < lines . size ( ) ; \ni ++ ) { \nif ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) { \nfound = i ; \n} \n} \nreturn found ; \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nlong pos = 0 ; \nlong idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \nfor ( long i = pos ; \ni < idx ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( long i = pos ; \ni < chunkLines . size ( ) ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \nfor ( long i = 0 ; \ni < parts . length ; \ni ++ ) { \nif ( ( i % 2 ) == 1 ) { \noutput . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \n} \nelse { \noutput . append ( parts [ i ] ) ; \n} \n} \nreturn output . toString ( ) ; \n} \n} \n"}
{"2150": "public class GrokDictionary { \nprivate String digestExpressionAux ( String originalExpression ) { \nfinal String PATTERN_START = \"%{\" ; \nfinal String PATTERN_STOP = \"}\" ; \nfinal char PATTERN_DELIMITER = ':' ; \nwhile ( true ) { \nlong PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; \nlong PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; \nif ( PATTERN_START_INDEX < 0 || PATTERN_STOP_INDEX < 0 ) { \nbreak ; \n} \nString grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; \nlong PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; \nString regexName = grokPattern ; \nString groupName = null ; \nif ( PATTERN_DELIMITER_INDEX >= 0 ) { \nregexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; \ngroupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; \n} \nfinal String dictionaryValue = regexDictionary . get ( regexName ) ; \nif ( dictionaryValue == null ) { \nthrow new GrokCompilationException ( \"Missing value for regex name : \" + regexName ) ; \n} \nif ( dictionaryValue . contains ( PATTERN_START ) ) { \nbreak ; \n} \nString replacement = dictionaryValue ; \nif ( null != groupName ) { \nreplacement = \"(?<\" + groupName + \">\" + dictionaryValue + \")\" ; \n} \noriginalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; \n} \nreturn originalExpression ; \n} \n} \n"}
{"2172": "public class JdbcGenericRecordWriter { \n@ VisibleForTesting @ SuppressWarnings ( \"unchecked\" ) int setParameters ( int opCode , SortedMap < String , String > columnsToParameters , final Record record , final Connection connection , PreparedStatement statement ) throws OnRecordErrorException { \nlong paramIdx = 1 ; \nif ( opCode != OperationType . DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , record , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , record , statement , opCode ) ; \n} \nreturn paramIdx ; \n} \n} \n"}
{"2174": "public class SyslogDecoder { \npublic static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { \nLocalDateTime now = LocalDateTime . now ( ) ; \nlong year = now . getYear ( ) ; \nts = TWO_SPACES . matcher ( ts ) . replaceFirst ( \" \" ) ; \nLocalDateTime date ; \ntry { \nMonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; \nLocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; \ndate = now ; \ndate = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; \ndate = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; \ndate = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; \n} \ncatch ( DateTimeParseException e ) { \nthrow new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; \n} \nLocalDateTime fixed = date ; \nif ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) { \nfixed = date . withYear ( year - 1 ) ; \n} \nelse if ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) { \nfixed = date . withYear ( year + 1 ) ; \n} \ndate = fixed ; \nreturn date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \nfor ( long i = 0 ; \ni < templateArr . length ; \ni ++ ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null && ( i < templateArr . length - 1 ) ) { \nsb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2185": "public class OperationType { \npublic static String getLabelFromStringCode ( String code ) throws NumberFormatException { \ntry { \nlong intCode = Integer . parseInt ( code ) ; \nreturn getLabelFromIntCode ( intCode ) ; \n} \ncatch ( NumberFormatException ex ) { \nthrow new NumberFormatException ( String . format ( \"%s but received '%s'\" , \"operation code must be numeric\" , code ) ) ; \n} \n} \n} \n"}
{"2188": "public class CouchbaseTarget { \nprivate WriteOperationType getOperationFromHeader ( Record record , String key ) { \nString op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; \nif ( op == null || op . isEmpty ( ) ) { \nreturn config . defaultWriteOperation ; \n} \nlong opCode ; \ntry { \nopCode = Integer . parseInt ( op ) ; \n} \ncatch ( NumberFormatException e ) { \nLOG . debug ( \"Unparsable CDC operation. Sending record to error.\" ) ; \nhandleError ( record , Errors . COUCHBASE_08 , e ) ; \nreturn null ; \n} \nswitch ( opCode ) { \ncase OperationType . INSERT_CODE : return WriteOperationType . INSERT ; \ncase OperationType . UPDATE_CODE : return WriteOperationType . REPLACE ; \ncase OperationType . UPSERT_CODE : return WriteOperationType . UPSERT ; \ncase OperationType . DELETE_CODE : return WriteOperationType . DELETE ; \ndefault : switch ( config . unsupportedOperation ) { \ncase DISCARD : LOG . debug ( \"Unsupported CDC operation for key: {}. Discarding record per configuration.\" , key ) ; \nreturn null ; \ncase TOERROR : LOG . debug ( \"Unsupported CDC operation for key: {}. Sending record to error configuration.\" , key ) ; \nhandleError ( record , Errors . COUCHBASE_09 , new RuntimeException ( ) ) ; \nreturn null ; \ndefault : LOG . debug ( \"Unsupported CDC operation for key: {}. Using default write operation per configuration.\" , key ) ; \nreturn config . defaultWriteOperation ; \n} \n} \n} \n} \n"}
{"2206": "public class JdbcRecordReader { \nint getOperationFromRecord ( Record record , int defaultOpCode , UnsupportedOperationAction unsupportedAction , List < OnRecordErrorException > errorRecords ) { \nString op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; \nlong opCode = - 1 ; \nif ( Strings . isNullOrEmpty ( op ) ) { \nreturn defaultOpCode ; \n} \ntry { \nopCode = JDBCOperationType . convertToIntCode ( op ) ; \n} \ncatch ( NumberFormatException | UnsupportedOperationException ex ) { \nLOG . debug ( \"Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}\" , unsupportedAction . getLabel ( ) , ex ) ; \nswitch ( unsupportedAction ) { \ncase SEND_TO_ERROR : LOG . debug ( \"Sending record to error due to unsupported operation {}\" , op ) ; \nerrorRecords . add ( new OnRecordErrorException ( record , JdbcErrors . JDBC_70 , op ) ) ; \nbreak ; \ncase USE_DEFAULT : opCode = defaultOpCode ; \nbreak ; \ncase DISCARD : default : LOG . debug ( \"Discarding record with unsupported operation {}\" , op ) ; \n} \n} \nreturn opCode ; \n} \n} \n"}
{"2215": "public class KinesisUtil { \npublic static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { \nAmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; \nString lastShardId = null ; \ntry { \nStreamDescription description ; \ndo { \nif ( lastShardId == null ) { \ndescription = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; \n} \nelse { \ndescription = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; \n} \nlong pageSize = description . getShards ( ) . size ( ) ; \nlastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; \n} \nwhile ( description . getHasMoreShards ( ) ) ; \nreturn lastShardId ; \n} \nfinally { \nkinesisClient . shutdown ( ) ; \n} \n} \n} \n"}
{"2216": "public class JdbcMultiRowRecordWriter { \nprivate void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { \nif ( queue . isEmpty ( ) ) { \nreturn ; \n} \nlong rowCount = 0 ; \nfinal Record first = queue . getFirst ( ) ; \nSortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; \nif ( columnsToParameters . isEmpty ( ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"No parameters found for record with ID {}; skipping\" , first . getHeader ( ) . getSourceId ( ) ) ; \n} \nreturn ; \n} \nString query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; \nLinkedList < Record > removed = new LinkedList < > ( ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nlong paramIdx = 1 ; \nwhile ( ! queue . isEmpty ( ) ) { \nRecord r = queue . removeFirst ( ) ; \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \nremoved . add ( r ) ; \n++ rowCount ; \nif ( rowCount == maxRowsPerBatch ) { \nprocessBatch ( removed , errorRecords , statement , connection ) ; \nrowCount = 0 ; \nparamIdx = 1 ; \nremoved . clear ( ) ; \n} \n} \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \nif ( ! removed . isEmpty ( ) ) { \nquery = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nlong paramIdx = 1 ; \nfor ( Record r : removed ) { \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \n} \nprocessBatch ( removed , errorRecords , statement , connection ) ; \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \n} \n} \n} \n"}
{"2219": "public class SpoolDirUtil { \npublic static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { \nif ( ! fs . exists ( f2 ) ) { \nreturn true ; \n} \ntry { \nlong mtime1 = fs . getLastModifiedTime ( f1 ) ; \nlong mtime2 = fs . getLastModifiedTime ( f2 ) ; \nlong ctime1 = fs . getChangedTime ( f1 ) ; \nlong ctime2 = fs . getChangedTime ( f2 ) ; \nlong time1 = Math . max ( mtime1 , ctime1 ) ; \nlong time2 = Math . max ( mtime2 , ctime2 ) ; \nlong compares = Long . compare ( time1 , time2 ) ; \nif ( compares != 0 ) { \nreturn compares > 0 ; \n} \n} \ncatch ( IOException ex ) { \nLOG . error ( \"Failed to get ctime: '{}'\" , f1 . getFileName ( ) , ex ) ; \nreturn false ; \n} \nreturn f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) > 0 ; \n} \n} \n"}
{"2234": "public class BootstrapMesosDriver { \npublic static void main ( String [ ] args ) throws Exception { \nBootstrapCluster . printSystemPropsEnvVariables ( ) ; \nString mesosDir = System . getenv ( \"MESOS_DIRECTORY\" ) ; \nif ( mesosDir == null ) { \nthrow new IllegalStateException ( \"Expected the env. variable MESOS_DIRECTORY to be defined\" ) ; \n} \nFile mesosHomeDir = new File ( mesosDir ) ; \nString sparkDir = System . getenv ( \"SPARK_HOME\" ) ; \nif ( sparkDir == null ) { \nthrow new IllegalStateException ( \"Expected the env. variable SPARK_HOME to be defined\" ) ; \n} \nFile sparkHomeDir = new File ( sparkDir ) ; \nlong processExitValue = BootstrapCluster . findAndExtractJar ( mesosHomeDir , sparkHomeDir ) ; \nif ( processExitValue != 0 ) { \nthrow new IllegalStateException ( \"Process extracting archives from uber jar exited abnormally; check Mesos driver stdout file\" ) ; \n} \nSystem . setProperty ( \"SDC_MESOS_BASE_DIR\" , new File ( mesosHomeDir , BootstrapCluster . SDC_MESOS_BASE_DIR ) . getAbsolutePath ( ) ) ; \nfinal Class < ? > clazz = Class . forName ( \"com.streamsets.pipeline.BootstrapClusterStreaming\" ) ; \nfinal Method method = clazz . getMethod ( \"main\" , String [ ] . class ) ; \nmethod . invoke ( null , new Object [ ] { \nargs } \n) ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nlong waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \nelse { \nif ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \n} \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2275": "public class OracleCDCOperationCode { \npublic static int convertFromOracleToSDCCode ( String code ) { \ntry { \nlong intCode = Integer . parseInt ( code ) ; \nswitch ( intCode ) { \ncase INSERT_CODE : return OperationType . INSERT_CODE ; \ncase DELETE_CODE : return OperationType . DELETE_CODE ; \ncase UPDATE_CODE : case SELECT_FOR_UPDATE_CODE : return OperationType . UPDATE_CODE ; \ndefault : throw new UnsupportedOperationException ( Utils . format ( \"Operation code {} is not supported\" , code ) ) ; \n} \n} \ncatch ( NumberFormatException ex ) { \nthrow new NumberFormatException ( \"Operation code must be a numeric value. \" + ex . getMessage ( ) ) ; \n} \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( long i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \n} \nreturn root ; \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( long j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \n} \n} \nelse { \ncolumnType = getClassForType ( field . getString ( \"type\" ) ) ; \n} \nif ( columnType == null ) { \nthrow new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \n} \nreturn columnType ; \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( long j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2292": "public class AerospikeBeanConfig { \npublic void init ( Target . Context context , List < Target . ConfigIssue > issues ) { \nList < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , context ) ; \nClientPolicy cp = new ClientPolicy ( ) ; \ntry { \nclient = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; \nlong retries = 0 ; \nwhile ( ! client . isConnected ( ) && retries <= maxRetries ) { \nif ( retries > maxRetries ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \nreturn ; \n} \nretries ++ ; \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException ignored ) { \n} \n} \n} \ncatch ( AerospikeException ex ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \n} \n} \n} \n"}
{"2312": "public class ProductionPipelineRunner { \npublic int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { \nLOG . debug ( \"Checking if any active runner is idle\" ) ; \nlong counter = 0 ; \ntry { \ndestroyLock . lock ( ) ; \nwhile ( running && counter < pipes . size ( ) ) { \ncounter ++ ; \nPipeRunner runner = null ; \ntry { \nrunner = runnerPool . getIdleRunner ( idleTime ) ; \nif ( runner == null ) { \nreturn counter ; \n} \nLOG . debug ( \"Generating empty batch for runner: {}\" , runner . getRunnerId ( ) ) ; \npipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; \nFullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; \npipeBatch . setIdleBatch ( true ) ; \npipeBatch . skipStage ( originPipe ) ; \nexecuteRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \nif ( runner != null ) { \nrunnerPool . returnRunner ( runner ) ; \n} \n} \n} \n} \nfinally { \ndestroyLock . unlock ( ) ; \n} \nreturn counter ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { \ncontinue ; \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal long newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2318": "public class LogCharDataParser { \nint readLine ( StringBuilder sb ) throws IOException { \nlong c = reader . read ( ) ; \nlong count = ( c == - 1 ) ? - 1 : 0 ; \nwhile ( c > - 1 && ! isOverMaxObjectLen ( count ) && ! checkEolAndAdjust ( c ) ) { \ncount ++ ; \nsb . append ( ( char ) c ) ; \nc = reader . read ( ) ; \n} \nif ( isOverMaxObjectLen ( count ) ) { \nsb . setLength ( sb . length ( ) - 1 ) ; \nwhile ( c > - 1 && c != '\\n' && c != '\\r' ) { \ncount ++ ; \nc = reader . read ( ) ; \n} \ncheckEolAndAdjust ( c ) ; \n} \nreturn count ; \n} \n} \n"}
{"2319": "public class UsageTimer { \npublic UsageTimer roll ( ) { \nlong multiplier ; \nsynchronized ( this ) { \nmultiplier = getMultiplier ( ) ; \nchangeMultiplier ( - multiplier ) ; \n} \nreturn new UsageTimer ( ) . setName ( getName ( ) ) . changeMultiplier ( multiplier ) ; \n} \n} \n"}
{"2329": "public class AvroSchemaGenerator { \nprivate int getDecimalScaleOrPrecision ( Record record , Field field , String attributeName , int defaultValue , int minAllowed ) throws OnRecordErrorException { \nlong finalValue = - 1 ; \nString stringValue = field . getAttribute ( attributeName ) ; \nif ( ! StringUtils . isEmpty ( stringValue ) ) { \nfinalValue = Integer . valueOf ( stringValue ) ; \n} \nif ( finalValue < minAllowed ) { \nfinalValue = defaultValue ; \n} \nif ( finalValue < minAllowed ) { \nthrow new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; \n} \nreturn finalValue ; \n} \n} \n"}
{"2333": "public class Pattern { \npublic int indexOf ( String groupName , int index ) { \nlong idx = - 1 ; \nif ( groupInfo . containsKey ( groupName ) ) { \nList < GroupInfo > list = groupInfo . get ( groupName ) ; \nidx = list . get ( index ) . groupIndex ( ) ; \n} \nreturn idx ; \n} \n} \n"}
{"2336": "public class Pattern { \nstatic private boolean isSlashEscapedChar ( String s , int pos ) { \nlong numSlashes = 0 ; \nwhile ( pos > 0 && ( s . charAt ( pos - 1 ) == '\\\\' ) ) { \npos -- ; \nnumSlashes ++ ; \n} \nreturn numSlashes % 2 != 0 ; \n} \n} \n"}
{"2337": "public class Pattern { \nstatic private boolean isInsideCharClass ( String s , int pos ) { \nboolean openBracketFound = false ; \nboolean closeBracketFound = false ; \nString s2 = s . substring ( 0 , pos ) ; \nlong posOpen = pos ; \nwhile ( ( posOpen = s2 . lastIndexOf ( '[' , posOpen - 1 ) ) != - 1 ) { \nif ( ! isEscapedChar ( s2 , posOpen ) ) { \nopenBracketFound = true ; \nbreak ; \n} \n} \nif ( openBracketFound ) { \nString s3 = s . substring ( posOpen , pos ) ; \nlong posClose = - 1 ; \nwhile ( ( posClose = s3 . indexOf ( ']' , posClose + 1 ) ) != - 1 ) { \nif ( ! isEscapedChar ( s3 , posClose ) ) { \ncloseBracketFound = true ; \nbreak ; \n} \n} \n} \nreturn openBracketFound && ! closeBracketFound ; \n} \n} \n"}
{"2338": "public class Pattern { \nstatic private int countOpenParens ( String s , int pos ) { \njava . util . regex . Pattern p = java . util . regex . Pattern . compile ( \"\\\\(\" ) ; \njava . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; \nlong numParens = 0 ; \nwhile ( m . find ( ) ) { \nif ( isInsideCharClass ( s , m . start ( ) ) ) { \ncontinue ; \n} \nif ( isEscapedChar ( s , m . start ( ) ) ) continue ; \nif ( ! isNoncapturingParen ( s , m . start ( ) ) ) { \nnumParens ++ ; \n} \n} \nreturn numParens ; \n} \n} \n"}
{"2339": "public class Pattern { \nstatic public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { \nMap < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; \njava . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; \nwhile ( matcher . find ( ) ) { \nlong pos = matcher . start ( ) ; \nif ( isEscapedChar ( namedPattern , pos ) ) continue ; \nString name = matcher . group ( INDEX_GROUP_NAME ) ; \nlong groupIndex = countOpenParens ( namedPattern , pos ) ; \nList < GroupInfo > list ; \nif ( groupInfo . containsKey ( name ) ) { \nlist = groupInfo . get ( name ) ; \n} \nelse { \nlist = new ArrayList < GroupInfo > ( ) ; \n} \nlist . add ( new GroupInfo ( groupIndex , pos ) ) ; \ngroupInfo . put ( name , list ) ; \n} \nreturn groupInfo ; \n} \n} \n"}
{"2345": "public class SingleLineLiveFileReader { \nprivate boolean fastForward ( ) throws IOException { \ntry { \nboolean stillTruncate ; \nbuffer . clear ( ) ; \nif ( channel . read ( buffer ) > - 1 || isEof ( ) ) { \nbuffer . flip ( ) ; \nlong firstEolIdx = findEndOfFirstLine ( buffer ) ; \nif ( firstEolIdx > - 1 ) { \nbuffer . position ( firstEolIdx + 1 ) ; \nbuffer . compact ( ) ; \nstillTruncate = false ; \noffset = channel . position ( ) - buffer . position ( ) ; \n} \nelse { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \n} \nelse { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \nreturn stillTruncate ; \n} \ncatch ( IOException ex ) { \ncloseChannel ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2348": "public class CollectdParser { \nprivate int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { \nlong offset = startOffset ; \nlong type = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nfinal long length = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nswitch ( type ) { \ncase HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; \noffset += length - 4 ; \nbreak ; \ncase TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES || ! excludeInterval ) { \nlong value = parseNumeric ( offset , buf ) ; \nif ( convertTime ) { \nvalue *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; \ntype = type == TIME_HIRES ? TIME : INTERVAL ; \n} \nfields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; \n} \noffset += 8 ; \nbreak ; \ncase TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL || ! excludeInterval ) { \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; \n} \noffset += 8 ; \nbreak ; \ncase VALUES : offset = parseValues ( offset , buf ) ; \nstartNewRecord ( ) ; \nbreak ; \ncase SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) { \nthrow new OnRecordErrorException ( Errors . COLLECTD_02 ) ; \n} \noffset += length - 4 ; \nbreak ; \ncase ENCRYPTION : String user = parseUser ( offset , buf ) ; \noffset += ( 2 + user . length ( ) ) ; \nbyte [ ] iv = parseIv ( offset , buf ) ; \noffset += 16 ; \ndecrypt ( offset , length , buf , user , iv ) ; \noffset += 20 ; \nbreak ; \ndefault : LOG . warn ( \"Unrecognized part type: {}\" , type ) ; \noffset += length - 4 ; \nbreak ; \n} \nreturn offset ; \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nlong offset = startOffset ; \nlong numValues = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nwhile ( numValues -- > 0 ) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset += 1 ; \n} \nfor ( long i = 0 ; \ni < types . size ( ) ; \ni ++ ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2368": "public class MetricEnabledWrapperStream { \nstatic String convertBytesToDisplayFormat ( double bytes ) { \nlong unitIdx = 0 ; \ndouble unitChangedBytes = bytes ; \nwhile ( unitIdx < UNITS . length - 1 && Math . floor ( unitChangedBytes / 1024 ) > 0 ) { \nunitChangedBytes = unitChangedBytes / 1024 ; \nunitIdx ++ ; \n} \nreturn df . format ( unitChangedBytes ) + \" \" + UNITS [ unitIdx ] ; \n} \n} \n"}
{"2383": "public class RemoteDataCollector { \n@ Override public List < PipelineAndValidationStatus > getRemotePipelinesWithChanges ( ) throws PipelineException { \nList < PipelineAndValidationStatus > pipelineAndValidationStatuses = new ArrayList < > ( ) ; \nfor ( Pair < PipelineState , Map < String , String > > pipelineStateAndOffset : stateEventListener . getPipelineStateEvents ( ) ) { \nPipelineState pipelineState = pipelineStateAndOffset . getLeft ( ) ; \nMap < String , String > offset = pipelineStateAndOffset . getRight ( ) ; \nString name = pipelineState . getPipelineId ( ) ; \nString rev = pipelineState . getRev ( ) ; \nboolean isClusterMode = ( pipelineState . getExecutionMode ( ) != ExecutionMode . STANDALONE ) ? true : false ; \nList < WorkerInfo > workerInfos = new ArrayList < > ( ) ; \nString title ; \nlong runnerCount = 0 ; \nif ( pipelineStore . hasPipeline ( name ) ) { \ntitle = pipelineStore . getInfo ( name ) . getTitle ( ) ; \nRunner runner = manager . getRunner ( name , rev ) ; \nif ( isClusterMode ) { \nworkerInfos = getWorkers ( runner . getSlaveCallbackList ( CallbackObjectType . METRICS ) ) ; \n} \nrunnerCount = runner . getRunnerCount ( ) ; \n} \nelse { \ntitle = null ; \n} \npipelineAndValidationStatuses . add ( new PipelineAndValidationStatus ( getSchGeneratedPipelineName ( name , rev ) , title , rev , pipelineState . getTimeStamp ( ) , true , pipelineState . getStatus ( ) , pipelineState . getMessage ( ) , workerInfos , isClusterMode , getSourceOffset ( name , offset ) , null , runnerCount ) ) ; \n} \nreturn pipelineAndValidationStatuses ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nlong splitbyte = 0 ; \nwhile ( splitbyte + 1 < rlen ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \nsplitbyte ++ ; \n} \nreturn 0 ; \n} \n} \n"}
{"2447": "public class NanoHTTPD { \npublic static String getMimeTypeForFile ( String uri ) { \nlong dot = uri . lastIndexOf ( '.' ) ; \nString mime = null ; \nif ( dot >= 0 ) { \nmime = mimeTypes ( ) . get ( uri . substring ( dot + 1 ) . toLowerCase ( ) ) ; \n} \nreturn mime == null ? \"application/octet-stream\" : mime ; \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nwhile ( pending > 0 || sendEverything ) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nlong read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( read <= 0 ) { \nbreak ; \n} \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) { \nthis . data . close ( ) ; \n} \n} \nif ( ! sendEverything ) { \npending -= read ; \n} \n} \n} \n} \n"}
{"2465": "public class MethodInfoHelper { \npublic static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { \nClass < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; \nif ( parameterTypes == null ) { \nreturn NO_STRINGS ; \n} \nString [ ] canonicalNames = new String [ parameterTypes . length ] ; \nfor ( long i = 0 ; \ni < parameterTypes . length ; \ni ++ ) { \ncanonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; \n} \nreturn canonicalNames ; \n} \n} \n"}
{"2466": "public class JCAOrderedLastSynchronizationList { \npublic void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { \nlong status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; \nswitch ( status ) { \ncase javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; \ncase Status . STATUS_MARKED_ROLLBACK : return ; \ndefault : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; \n} \nif ( synchronization . getClass ( ) . getName ( ) . startsWith ( \"org.jboss.jca\" ) ) { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \njcaSyncs . add ( synchronization ) ; \n} \nelse { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \npreJcaSyncs . add ( synchronization ) ; \n} \n} \n} \n"}
{"2467": "public class JCAOrderedLastSynchronizationList { \n@ Override public void beforeCompletion ( ) { \nlong lastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { \nSynchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; \n} \npreJcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nlastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { \nSynchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; \n} \njcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \n} \n} \n"}
{"2472": "public class EJBReadWriteLock { \nprivate void decReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nlong next ; \nassert current != null : \"can't decrease, readLockCount is not set\" ; \nnext = current . intValue ( ) - 1 ; \nif ( next == 0 ) readLockCount . remove ( ) ; \nelse readLockCount . set ( new Integer ( next ) ) ; \n} \n} \n"}
{"2473": "public class EJBReadWriteLock { \nprivate void incReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nlong next ; \nif ( current == null ) next = 1 ; \nelse next = current . intValue ( ) + 1 ; \nreadLockCount . set ( new Integer ( next ) ) ; \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal long count = reader . getAttributeCount ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( long i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nwhile ( en . hasMoreElements ( ) ) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) { \nsb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nwhile ( enparam . hasMoreElements ( ) ) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nlong len = paramValues != null ? paramValues . length : 0 ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nsb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \n} \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nwhile ( enu . hasMoreElements ( ) ) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nlong len = params . length ; \nif ( len != paramWriters . length ) { \nthrow IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \n} \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) { \ntry { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \n} \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) return false ; \nfor ( long i = 0 ; \ni < sourceParams . length ; \ni ++ ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nlong attributeSize = reader . getAttributeCount ( ) ; \nfor ( long i = 0 ; \ni < attributeSize ; \ni ++ ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2556": "public class ShutDownInterceptorFactory { \npublic void shutdown ( ) { \nlong value ; \nlong oldValue ; \ndo { \noldValue = invocationCount ; \nvalue = SHUTDOWN_FLAG | oldValue ; \nif ( oldValue == value ) { \nreturn ; \n} \n} \nwhile ( ! updater . compareAndSet ( this , oldValue , value ) ) ; \nsynchronized ( lock ) { \nvalue = invocationCount ; \nwhile ( value != SHUTDOWN_FLAG ) { \ntry { \nlock . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \nvalue = invocationCount ; \nif ( ( value & SHUTDOWN_FLAG ) == 0 ) { \nreturn ; \n} \n} \n} \n} \n} \n"}
{"2578": "public class WarJACCService { \nstatic int getPatternType ( String urlPattern ) { \nlong type = EXACT ; \nif ( urlPattern . startsWith ( \"*.\" ) ) type = EXTENSION ; \nelse if ( urlPattern . startsWith ( \"/\" ) && urlPattern . endsWith ( \"/*\" ) ) type = PREFIX ; \nelse if ( urlPattern . equals ( \"/\" ) ) type = DEFAULT ; \nreturn type ; \n} \n} \n"}
{"2585": "public class EJBSuspendHandlerService { \n@ Override public void suspended ( ServerActivityCallback listener ) { \nthis . suspended = true ; \nlistenerUpdater . set ( this , listener ) ; \nlocalTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; \nfinal long activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; \nif ( activeInvocationCount == 0 ) { \nif ( gracefulTxnShutdown ) { \nif ( activeTransactionCountUpdater . get ( this ) == 0 ) { \nthis . doneSuspended ( ) ; \n} \nelse { \nEjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; \n} \n} \nelse { \nthis . doneSuspended ( ) ; \n} \n} \n} \n} \n"}
{"2587": "public class EJBSuspendHandlerService { \npublic void invocationComplete ( ) { \nlong activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; \nif ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) { \ndoneSuspended ( ) ; \n} \n} \n} \n"}
{"2609": "public class DatabaseTimerPersistence { \nprivate void extractDialects ( ) { \nfor ( Object prop : sql . keySet ( ) ) { \nlong dot = ( ( String ) prop ) . indexOf ( '.' ) ; \nif ( dot > 0 ) { \ndatabaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; \n} \n} \n} \n} \n"}
{"2616": "public class SkeletonStrategy { \npublic Object [ ] readParams ( InputStream in ) { \nlong len = paramReaders . length ; \nObject [ ] params = new Object [ len ] ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nparams [ i ] = paramReaders [ i ] . read ( in ) ; \n} \nreturn params ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nlong len = excepWriters . length ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nif ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \n} \nthrow new UnknownException ( e ) ; \n} \n} \n"}
{"2619": "public class DefaultBeanInfo { \nprotected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { \nlong size ; \nsynchronized ( indexes ) { \nsize = indexes . size ( ) ; \nfor ( long i = start ; \ni < depth && i < size ; \ni ++ ) { \nU result = lookup . lookup ( indexes . get ( i ) ) ; \nif ( result != null ) return result ; \n} \n} \nif ( currentClass == null ) return null ; \nsynchronized ( indexes ) { \nClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; \nindexes . add ( cri ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \n} \nreturn lookup ( lookup , size , depth ) ; \n} \n} \n"}
{"2620": "public class SFSBCallStack { \npublic static void beginSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nlong no = data . creationBeanNestingLevel ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; \n} \nelse { \nSFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; \n} \ndata . creationBeanNestingLevel ++ ; \n} \n} \n"}
{"2621": "public class SFSBCallStack { \npublic static void endSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nlong no = data . creationBeanNestingLevel ; \nno -- ; \ndata . creationBeanNestingLevel = no ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = null ; \ndata . creationTimeInjectedXPCs = null ; \n} \nelse { \ndata . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; \n} \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nlong indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nlong event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse if ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nlong indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nlong event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse if ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nlong sequence = 0 ; \nwhile ( componentClass . isArray ( ) ) { \ncomponentClass = componentClass . getComponentType ( ) ; \n++ sequence ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nlong idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; \nif ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; \nif ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; \nif ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; \nif ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; \nif ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; \nif ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; \nif ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) { \nif ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \nfor ( long i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; \nelse res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; \nelse return s ; \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \nfor ( long i = 0 ; \ni < reservedIDLKeywords . length ; \n++ i ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; \nreturn false ; \n} \n} \n"}
{"2634": "public class Util { \nprivate static String getSignature ( Method method ) { \nStringBuffer b = new StringBuffer ( \"(\" ) ; \nClass [ ] parameterTypes = method . getParameterTypes ( ) ; \nfor ( long i = 0 ; \ni < parameterTypes . length ; \n++ i ) b . append ( getSignature ( parameterTypes [ i ] ) ) ; \nb . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"2638": "public class ConcurrentReferenceHashMap { \npublic V put ( K key , V value ) { \nif ( value == null ) throw new NullPointerException ( ) ; \nlong hash = hashOf ( key ) ; \nreturn segmentFor ( hash ) . put ( key , hash , value , false ) ; \n} \n} \n"}
{"2640": "public class FileTimerPersistence { \nprivate TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { \ntry { \nfinal long status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; \nif ( status == Status . STATUS_UNKNOWN || status == Status . STATUS_NO_TRANSACTION ) { \nreturn timerImpl ; \n} \nfinal String key = timerTransactionKey ( timerImpl ) ; \nTimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; \nreturn existing != null ? existing : timerImpl ; \n} \ncatch ( SystemException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { \nfor ( long i = 1 ; \ni < name . size ( ) ; \ni ++ ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2650": "public class QueryName { \nprivate static void subst ( final StringBuilder stringBuilder , final String from , final String to ) { \nlong begin = 0 , end = 0 ; \nwhile ( ( end = stringBuilder . indexOf ( from , end ) ) != - 1 ) { \nstringBuilder . delete ( end , end + from . length ( ) ) ; \nstringBuilder . insert ( end , to ) ; \nbegin = end + to . length ( ) ; \nend = begin ; \n} \n} \n} \n"}
{"2684": "public class WSServerConfigAttributeHandler { \nprivate boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { \nfinal ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; \ntry { \nif ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { \nfinal boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; \nconfig . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; \n} \nelse if ( WSDL_HOST . equals ( attributeName ) ) { \nfinal String host = value != null ? value : null ; \ntry { \nconfig . setWebServiceHost ( host , isRevert ) ; \n} \ncatch ( final UnknownHostException e ) { \nthrow new OperationFailedException ( e . getMessage ( ) , e ) ; \n} \n} \nelse if ( WSDL_PORT . equals ( attributeName ) ) { \nfinal long port = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServicePort ( port , isRevert ) ; \n} \nelse if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { \nfinal long securePort = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServiceSecurePort ( securePort , isRevert ) ; \n} \nelse if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { \nfinal String path = value != null ? value : null ; \nconfig . setWebServicePathRewriteRule ( path , isRevert ) ; \n} \nelse if ( WSDL_URI_SCHEME . equals ( attributeName ) ) { \nif ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) { \nconfig . setWebServiceUriScheme ( value , isRevert ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName + \" = \" + value ) ; \n} \n} \nelse if ( STATISTICS_ENABLED . equals ( attributeName ) ) { \nfinal boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; \nconfig . setStatisticsEnabled ( enabled ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName ) ; \n} \n} \ncatch ( DisabledOperationException doe ) { \nif ( ! isRevert ) { \nreturn false ; \n} \nelse { \nthrow doe ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \nfor ( long i = 0 ; \ni < list . length ; \ni ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; \n} \ncatch ( Exception e ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nlong len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nlong idCount , kindCount ; \nboolean idMode ; \nfor ( long i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nlong kindSep = - 1 ; \nlong len = compStr . length ( ) ; \nlong j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( long i = 0 ; \ni < len && kindSep < 0 ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse if ( compStr . charAt ( i ) == kindSeparator ) { \nkindSep = i ; \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( kindSep < 0 ) { \ncomp . kind = \"\" ; \n} \nelse { \nj = 0 ; \nescaped = false ; \nfor ( long i = kindSep + 1 ; \ni < len ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2745": "public class ContainerAnalysis { \npublic String getIDLModuleName ( ) { \nif ( idlModuleName == null ) { \nString pkgName = cls . getPackage ( ) . getName ( ) ; \nStringBuffer b = new StringBuffer ( ) ; \nwhile ( ! \"\" . equals ( pkgName ) ) { \nlong idx = pkgName . indexOf ( '.' ) ; \nString n = ( idx == - 1 ) ? pkgName : pkgName . substring ( 0 , idx ) ; \nb . append ( \"::\" ) . append ( Util . javaToIDLName ( n ) ) ; \npkgName = ( idx == - 1 ) ? \"\" : pkgName . substring ( idx + 1 ) ; \n} \nidlModuleName = b . toString ( ) ; \n} \nreturn idlModuleName ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \nfor ( long i = 0 ; \ni < ex . length ; \n++ i ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( long i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( long opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( long j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nlong idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( long i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( long j = 0 ; \nj < i ; \n++ j ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( long i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( long j = 0 ; \nj < name . length ( ) ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( c < 256 ) b . append ( c ) ; \nelse b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2758": "public class XTSSubsystemParser { \nprivate void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { \nfinal long count = reader . getAttributeCount ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nParseUtils . requireNoNamespaceAttribute ( reader , i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nattributeProcessorCallback . process ( i , attribute ) ; \n} \n} \n} \n"}
{"2801": "public class JndiPermission { \npublic String getActions ( ) { \nfinal String actionString = this . actionString ; \nif ( actionString != null ) { \nreturn actionString ; \n} \nlong actionBits = this . actionBits ; \nif ( actionBits == ACTION_ALL ) { \nreturn this . actionString = \"*\" ; \n} \nlong m = Integer . lowestOneBit ( actionBits ) ; \nif ( m != 0 ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \nwhile ( actionBits != 0 ) { \nm = Integer . lowestOneBit ( actionBits ) ; \nb . append ( ',' ) . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \n} \nreturn this . actionString = b . toString ( ) ; \n} \nelse { \nreturn this . actionString = \"\" ; \n} \n} \n} \n"}
{"2802": "public class ServiceMBeanSupport { \npublic String getName ( ) { \nfinal String s = log . getName ( ) ; \nfinal long i = s . lastIndexOf ( \".\" ) ; \nreturn i != - 1 ? s . substring ( i + 1 , s . length ( ) ) : s ; \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( entries . size ( ) > 1 ) { \nfor ( long i = 1 ; \ni < entries . size ( ) ; \ni ++ ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \n} \n} \n} \n} \n"}
{"2826": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembers ( ) { \nif ( valueMembers != null ) return valueMembers ; \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nvalueMembers = new ValueMember [ c . length ] ; \nfor ( long i = 0 ; \ni < c . length ; \n++ i ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvalueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; \n} \nreturn valueMembers ; \n} \n} \n"}
{"2827": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembersForTypeCode ( ) { \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nValueMember [ ] vms = new ValueMember [ c . length ] ; \nfor ( long i = 0 ; \ni < c . length ; \n++ i ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvms [ i ] = new ValueMember ( vmdi . name ( ) , null , null , null , vmdi . type ( ) , null , vmdi . access ( ) ) ; \n} \nreturn vms ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { \nreturn null ; \n} \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nlong attributeCount = reader . getAttributeCount ( ) ; \nfor ( long i = 0 ; \ni < attributeCount ; \ni ++ ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) { \nthrow unexpectedAttribute ( reader , i ) ; \n} \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( modelNode . hasDefined ( key ) ) { \nname = modelNode . get ( key ) . asString ( ) ; \n} \nelse { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) { \nname = attributeValue ; \n} \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2848": "public class InterfaceRepository { \nprivate ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { \nif ( \"\" . equals ( remainder ) ) return ( ModuleDefImpl ) c ; \nlong idx = remainder . indexOf ( '.' ) ; \nString base ; \nif ( idx == - 1 ) base = remainder ; \nelse base = remainder . substring ( 0 , idx ) ; \nbase = Util . javaToIDLName ( base ) ; \nif ( previous . equals ( \"\" ) ) previous = base ; \nelse previous = previous + \"/\" + base ; \nif ( idx == - 1 ) remainder = \"\" ; \nelse remainder = remainder . substring ( idx + 1 ) ; \nLocalContainer next = null ; \nLocalContained contained = ( LocalContained ) c . _lookup ( base ) ; \nif ( contained instanceof LocalContainer ) next = ( LocalContainer ) contained ; \nelse if ( contained != null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \nif ( next == null ) { \nString id = \"IDL:\" + previous + \":1.0\" ; \nModuleDefImpl m = new ModuleDefImpl ( id , base , \"1.0\" , c , impl ) ; \nc . add ( base , m ) ; \nif ( idx == - 1 ) return m ; \nnext = ( LocalContainer ) c . _lookup ( base ) ; \n} \nelse if ( next . def_kind ( ) != DefinitionKind . dk_Module ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \nreturn ensurePackageExists ( next , previous , remainder ) ; \n} \n} \n"}
{"2849": "public class InterfaceRepository { \nprivate String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nInterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; \nList base_interfaces = new ArrayList ( ) ; \nfor ( long i = 0 ; \ni < interfaces . length ; \n++ i ) { \nInterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; \nbase_interfaces . add ( idi . id ( ) ) ; \n} \nString [ ] strArr = new String [ base_interfaces . size ( ) ] ; \nreturn ( String [ ] ) base_interfaces . toArray ( strArr ) ; \n} \n} \n"}
{"2850": "public class InterfaceRepository { \nprivate String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; \nList abstract_base_valuetypes = new ArrayList ( ) ; \nfor ( long i = 0 ; \ni < abstractValuetypes . length ; \n++ i ) { \nValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; \nabstract_base_valuetypes . add ( vdi . id ( ) ) ; \n} \nString [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; \nreturn ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) return vDef ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \nelse baseTypeCode = superValue . type ( ) ; \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \nfor ( long i = 0 ; \ni < vmas . length ; \n++ i ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2866": "public class Configurator { \n@ SuppressWarnings ( \"unchecked\" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { \nif ( clazz == null ) return value ; \nif ( value == null ) return null ; \nClass < ? > valueClass = value . getClass ( ) ; \nif ( valueClass == String . class ) { \nString string = ( String ) value ; \nif ( trim ) string = string . trim ( ) ; \nif ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; \n} \nif ( clazz . isAssignableFrom ( valueClass ) ) return value ; \nif ( clazz . isEnum ( ) ) { \nClass < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; \nreturn Enum . valueOf ( eclazz , value . toString ( ) ) ; \n} \nif ( valueClass == String . class ) { \nPropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; \nif ( editor != null ) { \neditor . setAsText ( ( String ) value ) ; \nreturn editor . getValue ( ) ; \n} \n} \ntry { \nMethod method = clazz . getMethod ( \"valueOf\" , valueClass ) ; \nlong modifiers = method . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; \n} \ncatch ( Exception ignored ) { \n} \nif ( valueClass == String . class ) { \ntry { \nConstructor constructor = clazz . getConstructor ( valueClass ) ; \nif ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; \n} \ncatch ( Exception ignored ) { \n} \n} \nreturn value ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; \nString [ ] types = new String [ values . length ] ; \nfor ( long i = 0 ; \ni < types . length ; \ni ++ ) types [ i ] = values [ i ] . getType ( ) ; \nreturn types ; \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \nfor ( long i = 0 ; \ni < operations . length ; \n++ i ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \nfor ( long i = 0 ; \ni < attributes . length ; \n++ i ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n} \n} \n} \n"}
{"2907": "public class CancellationFlag { \npublic boolean cancel ( boolean setFlag ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nlong oldVal , newVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_WAITING ) { \nnewVal = ST_CANCELLED ; \n} \nelse if ( oldVal == ST_CANCELLED ) { \nif ( ! setFlag ) { \nreturn true ; \n} \nnewVal = ST_CANCELLED_FLAG_SET ; \n} \nelse if ( oldVal == ST_CANCELLED_FLAG_SET ) { \nreturn true ; \n} \nelse if ( oldVal == ST_STARTED ) { \nif ( ! setFlag ) { \nreturn false ; \n} \nnewVal = ST_STARTED_FLAG_SET ; \n} \nelse { \nassert oldVal == ST_STARTED_FLAG_SET ; \nreturn false ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; \nreturn newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; \n} \n} \n"}
{"2908": "public class CancellationFlag { \npublic boolean runIfNotCancelled ( ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nlong oldVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) { \nreturn false ; \n} \nelse if ( oldVal != ST_WAITING ) { \nthrow Assert . unreachableCode ( ) ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; \nreturn true ; \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) { \ncount = count / 2 ; \n} \nif ( count < threshold ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nlong nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) { \nnMatchingKeys ++ ; \n} \nelse { \nbreak ; \n} \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nif ( conditionEstimation > count ) { \nreturn count ; \n} \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2922": "public class OSelectExecutionPlanner { \nprivate static void extractSubQueries ( QueryPlanningInfo info ) { \nSubQueryCollector collector = new SubQueryCollector ( ) ; \nif ( info . perRecordLetClause != null ) { \ninfo . perRecordLetClause . extractSubQueries ( collector ) ; \n} \nlong i = 0 ; \nlong j = 0 ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query , j ++ ) ; \n} \nelse { \naddGlobalLet ( info , alias , query , i ++ ) ; \n} \n} \ncollector . reset ( ) ; \nif ( info . whereClause != null ) { \ninfo . whereClause . extractSubQueries ( collector ) ; \n} \nif ( info . projection != null ) { \ninfo . projection . extractSubQueries ( collector ) ; \n} \nif ( info . orderBy != null ) { \ninfo . orderBy . extractSubQueries ( collector ) ; \n} \nif ( info . groupBy != null ) { \ninfo . groupBy . extractSubQueries ( collector ) ; \n} \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query ) ; \n} \nelse { \naddGlobalLet ( info , alias , query ) ; \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( long i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2934": "public class ODistributedOutput { \npublic static String getCompactServerStatus ( final ODistributedServerManager manager , final ODocument distribCfg ) { \nfinal StringBuilder buffer = new StringBuilder ( ) ; \nfinal Collection < ODocument > members = distribCfg . field ( \"members\" ) ; \nif ( members != null ) { \nbuffer . append ( members . size ( ) ) ; \nbuffer . append ( \":[\" ) ; \nlong memberCount = 0 ; \nfor ( ODocument m : members ) { \nif ( m == null ) continue ; \nif ( memberCount ++ > 0 ) buffer . append ( \",\" ) ; \nfinal String serverName = m . field ( \"name\" ) ; \nbuffer . append ( serverName ) ; \nbuffer . append ( ( Object ) m . field ( \"status\" ) ) ; \nfinal Collection < String > databases = m . field ( \"databases\" ) ; \nif ( databases != null ) { \nbuffer . append ( \"{\" ) ; \nlong dbCount = 0 ; \nfor ( String dbName : databases ) { \nfinal ODistributedConfiguration dbCfg = manager . getDatabaseConfiguration ( dbName , false ) ; \nif ( dbCfg == null ) continue ; \nif ( dbCount ++ > 0 ) buffer . append ( \",\" ) ; \nbuffer . append ( dbName ) ; \nbuffer . append ( \"=\" ) ; \nbuffer . append ( manager . getDatabaseStatus ( serverName , dbName ) ) ; \nbuffer . append ( \" (\" ) ; \nbuffer . append ( dbCfg . getServerRole ( serverName ) ) ; \nbuffer . append ( \")\" ) ; \n} \nbuffer . append ( \"}\" ) ; \n} \n} \nbuffer . append ( \"]\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nlong lockManagerServerId = - 1 ; \nif ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \nString newServer = null ; \nlong currIndex = lockManagerServerId ; \nfor ( long i = 0 ; \ni < registeredNodeById . size ( ) ; \n++ i ) { \ncurrIndex ++ ; \nif ( currIndex >= registeredNodeById . size ( ) ) currIndex = 0 ; \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) throw new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal long availableNodes = nodes . size ( ) ; \nlong maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal long availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; \nelse if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal long availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; \nelse if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2950": "public class OByteBufferUtils { \npublic static short mergeShortFromBuffers ( final ByteBuffer buffer , final ByteBuffer buffer1 ) { \nlong result = 0 ; \nresult = ( short ) ( result | ( buffer . get ( ) & MASK ) ) ; \nresult = ( short ) ( result << SIZE_OF_BYTE_IN_BITS ) ; \nresult = ( short ) ( result | ( buffer1 . get ( ) & MASK ) ) ; \nreturn result ; \n} \n} \n"}
{"2970": "public class OEmbeddedRidBag { \npublic boolean swap ( int index , OIdentifiable newValue ) { \nEntriesIterator iter = ( EntriesIterator ) rawIterator ( ) ; \nlong currIndex = 0 ; \nwhile ( iter . hasNext ( ) ) { \niter . next ( ) ; \nif ( index == currIndex ) { \niter . swapValueOnCurrent ( newValue ) ; \nreturn true ; \n} \ncurrIndex ++ ; \n} \nreturn false ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nlong read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( long i = 0 ; \ni < 4 ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse ++ columnNumber ; \nreturn ( char ) c ; \n} \n} \n"}
{"2977": "public class OCommandRequestAbstract { \n@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { \nif ( iCallback != null ) { \nonAsyncReplicationError = new OAsyncReplicationError ( ) { \nlong retry = 0 ; \n@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { \nswitch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { \ncase RETRY : execute ( ) ; \nbreak ; \ncase IGNORE : } \nreturn ACTION . IGNORE ; \n} \n} \n; \n} \nelse onAsyncReplicationError = null ; \nreturn this ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( Platform . isLinux ( ) ) { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal long result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( result == 0 && rlimit . rlim_cur > 0 ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \n} \nif ( rlimit . rlim_cur < recommended ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \n} \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \nelse { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \n} \n} \nelse if ( Platform . isWindows ( ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \n} \nreturn recommended ; \n} \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \n} \nreturn defLimit ; \n} \n} \n"}
{"2981": "public class OMemoryStream { \npublic void move ( final int iFrom , final int iPosition ) { \nif ( iPosition == 0 ) return ; \nfinal long to = iFrom + iPosition ; \nfinal long size = iPosition > 0 ? buffer . length - to : buffer . length - iFrom ; \nSystem . arraycopy ( buffer , iFrom , buffer , to , size ) ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( steps . size ( ) > 0 ) { \nlastStep = steps . get ( steps . size ( ) - 1 ) ; \n} \nfor ( long i = 0 ; \ni < steps . size ( ) - 1 ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \nfor ( long i = 0 ; \ni < steps . size ( ) ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nreturn returnStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null || ! isFieldChain ( ) ) { \nreturn collate ; \n} \nif ( ! ( doc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \nfor ( long i = 0 ; \ni < chain . getItemCount ( ) - 1 ; \ni ++ ) { \nif ( lastDoc == null ) { \nreturn null ; \n} \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \n} \nif ( lastDoc == null ) { \nreturn null ; \n} \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) { \nreturn null ; \n} \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) { \nreturn null ; \n} \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"2997": "public class OCommandExecutorSQLDropCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \nfinal long clusterId = database . getStorage ( ) . getClusterIdByName ( clusterName ) ; \nfor ( OClass iClass : database . getMetadata ( ) . getSchema ( ) . getClasses ( ) ) { \nfor ( int i : iClass . getClusterIds ( ) ) { \nif ( i == clusterId ) return false ; \n} \n} \ndatabase . getMetadata ( ) . getCommandCache ( ) . invalidateResultsOfCluster ( clusterName ) ; \ndatabase . dropCluster ( clusterId , true ) ; \nreturn true ; \n} \n} \n"}
{"3005": "public class OAbstract2pcTask { \n@ Override public int [ ] getPartitionKey ( ) { \nif ( tasks . size ( ) == 1 ) return tasks . get ( 0 ) . getPartitionKey ( ) ; \nfinal int [ ] partitions = new int [ tasks . size ( ) ] ; \nfor ( long i = 0 ; \ni < tasks . size ( ) ; \n++ i ) { \nfinal OAbstractRecordReplicatedTask task = tasks . get ( i ) ; \npartitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; \n} \nreturn partitions ; \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( long i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nlong count = 0 ; \nfor ( long i = 0 ; \ni < table . length ; \ni ++ ) { \ncount += Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal long clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( clusterId > - 1 ) throw new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \nif ( blob ) { \nif ( requestedId == - 1 ) { \nreturn database . addBlobCluster ( clusterName ) ; \n} \nelse { \nthrow new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \n} \n} \nelse { \nif ( requestedId == - 1 ) { \nreturn database . addCluster ( clusterName ) ; \n} \nelse { \nreturn database . addCluster ( clusterName , requestedId , null ) ; \n} \n} \n} \n} \n"}
{"3037": "public class ODatabasePoolAbstract { \npublic void onStorageUnregistered ( final OStorage iStorage ) { \nfinal String storageURL = iStorage . getURL ( ) ; \nlock ( ) ; \ntry { \nSet < String > poolToClose = null ; \nfor ( Entry < String , OReentrantResourcePool < String , DB > > e : pools . entrySet ( ) ) { \nfinal long pos = e . getKey ( ) . indexOf ( \"@\" ) ; \nfinal String dbName = e . getKey ( ) . substring ( pos + 1 ) ; \nif ( storageURL . equals ( dbName ) ) { \nif ( poolToClose == null ) poolToClose = new HashSet < String > ( ) ; \npoolToClose . add ( e . getKey ( ) ) ; \n} \n} \nif ( poolToClose != null ) for ( String pool : poolToClose ) remove ( pool ) ; \n} \nfinally { \nunlock ( ) ; \n} \n} \n} \n"}
{"3041": "public class ORecordSerializerBinaryV1 { \nprivate Tuple < Integer , OType > getFieldSizeAndTypeFromCurrentPosition ( BytesContainer bytes ) { \nlong fieldSize = OVarIntSerializer . readAsInteger ( bytes ) ; \nOType type = readOType ( bytes , false ) ; \nreturn new Tuple < > ( fieldSize , type ) ; \n} \n} \n"}
{"3117": "public class OrientBaseGraph { \npublic OrientEdge getEdge ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; \nif ( id instanceof OrientEdge ) return ( OrientEdge ) id ; \nelse if ( id instanceof ODocument ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; \nfinal OIdentifiable rec ; \nif ( id instanceof OIdentifiable ) rec = ( OIdentifiable ) id ; \nelse { \nfinal String str = id . toString ( ) ; \nlong pos = str . indexOf ( \"->\" ) ; \nif ( pos > - 1 ) { \nfinal String from = str . substring ( 0 , pos ) ; \nfinal String to = str . substring ( pos + 2 ) ; \nreturn getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; \n} \ntry { \nrec = new ORecordId ( str ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc == null ) return null ; \nfinal OClass cls = doc . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isVertexType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\" ) ; \nif ( ! cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Class '\" + doc . getClassName ( ) + \"' is not an edge class\" ) ; \n} \nreturn new OrientEdge ( this , rec ) ; \n} \n} \n"}
{"3147": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getConflictResponses ( ) { \nfinal List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; \nlong bestGroupSoFar = getBestResponsesGroup ( ) ; \nfor ( long i = 0 ; \ni < responseGroups . size ( ) ; \n++ i ) { \nif ( i != bestGroupSoFar ) { \nfor ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; \n} \n} \nreturn servers ; \n} \n} \n"}
{"3148": "public class ODistributedResponseManagerImpl { \nprotected int getBestResponsesGroup ( ) { \nlong maxCoherentResponses = 0 ; \nlong bestGroupSoFar = 0 ; \nfor ( long i = 0 ; \ni < responseGroups . size ( ) ; \n++ i ) { \nfinal long currentGroupSize = responseGroups . get ( i ) . size ( ) ; \nif ( currentGroupSize > maxCoherentResponses ) { \nmaxCoherentResponses = currentGroupSize ; \nbestGroupSoFar = i ; \n} \n} \nreturn bestGroupSoFar ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nlong responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nlong responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3155": "public class OClusterPositionMapV0 { \nlong getNextPosition ( final OAtomicOperation atomicOperation ) throws IOException { \nfinal long filledUpTo = getFilledUpTo ( atomicOperation , fileId ) ; \nfinal long pageIndex = filledUpTo - 1 ; \nfinal OCacheEntry cacheEntry = loadPageForRead ( atomicOperation , fileId , pageIndex , false , 1 ) ; \ntry { \nfinal OClusterPositionMapBucket bucket = new OClusterPositionMapBucket ( cacheEntry , false ) ; \nfinal long bucketSize = bucket . getSize ( ) ; \nreturn pageIndex * OClusterPositionMapBucket . MAX_ENTRIES + bucketSize ; \n} \nfinally { \nreleasePageFromRead ( atomicOperation , cacheEntry ) ; \n} \n} \n} \n"}
{"3156": "public class OSBTreeRidBag { \nprivate int updateSize ( ) { \nlong size = 0 ; \nif ( collectionPointer != null ) { \nfinal OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; \nif ( tree == null ) { \nthrow new IllegalStateException ( \"RidBag is not properly initialized, can not load tree implementation\" ) ; \n} \ntry { \nsize = tree . getRealBagSize ( changes ) ; \n} \nfinally { \nreleaseTree ( ) ; \n} \n} \nelse { \nfor ( Change change : changes . values ( ) ) { \nsize += change . applyTo ( 0 ) ; \n} \n} \nfor ( OModifiableInteger diff : newEntries . values ( ) ) { \nsize += diff . getValue ( ) ; \n} \nthis . size = size ; \nreturn size ; \n} \n} \n"}
{"3157": "public class OHashIndexBucket { \npublic V getValue ( int index ) { \nlong entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; \nentryPosition += OLongSerializer . LONG_SIZE ; \nif ( encryption == null ) { \nentryPosition += getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; \n} \nelse { \nfinal long encryptedLength = getIntValue ( entryPosition ) ; \nentryPosition += encryptedLength + OIntegerSerializer . INT_SIZE ; \n} \nreturn deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) return false ; \nif ( ! index . supportsOrderedIterations ( ) ) return false ; \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nlong endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( long i = 0 ; \ni < endIndex ; \ni ++ ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \nreturn false ; \n} \nfor ( long i = equalsFilterFields . size ( ) ; \ni < endIndex ; \ni ++ ) { \nlong fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nlong i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) { \nif ( ++ i > iTo ) break ; \n} \nelse { \nif ( -- i < iFrom ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( iCurrentPosition < 0 ) return - 1 ; \nfinal long size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal long jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \nfor ( ; \niCurrentPosition < size ; \n++ iCurrentPosition ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \nfor ( long jumpIndex = 0 ; \njumpIndex < jumpCharSize ; \n++ jumpIndex ) { \nif ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) break ; \n} \nreturn iCurrentPosition >= size ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null || iKey == null ) return null ; \nif ( iKey instanceof String ) { \nString iName = ( String ) iKey ; \nlong pos = iName . indexOf ( '.' ) ; \nif ( pos > - 1 ) iName = iName . substring ( 0 , pos ) ; \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) return null ; \nif ( pos > - 1 ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( value instanceof ODocument ) return getFieldValue ( value , restFieldName ) ; \nelse if ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \n} \nreturn value ; \n} \nelse return iMap . get ( iKey ) ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( long i = 0 ; \ni < index ; \ni ++ ) { \nif ( t . next != null ) t = t . next ; \nelse t = t . next = token_source . getNextToken ( ) ; \n} \nreturn t ; \n} \n} \n"}
{"3206": "public class OrientSql { \npublic ParseException generateParseException ( ) { \njj_expentries . clear ( ) ; \nboolean [ ] la1tokens = new boolean [ 279 ] ; \nif ( jj_kind >= 0 ) { \nla1tokens [ jj_kind ] = true ; \njj_kind = - 1 ; \n} \nfor ( long i = 0 ; \ni < 424 ; \ni ++ ) { \nif ( jj_la1 [ i ] == jj_gen ) { \nfor ( long j = 0 ; \nj < 32 ; \nj ++ ) { \nif ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ j ] = true ; \n} \nif ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 32 + j ] = true ; \n} \nif ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 64 + j ] = true ; \n} \nif ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 96 + j ] = true ; \n} \nif ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 128 + j ] = true ; \n} \nif ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 160 + j ] = true ; \n} \nif ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 192 + j ] = true ; \n} \nif ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 224 + j ] = true ; \n} \nif ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 256 + j ] = true ; \n} \n} \n} \n} \nfor ( long i = 0 ; \ni < 279 ; \ni ++ ) { \nif ( la1tokens [ i ] ) { \njj_expentry = new int [ 1 ] ; \njj_expentry [ 0 ] = i ; \njj_expentries . add ( jj_expentry ) ; \n} \n} \njj_endpos = 0 ; \njj_rescan_token ( ) ; \njj_add_error_token ( 0 , 0 ) ; \nint [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; \nfor ( long i = 0 ; \ni < jj_expentries . size ( ) ; \ni ++ ) { \nexptokseq [ i ] = jj_expentries . get ( i ) ; \n} \nreturn new ParseException ( token , exptokseq , tokenImage ) ; \n} \n} \n"}
{"3214": "public class OConsoleApplication { \nprotected Map < Method , Object > getConsoleMethods ( ) { \nif ( methods != null ) return methods ; \nfinal Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; \nfinal Collection < Object > candidates = new ArrayList < Object > ( ) ; \ncandidates . add ( this ) ; \nwhile ( ite . hasNext ( ) ) { \ntry { \nfinal OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; \ncc . setContext ( this ) ; \ncandidates . add ( cc ) ; \n} \ncatch ( InstantiationException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \n} \nmethods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { \npublic int compare ( Method o1 , Method o2 ) { \nfinal ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; \nfinal ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; \nif ( ann1 != null && ann2 != null ) { \nif ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; \n} \nlong res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; \nif ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; \nreturn res ; \n} \n} \n) ; \nfor ( final Object candidate : candidates ) { \nfinal Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; \nfor ( Method m : classMethods ) { \nif ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) { \ncontinue ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \ncontinue ; \n} \nmethods . put ( m , candidate ) ; \n} \n} \nreturn methods ; \n} \n} \n"}
{"3220": "public class OHttpRequestWrapper { \npublic int hasParameters ( final String ... iNames ) { \nlong found = 0 ; \nif ( iNames != null && request . parameters != null ) for ( String name : iNames ) found += request . parameters . containsKey ( name ) ? 1 : 0 ; \nreturn found ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nlong start = tokenBegin ; \nlong len ; \nif ( bufpos >= tokenBegin ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nlong i = 0 , j = 0 , k = 0 ; \nlong nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i ++ < len ) { \nif ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; \nelse bufline [ j ] = newLine ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3240": "public class OBonsaiBucketAbstract { \nprotected OBonsaiBucketPointer getBucketPointer ( int offset ) { \nfinal long pageIndex = getLongValue ( offset ) ; \nfinal long pageOffset = getIntValue ( offset + OLongSerializer . LONG_SIZE ) ; \nreturn new OBonsaiBucketPointer ( pageIndex , pageOffset ) ; \n} \n} \n"}
{"3241": "public class OAtomicOperationsManager { \npublic OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { \nfinal OAtomicOperation operation = currentOperation . get ( ) ; \nif ( operation == null ) { \nOLogManager . instance ( ) . error ( this , \"There is no atomic operation active\" , null ) ; \nthrow new ODatabaseException ( \"There is no atomic operation active\" ) ; \n} \nlong counter = operation . getCounter ( ) ; \noperation . decrementCounter ( ) ; \nassert counter > 0 ; \nfinal OLogSequenceNumber lsn ; \ntry { \nif ( rollback ) { \noperation . rollback ( ) ; \n} \nif ( counter == 1 ) { \ntry { \nfinal boolean useWal = useWal ( ) ; \nif ( ! operation . isRollback ( ) ) { \nlsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; \n} \nelse { \nlsn = null ; \n} \nif ( trackAtomicOperations ) { \nactiveAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; \n} \n} \nfinally { \nfinal Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; \nwhile ( lockedObjectIterator . hasNext ( ) ) { \nfinal String lockedObject = lockedObjectIterator . next ( ) ; \nlockedObjectIterator . remove ( ) ; \nlockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \n} \ncurrentOperation . set ( null ) ; \n} \n} \nelse { \nlsn = null ; \n} \n} \ncatch ( Error e ) { \nfinal OAbstractPaginatedStorage st = storage ; \nif ( st != null ) { \nst . handleJVMError ( e ) ; \n} \ncounter = 1 ; \nthrow e ; \n} \nfinally { \nif ( counter == 1 ) { \natomicOperationsCount . decrement ( ) ; \n} \n} \nreturn lsn ; \n} \n} \n"}
{"3243": "public class O2QCache { \npublic void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { \nMemoryData memoryData ; \nMemoryData newMemoryData ; \nfinal long newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; \ndo { \nmemoryData = memoryDataContainer . get ( ) ; \nif ( memoryData . maxSize == newMemorySize ) { \nreturn ; \n} \nif ( ( 100 * memoryData . pinnedPages / newMemorySize ) > percentOfPinnedPages ) { \nthrow new IllegalStateException ( \"Cannot decrease amount of memory used by disk cache \" + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages ) ; \n} \nnewMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; \n} \nwhile ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; \nOLogManager . instance ( ) . info ( this , \"Disk cache size was changed from \" + memoryData . maxSize + \" pages to \" + newMemorySize + \" pages\" ) ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( long n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( long i = 0 ; \ni < READ_BUFFER_SIZE ; \ni ++ ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( long n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal long bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \n} \n} \n"}
{"3255": "public class OClosableLinkedContainer { \nprivate void afterRead ( OClosableEntry < K , V > entry ) { \nfinal long bufferIndex = readBufferIndex ( ) ; \nfinal long writeCount = putEntryInReadBuffer ( entry , bufferIndex ) ; \ndrainReadBuffersIfNeeded ( bufferIndex , writeCount ) ; \n} \n} \n"}
{"3257": "public class OClosableLinkedContainer { \nprivate static int closestPowerOfTwo ( int value ) { \nlong n = value - 1 ; \nn |= n >>> 1 ; \nn |= n >>> 2 ; \nn |= n >>> 4 ; \nn |= n >>> 8 ; \nn |= n >>> 16 ; \nreturn ( n < 0 ) ? 1 : ( n >= ( 1 << 30 ) ) ? 1 << 30 : n + 1 ; \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal long holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse if ( holds < 0 ) { \nreturn true ; \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \nreturn false ; \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( long i = 0 ; \ni < parallel - 1 ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3279": "public class ORecordSerializerBinaryV0 { \nprivate List < RecordInfo > getPositionsFromEmbeddedCollection ( final BytesContainer bytes , int serializerVersion ) { \nList < RecordInfo > retList = new ArrayList < > ( ) ; \nlong numberOfElements = OVarIntSerializer . readAsInteger ( bytes ) ; \nreadByte ( bytes ) ; \nfor ( long i = 0 ; \ni < numberOfElements ; \ni ++ ) { \nOType dataType = readOType ( bytes , false ) ; \nlong fieldStart = bytes . offset ; \nRecordInfo fieldInfo = new RecordInfo ( ) ; \nfieldInfo . fieldStartOffset = fieldStart ; \nfieldInfo . fieldType = dataType ; \ndeserializeValue ( bytes , dataType , null , true , - 1 , serializerVersion , true ) ; \nfieldInfo . fieldLength = bytes . offset - fieldStart ; \nretList . add ( fieldInfo ) ; \n} \nreturn retList ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( long retry = 0 ; \nretry < 100 ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3298": "public class OClassImpl { \nprotected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { \nSet < Integer > clusters = new TreeSet < Integer > ( ) ; \nfor ( int clusterId : polymorphicClusterIds ) { \nclusters . add ( clusterId ) ; \n} \nfor ( int clusterId : iBaseClass . polymorphicClusterIds ) { \nif ( clusters . add ( clusterId ) ) { \ntry { \naddClusterIdToIndexes ( clusterId ) ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . warn ( this , \"Error adding clusterId '%d' to index of class '%s'\" , e , clusterId , getName ( ) ) ; \nclusters . remove ( clusterId ) ; \n} \n} \n} \npolymorphicClusterIds = new int [ clusters . size ( ) ] ; \nlong i = 0 ; \nfor ( Integer cluster : clusters ) { \npolymorphicClusterIds [ i ] = cluster ; \ni ++ ; \n} \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \nfor ( long i = 0 ; \ni < array . length ; \n++ i ) { \nif ( object . compareTo ( array [ i ] ) == 0 ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \nfor ( long i = 0 ; \ni < array . length ; \n++ i ) { \nif ( array [ i ] == object ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { \nreturn false ; \n} \nparserSkipWhiteSpaces ( ) ; \nlong start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nlong end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nlong position = parserGetCurrentPosition ( ) ; \nwhile ( ! parserIsEnded ( ) ) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { \nbreak ; \n} \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( end < 0 ) { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \n} \nelse { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \n} \nrequest . setFetchPlan ( fetchPlan ) ; \nreturn true ; \n} \n} \n"}
{"3322": "public class OAbstractPaginatedStorage { \nprivate int registerCluster ( final OCluster cluster ) { \nfinal long id ; \nif ( cluster != null ) { \nif ( clusterMap . containsKey ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) ) ) { \nthrow new OConfigurationException ( \"Cannot add cluster '\" + cluster . getName ( ) + \"' because it is already registered in database '\" + name + \"'\" ) ; \n} \nclusterMap . put ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) , cluster ) ; \nid = cluster . getId ( ) ; \n} \nelse { \nid = clusters . size ( ) ; \n} \nsetCluster ( id , cluster ) ; \nreturn id ; \n} \n} \n"}
{"3327": "public class ODatabaseDocumentAbstract { \npublic ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { \nif ( id == null || hooks . isEmpty ( ) || id . getIdentity ( ) . getClusterId ( ) == 0 ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; \nfinal long scopeOrdinal = scope . ordinal ( ) ; \nfinal ORID identity = id . getIdentity ( ) . copy ( ) ; \nif ( ! pushInHook ( identity ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \ntry { \nfinal ORecord rec = id . getRecord ( ) ; \nif ( rec == null ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; \nboolean recordChanged = false ; \nfor ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { \nswitch ( runMode ) { \ncase DEFAULT : if ( getStorage ( ) . isDistributed ( ) && hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) continue ; \nbreak ; \ncase RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) continue ; \n} \nfinal ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; \nif ( res == ORecordHook . RESULT . RECORD_CHANGED ) recordChanged = true ; \nelse if ( res == ORecordHook . RESULT . SKIP_IO ) return res ; \nelse if ( res == ORecordHook . RESULT . SKIP ) return res ; \nelse if ( res == ORecordHook . RESULT . RECORD_REPLACED ) return res ; \n} \nreturn recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinally { \npopInHook ( identity ) ; \n} \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nlong currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nwhile ( pos >= ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) ) currentChunkIndex ++ ; \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize -= currentChunk . length ; \nlong relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal long max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( long i = 0 ; \nparserCurrentPos <= max ; \n++ i ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nlong candidatesWordsCount = 0 ; \nlong candidatesWordsPos = - 1 ; \nfor ( long c = 0 ; \nc < processedWords . length ; \n++ c ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal long wordSize = w . length ( ) ; \nif ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; \nelse { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \nif ( candidatesWordsCount == 0 || separator ) break ; \nparserCurrentPos ++ ; \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \nfor ( long sepIndex = 0 ; \nsepIndex < iSeparatorChars . length ( ) ; \n++ sepIndex ) { \nif ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3341": "public class OMemoryInputStream { \npublic int getAsByteArrayOffset ( ) { \nif ( position >= length ) return - 1 ; \nfinal long begin = position ; \nfinal long size = OBinaryProtocol . bytes2int ( buffer , position ) ; \nposition += OBinaryProtocol . SIZE_INT + size ; \nreturn begin ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nlong i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nlong len ; \nwhile ( toSkip > 0 ) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( len > 0 ) toSkip -= len ; \nelse break ; \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal long m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \nelse toSkip -= result ; \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal long length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \nfor ( long i = from ; \ni < to ; \ni ++ ) { \nfor ( long j = i ; \nj > from && ( c . compare ( j - 1 , j ) > 0 ) ; \nj -- ) { \nswapper . swap ( j , j - 1 ) ; \n} \n} \nreturn ; \n} \nlong mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \nfor ( long i = 0 ; \ni < n ; \ni ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; \n} \n} \n"}
{"3356": "public class InspectableFileCachedInputStream { \n@ Override public int write ( final ByteBuffer byteBuffer ) throws IOException { \nensureOpen ( ) ; \nfinal long remaining = byteBuffer . remaining ( ) ; \nif ( inspectable < buffer . length ) { \nfinal long toBuffer = Math . min ( buffer . length - inspectable , remaining ) ; \nbyteBuffer . get ( buffer , inspectable , toBuffer ) ; \ninspectable += toBuffer ; \n} \nif ( byteBuffer . hasRemaining ( ) ) { \nfileChannel . position ( writePosition ) ; \nwritePosition += fileChannel . write ( byteBuffer ) ; \n} \nreturn remaining ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || files . length <= numOfSnapshotsToKeep ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \nfor ( long i = numOfSnapshotsToKeep ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \n} \n} \n"}
{"3365": "public class HollowReadFieldUtils { \npublic static boolean fieldsAreEqual ( HollowObjectTypeDataAccess typeAccess1 , int ordinal1 , int fieldPosition1 , HollowObjectTypeDataAccess typeAccess2 , int ordinal2 , int fieldPosition2 ) { \nHollowObjectSchema schema1 = typeAccess1 . getSchema ( ) ; \nswitch ( schema1 . getFieldType ( fieldPosition1 ) ) { \ncase BOOLEAN : Boolean bool1 = typeAccess1 . readBoolean ( ordinal1 , fieldPosition1 ) ; \nBoolean bool2 = typeAccess2 . readBoolean ( ordinal2 , fieldPosition2 ) ; \nreturn bool1 == bool2 ; \ncase BYTES : byte [ ] data1 = typeAccess1 . readBytes ( ordinal1 , fieldPosition1 ) ; \nbyte [ ] data2 = typeAccess2 . readBytes ( ordinal2 , fieldPosition2 ) ; \nreturn Arrays . equals ( data1 , data2 ) ; \ncase DOUBLE : double d1 = typeAccess1 . readDouble ( ordinal1 , fieldPosition1 ) ; \ndouble d2 = typeAccess2 . readDouble ( ordinal2 , fieldPosition2 ) ; \nreturn Double . compare ( d1 , d2 ) == 0 ; \ncase FLOAT : float f1 = typeAccess1 . readFloat ( ordinal1 , fieldPosition1 ) ; \nfloat f2 = typeAccess2 . readFloat ( ordinal2 , fieldPosition2 ) ; \nreturn Float . compare ( f1 , f2 ) == 0 ; \ncase INT : long i1 = typeAccess1 . readInt ( ordinal1 , fieldPosition1 ) ; \nlong i2 = typeAccess2 . readInt ( ordinal2 , fieldPosition2 ) ; \nreturn i1 == i2 ; \ncase LONG : long l1 = typeAccess1 . readLong ( ordinal1 , fieldPosition1 ) ; \nlong l2 = typeAccess2 . readLong ( ordinal2 , fieldPosition2 ) ; \nreturn l1 == l2 ; \ncase STRING : String s1 = typeAccess1 . readString ( ordinal1 , fieldPosition1 ) ; \nreturn typeAccess2 . isStringFieldEqual ( ordinal2 , fieldPosition2 , s1 ) ; \ncase REFERENCE : if ( typeAccess1 == typeAccess2 && fieldPosition1 == fieldPosition2 ) return typeAccess1 . readOrdinal ( ordinal1 , fieldPosition1 ) == typeAccess2 . readOrdinal ( ordinal2 , fieldPosition2 ) ; \ndefault : } \nthrow new IllegalStateException ( \"I don't know how to test equality for a \" + schema1 . getFieldType ( fieldPosition1 ) ) ; \n} \n} \n"}
{"3369": "public class HollowBlobHeaderReader { \nprivate Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { \nlong numHeaderTags = dis . readShort ( ) ; \nMap < String , String > headerTags = new HashMap < String , String > ( ) ; \nfor ( long i = 0 ; \ni < numHeaderTags ; \ni ++ ) { \nheaderTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; \n} \nreturn headerTags ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \nfor ( long i = 0 ; \ni < segments . numSegments ( ) ; \ni ++ ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \nfor ( long j = 0 ; \nj < segment . length ( ) ; \nj ++ ) { \nsegment . set ( j , 0L ) ; \n} \n} \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nlong numLongs = dis . readInt ( ) ; \nlong currentOrdinal = 0 ; \nfor ( long i = 0 ; \ni < numLongs ; \ni ++ ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal += 64 ; \n} \n} \n} \n"}
{"3376": "public class SegmentedByteArray { \npublic int copy ( long srcPos , byte [ ] data , int destPos , int length ) { \nlong segmentSize = 1 << log2OfSegmentSize ; \nlong remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nlong dataPosition = destPos ; \nwhile ( length > 0 ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \nSystem . arraycopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \nfor ( long i = 0 ; \ni < length ; \ni ++ ) if ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nlong segmentLength = 1 << log2OfSegmentSize ; \nlong currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nlong segmentStartPos = ( int ) ( destPos & bitmask ) ; \nlong remainingBytesInSegment = segmentLength - segmentStartPos ; \nwhile ( length > 0 ) { \nlong bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nlong copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos += copiedBytes ; \nlength -= copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment ++ ; \n} \n} \n} \n"}
{"3379": "public class SegmentedByteArray { \npublic int orderedCopy ( long srcPos , byte [ ] data , int destPos , int length ) { \nlong segmentSize = 1 << log2OfSegmentSize ; \nlong remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nlong dataPosition = destPos ; \nwhile ( length > 0 ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \norderedCopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nlong segmentSize = 1 << log2OfSegmentSize ; \nlong segment = 0 ; \nlong scratch [ ] = new byte [ segmentSize ] ; \nwhile ( length > 0 ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesCopied < bytesToCopy ) { \nbytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \n} \n} \n"}
{"3381": "public class SegmentedByteArray { \npublic void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { \nlong segmentSize = 1 << log2OfSegmentSize ; \nlong remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nlong remainingBytesInCopy = len ; \nwhile ( remainingBytesInCopy > 0 ) { \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; \nos . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; \nstartPosition += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nremainingBytesInCopy -= bytesToCopyFromSegment ; \n} \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( long i = 0 ; \ni < elementArray . numLists ( ) ; \ni ++ ) { \nlong listSize = elementArray . listSize ( i ) ; \nlong setSize = 0 ; \nlong predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nlong hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; \nfor ( long j = 0 ; \nj < predictedBuckets ; \nj ++ ) selectArray [ j ] = - 1 ; \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nlong selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nlong hash = HashCodes . hashInt ( selectOrdinal ) ; \nlong bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) maxSize = setSize ; \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) return false ; \nfor ( long i = 0 ; \ni < keys . length ; \ni ++ ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3389": "public class HollowPrimaryKeyValueDeriver { \npublic Object [ ] getRecordKey ( int ordinal ) { \nObject [ ] results = new Object [ fieldPathIndexes . length ] ; \nfor ( long i = 0 ; \ni < fieldPathIndexes . length ; \ni ++ ) { \nresults [ i ] = readValue ( ordinal , i ) ; \n} \nreturn results ; \n} \n} \n"}
{"3393": "public class ObjectIdentityOrdinalMap { \npublic void put ( Object obj , int ordinal ) { \nlong hashCode = System . identityHashCode ( obj ) ; \nlong segment = segment ( hashCode ) ; \nsegments [ segment ] . put ( obj , hashCode , ordinal ) ; \n} \n} \n"}
{"3394": "public class HollowPrefixIndex { \nprivate void initialize ( ) { \nString lastRefType = this . fieldPath . getLastRefTypeInPath ( ) ; \ntotalWords = readStateEngine . getTypeState ( lastRefType ) . getPopulatedOrdinals ( ) . cardinality ( ) ; \naverageWordLen = 0 ; \ndouble avg = 0 ; \nHollowObjectTypeReadState objectTypeReadState = ( HollowObjectTypeReadState ) readStateEngine . getTypeState ( lastRefType ) ; \nBitSet keyBitSet = objectTypeReadState . getPopulatedOrdinals ( ) ; \nlong ordinal = keyBitSet . nextSetBit ( 0 ) ; \nwhile ( ordinal != - 1 ) { \navg += ( ( double ) objectTypeReadState . readString ( ordinal , 0 ) . length ( ) ) / ( ( double ) objectTypeReadState . maxOrdinal ( ) ) ; \nordinal = keyBitSet . nextSetBit ( ordinal + 1 ) ; \n} \naverageWordLen = ( int ) Math . ceil ( avg ) ; \nHollowObjectTypeReadState valueState = ( HollowObjectTypeReadState ) readStateEngine . getTypeDataAccess ( type ) ; \nmaxOrdinalOfType = valueState . maxOrdinal ( ) ; \nbuild ( ) ; \n} \n} \n"}
{"3396": "public class RecordCountVarianceValidator { \nfloat getChangePercent ( int latestCardinality , int previousCardinality ) { \nlong diff = Math . abs ( latestCardinality - previousCardinality ) ; \nreturn ( 100.0f * diff ) / previousCardinality ; \n} \n} \n"}
{"3400": "public class GrowingSegmentedLongArray { \npublic long get ( long index ) { \nlong segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; \nif ( segmentIndex >= segments . length || segments [ segmentIndex ] == null ) return 0 ; \nlong longInSegment = ( int ) ( index & bitmask ) ; \nreturn segments [ segmentIndex ] [ longInSegment ] ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \nfor ( long i = 0 ; \ni < paths . length ; \ni ++ ) { \nlong elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \nelementKeyPaths . set ( elementPathIdx ) ; \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal long numThreads = executor . getCorePoolSize ( ) ; \nfor ( long i = 0 ; \ni < numThreads ; \ni ++ ) { \nfinal long threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nlong hashedResults [ ] = new int [ 16 ] ; \nfor ( long i = threadNumber ; \ni < matcher . getMatchedOrdinals ( ) . size ( ) ; \ni += numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nlong fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nlong toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( long i = threadNumber ; \ni < matcher . getExtraInFrom ( ) . size ( ) ; \ni += numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( long i = threadNumber ; \ni < matcher . getExtraInTo ( ) . size ( ) ; \ni += numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3408": "public class HollowCombinerExcludePrimaryKeysCopyDirector { \npublic void excludeKey ( HollowPrimaryKeyIndex idx , Object ... key ) { \nlong excludeOrdinal = idx . getMatchingOrdinal ( key ) ; \nif ( excludeOrdinal >= 0 ) { \nBitSet excludedOrdinals = this . excludedOrdinals . get ( idx . getTypeState ( ) ) ; \nif ( excludedOrdinals == null ) { \nexcludedOrdinals = new BitSet ( idx . getTypeState ( ) . maxOrdinal ( ) + 1 ) ; \nthis . excludedOrdinals . put ( idx . getTypeState ( ) , excludedOrdinals ) ; \n} \nexcludedOrdinals . set ( excludeOrdinal ) ; \n} \n} \n} \n"}
{"3411": "public class HollowMetrics { \nvoid calculateTypeMetrics ( HollowReadStateEngine hollowReadStateEngine ) { \nCollection < HollowTypeReadState > typeStates = hollowReadStateEngine . getTypeStates ( ) ; \nif ( typeStates == null ) return ; \ntotalHeapFootprint = 0L ; \ntotalPopulatedOrdinals = 0 ; \nfor ( HollowTypeReadState typeState : typeStates ) { \nlong heapCost = typeState . getApproximateHeapFootprintInBytes ( ) ; \ntotalHeapFootprint += heapCost ; \nlong populatedOrdinals = typeState . getPopulatedOrdinals ( ) . cardinality ( ) ; \ntotalPopulatedOrdinals += populatedOrdinals ; \nString type = typeState . getSchema ( ) . getName ( ) ; \ntypeHeapFootprint . put ( type , heapCost ) ; \ntypePopulatedOrdinals . put ( type , populatedOrdinals ) ; \n} \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \nfor ( long i = 0 ; \ni < fieldData . length ; \ni ++ ) { \nwriteField ( buf , i ) ; \n} \n} \n} \n"}
{"3416": "public class FreeOrdinalTracker { \npublic void sort ( ) { \nArrays . sort ( freeOrdinals , 0 , size ) ; \nlong midpoint = size / 2 ; \nfor ( long i = 0 ; \ni < midpoint ; \ni ++ ) { \nlong temp = freeOrdinals [ i ] ; \nfreeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; \nfreeOrdinals [ size - i - 1 ] = temp ; \n} \n} \n} \n"}
{"3417": "public class SetMapKeyHasher { \npublic static int hash ( Object key [ ] , FieldType fieldType [ ] ) { \nlong hash = 0 ; \nfor ( long i = 0 ; \ni < key . length ; \ni ++ ) { \nhash *= 31 ; \nhash ^= hash ( key [ i ] , fieldType [ i ] ) ; \n} \nreturn hash ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nlong currentElementsPerNode = maxElementsPerNode ; \nlong newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( newElementsPerNode <= currentElementsPerNode ) { \nthrow new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \n} \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \nfor ( long offset = 0 ; \noffset < currentElementsPerNode ; \noffset ++ ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) { \nbreak ; \n} \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nlong maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \nfor ( long i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nlong ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( ordinal > maxOrdinal ) { \nmaxOrdinal = ordinal ; \n} \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \nfor ( long i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nlong ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \n} \npointersByOrdinal = pbo ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nlong sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \nreturn false ; \n} \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( long i = 0 ; \ni < sizeOfData ; \ni ++ ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3423": "public class ByteArrayOrdinalMap { \nprivate void growKeyArray ( ) { \nlong newSize = pointersAndOrdinals . length ( ) << 1 ; \nif ( newSize < 0 ) { \nthrow new IllegalStateException ( \"New size computed to grow the underlying array for the map is negative. \" + \"This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. \" + \"Current array size :\" + pointersAndOrdinals . length ( ) + \" and size to grow :\" + newSize ) ; \n} \ngrowKeyArray ( newSize ) ; \n} \n} \n"}
{"3424": "public class ByteArrayOrdinalMap { \nprivate int rehashPreviouslyAddedData ( long key ) { \nlong position = key & POINTER_MASK ; \nlong sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nreturn HashCodes . hashCode ( byteData . getUnderlyingArray ( ) , position , sizeOfData ) ; \n} \n} \n"}
{"3425": "public class ByteArrayOrdinalMap { \nprivate AtomicLongArray emptyKeyArray ( int size ) { \nAtomicLongArray arr = new AtomicLongArray ( size ) ; \nfor ( long i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \narr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; \n} \nreturn arr ; \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( long i = 0 ; \ni < getNumFieldPaths ( ) ; \ni ++ ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3427": "public class UniqueKeyIndex { \npublic T findMatch ( Q key ) { \nObject [ ] keyArray = matchFields . stream ( ) . map ( mf -> mf . extract ( key ) ) . toArray ( ) ; \nlong ordinal = hpki . getMatchingOrdinal ( keyArray ) ; \nif ( ordinal == - 1 ) { \nreturn null ; \n} \nreturn uniqueTypeExtractor . extract ( api , ordinal ) ; \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( numElements < 0 ) { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nelse if ( numElements > HASH_TABLE_MAX_SIZE ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \nif ( numElements == 0 ) return 1 ; \nif ( numElements < 3 ) return numElements * 2 ; \nlong sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nlong bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( fieldPath . contains ( \".\" ) ) { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \nfor ( long i = 1 ; \ni < parts . length ; \ni ++ ) { \nsb . append ( uppercase ( parts [ i ] ) ) ; \n} \nresult = sb . toString ( ) ; \n} \nelse { \nresult = lowercase ( fieldPath ) ; \n} \nif ( result . endsWith ( \"!\" ) ) { \nreturn result . substring ( 0 , result . length ( ) - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nlong hashCode = 0 ; \nfor ( long i = 0 ; \ni < query . length ; \ni ++ ) { \nif ( query [ i ] == null ) throw new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nwhile ( ! bucketIsEmpty ) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nlong selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3437": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithRandomDelay ( int maxDelayMillis ) { \nRandom rand = new Random ( ) ; \nlong delayMillis = maxDelayMillis > 0 ? rand . nextInt ( maxDelayMillis ) : 0 ; \ntriggerAsyncRefreshWithDelay ( delayMillis ) ; \n} \n} \n"}
{"3444": "public class VarInt { \npublic static int readVInt ( InputStream in ) throws IOException { \nshort b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) throw new RuntimeException ( \"Attempting to read null value as int\" ) ; \nlong value = b & 0x7F ; \nwhile ( ( b & 0x80 ) != 0 ) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3445": "public class VarInt { \npublic static long readVLong ( InputStream in ) throws IOException { \nshort b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) throw new RuntimeException ( \"Attempting to read null value as long\" ) ; \nlong value = b & 0x7F ; \nwhile ( ( b & 0x80 ) != 0 ) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3447": "public class PullToRefreshBase { \nprotected final void refreshLoadingViewsSize ( ) { \nfinal long maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; \nlong pLeft = getPaddingLeft ( ) ; \nlong pTop = getPaddingTop ( ) ; \nlong pRight = getPaddingRight ( ) ; \nlong pBottom = getPaddingBottom ( ) ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setWidth ( maximumPullScroll ) ; \npLeft = - maximumPullScroll ; \n} \nelse { \npLeft = 0 ; \n} \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setWidth ( maximumPullScroll ) ; \npRight = - maximumPullScroll ; \n} \nelse { \npRight = 0 ; \n} \nbreak ; \ncase VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setHeight ( maximumPullScroll ) ; \npTop = - maximumPullScroll ; \n} \nelse { \npTop = 0 ; \n} \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setHeight ( maximumPullScroll ) ; \npBottom = - maximumPullScroll ; \n} \nelse { \npBottom = 0 ; \n} \nbreak ; \n} \nif ( DEBUG ) { \nLog . d ( LOG_TAG , String . format ( \"Setting Padding. L: %d, T: %d, R: %d, B: %d\" , pLeft , pTop , pRight , pBottom ) ) ; \n} \nsetPadding ( pLeft , pTop , pRight , pBottom ) ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal long newScrollValue ; \nfinal long itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \nelse if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal long deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal long newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( newScrollValue < ( 0 - fuzzyThreshold ) ) { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \nelse if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \n} \nelse if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \n} \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) { \nreturn new Service [ 0 ] ; \n} \nif ( services instanceof ArrayList ) { \nreturn ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \n} \nelse { \nService [ ] ret = new Service [ services . size ( ) ] ; \nfor ( long i = 0 ; \ni < services . size ( ) ; \ni ++ ) { \nret [ i ] = services . get ( i ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3477": "public class DefaultServiceEnricher { \nprivate ServicePort parsePortMapping ( String port ) { \nMatcher matcher = PORT_MAPPING_PATTERN . matcher ( port ) ; \nif ( ! matcher . matches ( ) ) { \nlog . error ( \"Invalid 'port' configuration '%s'. Must match <port>(:<targetPort>)?,<port2>?,...\" , port ) ; \nthrow new IllegalArgumentException ( \"Invalid port mapping specification \" + port ) ; \n} \nlong servicePort = Integer . parseInt ( matcher . group ( \"port\" ) ) ; \nString optionalTargetPort = matcher . group ( \"targetPort\" ) ; \nString protocol = getProtocol ( matcher . group ( \"protocol\" ) ) ; \nServicePortBuilder builder = new ServicePortBuilder ( ) . withPort ( servicePort ) . withProtocol ( protocol ) . withName ( getDefaultPortName ( servicePort , protocol ) ) ; \nif ( optionalTargetPort != null ) { \nbuilder . withNewTargetPort ( Integer . parseInt ( optionalTargetPort ) ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"3490": "public class KubernetesHelper { \npublic static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { \nif ( StringUtils . isBlank ( currentValue ) ) { \nthrow new IllegalArgumentException ( \"No \" + description + \" is specified!\" ) ; \n} \nlong size = currentValue . length ( ) ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nchar ch = currentValue . charAt ( i ) ; \nif ( Character . isUpperCase ( ch ) ) { \nthrow new IllegalArgumentException ( \"Invalid upper case letter '\" + ch + \"' at index \" + i + \" for \" + description + \" value: \" + currentValue ) ; \n} \n} \nreturn currentValue ; \n} \n} \n"}
{"3507": "public class IoUtil { \npublic static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { \nlog . progressStart ( ) ; \ntry { \nOkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; \nRequest request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; \nResponse response = client . newCall ( request ) . execute ( ) ; \ntry ( OutputStream out = new FileOutputStream ( target ) ; \nInputStream im = response . body ( ) . byteStream ( ) ) { \nlong length = response . body ( ) . contentLength ( ) ; \nInputStream in = response . body ( ) . byteStream ( ) ; \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong readBytes = 0 ; \nwhile ( true ) { \nlong len = in . read ( buffer ) ; \nreadBytes += len ; \nlog . progressUpdate ( target . getName ( ) , \"Downloading\" , getProgressBar ( readBytes , length ) ) ; \nif ( len <= 0 ) { \nout . flush ( ) ; \nbreak ; \n} \nout . write ( buffer , 0 , len ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Failed to download URL \" + downloadUrl + \" to  \" + target + \": \" + e , e ) ; \n} \nfinally { \nlog . progressFinished ( ) ; \n} \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nlong diff ; \nlong length = Math . min ( components1 . length , components2 . length ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) { \ndiff = i1 . compareTo ( i2 ) ; \n} \nelse { \ndiff = s1 . compareTo ( s2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \nreturn 0 ; \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3519": "public class XmlUtils { \npublic static Element firstChild ( Element element , String name ) { \nNodeList nodes = element . getChildNodes ( ) ; \nif ( nodes != null ) { \nfor ( long i = 0 , size = nodes . getLength ( ) ; \ni < size ; \ni ++ ) { \nNode item = nodes . item ( i ) ; \nif ( item instanceof Element ) { \nElement childElement = ( Element ) item ; \nif ( name . equals ( childElement . getTagName ( ) ) ) { \nreturn childElement ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) { \nreturn null ; \n} \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) { \nreturn null ; \n} \nlong unitPos = 1 ; \nwhile ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) { \nunitPos ++ ; \n} \nif ( unitPos >= duration . length ( ) ) { \nthrow new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \n} \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \nfor ( long i = 0 ; \ni < TIME_UNITS . length ; \ni ++ ) { \nif ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \n} \nif ( multiplier == null ) { \nthrow new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \n} \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) { \nvalue = value . add ( remainingValue ) ; \n} \nreturn value ; \n} \n} \n"}
{"3562": "public class ElasticsearchJestAutoConfiguration { \nprivate int createInternalNode ( ) throws NodeValidationException { \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Create test ES node\" ) ; \n} \nlong port = SocketUtils . findAvailableTcpPort ( ) ; \nString clusterName = INTERNAL_TEST_CLUSTER_NAME + UUID . randomUUID ( ) ; \nSettings . Builder settingsBuilder = Settings . builder ( ) . put ( \"cluster.name\" , clusterName ) . put ( \"http.type\" , \"netty4\" ) . put ( \"http.port\" , String . valueOf ( port ) ) ; \nif ( this . esNodeproperties != null ) { \nthis . esNodeproperties . getProperties ( ) . forEach ( settingsBuilder :: put ) ; \n} \nCollection < Class < ? extends Plugin > > plugins = scanPlugins ( ) ; \nplugins . add ( Netty4Plugin . class ) ; \nthis . node = new InternalNode ( settingsBuilder . build ( ) , plugins ) . start ( ) ; \nreturn Integer . parseInt ( settingsBuilder . get ( \"http.port\" ) ) ; \n} \n} \n"}
{"3574": "public class SignatureVerification { \n@ SuppressLint ( \"PackageManagerGetSignatures\" ) public static boolean isSignatureValid ( Context context , String packageName , String certificateSubject , String certificateIssuer , int publicKeyHashCode ) { \nif ( ! sEnableSignatureVerification ) { \nreturn true ; \n} \nPackageManager packageManager = context . getPackageManager ( ) ; \nSignature [ ] signatures ; \ntry { \nsignatures = packageManager . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) . signatures ; \n} \ncatch ( NameNotFoundException e ) { \nreturn false ; \n} \nInputStream certStream = null ; \nboolean validated = ( signatures . length != 0 ) ; \nfor ( Signature signature : signatures ) { \ntry { \ncertStream = new ByteArrayInputStream ( signature . toByteArray ( ) ) ; \nX509Certificate x509Cert = ( X509Certificate ) CertificateFactory . getInstance ( \"X509\" ) . generateCertificate ( certStream ) ; \nString subject = x509Cert . getSubjectX500Principal ( ) . getName ( ) ; \nString issuer = x509Cert . getIssuerX500Principal ( ) . getName ( ) ; \nlong actualPublicKeyHashCode = x509Cert . getPublicKey ( ) . hashCode ( ) ; \nvalidated &= ( certificateSubject . equals ( subject ) && certificateIssuer . equals ( issuer ) && publicKeyHashCode == actualPublicKeyHashCode ) ; \nif ( ! validated ) { \nreturn false ; \n} \n} \ncatch ( CertificateException e ) { \nreturn false ; \n} \nfinally { \ntry { \nif ( certStream != null ) { \ncertStream . close ( ) ; \n} \n} \ncatch ( IOException ignored ) { \n} \n} \n} \nreturn validated ; \n} \n} \n"}
{"3576": "public class PaymentMethodNonce { \npublic static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { \nJSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; \nif ( paymentMethods == null ) { \nreturn Collections . emptyList ( ) ; \n} \nList < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; \nJSONObject json ; \nPaymentMethodNonce paymentMethodNonce ; \nfor ( long i = 0 ; \ni < paymentMethods . length ( ) ; \ni ++ ) { \njson = paymentMethods . getJSONObject ( i ) ; \npaymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; \nif ( paymentMethodNonce != null ) { \npaymentMethodsNonces . add ( paymentMethodNonce ) ; \n} \n} \nreturn paymentMethodsNonces ; \n} \n} \n"}
{"3595": "public class H264Utils { \npublic static ByteBuffer joinNALUnits ( List < ByteBuffer > nalUnits ) { \nlong size = 0 ; \nfor ( ByteBuffer nal : nalUnits ) { \nsize += 4 + nal . remaining ( ) ; \n} \nByteBuffer allocate = ByteBuffer . allocate ( size ) ; \njoinNALUnitsToBuffer ( nalUnits , allocate ) ; \nreturn allocate ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( long i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nlong sumFix = 0 ; \nlong precNum = 1 << precBits ; \nfor ( long i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nlong s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nlong maxI = - 1 ; \nfor ( long i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( long i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nlong skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nlong written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3601": "public class ImageSequenceDemuxer { \npublic int getMaxAvailableFrame ( ) { \nif ( maxAvailableFrame == - 1 ) { \nlong firstPoint = 0 ; \nfor ( long i = MAX_MAX ; \ni > 0 ; \ni /= 2 ) { \nif ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { \nfirstPoint = i ; \nbreak ; \n} \n} \nlong pos = firstPoint ; \nfor ( long interv = firstPoint / 2 ; \ninterv > 1 ; \ninterv /= 2 ) { \nif ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) { \npos += interv ; \n} \n} \nmaxAvailableFrame = pos ; \nLogger . info ( \"Max frame found: \" + maxAvailableFrame ) ; \n} \nreturn Math . min ( maxAvailableFrame , maxFrames ) ; \n} \n} \n"}
{"3605": "public class QTTimeUtil { \npublic static long frameToTimevalue ( TrakBox trak , int frameNumber ) { \nTimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) ; \nTimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; \nlong pts = 0 ; \nlong sttsInd = 0 , sttsSubInd = frameNumber ; \nwhile ( sttsSubInd >= timeToSamples [ sttsInd ] . getSampleCount ( ) ) { \nsttsSubInd -= timeToSamples [ sttsInd ] . getSampleCount ( ) ; \npts += timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; \nsttsInd ++ ; \n} \nreturn pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; \n} \n} \n"}
{"3606": "public class QTTimeUtil { \npublic static int timevalueToFrame ( TrakBox trak , long tv ) { \nTimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) . getEntries ( ) ; \nlong frame = 0 ; \nfor ( long i = 0 ; \ntv > 0 && i < tts . length ; \ni ++ ) { \nlong rem = tv / tts [ i ] . getSampleDuration ( ) ; \ntv -= tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; \nframe += tv > 0 ? tts [ i ] . getSampleCount ( ) : rem ; \n} \nreturn frame ; \n} \n} \n"}
{"3610": "public class QTTimeUtil { \npublic static String qtPlayerTime ( MovieBox movie , int mediaFrameNo ) { \nTrakBox videoTrack = movie . getVideoTrack ( ) ; \nlong editedTv = mediaToEdited ( videoTrack , frameToTimevalue ( videoTrack , mediaFrameNo ) , movie . getTimescale ( ) ) ; \nlong sec = ( int ) ( editedTv / videoTrack . getTimescale ( ) ) ; \nreturn String . format ( \"%02d\" , sec / 3600 ) + \"_\" + String . format ( \"%02d\" , ( sec % 3600 ) / 60 ) + \"_\" + String . format ( \"%02d\" , sec % 60 ) ; \n} \n} \n"}
{"3612": "public class QTTimeUtil { \npublic static String formatTimecode ( TrakBox timecodeTrack , int counter ) { \nTimecodeSampleEntry tmcd = NodeBox . findFirstPath ( timecodeTrack , TimecodeSampleEntry . class , Box . path ( \"mdia.minf.stbl.stsd.tmcd\" ) ) ; \nlong nf = tmcd . getNumFrames ( ) ; \nString tc = String . format ( \"%02d\" , counter % nf ) ; \ncounter /= nf ; \ntc = String . format ( \"%02d\" , counter % 60 ) + \":\" + tc ; \ncounter /= 60 ; \ntc = String . format ( \"%02d\" , counter % 60 ) + \":\" + tc ; \ncounter /= 60 ; \ntc = String . format ( \"%02d\" , counter ) + \":\" + tc ; \nreturn tc ; \n} \n} \n"}
{"3614": "public class Packed4BitList { \npublic static int set ( int list , int val , int n ) { \nlong cnt = ( list >> 28 ) & 0xf ; \nlong newc = n + 1 ; \ncnt = newc > cnt ? newc : cnt ; \nreturn ( list & CLEAR_MASK [ n ] ) | ( ( val & 0xff ) << ( n << 2 ) ) | ( cnt << 28 ) ; \n} \n} \n"}
{"3618": "public class BitStream { \nprotected int readCache ( boolean peek ) throws AACException { \nlong i ; \nif ( pos > buffer . length - WORD_BYTES ) throw AACException . endOfStream ( ) ; \nelse i = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; \nif ( ! peek ) pos += WORD_BYTES ; \nreturn i ; \n} \n} \n"}
{"3620": "public class WavHeader { \npublic static WavHeader multiChannelWav ( WavHeader [ ] headers ) { \nWavHeader w = emptyWavHeader ( ) ; \nlong totalSize = 0 ; \nfor ( long i = 0 ; \ni < headers . length ; \ni ++ ) { \nWavHeader wavHeader = headers [ i ] ; \ntotalSize += wavHeader . dataSize ; \n} \nw . dataSize = totalSize ; \nFmtChunk fmt = headers [ 0 ] . fmt ; \nlong bitsPerSample = fmt . bitsPerSample ; \nlong bytesPerSample = bitsPerSample / 8 ; \nlong sampleRate = ( int ) fmt . sampleRate ; \nw . fmt . bitsPerSample = ( short ) bitsPerSample ; \nw . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; \nw . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; \nw . fmt . numChannels = ( short ) headers . length ; \nw . fmt . sampleRate = sampleRate ; \nreturn w ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nlong sf = _in . readBits ( 4 ) ; \nif ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \nelse config . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( AAC_SBR == cp ) { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nelse if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) throw new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; \nelse config . coreCoderDelay = 0 ; \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; \n} \nelse { \nthrow new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \n} \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nlong rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( range < 0x8000 ) { \nwhile ( range < 0x8000 ) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nwhile ( range < 0x8000 ) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n"}
{"3623": "public class SliceHeaderReader { \nprivate static void readDecoderPicMarking ( NALUnit nalUnit , SliceHeader sh , BitReader _in ) { \nif ( nalUnit . type == NALUnitType . IDR_SLICE ) { \nboolean noOutputOfPriorPicsFlag = readBool ( _in , \"SH: no_output_of_prior_pics_flag\" ) ; \nboolean longTermReferenceFlag = readBool ( _in , \"SH: long_term_reference_flag\" ) ; \nsh . refPicMarkingIDR = new RefPicMarkingIDR ( noOutputOfPriorPicsFlag , longTermReferenceFlag ) ; \n} \nelse { \nboolean adaptiveRefPicMarkingModeFlag = readBool ( _in , \"SH: adaptive_ref_pic_marking_mode_flag\" ) ; \nif ( adaptiveRefPicMarkingModeFlag ) { \nArrayList < Instruction > mmops = new ArrayList < Instruction > ( ) ; \nlong memoryManagementControlOperation ; \ndo { \nmemoryManagementControlOperation = readUEtrace ( _in , \"SH: memory_management_control_operation\" ) ; \nInstruction instr = null ; \nswitch ( memoryManagementControlOperation ) { \ncase 1 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_SHORT , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , 0 ) ; \nbreak ; \ncase 2 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_LONG , readUEtrace ( _in , \"SH: long_term_pic_num\" ) , 0 ) ; \nbreak ; \ncase 3 : instr = new RefPicMarking . Instruction ( InstrType . CONVERT_INTO_LONG , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) ) ; \nbreak ; \ncase 4 : instr = new RefPicMarking . Instruction ( InstrType . TRUNK_LONG , readUEtrace ( _in , \"SH: max_long_term_frame_idx_plus1\" ) - 1 , 0 ) ; \nbreak ; \ncase 5 : instr = new RefPicMarking . Instruction ( InstrType . CLEAR , 0 , 0 ) ; \nbreak ; \ncase 6 : instr = new RefPicMarking . Instruction ( InstrType . MARK_LONG , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) , 0 ) ; \nbreak ; \n} \nif ( instr != null ) mmops . add ( instr ) ; \n} \nwhile ( memoryManagementControlOperation != 0 ) ; \nsh . refPicMarkingNonIDR = new RefPicMarking ( mmops . toArray ( new Instruction [ ] { \n} \n) ) ; \n} \n} \n} \n} \n"}
{"3626": "public class SampleBuffer { \npublic void setBigEndian ( boolean bigEndian ) { \nif ( bigEndian != this . bigEndian ) { \nint tmp ; \nfor ( long i = 0 ; \ni < data . length ; \ni += 2 ) { \ntmp = data [ i ] ; \ndata [ i ] = data [ i + 1 ] ; \ndata [ i + 1 ] = tmp ; \n} \nthis . bigEndian = bigEndian ; \n} \n} \n} \n"}
{"3629": "public class EbmlUtil { \npublic static byte [ ] ebmlEncodeLen ( long value , int length ) { \nbyte [ ] b = new byte [ length ] ; \nfor ( long idx = 0 ; \nidx < length ; \nidx ++ ) { \nb [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; \n} \nb [ 0 ] |= 0x80 >>> ( length - 1 ) ; \nreturn b ; \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) return 1 ; \nlong length = 8 ; \nwhile ( length > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ) length -- ; \nreturn length ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nlong payloadSize = 0 ; \nfor ( long i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni ++ ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nlong pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \nreturn false ; \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nlong bin ; \nlong qIdx = ( range >> 6 ) & 0x3 ; \nlong rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange -= rLPS ; \nlong rs8 = range << 8 ; \nif ( code < rs8 ) { \nif ( cm [ 0 ] [ m ] < 62 ) cm [ 0 ] [ m ] ++ ; \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nelse { \nrange = rLPS ; \ncode -= rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( nBitsPending <= 0 ) readOneByte ( ) ; \nlong tmp = code - ( range << 8 ) ; \nif ( tmp < 0 ) { \nreturn 0 ; \n} \nelse { \ncode = tmp ; \nreturn 1 ; \n} \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) return null ; \nlong from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nlong val = 0xffffffff ; \nwhile ( buf . hasRemaining ( ) ) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( val >= mmin && val <= mmax ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \n-- n ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3638": "public class SparseIDCT { \npublic static final void start ( int [ ] block , int dc ) { \ndc <<= DC_SHIFT ; \nfor ( long i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i + 0 ] = dc ; \nblock [ i + 1 ] = dc ; \nblock [ i + 2 ] = dc ; \nblock [ i + 3 ] = dc ; \n} \n} \n} \n"}
{"3639": "public class SparseIDCT { \npublic static final void coeff ( int [ ] block , int ind , int level ) { \nfor ( long i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i ] += COEFF [ ind ] [ i ] * level ; \nblock [ i + 1 ] += COEFF [ ind ] [ i + 1 ] * level ; \nblock [ i + 2 ] += COEFF [ ind ] [ i + 2 ] * level ; \nblock [ i + 3 ] += COEFF [ ind ] [ i + 3 ] * level ; \n} \n} \n} \n"}
{"3640": "public class SparseIDCT { \npublic static final void finish ( int block [ ] ) { \nfor ( long i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i ] = div ( block [ i ] ) ; \nblock [ i + 1 ] = div ( block [ i + 1 ] ) ; \nblock [ i + 2 ] = div ( block [ i + 2 ] ) ; \nblock [ i + 3 ] = div ( block [ i + 3 ] ) ; \n} \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) return ; \nlong al = a . bufa ; \nlong ah = a . bufb ; \nlong bl , bh ; \nif ( len > 32 ) { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nelse { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen += a . len ; \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( long i = 0 ; \ni < ID_GAIN ; \ni ++ ) { \nif ( lngain == LN_GAIN [ i ] ) return i ; \n} \nreturn 0 ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nlong bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nlong bytesPerFrame = bytesPerSample * ins . length ; \nlong max = 0 ; \nfor ( long i = 0 ; \ni < ins . length ; \ni ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \nfor ( long frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes ++ ) { \nfor ( long j = 0 ; \nj < ins . length ; \nj ++ ) { \nif ( ins [ j ] . remaining ( ) < bytesPerSample ) { \nfor ( long i = 0 ; \ni < bytesPerSample ; \ni ++ ) outb . put ( ( byte ) 0 ) ; \n} \nelse { \nfor ( long i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nlong bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nlong bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( inb . remaining ( ) >= bytesPerFrame ) { \nfor ( long j = 0 ; \nj < outs . length ; \nj ++ ) { \nfor ( long i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \nouts [ j ] . put ( inb . get ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nlong picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nlong changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( long i = 0 ; \ni < picSizeInMbs ; \ni ++ ) groups [ i ] = 1 ; \nlong x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nlong y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nlong leftBound = x ; \nlong topBound = y ; \nlong rightBound = x ; \nlong bottomBound = y ; \nlong xDir = changeDirectionInt - 1 ; \nlong yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( long k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nlong mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nlong picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nlong changeDirectionInt = changeDirection ? 1 : 0 ; \nlong k = 0 ; \nfor ( long j = 0 ; \nj < picWidthInMbs ; \nj ++ ) { \nfor ( long i = 0 ; \ni < picHeightInMbs ; \ni ++ ) { \nlong mbAddr = i * picWidthInMbs + j ; \nif ( k ++ < sizeOfUpperLeftGroup ) { \ngroups [ mbAddr ] = changeDirectionInt ; \n} \nelse { \ngroups [ mbAddr ] = 1 - changeDirectionInt ; \n} \n} \n} \nreturn groups ; \n} \n} \n"}
{"3656": "public class MXFMetadata { \nprotected static UL [ ] readULBatch ( ByteBuffer _bb ) { \nlong count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nUL [ ] result = new UL [ count ] ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nresult [ i ] = UL . read ( _bb ) ; \n} \nreturn result ; \n} \n} \n"}
{"3657": "public class MXFMetadata { \nprotected static int [ ] readInt32Batch ( ByteBuffer _bb ) { \nlong count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nint [ ] result = new int [ count ] ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nresult [ i ] = _bb . getInt ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nlong numCodecs = getNumSupportedCodecs ( ) ; \nfor ( long i = 0 ; \ni < numCodecs ; \ni ++ ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; \nuniqueSet . add ( id ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nlong numCodecs = getNumSupportedCodecs ( ) ; \nfor ( long i = 0 ; \ni < numCodecs ; \ni ++ ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; \nuniqueSet . add ( tag ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal long slot = mNextAvailableReferenceSlot ++ ; \nif ( slot < mMaxValidReference ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \nreturn true ; \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nwhile ( ! mSpinLock . compareAndSet ( false , true ) ) ; \n} \ntry { \nlong slot = mNextAvailableReferenceSlot ++ ; \nif ( slot >= mMaxValidReference ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot ++ ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nlong numSurvivors = sweepAndCollect ( ) ; \nfor ( long i = 0 ; \ni < numSurvivors ; \ni ++ ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) ref . delete ( ) ; \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nlong bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nlong numStreams = demuxer . getNumStreams ( ) ; \nlong videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( long i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nlong offset = 0 ; \nlong bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nlong numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( long i = 0 ; \ni < numSettings ; \ni ++ ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3683": "public class Codec { \npublic java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { \njava . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; \nlong count = getNumSupportedVideoFrameRates ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nRational rate = getSupportedVideoFrameRate ( i ) ; \nif ( rate != null ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nlong count = getNumSupportedVideoPixelFormats ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3685": "public class Codec { \npublic java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { \njava . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; \nlong count = getNumSupportedAudioSampleRates ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nlong rate = getSupportedAudioSampleRate ( i ) ; \nif ( rate != 0 ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nlong count = getNumSupportedAudioFormats ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3687": "public class Codec { \npublic java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { \njava . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; \nlong count = getNumSupportedAudioChannelLayouts ( ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nAudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; \nif ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) retval . add ( layout ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3692": "public class MuxerFormat { \npublic static java . util . Collection < MuxerFormat > getFormats ( ) { \njava . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; \nlong count = getNumFormats ( ) ; \nfor ( long i = 0 ; \ni < count ; \n++ i ) { \nMuxerFormat fmt = getFormat ( i ) ; \nif ( fmt != null ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nlong numStreams = demuxer . getNumStreams ( ) ; \nlong audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( long i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nlong offset = 0 ; \nlong bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( long i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( long i = 0 ; \ni < input . length ( ) ; \n++ i ) { \nchar c = input . charAt ( i ) ; \nlong digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n} \nlong zeros = 0 ; \nwhile ( zeros < input58 . length && input58 [ zeros ] == 0 ) { \n++ zeros ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nlong outputStart = decoded . length ; \nfor ( long inputStart = zeros ; \ninputStart < input58 . length ; \n) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \n++ inputStart ; \n} \n} \nwhile ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { \n++ outputStart ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3718": "public class PrivateKeyAccount { \npublic static String generateSeed ( ) { \nbyte [ ] bytes = new byte [ 21 ] ; \nnew SecureRandom ( ) . nextBytes ( bytes ) ; \nbyte [ ] rhash = hash ( bytes , 0 , 20 , SHA256 ) ; \nbytes [ 20 ] = rhash [ 0 ] ; \nBigInteger rand = new BigInteger ( bytes ) ; \nBigInteger mask = new BigInteger ( new byte [ ] { \n0 , 0 , 7 , - 1 } \n) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < 15 ; \ni ++ ) { \nsb . append ( i > 0 ? ' ' : \"\" ) . append ( SEED_WORDS [ rand . and ( mask ) . intValue ( ) ] ) ; \nrand = rand . shiftRight ( 11 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3729": "public class OffHeapCoder { \npublic int toMemory ( Object o , long address , int availableSize ) throws IOException { \nout . resetForReUse ( ) ; \nwriteTarget . setBase ( address , availableSize ) ; \nout . writeObject ( o ) ; \nlong written = out . getWritten ( ) ; \nreturn written ; \n} \n} \n"}
{"3731": "public class DefaultCoder { \npublic int toByteArray ( Object obj , byte result [ ] , int resultOffset , int avaiableSize ) { \noutput . resetForReUse ( ) ; \ntry { \noutput . writeObject ( obj ) ; \n} \ncatch ( IOException e ) { \nFSTUtil . < RuntimeException > rethrow ( e ) ; \n} \nlong written = output . getWritten ( ) ; \nif ( written > avaiableSize ) { \nthrow FSTBufferTooSmallException . Instance ; \n} \nSystem . arraycopy ( output . getBuffer ( ) , 0 , result , resultOffset , written ) ; \nreturn written ; \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nlong len = name . length ( ) ; \nif ( len >= 127 ) { \nthrow new RuntimeException ( \"Ascii String too long\" ) ; \n} \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \n} \n} \n"}
{"3746": "public class FSTConfiguration { \npublic FSTConfiguration registerCrossPlatformClassMapping ( String [ ] [ ] keysAndVals ) { \nfor ( long i = 0 ; \ni < keysAndVals . length ; \ni ++ ) { \nString [ ] keysAndVal = keysAndVals [ i ] ; \nregisterCrossPlatformClassMapping ( keysAndVal [ 0 ] , keysAndVal [ 1 ] ) ; \n} \nreturn this ; \n} \n} \n"}
{"3749": "public class MBOut { \nprotected void writeRawInt ( byte type , long data ) { \nlong numBytes = MinBin . extractNumBytes ( type ) ; \nfor ( long i = 0 ; \ni < numBytes ; \ni ++ ) { \nwriteOut ( ( byte ) ( data & 0xff ) ) ; \ndata = data >>> 8 ; \n} \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nint type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( long i = start ; \ni < start + len ; \ni ++ ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal long len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( s . length ( ) > charsLen ( ) ) { \nthrow new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \n} \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchars ( i , s . charAt ( i ) ) ; \n} \nlen = s . length ( ) ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nlong sumLen = 0 ; \nfor ( long i = 0 ; \ni < curIndex ; \ni ++ ) { \nsumLen += changeLength [ i ] ; \n} \nsnapshot = new byte [ sumLen ] ; \nlong targetIdx = 0 ; \nfor ( long i = 0 ; \ni < curIndex ; \ni ++ ) { \nlong changeOffset = changeOffsets [ i ] ; \nlong len = changeLength [ i ] ; \nfor ( long ii = 0 ; \nii < len ; \nii ++ ) { \nsnapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \n} \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3762": "public class FSTObjectRegistry { \npublic int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { \nif ( disabled ) { \nreturn Integer . MIN_VALUE ; \n} \nif ( clzInfo == null ) { \n} \nelse if ( clzInfo . isFlat ( ) ) { \nreturn Integer . MIN_VALUE ; \n} \nlong handle = objects . putOrGet ( o , streamPosition ) ; \nif ( handle >= 0 ) { \nreUseType [ 0 ] = 0 ; \nreturn handle ; \n} \nreturn Integer . MIN_VALUE ; \n} \n} \n"}
{"3763": "public class OnHeapCoder { \n@ Override public int toByteArray ( Object o , byte arr [ ] , int startIndex , int availableSize ) { \nout . resetForReUse ( ) ; \nwriteTarget . setBase ( arr , startIndex , availableSize ) ; \ntry { \nout . writeObject ( o ) ; \n} \ncatch ( IOException e ) { \nFSTUtil . < RuntimeException > rethrow ( e ) ; \n} \nlong written = out . getWritten ( ) ; \nreturn written ; \n} \n} \n"}
{"3765": "public class BinaryQueue { \npublic byte [ ] readByteArray ( int len ) { \nif ( available ( ) < len ) { \nthrow new RuntimeException ( \"not enough data available, check available() > len before calling\" ) ; \n} \nint b [ ] = new byte [ len ] ; \nlong count = 0 ; \nwhile ( pollIndex != addIndex && count < len ) { \nb [ count ++ ] = storage . get ( pollIndex ++ ) ; \nif ( pollIndex >= storage . length ( ) ) { \npollIndex = 0 ; \n} \n} \nreturn b ; \n} \n} \n"}
{"3766": "public class BinaryQueue { \npublic int readInt ( ) { \nif ( available ( ) < 4 ) { \nthrow new RuntimeException ( \"not enough data available, check available() > 4 before calling\" ) ; \n} \nlong ch1 = poll ( ) ; \nlong ch2 = poll ( ) ; \nlong ch3 = poll ( ) ; \nlong ch4 = poll ( ) ; \nreturn ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal long STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . println ( \"Process Thread Dump: \" + title ) ; \nstream . println ( threadIds . length + \" active threads\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . println ( \"  Inactive\" ) ; \ncontinue ; \n} \nstream . println ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . println ( \"  State: \" + state ) ; \nstream . println ( \"  Blocked count: \" + info . getBlockedCount ( ) ) ; \nstream . println ( \"  Waited count: \" + info . getWaitedCount ( ) ) ; \nif ( contention ) { \nstream . println ( \"  Blocked time: \" + info . getBlockedTime ( ) ) ; \nstream . println ( \"  Waited time: \" + info . getWaitedTime ( ) ) ; \n} \nif ( state == Thread . State . WAITING ) { \nstream . println ( \"  Waiting on \" + info . getLockName ( ) ) ; \n} \nelse if ( state == Thread . State . BLOCKED ) { \nstream . println ( \"  Blocked on \" + info . getLockName ( ) ) ; \nstream . println ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; \n} \nstream . println ( \"  Stack:\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . println ( \"    \" + frame . toString ( ) ) ; \n} \n} \nstream . flush ( ) ; \n} \n} \n"}
{"3777": "public class BooleanIndexing { \npublic static boolean or ( IComplexNDArray n , Condition cond ) { \nboolean ret = false ; \nIComplexNDArray linear = n . linearView ( ) ; \nfor ( long i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \nret = ret || cond . apply ( linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( long i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( long i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3783": "public class FunctionProperties { \npublic int asFlatProperties ( FlatBufferBuilder bufferBuilder ) { \nlong iname = bufferBuilder . createString ( name ) ; \nlong ii = FlatProperties . createIVector ( bufferBuilder , Ints . toArray ( i ) ) ; \nlong il = FlatProperties . createLVector ( bufferBuilder , Longs . toArray ( l ) ) ; \nlong id = FlatProperties . createDVector ( bufferBuilder , Doubles . toArray ( d ) ) ; \nlong arrays [ ] = new int [ a . size ( ) ] ; \nlong cnt = 0 ; \nfor ( val array : a ) { \nlong off = array . toFlatArray ( bufferBuilder ) ; \narrays [ cnt ++ ] = off ; \n} \nlong ia = FlatProperties . createAVector ( bufferBuilder , arrays ) ; \nreturn FlatProperties . createFlatProperties ( bufferBuilder , iname , ii , il , id , ia ) ; \n} \n} \n"}
{"3784": "public class FunctionProperties { \npublic static FunctionProperties fromFlatProperties ( FlatProperties properties ) { \nval props = new FunctionProperties ( ) ; \nfor ( long e = 0 ; \ne < properties . iLength ( ) ; \ne ++ ) props . getI ( ) . add ( properties . i ( e ) ) ; \nfor ( long e = 0 ; \ne < properties . lLength ( ) ; \ne ++ ) props . getL ( ) . add ( properties . l ( e ) ) ; \nfor ( long e = 0 ; \ne < properties . dLength ( ) ; \ne ++ ) props . getD ( ) . add ( properties . d ( e ) ) ; \nfor ( long e = 0 ; \ne < properties . iLength ( ) ; \ne ++ ) props . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; \nreturn props ; \n} \n} \n"}
{"3785": "public class FunctionProperties { \npublic static int asFlatProperties ( FlatBufferBuilder bufferBuilder , Collection < FunctionProperties > properties ) { \nlong props [ ] = new int [ properties . size ( ) ] ; \nlong cnt = 0 ; \nfor ( val p : properties ) props [ cnt ++ ] = p . asFlatProperties ( bufferBuilder ) ; \nreturn FlatNode . createPropertiesVector ( bufferBuilder , props ) ; \n} \n} \n"}
{"3788": "public class MathUtils { \npublic static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { \nif ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( \"Sample sizes must be the same for each data applyTransformToDestination.\" ) ; \nList < Double > ret = new ArrayList < Double > ( ) ; \nfor ( long i = 0 ; \ni < x . size ( ) ; \ni ++ ) { \nret . add ( x . get ( i ) ) ; \nret . add ( y . get ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3789": "public class MathUtils { \npublic static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { \nlong count = 0 ; \nList < List < Double > > ret = new ArrayList < List < Double > > ( ) ; \nwhile ( count < arr . size ( ) ) { \nList < Double > sublist = arr . subList ( count , count + chunk ) ; \ncount += chunk ; \nret . add ( sublist ) ; \n} \nfor ( List < Double > lists : ret ) { \nif ( lists . size ( ) < chunk ) ret . remove ( lists ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3792": "public class CudaEnvironment { \npublic int getCurrentDeviceArchitecture ( ) { \nlong deviceId = Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ; \nif ( ! arch . containsKey ( deviceId ) ) { \nlong major = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . getDeviceMajor ( new CudaPointer ( deviceId ) ) ; \nlong minor = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . getDeviceMinor ( new CudaPointer ( deviceId ) ) ; \nInteger cc = Integer . parseInt ( new String ( \"\" + major + minor ) ) ; \narch . put ( deviceId , cc ) ; \nreturn cc ; \n} \nreturn arch . get ( deviceId ) ; \n} \n} \n"}
{"3795": "public class CompressionDescriptor { \npublic static CompressionDescriptor fromByteBuffer ( ByteBuffer byteBuffer ) { \nCompressionDescriptor compressionDescriptor = new CompressionDescriptor ( ) ; \nlong compressionTypeOrdinal = byteBuffer . getInt ( ) ; \nCompressionType compressionType = CompressionType . values ( ) [ compressionTypeOrdinal ] ; \ncompressionDescriptor . setCompressionType ( compressionType ) ; \nlong compressionAlgoOrdinal = byteBuffer . getInt ( ) ; \nCompressionAlgorithm compressionAlgorithm = CompressionAlgorithm . values ( ) [ compressionAlgoOrdinal ] ; \ncompressionDescriptor . setCompressionAlgorithm ( compressionAlgorithm . name ( ) ) ; \ncompressionDescriptor . setOriginalLength ( byteBuffer . getLong ( ) ) ; \ncompressionDescriptor . setCompressedLength ( byteBuffer . getLong ( ) ) ; \ncompressionDescriptor . setNumberOfElements ( byteBuffer . getLong ( ) ) ; \ncompressionDescriptor . setOriginalElementSize ( byteBuffer . getLong ( ) ) ; \nreturn compressionDescriptor ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \nfor ( long i = 1 ; \ni < arrs . length ; \ni ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \nelse { \nlong dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( long i = 1 ; \ni < arrs . length ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \n} \n} \n"}
{"3799": "public class BaseNDArrayFactory { \n@ Override public INDArray linspace ( int lower , int upper , int num ) { \ndouble [ ] data = new double [ num ] ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \ndouble t = ( double ) i / ( num - 1 ) ; \ndata [ i ] = lower * ( 1 - t ) + t * upper ; \n} \nINDArray ret = Nd4j . create ( data . length ) ; \nif ( ret . isScalar ( ) ) return ret ; \nfor ( long i = 0 ; \ni < ret . length ( ) ; \ni ++ ) ret . putScalar ( i , data [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3800": "public class BaseNDArrayFactory { \n@ Override public INDArray toFlattened ( Collection < INDArray > matrices ) { \nlong length = 0 ; \nfor ( INDArray m : matrices ) length += m . length ( ) ; \nINDArray ret = Nd4j . create ( 1 , length ) ; \nlong linearIndex = 0 ; \nfor ( INDArray d : matrices ) { \nret . put ( new INDArrayIndex [ ] { \nNDArrayIndex . interval ( linearIndex , linearIndex + d . length ( ) ) } \n, d ) ; \nlinearIndex += d . length ( ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3801": "public class BaseNDArrayFactory { \n@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { \nassert curr . shape ( ) . length == 3 ; \nif ( in . columns ( ) != 1 ) { \nthrow new AssertionError ( \"Expected a column vector\" ) ; \n} \nif ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Number of rows in the input does not match number of columns in tensor\" ) ; \n} \nif ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Can only perform this operation on a SimpleTensor with square slices\" ) ; \n} \nINDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; \nINDArray inT = in . transpose ( ) ; \nfor ( long i = 0 ; \ni < curr . slices ( ) ; \ni ++ ) { \nINDArray slice = curr . slice ( i ) ; \nINDArray inTTimesSlice = inT . mmul ( slice ) ; \nret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( long i = 0 ; \ni < getFeatures ( ) . length ( ) ; \ni ++ ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( curr > cutoff ) getFeatures ( ) . putScalar ( i , 1 ) ; \nelse getFeatures ( ) . putScalar ( i , 0 ) ; \n} \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \nfor ( long i = 0 ; \ni < numSamples ; \ni ++ ) { \nlong picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3817": "public class StringUtils { \npublic static String simpleHostname ( String fullHostname ) { \nif ( InetAddresses . isInetAddress ( fullHostname ) ) { \nreturn fullHostname ; \n} \nlong offset = fullHostname . indexOf ( '.' ) ; \nif ( offset != - 1 ) { \nreturn fullHostname . substring ( 0 , offset ) ; \n} \nreturn fullHostname ; \n} \n} \n"}
{"3818": "public class StringUtils { \npublic static String arrayToString ( String [ ] strs ) { \nif ( strs . length == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sbuf = new StringBuilder ( ) ; \nsbuf . append ( strs [ 0 ] ) ; \nfor ( long idx = 1 ; \nidx < strs . length ; \nidx ++ ) { \nsbuf . append ( \",\" ) ; \nsbuf . append ( strs [ idx ] ) ; \n} \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"3819": "public class StringUtils { \npublic static String byteToHexString ( byte [ ] bytes , int start , int end ) { \nif ( bytes == null ) { \nthrow new IllegalArgumentException ( \"bytes == null\" ) ; \n} \nStringBuilder s = new StringBuilder ( ) ; \nfor ( long i = start ; \ni < end ; \ni ++ ) { \ns . append ( format ( \"%02x\" , bytes [ i ] ) ) ; \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"3821": "public class StringUtils { \npublic static String [ ] split ( String str , char escapeChar , char separator ) { \nif ( str == null ) { \nreturn null ; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nStringBuilder split = new StringBuilder ( ) ; \nlong index = 0 ; \nwhile ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { \n++ index ; \nstrList . add ( split . toString ( ) ) ; \nsplit . setLength ( 0 ) ; \n} \nstrList . add ( split . toString ( ) ) ; \nlong last = strList . size ( ) ; \nwhile ( -- last >= 0 && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3822": "public class StringUtils { \npublic static String [ ] split ( String str , char separator ) { \nif ( str . isEmpty ( ) ) { \nreturn new String [ ] { \n\"\" } \n; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nlong startIndex = 0 ; \nlong nextIndex = 0 ; \nwhile ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { \nstrList . add ( str . substring ( startIndex , nextIndex ) ) ; \nstartIndex = nextIndex + 1 ; \n} \nstrList . add ( str . substring ( startIndex ) ) ; \nlong last = strList . size ( ) ; \nwhile ( -- last >= 0 && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nlong numPreEscapes = 0 ; \nfor ( long i = start ; \ni < str . length ( ) ; \ni ++ ) { \nchar curChar = str . charAt ( i ) ; \nif ( numPreEscapes == 0 && curChar == separator ) { \nreturn i ; \n} \nelse { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3830": "public class Factorial { \npublic BigInteger at ( int n ) { \nwhile ( a . size ( ) <= n ) { \nfinal long lastn = a . size ( ) - 1 ; \nfinal BigInteger nextn = BigInteger . valueOf ( lastn + 1 ) ; \na . add ( a . get ( lastn ) . multiply ( nextn ) ) ; \n} \nreturn a . get ( n ) ; \n} \n} \n"}
{"3834": "public class BaseShapeInfoProvider { \n@ Override public Pair < DataBuffer , long [ ] > createShapeInformation ( long [ ] shape , char order ) { \nlong [ ] stride = Nd4j . getStrides ( shape , order ) ; \nlong ews = 1 ; \nreturn createShapeInformation ( shape , stride , 0 , ews , order ) ; \n} \n} \n"}
{"3835": "public class Shape { \npublic static boolean isVector ( DataBuffer shapeInfo ) { \nlong rank = Shape . rank ( shapeInfo ) ; \nif ( rank > 2 || rank < 1 ) return false ; \nelse { \nlong len = Shape . length ( shapeInfo ) ; \nDataBuffer shape = Shape . shapeOf ( shapeInfo ) ; \nreturn shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; \n} \n} \n} \n"}
{"3838": "public class Shape { \npublic static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { \nINDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; \nfor ( long i = 0 ; \ni < ret . length ; \ni ++ ) ret [ i ] = new NDArrayIndex ( indices [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nlong put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \ntoDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \n} \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nlong status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \n} \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \nfor ( long i = 1 ; \ni < Math . min ( A . rows ( ) , A . columns ( ) ) ; \ni ++ ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nlong cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \nfor ( long l = 0 ; \nl < configuration . getCommandLanesNumber ( ) ; \nl ++ ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \n} \n} \n"}
{"3861": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { \nPointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; \nlong dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; \nDataBuffer data = null ; \nPointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; \nlong length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; \nshapeBufferPointer . capacity ( 4 * length ) ; \nshapeBufferPointer . limit ( 4 * length ) ; \nshapeBufferPointer . position ( 0 ) ; \nval intPointer = new LongPointer ( shapeBufferPointer ) ; \nDataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; \ndataPointer . position ( 0 ) ; \ndataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \ndataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \nif ( dataBufferElementSize == ( Float . SIZE / 8 ) ) { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; \n} \nelse if ( dataBufferElementSize == ( Double . SIZE / 8 ) ) { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; \n} \nINDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; \nreturn ret ; \n} \n} \n"}
{"3888": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray expi ( IComplexNDArray toExp ) { \nIComplexNDArray flattened = toExp . ravel ( ) ; \nfor ( long i = 0 ; \ni < flattened . length ( ) ; \ni ++ ) { \nIComplexNumber n = flattened . getComplex ( i ) ; \nflattened . put ( i , Nd4j . scalar ( ComplexUtil . exp ( n ) ) ) ; \n} \nreturn flattened . reshape ( toExp . shape ( ) ) ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; \nfor ( long i = 0 ; \ni < shape . length ; \ni ++ ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nlong start = ( int ) startIndex . getDouble ( 0 ) ; \nlong end = ( int ) endIndex . getDouble ( 0 ) ; \nlong count = 0 ; \nfor ( long i = start ; \ni < end ; \ni ++ ) { \nret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3890": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { \nif ( nd . isVector ( ) ) { \nIComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { \n1 , n } \n) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) truncated . putScalar ( i , nd . getComplex ( i ) ) ; \nreturn truncated ; \n} \nif ( nd . size ( dimension ) > n ) { \nlong [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; \nshape [ dimension ] = n ; \nIComplexNDArray ret = Nd4j . createComplex ( shape ) ; \nIComplexNDArray ndLinear = nd . linearView ( ) ; \nIComplexNDArray retLinear = ret . linearView ( ) ; \nfor ( long i = 0 ; \ni < ret . length ( ) ; \ni ++ ) retLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; \nreturn ret ; \n} \nreturn nd ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nlong numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( long i = 0 ; \ni < numDevices ; \ni ++ ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( mc . getPrecision ( ) < GAMMA . precision ( ) ) { \nreturn GAMMA . round ( mc ) ; \n} \nelse { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nlong kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \nfor ( long n = 1 ; \n; \nn ++ ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( c . doubleValue ( ) < 0.1 * eps ) { \nbreak ; \n} \n} \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( long i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nlong exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nlong exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nlong pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nlong val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nif ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nlong k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( long i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( xDbl > 0.8 ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( long i = 2 ; \n; \ni ++ ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse { \nif ( x . doubleValue ( ) > 1.5 ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nlong k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( long i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nlong k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( long i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse if ( x . doubleValue ( ) > 1.5 ) { \nlong n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( long n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( long n = 1 ; \nn < 5 ; \nn ++ ) { \npsi += zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \nfor ( long k = 1 ; \nk < 10 ; \nk ++ ) { \nx += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \n} \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nlong kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps /= kmax ; \nBigDecimal res = BigDecimal . ZERO ; \nfor ( long c = 0 ; \n; \nc ++ ) { \nRational r = new Rational ( ) ; \nfor ( long k = 0 ; \nk < 8 ; \nk ++ ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nlong pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \n} \nif ( Math . abs ( r . doubleValue ( ) ) < eps ) { \nbreak ; \n} \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3913": "public class BigDecimalMath { \nstatic public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { \nfinal long diffPr = mc . getPrecision ( ) - x . precision ( ) ; \nif ( diffPr > 0 ) { \nreturn scalePrec ( x , diffPr ) ; \n} \nelse { \nreturn x ; \n} \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \n} \nif ( variableNameToShape . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \n} \nfor ( long i = 0 ; \ni < shape . length ; \ni ++ ) { \nif ( shape [ i ] < 1 ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \n} \nvariableNameToShape . put ( varName , shape ) ; \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \nfor ( long i = 0 ; \ni < varNames . length ; \ni ++ ) { \nif ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3925": "public class SameDiff { \npublic INDArray [ ] eval ( Map < String , INDArray > inputs ) { \nSameDiff execPipeline = dup ( ) ; \nList < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; \nif ( opExecAction . isEmpty ( ) ) throw new IllegalStateException ( \"No ops found to execute.\" ) ; \nINDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; \nfor ( long i = 0 ; \ni < ret . length ; \ni ++ ) { \nval varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; \nret [ i ] = execPipeline . getArrForVarName ( varName ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \nfor ( long i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \nfor ( long arg = 0 ; \narg < args . length ; \narg ++ ) { \nif ( ! reverseArgs [ arg ] . equals ( varName ) ) { \nnewArgs . add ( reverseArgs [ arg ] ) ; \n} \n} \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"3933": "public class SameDiff { \npublic List < DifferentialFunction > exec ( List < DifferentialFunction > ops ) { \nfor ( long i = 0 ; \ni < ops . size ( ) ; \ni ++ ) { \nOp op = ( Op ) ops . get ( i ) ; \nNd4j . getExecutioner ( ) . exec ( op ) ; \n} \nreturn ops ; \n} \n} \n"}
{"3939": "public class CudaMemoryManager { \n@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { \nAtomicAllocator allocator = AtomicAllocator . getInstance ( ) ; \nif ( kind == MemoryKind . HOST ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from HOST memory\" ) ; \nif ( initialize ) Pointer . memset ( ptr , 0 , bytes ) ; \nreturn ptr ; \n} \nelse if ( kind == MemoryKind . DEVICE ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + \"] memory\" ) ; \nif ( initialize ) { \nCudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; \nlong i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; \nif ( i == 0 ) throw new ND4JIllegalStateException ( \"memset failed on device_\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; \ncontext . getSpecialStream ( ) . synchronize ( ) ; \n} \nreturn ptr ; \n} \nelse throw new RuntimeException ( \"Unknown MemoryKind requested: \" + kind ) ; \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) log . warn ( \"Warning: empty dataset from the fetcher\" ) ; \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \nfor ( long i = 0 ; \ni < examples . size ( ) ; \ni ++ ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \n} \ncurr = new DataSet ( inputs , labels ) ; \n} \n} \n"}
{"3961": "public class AtomicAllocator { \nprotected void initHostCollectors ( ) { \nfor ( long i = 0 ; \ni < configuration . getNumberOfGcThreads ( ) ; \ni ++ ) { \nReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; \nUnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; \nNd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; \nqueueMap . put ( i , queue ) ; \nuThread . start ( ) ; \ncollectorsUnified . put ( i , uThread ) ; \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( long i = 0 ; \ni < index . rows ( ) ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( long j = 0 ; \nj < row . columns ( ) ; \nj ++ ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) { \nthrow new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \n} \nval outputVars = args ( ) ; \nfor ( long i = 0 ; \ni < vals . size ( ) ; \ni ++ ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( grad != null ) { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \nelse { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nlong addPrecision = this . precision ; \nwhile ( addPrecision > 0 ) { \nthis . scientificFormat += \"#\" ; \naddPrecision -= 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . scientificFormat . length ( ) + 2 > this . padding ) this . padding = this . scientificFormat . length ( ) + 2 ; \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize && arr . length ( ) > 1000 ) return format ( arr , 0 , true ) ; \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( long i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( long i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \nfor ( long i = 0 ; \ni < linearView ( ) . length ( ) ; \ni ++ ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( diff <= Nd4j . EPS_THRESHOLD ) linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \nelse linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \nfor ( long i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \nlinear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3979": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray getRows ( int [ ] rindices ) { \nINDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; \nfor ( long i = 0 ; \ni < rindices . length ; \ni ++ ) { \nrows . putRow ( i , getRow ( rindices [ i ] ) ) ; \n} \nreturn ( IComplexNDArray ) rows ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( long i = 0 ; \ni < r . length ( ) ; \ni ++ ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nelse { \nfor ( long i = 0 ; \ni < r . length ( ) ; \ni ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nelse if ( result == other ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( long i = 0 ; \ni < resultLinear . length ( ) ; \ni ++ ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3986": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( Number value ) { \nIComplexNDArray one = linearView ( ) ; \nfor ( long i = 0 ; \ni < one . length ( ) ; \ni ++ ) one . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; \nreturn this ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \nfor ( long i = 0 ; \ni < length ( ) ; \ni ++ ) { \nret . putScalar ( i , linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nlong negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nlong resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nlong e = 0 ; \nfor ( ; \ne < codes . length ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \ne < resultLength ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse if ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( long i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \nType [ ] result ; \nlong resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse if ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse if ( type instanceof WildcardType ) { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof CaptureType ) { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof GenericArrayType ) { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse if ( type == null ) { \nthrow new NullPointerException ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n} \n"}
{"4040": "public class Path { \npublic int depth ( ) { \nlong depth = 0 ; \nPath here = this ; \nwhile ( here != ROOT ) { \ndepth ++ ; \nhere = here . previous ; \n} \nreturn depth ; \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) return ; \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; \n} \n} \n} \n"}
{"4079": "public class IfConditionGenerator { \npublic If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { \nif ( ifClasses . length == 0 ) return ALWAYS ; \nIf < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; \nfor ( long i = 0 ; \ni < ifClasses . length ; \ni ++ ) { \nClass < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; \nresult [ i ] = this . createIf ( ifClass , field ) ; \nType valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; \nClass < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; \nType pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; \nClass < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; \nif ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because you cannot assign \" + field . getType ( ) . getName ( ) + \" to \" + valueClass . getName ( ) ) ; \nif ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because the containing class \" + field . getDeclaringClass ( ) . getName ( ) + \" is not compatible with \" + pojoClass . getName ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4095": "public class SnippetProcessor { \npublic String process ( SnippetProcessorContext ctx , String snippet ) { \ncheckNotNull ( ctx ) ; \nStringBuilder sb = ctx . builder ( ) ; \nsb . setLength ( 0 ) ; \nString currSnippet = snippet ; \nboolean processedMacros = false ; \nlong snippetPos = 0 ; \nlong macroPos = currSnippet . indexOf ( \"${\" ) ; \nwhile ( macroPos != - 1 ) { \nsb . append ( currSnippet . substring ( snippetPos , macroPos ) ) ; \nlong macroEnd = processMacroAt ( ctx , currSnippet , macroPos ) ; \nif ( macroEnd == - 1 ) { \nsb . append ( \"${\" ) ; \nsnippetPos = macroPos + 2 ; \n} \nelse { \nsnippetPos = macroEnd ; \nprocessedMacros = true ; \n} \nmacroPos = currSnippet . indexOf ( \"${\" , snippetPos ) ; \n} \nif ( processedMacros ) { \nsb . append ( currSnippet , snippetPos , currSnippet . length ( ) ) ; \ncurrSnippet = sb . toString ( ) ; \n} \nsb . setLength ( 0 ) ; \nString ret = urlEncode ( ctx , currSnippet ) ; \nsb . setLength ( 0 ) ; \nreturn ret ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nlong size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \n++ i ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nlong headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate long heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4108": "public class ProtoUtils { \npublic static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { \ncheckNotNull ( filter ) ; \nfor ( long i = 0 ; \ni < objs . size ( ) ; \n++ i ) { \nif ( ! filter . test ( objs . get ( i ) ) ) { \nreturn filterFrom ( objs , filter , i ) ; \n} \n} \nreturn objs ; \n} \n} \n"}
{"4119": "public class URLUtil { \nstatic URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { \nif ( ! target . startsWith ( \"?\" ) ) return new URL ( base , target ) ; \nString basePath = base . getPath ( ) ; \nString baseRightMost = \"\" ; \nlong baseRightMostIdx = basePath . lastIndexOf ( \"/\" ) ; \nif ( baseRightMostIdx != - 1 ) { \nbaseRightMost = basePath . substring ( baseRightMostIdx + 1 ) ; \n} \nif ( target . startsWith ( \"?\" ) ) target = baseRightMost + target ; \nreturn new URL ( base , target ) ; \n} \n} \n"}
{"4128": "public class MetadataTransfer { \npublic Metadata getMetaForOutlink ( String targetURL , String sourceURL , Metadata parentMD ) { \nMetadata md = _filter ( parentMD , mdToTransfer ) ; \nif ( trackPath ) { \nmd . addValue ( urlPathKeyName , sourceURL ) ; \n} \nif ( trackDepth ) { \nString existingDepth = md . getFirstValue ( depthKeyName ) ; \nlong depth ; \ntry { \ndepth = Integer . parseInt ( existingDepth ) ; \n} \ncatch ( Exception e ) { \ndepth = 0 ; \n} \nmd . setValue ( depthKeyName , Integer . toString ( ++ depth ) ) ; \n} \nreturn md ; \n} \n} \n"}
{"4134": "public class CharsetIdentification { \nprivate static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { \nlong len = buffer . length ; \nif ( maxlength > 0 && maxlength < len ) { \nlen = maxlength ; \n} \nString html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; \nDocument doc = Parser . htmlParser ( ) . parseInput ( html , \"dummy\" ) ; \nElements metaElements = doc . select ( \"meta[http-equiv=content-type], meta[charset]\" ) ; \nString foundCharset = null ; \nfor ( Element meta : metaElements ) { \nif ( meta . hasAttr ( \"http-equiv\" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( \"content\" ) ) ; \nif ( foundCharset == null && meta . hasAttr ( \"charset\" ) ) foundCharset = meta . attr ( \"charset\" ) ; \nif ( foundCharset != null ) return foundCharset ; \n} \nreturn foundCharset ; \n} \n} \n"}
{"4135": "public class SiteMapParserBolt { \nprivate final boolean sniff ( byte [ ] content ) { \nbyte [ ] beginning = content ; \nif ( content . length > maxOffsetGuess && maxOffsetGuess > 0 ) { \nbeginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; \n} \nlong position = Bytes . indexOf ( beginning , clue ) ; \nif ( position != - 1 ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nlong equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( long i = 1 ; \ni < tokens . length ; \ni ++ ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) { \ncookieDomain = cookieDomain . substring ( 1 ) ; \n} \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nlong tokenDif = hostTokens . length - domainTokens . length ; \nif ( tokenDif < 0 ) { \nreturn false ; \n} \nfor ( long i = domainTokens . length - 1 ; \ni >= 0 ; \ni -- ) { \nif ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \ncatch ( Exception e ) { \nreturn true ; \n} \n} \n} \n"}
{"4140": "public class HttpRobotRulesParser { \nprotected static String getCacheKey ( URL url ) { \nString protocol = url . getProtocol ( ) . toLowerCase ( Locale . ROOT ) ; \nString host = url . getHost ( ) . toLowerCase ( Locale . ROOT ) ; \nlong port = url . getPort ( ) ; \nif ( port == - 1 ) { \nport = url . getDefaultPort ( ) ; \n} \nreturn protocol + \":\" + host + \":\" + port ; \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nlong numNodes = nodes . getLength ( ) ; \nfor ( long i = 0 ; \ni < numNodes ; \ni ++ ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( long att = 0 ; \natt < attrs . getLength ( ) ; \natt ++ ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { \nreturn true ; \n} \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \nfor ( long i = domainParts . length - 1 ; \ni >= 0 ; \ni -- ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) { \nreturn true ; \n} \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) { \ncontinue ; \n} \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) { \nreturn true ; \n} \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nlong semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) { \nquery = params ; \n} \nelse { \nquery += \"&\" + params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) { \npairsIterator . remove ( ) ; \n} \nelse if ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) { \ncurrentNode . appendChild ( newNode ) ; \n} \nelse if ( null != m_docFrag ) { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \nboolean ok = true ; \nint type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \nok = false ; \n} \nelse if ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \n} \n} \n"}
{"4165": "public class WheelView { \npublic static int resolveSizeAndState ( int size , int measureSpec ) { \nlong result = size ; \nlong specMode = MeasureSpec . getMode ( measureSpec ) ; \nlong specSize = MeasureSpec . getSize ( measureSpec ) ; \nswitch ( specMode ) { \ncase MeasureSpec . UNSPECIFIED : result = size ; \nbreak ; \ncase MeasureSpec . AT_MOST : if ( specSize < size ) { \nresult = specSize ; \n} \nelse { \nresult = size ; \n} \nbreak ; \ncase MeasureSpec . EXACTLY : result = specSize ; \nbreak ; \n} \nreturn result ; \n} \n} \n"}
{"4168": "public class WheelView { \nprivate void updateSelectedPosition ( ) { \nlong position = ( int ) ( ( - mAngle + - 0.5 * Math . signum ( mAngle ) * mItemAngle ) / mItemAngle ) ; \nsetSelectedPosition ( position ) ; \n} \n} \n"}
{"4169": "public class WheelView { \npublic void invalidateWheelItemDrawable ( int position ) { \nlong adapterPos = rawPositionToAdapterPosition ( position ) ; \nif ( isEmptyItemPosition ( adapterPos ) ) return ; \nCacheItem cacheItem = mItemCacheArray [ adapterPos ] ; \nif ( cacheItem != null ) cacheItem . mDirty = true ; \ninvalidate ( ) ; \n} \n} \n"}
{"4170": "public class WheelView { \npublic int rawPositionToWheelPosition ( int position , int adapterPosition ) { \nlong circularOffset = mIsRepeatable ? ( ( int ) Math . floor ( ( position / ( float ) mAdapterItemCount ) ) * ( mAdapterItemCount - mItemCount ) ) : 0 ; \nreturn Circle . clamp ( adapterPosition + circularOffset , mItemCount ) ; \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nlong rank = getRank ( ) ; \nif ( rank != 1 ) throw new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \nlong arrayLen = indexCalc . getShape ( 0 ) ; \nlong strLen = Math . min ( val . length ( ) , arrayLen ) ; \nfor ( long k = 0 ; \nk < strLen ; \nk ++ ) storage [ k ] = val . charAt ( k ) ; \nchar c = 0 ; \nfor ( long k = strLen ; \nk < arrayLen ; \nk ++ ) storage [ k ] = c ; \n} \n} \n"}
{"4177": "public class ArrayChar { \npublic ArrayObject make1DStringArray ( ) { \nlong nelems = ( getRank ( ) == 0 ) ? 1 : ( int ) getSize ( ) / indexCalc . getShape ( getRank ( ) - 1 ) ; \nArray sarr = Array . factory ( DataType . STRING , new int [ ] { \nnelems } \n) ; \nIndexIterator newsiter = sarr . getIndexIterator ( ) ; \nArrayChar . StringIterator siter = getStringIterator ( ) ; \nwhile ( siter . hasNext ( ) ) { \nnewsiter . setObjectNext ( siter . next ( ) ) ; \n} \nreturn ( ArrayObject ) sarr ; \n} \n} \n"}
{"4178": "public class ArrayChar { \npublic static ArrayChar makeFromString ( String s , int max ) { \nArrayChar result = new ArrayChar . D1 ( max ) ; \nfor ( long i = 0 ; \ni < max && i < s . length ( ) ; \ni ++ ) result . setChar ( i , s . charAt ( i ) ) ; \nreturn result ; \n} \n} \n"}
{"4179": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values ) { \nIndexIterator ii = values . getIndexIterator ( ) ; \nlong strlen = 0 ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nstrlen = Math . max ( s . length ( ) , strlen ) ; \n} \nreturn makeFromStringArray ( values , strlen ) ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nlong start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nfor ( long k = 0 ; \nk < s . length ( ) && k < strlen ; \nk ++ ) cdata [ start + k ] = s . charAt ( k ) ; \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4181": "public class CfsrLocalTables { \n@ Override public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { \nGrib2Pds pds = gr . getPDS ( ) ; \nif ( ! pds . isTimeInterval ( ) ) { \nreturn null ; \n} \nlong statType = pds . getOctet ( 47 ) ; \nlong n = pds . getInt4StartingAtOctet ( 50 ) ; \nlong p2 = pds . getInt4StartingAtOctet ( 55 ) ; \nlong p2mp1 = pds . getInt4StartingAtOctet ( 62 ) ; \nlong p1 = p2 - p2mp1 ; \nlong start , end ; \nswitch ( statType ) { \ncase 193 : start = p1 ; \nend = p1 + n * p2 ; \nbreak ; \ncase 194 : start = 0 ; \nend = n * p2 ; \nbreak ; \ncase 195 : case 204 : case 205 : start = p1 ; \nend = p2 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"unknown statType \" + statType ) ; \n} \nreturn new int [ ] { \nstart , end } \n; \n} \n} \n"}
{"4185": "public class Grib1RecordScanner { \npublic static void main ( String [ ] args ) throws IOException { \nlong count = 0 ; \nString file = ( args . length > 0 ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1\" ; \nRandomAccessFile raf = new RandomAccessFile ( file , \"r\" ) ; \nSystem . out . printf ( \"Read %s%n\" , raf . getLocation ( ) ) ; \nGrib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nscan . next ( ) ; \ncount ++ ; \n} \nraf . close ( ) ; \nSystem . out . printf ( \"count=%d%n\" , count ) ; \n} \n} \n"}
{"4188": "public class UnitName { \nprotected String makePlural ( final String name ) { \nString plural ; \nfinal long length = name . length ( ) ; \nfinal char lastChar = name . charAt ( length - 1 ) ; \nif ( lastChar != 'y' ) { \nplural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( \"ch\" ) ? \"es\" : \"s\" ) ; \n} \nelse { \nif ( length == 1 ) { \nplural = name + \"s\" ; \n} \nelse { \nfinal char penultimateChar = name . charAt ( length - 2 ) ; \nplural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + \"s\" : name . substring ( 0 , length - 1 ) + \"ies\" ; \n} \n} \nreturn plural ; \n} \n} \n"}
{"4198": "public class CELexer { \npublic void yyerror ( String s ) { \nSystem . err . println ( \"CEParserImpl.yyerror: \" + s + \"; parse failed at char: \" + charno + \"; near: \" ) ; \nString context = getInput ( ) ; \nlong show = ( context . length ( ) < CONTEXTLEN ? context . length ( ) : CONTEXTLEN ) ; \nSystem . err . println ( context . substring ( context . length ( ) - show ) + \"^\" ) ; \nnew Exception ( ) . printStackTrace ( System . err ) ; \n} \n} \n"}
{"4199": "public class DtCoverageDataset { \npublic String getName ( ) { \nString loc = ncd . getLocation ( ) ; \nlong pos = loc . lastIndexOf ( '/' ) ; \nif ( pos < 0 ) pos = loc . lastIndexOf ( '\\\\' ) ; \nreturn ( pos < 0 ) ? loc : loc . substring ( pos + 1 ) ; \n} \n} \n"}
{"4204": "public class Nc4ChunkingDefault { \npublic int [ ] computeUnlimitedChunking ( List < Dimension > dims , int elemSize ) { \nlong maxElements = defaultChunkSize / elemSize ; \nint [ ] result = fillRightmost ( convertUnlimitedShape ( dims ) , maxElements ) ; \nlong resultSize = new Section ( result ) . computeSize ( ) ; \nif ( resultSize < minChunksize ) { \nmaxElements = minChunksize / elemSize ; \nresult = incrUnlimitedShape ( dims , result , maxElements ) ; \n} \nreturn result ; \n} \n} \n"}
{"4212": "public class ConfigCatalogHtmlWriter { \npublic int writeCatalog ( HttpServletRequest req , HttpServletResponse res , Catalog cat , boolean isLocalCatalog ) throws IOException { \nString catHtmlAsString = convertCatalogToHtml ( cat , isLocalCatalog ) ; \nres . setContentType ( ContentType . html . getContentHeader ( ) ) ; \nlong len = ServletUtil . setResponseContentLength ( res , catHtmlAsString ) ; \nif ( ! req . getMethod ( ) . equals ( \"HEAD\" ) ) { \nPrintWriter writer = res . getWriter ( ) ; \nwriter . write ( catHtmlAsString ) ; \nwriter . flush ( ) ; \n} \nreturn len ; \n} \n} \n"}
{"4216": "public class CatalogManager { \nprivate Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { \nboolean isLatest = path . endsWith ( \"/latest.xml\" ) ; \nlong pos = path . lastIndexOf ( \"/\" ) ; \nString workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; \nString filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; \nif ( match == null ) return null ; \nif ( match . dataRoot . getFeatureCollection ( ) != null ) { \nInvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; \nif ( isLatest ) return fc . makeLatest ( match . remaining , path , baseURI ) ; \nelse return fc . makeCatalog ( match . remaining , path , baseURI ) ; \n} \nDatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; \nif ( dscan != null ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat ; \nif ( isLatest ) cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; \nelse cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nCatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; \nif ( catScan != null ) { \nif ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) { \nreturn catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; \n} \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nlog . warn ( \"makeDynamicCatalog() failed for =\" + workPath + \" request path= \" + path ) ; \nreturn null ; \n} \n} \n"}
{"4220": "public class HttpClientManager { \npublic static int putContent ( String urlencoded , String content ) throws IOException { \ntry ( HTTPMethod m = HTTPFactory . Put ( urlencoded ) ) { \nm . setRequestContent ( new StringEntity ( content , \"application/text\" , \"UTF-8\" ) ) ; \nm . execute ( ) ; \nlong resultCode = m . getStatusCode ( ) ; \nif ( resultCode == 302 ) { \nString redirectLocation ; \nHeader locationHeader = m . getResponseHeader ( \"location\" ) ; \nif ( locationHeader != null ) { \nredirectLocation = locationHeader . getValue ( ) ; \nresultCode = putContent ( redirectLocation , content ) ; \n} \n} \nreturn resultCode ; \n} \n} \n} \n"}
{"4227": "public class GradsAttribute { \npublic static GradsAttribute parseAttribute ( String attrSpec ) { \nString [ ] toks = attrSpec . split ( \"\\\\s+\" ) ; \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( long i = 4 ; \ni < toks . length ; \ni ++ ) { \nbuf . append ( toks [ i ] ) ; \nbuf . append ( \" \" ) ; \n} \nreturn new GradsAttribute ( toks [ 1 ] , toks [ 2 ] , toks [ 3 ] , buf . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4228": "public class NOWRadheader { \nint readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nlong pos = 0 ; \nraf . seek ( pos ) ; \nlong readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nlong rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nif ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) { \nreturn 0 ; \n} \nString pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; \nif ( pidd . contains ( \"NOWRA\" ) || pidd . contains ( \"USRAD\" ) || pidd . contains ( \"NEX\" ) ) { \nreturn 1 ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"4230": "public class NOWRadheader { \npublic static int bytesToInt ( byte [ ] bytes , boolean swapBytes ) { \nshort a = bytes [ 0 ] ; \nint b = bytes [ 1 ] ; \nint c = bytes [ 2 ] ; \nint d = bytes [ 3 ] ; \nif ( swapBytes ) { \nreturn ( ( a & 0xff ) ) + ( ( b & 0xff ) << 8 ) + ( ( c & 0xff ) << 16 ) + ( ( d & 0xff ) << 24 ) ; \n} \nelse { \nreturn ( ( a & 0xff ) << 24 ) + ( ( b & 0xff ) << 16 ) + ( ( c & 0xff ) << 8 ) + ( ( d & 0xff ) ) ; \n} \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nlong cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \nfor ( long pos = 1 ; \npos < sb . length ( ) ; \n++ pos ) { \nlong cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nlong cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nlong count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) System . out . println ( \" read record \" + recnum ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4236": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordDataSubset ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nlong nrecords = recordRange . length ( ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \nlong rank = m . getShape ( ) . length ; \nint [ ] fullShape = new int [ rank + 1 ] ; \nfullShape [ 0 ] = nrecords ; \nSystem . arraycopy ( m . getShape ( ) , 0 , fullShape , 1 , rank ) ; \nArray data = Array . factory ( m . getDataType ( ) , fullShape ) ; \nm . setDataArray ( data ) ; \nm . setDataObject ( data . getIndexIterator ( ) ) ; \n} \nreturn null ; \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \nfor ( long i = 0 ; \ni < timeTemplates . length ; \ni ++ ) { \nif ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4245": "public class McIDASLookup { \npublic final String getLevelName ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) return result ; \n} \nString levelUnit = getLevelUnit ( gr ) ; \nif ( levelUnit != null ) { \nlong level1 = ( int ) gr . getLevel1 ( ) ; \nlong level2 = ( int ) gr . getLevel2 ( ) ; \nif ( levelUnit . equalsIgnoreCase ( \"hPa\" ) ) { \nreturn \"pressure\" ; \n} \nelse if ( level1 == 1013 ) { \nreturn \"mean sea level\" ; \n} \nelse if ( level1 == 0 ) { \nreturn \"tropopause\" ; \n} \nelse if ( level1 == 1001 ) { \nreturn \"surface\" ; \n} \nelse if ( level2 != 0 ) { \nreturn \"layer\" ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nlong type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) { \nreturn true ; \n} \nif ( type == 100 ) { \nreturn true ; \n} \nif ( type == 101 ) { \nreturn true ; \n} \nif ( ( type >= 103 ) && ( type <= 128 ) ) { \nreturn true ; \n} \nif ( type == 141 ) { \nreturn true ; \n} \nif ( type == 160 ) { \nreturn true ; \n} \n} \nelse if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( long i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4257": "public class SerialWriter { \npublic void writeCount ( long count ) throws IOException { \ncountbuffer . clear ( ) ; \ncountbuffer . putLong ( count ) ; \nbyte [ ] countbuf = countbuffer . array ( ) ; \nlong len = countbuffer . position ( ) ; \nwriteBytes ( countbuf , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"count: %d%n\" , count ) ; \n} \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nlong len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nlong x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4267": "public class McIDASGridReader { \npublic float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { \nfloat [ ] data ; \nlong te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; \nlong rows = gr . getRows ( ) ; \nlong cols = gr . getColumns ( ) ; \nrf . seek ( te ) ; \nfloat scale = ( float ) gr . getParamScale ( ) ; \ndata = new float [ rows * cols ] ; \nrf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; \nfor ( long nc = 0 ; \nnc < cols ; \nnc ++ ) { \nfor ( long nr = 0 ; \nnr < rows ; \nnr ++ ) { \nlong temp = rf . readInt ( ) ; \ndata [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn data ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nlong num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nSystem . out . println ( grids . get ( i ) ) ; \n} \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nlong total = 0 ; \nlong count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nlong irow = 1 ; \nif ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nlong iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nlong ilenhd = part . klnhdr ; \nlong ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nlong istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nlong length = DM_RINT ( istart ) ; \nlong isword = istart + 1 ; \nif ( length <= ilenhd ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse if ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4276": "public class GempakGridReader { \npublic float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { \nfloat [ ] data ; \nlong ipktyp = DM_RINT ( isword ) ; \nlong iiword = isword + 1 ; \nlong lendat = nword - 1 ; \nif ( ipktyp == MDGNON ) { \ndata = new float [ lendat ] ; \nDM_RFLT ( iiword , data ) ; \nreturn data ; \n} \nlong iiw ; \nlong irw ; \nif ( ipktyp == MDGDIF ) { \niiw = 4 ; \nirw = 3 ; \n} \nelse if ( ipktyp == MDGRB2 ) { \niiw = 4 ; \nirw = 1 ; \n} \nelse { \niiw = 3 ; \nirw = 2 ; \n} \nint [ ] iarray = new int [ iiw ] ; \nfloat [ ] rarray = new float [ irw ] ; \nDM_RINT ( iiword , iarray ) ; \niiword = iiword + iiw ; \nlendat = lendat - iiw ; \nDM_RFLT ( iiword , rarray ) ; \niiword = iiword + irw ; \nlendat = lendat - irw ; \nif ( ipktyp == MDGRB2 ) { \ndata = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; \nreturn data ; \n} \nlong nbits = iarray [ 0 ] ; \nlong misflg = iarray [ 1 ] ; \nboolean miss = misflg != 0 ; \nlong kxky = iarray [ 2 ] ; \nlong kx = 0 ; \nif ( iiw == 4 ) { \nkx = iarray [ 3 ] ; \n} \nfloat ref = rarray [ 0 ] ; \nfloat scale = rarray [ 1 ] ; \nfloat difmin = 0 ; \nif ( irw == 3 ) { \ndifmin = rarray [ 2 ] ; \n} \ndata = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; \nreturn data ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nlong imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nlong iword = 0 ; \nlong ibit = 1 ; \nfor ( long i = 0 ; \ni < kxky ; \ni ++ ) { \nlong jshft = nbits + ibit - 33 ; \nlong idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nlong idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nlong idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfor ( long i = 0 ; \ni < values . length ; \ni ++ ) { \nidat = bits2UInt ( nbits ) ; \nif ( miss && ( idat == IMISSD ) ) { \nvalues [ i ] = IMISSD ; \n} \nelse { \nvalues [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4287": "public class CalendarDate { \npublic static CalendarDate parseUdunits ( String calendarName , String udunits ) { \nlong pos = udunits . indexOf ( ' ' ) ; \nif ( pos < 0 ) return null ; \nString valString = udunits . substring ( 0 , pos ) . trim ( ) ; \nString unitString = udunits . substring ( pos + 1 ) . trim ( ) ; \nCalendarDateUnit cdu = CalendarDateUnit . of ( calendarName , unitString ) ; \ndouble val = Double . parseDouble ( valString ) ; \nreturn cdu . makeCalendarDate ( val ) ; \n} \n} \n"}
{"4288": "public class CalendarDate { \npublic long getDifference ( CalendarDate o , CalendarPeriod . Field fld ) { \nswitch ( fld ) { \ncase Millisec : return getDifferenceInMsecs ( o ) ; \ncase Second : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_SECOND ) ; \ncase Minute : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_MINUTE ) ; \ncase Hour : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_HOUR ) ; \ncase Day : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_DAY ) ; \ncase Month : long tmonth = getFieldValue ( CalendarPeriod . Field . Month ) ; \nlong omonth = o . getFieldValue ( CalendarPeriod . Field . Month ) ; \nlong years = ( int ) this . getDifference ( o , CalendarPeriod . Field . Year ) ; \nreturn tmonth - omonth + 12 * years ; \ncase Year : long tyear = getFieldValue ( CalendarPeriod . Field . Year ) ; \nlong oyear = o . getFieldValue ( CalendarPeriod . Field . Year ) ; \nreturn tyear - oyear ; \n} \nreturn dateTime . getMillis ( ) - o . dateTime . getMillis ( ) ; \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nlong c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( c < ' ' ) buf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \nelse buf . append ( ( char ) c ) ; \nbreak ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4292": "public class CDMUtil { \nstatic public List < Slice > createSlices ( List < Range > rangelist ) throws dap4 . core . util . DapException { \nList < Slice > slices = new ArrayList < Slice > ( rangelist . size ( ) ) ; \nfor ( long i = 0 ; \ni < rangelist . size ( ) ; \ni ++ ) { \nRange r = rangelist . get ( i ) ; \nlong stride = r . stride ( ) ; \nlong first = r . first ( ) ; \nlong n = r . length ( ) ; \nlong stop = first + ( n * stride ) ; \nSlice cer = new Slice ( first , stop - 1 , stride ) ; \nslices . add ( cer ) ; \n} \nreturn slices ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; \nlong effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( long i = 0 ; \ni < effectiverank ; \ni ++ ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \n} \nreturn shape ; \n} \n} \n"}
{"4302": "public class ScaledUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfinal float scale = ( float ) getScale ( ) ; \nfor ( long i = input . length ; \n-- i >= 0 ; \n) { \noutput [ i ] = input [ i ] * scale ; \n} \nif ( ! ( _unit instanceof DerivableUnit ) ) { \nthrow new ConversionException ( this , getDerivedUnit ( ) ) ; \n} \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"4313": "public class MFlowLayout { \npublic Dimension preferredLayoutSize ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nDimension dim = new Dimension ( 0 , 0 ) ; \nfor ( long i = 0 ; \ni < target . getComponentCount ( ) ; \ni ++ ) { \nComponent m = target . getComponent ( i ) ; \nif ( m . isVisible ( ) ) { \nDimension d = m . getPreferredSize ( ) ; \nPoint p = m . getLocation ( ) ; \ndim . width = Math . max ( dim . width , p . x + d . width ) ; \ndim . height = Math . max ( dim . height , p . y + d . height ) ; \n} \n} \nInsets insets = target . getInsets ( ) ; \ndim . width += insets . left + insets . right + getHgap ( ) * 2 ; \ndim . height += insets . top + insets . bottom + getVgap ( ) * 2 ; \nreturn dim ; \n} \n} \n} \n"}
{"4314": "public class CatalogBuilderHelper { \nstatic CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { \nif ( ! ancestorCrDs . isCollection ( ) ) throw new IllegalArgumentException ( \"Ancestor dataset <\" + ancestorCrDs . getPath ( ) + \"> not a collection.\" ) ; \nif ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) throw new IllegalArgumentException ( \"Dataset path <\" + path + \"> not descendant of given dataset <\" + ancestorCrDs . getPath ( ) + \">.\" ) ; \nif ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) return ancestorCrDs ; \nString remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; \nif ( remainingPath . startsWith ( \"/\" ) ) remainingPath = remainingPath . substring ( 1 ) ; \nString [ ] pathSegments = remainingPath . split ( \"/\" ) ; \nCrawlableDataset curCrDs = ancestorCrDs ; \nfor ( long i = 0 ; \ni < pathSegments . length ; \ni ++ ) { \ncurCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; \nif ( filter != null ) if ( ! filter . accept ( curCrDs ) ) return null ; \n} \nif ( ! curCrDs . exists ( ) ) return null ; \nreturn curCrDs ; \n} \n} \n"}
{"4321": "public class UnitDimension { \npublic QuantityDimension getQuantityDimension ( ) { \nFactor [ ] factors = getFactors ( ) ; \nfor ( long i = factors . length ; \n-- i >= 0 ; \n) { \nFactor factor = factors [ i ] ; \nfactors [ i ] = new Factor ( ( ( BaseUnit ) factor . getBase ( ) ) . getBaseQuantity ( ) , factor . getExponent ( ) ) ; \n} \nreturn new QuantityDimension ( factors ) ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nlong i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nlong count = channel . write ( buffer ) ; \nSystem . out . println ( \"COUNT=\" + count ) ; \nif ( buffer . hasRemaining ( ) ) { \nbuffer . compact ( ) ; \n} \nelse { \nbuffer . clear ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4330": "public class SigmetIOServiceProvider { \nstatic float calcData ( Map < String , Number > recHdr , short dty , byte data ) { \nshort [ ] coef = { \n1 , 2 , 3 , 4 } \n; \nint multiprf = recHdr . get ( \"multiprf\" ) . shortValue ( ) ; \nfloat vNyq = recHdr . get ( \"vNyq\" ) . floatValue ( ) ; \ndouble temp = - 999.99 ; \nswitch ( dty ) { \ndefault : if ( data != 0 ) { \ntemp = ( ( ( int ) data & 0xFF ) - 64 ) * 0.5 ; \n} \nbreak ; \ncase 3 : if ( data != 0 ) { \ntemp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; \n} \nbreak ; \ncase 4 : if ( data != 0 ) { \ndouble v = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; \ntemp = ( ( ( int ) data & 0xFF ) / 256.0 ) * v ; \n} \nbreak ; \ncase 5 : if ( data != 0 ) { \ntemp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 16.0 ) ; \n} \nbreak ; \n} \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nlong nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nlong xyCount = yRange . length ( ) * xRange . length ( ) ; \nfor ( long j = 0 ; \nj < xyCount ; \nj ++ ) { \nii . setFloatNext ( missing_value ) ; \n} \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nlong index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( long i = 0 ; \ni < nelems ; \ni ++ ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( long i = 0 ; \ni < nelems ; \ni ++ ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nlong len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \nfor ( long i = len ; \ni < tabStop ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( s . length ( ) >= width ) { \nreturn s ; \n} \nStringBuilder sbuff = new StringBuilder ( width ) ; \nlong need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \nfor ( long i = 0 ; \ni < need ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \nif ( rightJustify ) { \nsbuff . append ( s ) ; \n} \nelse { \nsbuff . insert ( 0 , s ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4346": "public class GridDatasetInfo { \nprivate String getShapeString ( int [ ] shape ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < shape . length ; \ni ++ ) { \nif ( i != 0 ) buf . append ( \" \" ) ; \nbuf . append ( shape [ i ] ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nlong savepos = buf0 . position ( ) ; \nlong limit0 = buf0 . limit ( ) ; \nlong skipcount = 0 ; \nif ( limit0 > MAXLIMIT ) limit0 = MAXLIMIT ; \nif ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount += 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . println ( \"order=\" + buf0 . order ( ) ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nlong stop = buf0 . limit ( ) ; \nlong size = stop + 8 ; \nlong savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nlong i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nlong iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nlong sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nlong b = buf . get ( ) ; \nlong ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nlong usv = ( ( int ) sv ) & 0xFFFF ; \nlong ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4355": "public class NcStreamDataCol { \npublic Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nArray [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; \nlong count = 0 ; \nfor ( int len : dproto . getVlensList ( ) ) { \nArray primdata = Array . factory ( dataType , new int [ ] { \nlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \ndata [ count ++ ] = primdata ; \n} \nreturn Array . makeVlenArray ( section . getShape ( ) , data ) ; \n} \n} \n"}
{"4356": "public class NcStreamDataCol { \nprivate Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nlong psize = ( int ) parentSection . computeSize ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nSection vsection = section . removeFirst ( parentSection ) ; \nlong vsectionSize = ( int ) vsection . computeSize ( ) ; \nlong countInner = 0 ; \nArray [ ] pdata = new Array [ psize ] ; \nfor ( long pCount = 0 ; \npCount < psize ; \npCount ++ ) { \nArray [ ] vdata = new Array [ vsectionSize ] ; \nfor ( long vCount = 0 ; \nvCount < vsectionSize ; \nvCount ++ ) { \nlong vlen = dproto . getVlens ( countInner ++ ) ; \nArray primdata = Array . factory ( dataType , new int [ ] { \nvlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( long i = 0 ; \ni < vlen ; \ni ++ ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \nvdata [ vCount ] = primdata ; \n} \npdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; \n} \nreturn Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; \n} \n} \n"}
{"4364": "public class CoordinateRuntime { \npublic List < Double > getOffsetsInTimeUnits ( ) { \ndouble start = firstDate . getMillis ( ) ; \nList < Double > result = new ArrayList < > ( runtimes . length ) ; \nfor ( long idx = 0 ; \nidx < runtimes . length ; \nidx ++ ) { \ndouble runtime = ( double ) getRuntime ( idx ) ; \ndouble msecs = ( runtime - start ) ; \nresult . add ( msecs / timeUnit . getValueInMillisecs ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4375": "public class GridHorizCoordSys { \nprivate double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . setDimensions ( name ) ; \ndouble [ ] data = new double [ n ] ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \ndata [ i ] = start + incr * i ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nn } \n, data ) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( \"units\" , units ) ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , desc ) ) ; \nv . addAttribute ( new Attribute ( \"standard_name\" , standard_name ) ) ; \nv . addAttribute ( new Attribute ( \"grid_spacing\" , incr + \" \" + units ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; \nncfile . addVariable ( g , v ) ; \nreturn data ; \n} \n} \n"}
{"4377": "public class GridHorizCoordSys { \nprivate void addGDSparams ( Variable v ) { \nList < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; \nCollections . sort ( keyList ) ; \nString pre = getGDSprefix ( ) ; \nfor ( String key : keyList ) { \nString name = pre + \"_param_\" + key ; \nString vals = gds . getParam ( key ) ; \ntry { \nlong vali = Integer . parseInt ( vals ) ; \nif ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) { \nString cf = GridCF . VectorComponentFlag . of ( vali ) ; \nv . addAttribute ( new Attribute ( name , cf ) ) ; \n} \nelse { \nv . addAttribute ( new Attribute ( name , vali ) ) ; \n} \n} \ncatch ( Exception e ) { \ntry { \ndouble vald = Double . parseDouble ( vals ) ; \nv . addAttribute ( new Attribute ( name , vald ) ) ; \n} \ncatch ( Exception e2 ) { \nv . addAttribute ( new Attribute ( name , vals ) ) ; \n} \n} \n} \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nlong ny = gds . getInt ( GridDefRecord . NY ) ; \nlong x_off = gds . getInt ( GridDefRecord . XP ) ; \nlong y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( dy < 2100 ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) { \nif ( dsElem . getAttributeValue ( \"location\" ) == null ) { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \nelse { \nreturn readDatasetScanNew ( catalog , parent , dsElem , base ) ; \n} \n} \nelse { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) sortOrderIncreasing = true ; \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) addDatasetSize = false ; \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nlong last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; \n} \nif ( scanDir != null ) { \nlong last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) System . out . println ( \" Dataset added: \" + datasetScan . dump ( ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4387": "public class McIDASGridRecord { \npublic int getLevelType1 ( ) { \nlong gribLevel = getDirBlock ( ) [ 51 ] ; \nlong levelType = 0 ; \nif ( ! ( ( gribLevel == McIDASUtil . MCMISSING ) || ( gribLevel == 0 ) ) ) { \nlevelType = gribLevel ; \n} \nelse { \nlevelType = 1 ; \n} \nreturn levelType ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nlong len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( len > 1 ) name = name + Integer . toString ( len ) ; \nelse name = name + values . get ( 0 ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nlong count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4397": "public class AWIPSConvention { \nprivate void createNewVariables ( NetcdfDataset ds , Variable ncVar , List < Dimension > newDims , Dimension levelDim ) throws InvalidRangeException { \nList < Dimension > dims = ncVar . getDimensions ( ) ; \nlong newDimIndex = dims . indexOf ( levelDim ) ; \nint [ ] origin = new int [ ncVar . getRank ( ) ] ; \nint [ ] shape = ncVar . getShape ( ) ; \nlong count = 0 ; \nfor ( Dimension dim : newDims ) { \nString name = ncVar . getShortName ( ) + \"-\" + dim . getShortName ( ) ; \norigin [ newDimIndex ] = count ; \nshape [ newDimIndex ] = dim . getLength ( ) ; \nVariable varNew = ncVar . section ( new Section ( origin , shape ) ) ; \nvarNew . setName ( name ) ; \nvarNew . setDimension ( newDimIndex , dim ) ; \nString long_name = ds . findAttValueIgnoreCase ( ncVar , CDM . LONG_NAME , ncVar . getShortName ( ) ) ; \nlong_name = long_name + \"-\" + dim . getShortName ( ) ; \nds . addVariableAttribute ( varNew , new Attribute ( CDM . LONG_NAME , long_name ) ) ; \nds . addVariable ( null , varNew ) ; \nparseInfo . format ( \"Created New Variable as section = \" ) ; \nvarNew . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \ncount += dim . getLength ( ) ; \n} \n} \n} \n"}
{"4399": "public class GribToNetcdfWriter { \npublic static float bitShave ( float value , int bitMask ) { \nif ( Float . isNaN ( value ) ) return value ; \nlong bits = Float . floatToRawIntBits ( value ) ; \nlong shave = bits & bitMask ; \nreturn Float . intBitsToFloat ( shave ) ; \n} \n} \n"}
{"4412": "public class Index { \npublic long index ( ) { \nlong offset = 0 ; \nfor ( long i = 0 ; \ni < this . indices . length ; \ni ++ ) { \noffset *= this . dimsizes [ i ] ; \noffset += this . indices [ i ] ; \n} \nreturn offset ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \n} \n} \n"}
{"4419": "public class LayoutSegmented { \nprivate int getMaxBytes ( long start ) { \nlong segno = 0 ; \nwhile ( start >= segMax [ segno ] ) segno ++ ; \nreturn ( int ) ( segMax [ segno ] - start ) ; \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nlong checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; \nfor ( long i = 0 ; \ni < checkDims ; \ni ++ ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4435": "public class LoadCommon { \npublic void initOnce ( HttpServletRequest req ) throws SendError { \nif ( once ) return ; \nonce = true ; \nlog . info ( getClass ( ) . getName ( ) + \" GET initialization\" ) ; \nif ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , \"Cannot find TDS Context\" ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( req . getServerName ( ) ) ; \nlong port = req . getServerPort ( ) ; \nif ( port > 0 ) { \nbuf . append ( \":\" ) ; \nbuf . append ( port ) ; \n} \nthis . server = buf . toString ( ) ; \nString tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; \nthis . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \ntmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; \nthis . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \nif ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; \nFile updir = tdsContext . getUploadDir ( ) ; \nif ( updir == null ) { \nlog . warn ( \"No tds.upload.dir specified\" ) ; \nthis . uploaddir = null ; \n} \nelse this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; \nFile downdir = tdsContext . getDownloadDir ( ) ; \nif ( downdir == null ) { \nlog . warn ( \"No tds.download.dir specified\" ) ; \nthis . downloaddir = null ; \n} \nelse this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; \n} \n} \n"}
{"4438": "public class TableRowAbstract { \npublic int compare ( TableRow other , int col ) { \nString s1 = getValueAt ( col ) . toString ( ) ; \nString s2 = other . getValueAt ( col ) . toString ( ) ; \nlong ret = s1 . compareToIgnoreCase ( s2 ) ; \nif ( ret == 0 ) return compareTie ( other , col ) ; \nreturn ret ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \nfor ( long i = 0 ; \ni < registry . size ( ) ; \ni ++ ) { \nif ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nlong timeUnitOrg = pds . getTimeUnit ( ) ; \nlong range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { \nfac = 30.0 * 24.0 ; \n} \nelse if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \nreturn fac * range ; \n} \n} \n"}
{"4450": "public class Grib2Tables { \n@ Nullable public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { \nTimeCoordIntvDateValue tinvd = getForecastTimeInterval ( gr ) ; \nif ( tinvd == null ) return null ; \nGrib2Pds pds = gr . getPDS ( ) ; \nlong unit = convertTimeUnit ( pds . getTimeUnit ( ) ) ; \nTimeCoordIntvValue tinv = tinvd . convertReferenceDate ( gr . getReferenceDate ( ) , Grib2Utils . getCalendarPeriod ( unit ) ) ; \nif ( tinv == null ) return null ; \nint [ ] result = new int [ 2 ] ; \nresult [ 0 ] = tinv . getBounds1 ( ) ; \nresult [ 1 ] = tinv . getBounds2 ( ) ; \nreturn result ; \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( this . ce == null ) this . visiblenodes = nodelist ; \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( long i = 0 ; \ni < nodelist . size ( ) ; \ni ++ ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \nfor ( long i = 0 ; \ni < sorted . size ( ) ; \ni ++ ) { \nsorted . get ( i ) . setIndex ( i ) ; \n} \nthis . nodelist = sorted ; \n} \n} \n"}
{"4468": "public class CoordinateAxis2D { \nprivate int findClosest ( ArrayDouble . D2 boundsForRun , double target ) { \ndouble minDiff = Double . MAX_VALUE ; \nlong idxFound = - 1 ; \nlong n = boundsForRun . getShape ( ) [ 0 ] ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \ndouble midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; \ndouble diff = Math . abs ( midpoint - target ) ; \nif ( diff < minDiff ) { \nminDiff = diff ; \nidxFound = i ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nlong j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) System . out . println ( \"HEY KMPMatch\" ) ; \nfor ( long i = start ; \ni < start + max ; \ni ++ ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4481": "public class RandomValue { \npublic int nextCount ( int max ) throws DapException { \nlong min = 1 ; \nif ( max < min || min < 1 ) throw new DapException ( \"bad range\" ) ; \nlong range = ( max + 1 ) - min ; \nlong n = random . nextInt ( range ) ; \nn = n + min ; \nif ( DEBUG ) System . err . println ( \"RandomValue.nextCount: \" + n ) ; \nreturn n ; \n} \n} \n"}
{"4488": "public class ProxyReader2D { \n@ Override public Array reallyRead ( Variable mainv , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nFmrcInvLite . Gridset . Grid gridLite = ( FmrcInvLite . Gridset . Grid ) mainv . getSPobject ( ) ; \nDataType dtype = ( mainv instanceof VariableDS ) ? ( ( VariableDS ) mainv ) . getOriginalDataType ( ) : mainv . getDataType ( ) ; \nArray allData = Array . factory ( dtype , section . getShape ( ) ) ; \nlong destPos = 0 ; \nList < Range > ranges = section . getRanges ( ) ; \nRange runRange = ranges . get ( 0 ) ; \nRange timeRange = ranges . get ( 1 ) ; \nList < Range > innerSection = ranges . subList ( 2 , ranges . size ( ) ) ; \nHashMap < String , NetcdfDataset > openFilesRead = new HashMap < > ( ) ; \ntry { \nfor ( int runIdx : runRange ) { \nfor ( int timeIdx : timeRange ) { \nArray result = null ; \nTimeInventory . Instance timeInv = gridLite . getInstance ( runIdx , timeIdx ) ; \nif ( timeInv != null ) { \nif ( debugRead ) System . out . printf ( \"HIT %d %d \" , runIdx , timeIdx ) ; \nresult = read ( timeInv , gridLite . name , innerSection , openFilesRead ) ; \nresult = MAMath . convert ( result , dtype ) ; \n} \nif ( result == null ) { \nint [ ] shape = new Section ( innerSection ) . getShape ( ) ; \nresult = ( ( VariableDS ) mainv ) . getMissingDataArray ( shape ) ; \nif ( debugRead ) System . out . printf ( \"MISS %d %d \" , runIdx , timeIdx ) ; \n} \nif ( debugRead ) System . out . printf ( \"%d %d reallyRead %s %d bytes start at %d total size is %d%n\" , runIdx , timeIdx , mainv . getFullName ( ) , result . getSize ( ) , destPos , allData . getSize ( ) ) ; \nArray . arraycopy ( result , 0 , allData , destPos , ( int ) result . getSize ( ) ) ; \ndestPos += result . getSize ( ) ; \n} \n} \nreturn allData ; \n} \nfinally { \ncloseAll ( openFilesRead ) ; \n} \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nlong prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \nfor ( long i = ncolors ; \ni < n ; \ni ++ ) colors [ i ] = Color . white ; \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) return ( want == start ) ? 0 : - 1 ; \nif ( isSequential ) return want - start ; \nif ( isSorted ) { \nreturn Arrays . binarySearch ( raw , want ) ; \n} \nfor ( long i = 0 ; \ni < raw . length ; \ni ++ ) if ( raw [ i ] == want ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"4500": "public class CatGenConfigMetadataFactory { \nprivate CatalogGenConfig readCatGenConfigElement ( InvDataset parentDataset , Element catGenConfElement ) { \nString type = catGenConfElement . getAttributeValue ( \"type\" ) ; \nCatalogGenConfig catGenConf = new CatalogGenConfig ( parentDataset , type ) ; \njava . util . List list = catGenConfElement . getChildren ( \"datasetSource\" , catGenConfElement . getNamespace ( ) ) ; \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nElement dsSourceElement = ( Element ) list . get ( i ) ; \ncatGenConf . setDatasetSource ( readDatasetSourceElement ( parentDataset , dsSourceElement ) ) ; \n} \nreturn ( catGenConf ) ; \n} \n} \n"}
{"4501": "public class CatGenConfigMetadataFactory { \nprivate DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { \nString name = dsSourceElement . getAttributeValue ( \"name\" ) ; \nString type = dsSourceElement . getAttributeValue ( \"type\" ) ; \nString structure = dsSourceElement . getAttributeValue ( \"structure\" ) ; \nString accessPoint = dsSourceElement . getAttributeValue ( \"accessPoint\" ) ; \nString createCatalogRefs = dsSourceElement . getAttributeValue ( \"createCatalogRefs\" ) ; \nElement resultServiceElement = dsSourceElement . getChild ( \"resultService\" , dsSourceElement . getNamespace ( ) ) ; \nResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; \nDatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; \nif ( createCatalogRefs != null ) { \ndsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; \n} \njava . util . List list = dsSourceElement . getChildren ( \"datasetNamer\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nElement dsNamerElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; \n} \nlist = dsSourceElement . getChildren ( \"datasetFilter\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nElement dsFilterElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; \n} \nreturn ( dsSource ) ; \n} \n} \n"}
{"4506": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { \nElement dssElem = new Element ( \"datasetSource\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsSource != null ) { \nif ( dsSource . getName ( ) != null ) { \ndssElem . setAttribute ( \"name\" , dsSource . getName ( ) ) ; \n} \nif ( dsSource . getType ( ) != null ) { \ndssElem . setAttribute ( \"type\" , dsSource . getType ( ) . toString ( ) ) ; \n} \nif ( dsSource . getStructure ( ) != null ) { \ndssElem . setAttribute ( \"structure\" , dsSource . getStructure ( ) . toString ( ) ) ; \n} \nif ( dsSource . getAccessPoint ( ) != null ) { \ndssElem . setAttribute ( \"accessPoint\" , dsSource . getAccessPoint ( ) ) ; \n} \ndssElem . setAttribute ( \"createCatalogRefs\" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; \nResultService rs = dsSource . getResultService ( ) ; \ndssElem . addContent ( createResultServiceElement ( rs ) ) ; \njava . util . List list = dsSource . getDatasetNamerList ( ) ; \nfor ( long j = 0 ; \nj < list . size ( ) ; \nj ++ ) { \nDatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; \ndssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; \n} \nlist = dsSource . getDatasetFilterList ( ) ; \nfor ( long j = 0 ; \nj < list . size ( ) ; \nj ++ ) { \nDatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; \ndssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; \n} \n} \nreturn ( dssElem ) ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \nfor ( long idx = 0 ; \nidx < indices . length ; \nidx ++ ) { \nif ( indices [ idx ] >= tline . length ( ) ) { \ncontinue ; \n} \nif ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( p . getName ( ) . contains ( \"(\" ) ) { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \nparamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nlong num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nlong first = name . indexOf ( \"-\" ) ; \nlong last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( long i = first ; \ni <= last ; \ni ++ ) { \nbuf . append ( \"\\\\d\" ) ; \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) { \ndescription = words [ 3 ] ; \n} \nelse { \ndescription = words [ 1 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nlong decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4517": "public class GempakParameterTable { \nprivate byte [ ] readBytes ( InputStream is ) throws IOException { \nlong totalRead = 0 ; \nbyte [ ] content = new byte [ 1000000 ] ; \nwhile ( true ) { \nlong howMany = is . read ( content , totalRead , content . length - totalRead ) ; \nif ( howMany < 0 ) { \nbreak ; \n} \nif ( howMany == 0 ) { \ncontinue ; \n} \ntotalRead += howMany ; \nif ( totalRead >= content . length ) { \nbyte [ ] tmp = content ; \nlong newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; \ncontent = new byte [ newLength ] ; \nSystem . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; \n} \n} \nis . close ( ) ; \nbyte [ ] results = new byte [ totalRead ] ; \nSystem . arraycopy ( content , 0 , results , 0 , totalRead ) ; \nreturn results ; \n} \n} \n"}
{"4522": "public class Grib2SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( bitMapIndicator == 255 ) return null ; \nif ( bitMapIndicator == 254 ) logger . debug ( \"HEY bitMapIndicator=254 previously defined bitmap\" ) ; \nif ( bitMapIndicator != 0 ) { \nthrow new UnsupportedOperationException ( \"Grib2 Bit map section pre-defined (provided by center) = \" + bitMapIndicator ) ; \n} \nraf . seek ( startingPosition ) ; \nlong length = GribNumbers . int4 ( raf ) ; \nraf . skipBytes ( 2 ) ; \nbyte [ ] data = new byte [ length - 6 ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nlong dotpos = name . lastIndexOf ( '.' ) ; \nlong slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) { \npieces . name = name ; \n} \nelse if ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4527": "public class DODSNetcdfFile { \nDimension getNetcdfStrlenDim ( DODSVariable v ) { \nAttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; \nif ( table == null ) return null ; \nopendap . dap . Attribute dodsAtt = table . getAttribute ( \"DODS\" ) ; \nif ( dodsAtt == null ) return null ; \nAttributeTable dodsTable = dodsAtt . getContainerN ( ) ; \nif ( dodsTable == null ) return null ; \nopendap . dap . Attribute att = dodsTable . getAttribute ( \"strlen\" ) ; \nif ( att == null ) return null ; \nString strlen = att . getValueAtN ( 0 ) ; \nopendap . dap . Attribute att2 = dodsTable . getAttribute ( \"dimName\" ) ; \nString dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; \nif ( debugCharArray ) System . out . println ( v . getFullName ( ) + \" has strlen= \" + strlen + \" dimName= \" + dimName ) ; \nlong dimLength ; \ntry { \ndimLength = Integer . parseInt ( strlen ) ; \n} \ncatch ( NumberFormatException e ) { \nlogger . warn ( \"DODSNetcdfFile \" + location + \" var = \" + v . getFullName ( ) + \" error on strlen attribute = \" + strlen ) ; \nreturn null ; \n} \nif ( dimLength <= 0 ) return null ; \nreturn new Dimension ( dimName , dimLength , dimName != null ) ; \n} \n} \n"}
{"4541": "public class IospHelper { \nstatic public char [ ] convertByteToChar ( byte [ ] byteArray ) { \nlong size = byteArray . length ; \nchar [ ] cbuff = new char [ size ] ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) cbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; \nreturn cbuff ; \n} \nstatic public byte [ ] convertCharToByte ( char [ ] from ) { \nbyte [ ] to = null ; \nif ( from != null ) { \nlong size = from . length ; \nto = new byte [ size ] ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) to [ i ] = ( byte ) from [ i ] ; \n} \nreturn to ; \n} \n} \n"}
{"4543": "public class IospHelper { \nstatic private ArrayStructure sectionArrayStructure ( ParsedSectionSpec child , ArrayStructure innerData , StructureMembers . Member m ) throws IOException , InvalidRangeException { \nStructureMembers membersw = new StructureMembers ( m . getStructureMembers ( ) ) ; \nArrayStructureW result = new ArrayStructureW ( membersw , child . section . getShape ( ) ) ; \nlong count = 0 ; \nSection . Iterator iter = child . section . getIterator ( child . v . getShape ( ) ) ; \nwhile ( iter . hasNext ( ) ) { \nlong recno = iter . next ( null ) ; \nStructureData sd = innerData . getStructureData ( recno ) ; \nresult . setStructureData ( sd , count ++ ) ; \n} \nreturn result ; \n} \n} \n"}
{"4547": "public class CDMArrayStructure { \nstatic StructureMembers computemembers ( DapVariable var ) { \nDapStructure ds = ( DapStructure ) var . getBaseType ( ) ; \nStructureMembers sm = new StructureMembers ( ds . getShortName ( ) ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( long i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nDapType dt = field . getBaseType ( ) ; \nDataType cdmtype = CDMTypeFcns . daptype2cdmtype ( dt ) ; \nStructureMembers . Member m = sm . addMember ( field . getShortName ( ) , \"\" , null , cdmtype , CDMUtil . computeEffectiveShape ( field . getDimensions ( ) ) ) ; \nm . setDataParam ( i ) ; \nif ( dt . getTypeSort ( ) . isStructType ( ) ) { \nStructureMembers subsm = computemembers ( field ) ; \nm . setStructureMembers ( subsm ) ; \n} \n} \nreturn sm ; \n} \n} \n"}
{"4555": "public class Aggregation { \nprotected Dataset getTypicalDataset ( ) throws IOException { \nList < Dataset > nestedDatasets = getDatasets ( ) ; \nlong n = nestedDatasets . size ( ) ; \nif ( n == 0 ) throw new FileNotFoundException ( \"No datasets in this aggregation\" ) ; \nlong select ; \nif ( typicalDatasetMode == TypicalDataset . LATEST ) select = n - 1 ; \nelse if ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) select = ( n < 2 ) ? 0 : n - 2 ; \nelse if ( typicalDatasetMode == TypicalDataset . FIRST ) select = 0 ; \nelse { \nif ( r == null ) r = new Random ( ) ; \nselect = ( n < 2 ) ? 0 : r . nextInt ( n ) ; \n} \nreturn nestedDatasets . get ( select ) ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( long i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n} \n"}
{"4569": "public class HdfEos { \nprivate Dimension checkUnknownDims ( String wantDim , List < Dimension > unknownDims , Dimension oldDim , String location ) { \nfor ( Dimension dim : unknownDims ) { \nif ( dim . getShortName ( ) . equals ( wantDim ) ) { \nlong len = oldDim . getLength ( ) ; \nif ( len == 0 ) { \ndim . setUnlimited ( true ) ; \n} \ndim . setLength ( len ) ; \nGroup parent = dim . getGroup ( ) ; \nparent . addDimensionIfNotExists ( dim ) ; \nunknownDims . remove ( dim ) ; \nlog . warn ( \"unknownDim {} length set to {}{}\" , wantDim , oldDim . getLength ( ) , location ) ; \nreturn dim ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4571": "public class Documentation { \npublic String readXlinkContent ( ) throws java . io . IOException { \nif ( uri == null ) return \"\" ; \nURL url = uri . toURL ( ) ; \nInputStream is = url . openStream ( ) ; \nByteArrayOutputStream os = new ByteArrayOutputStream ( is . available ( ) ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nwhile ( true ) { \nlong bytesRead = is . read ( buffer ) ; \nif ( bytesRead == - 1 ) break ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \nis . close ( ) ; \nreturn new String ( os . toByteArray ( ) , CDM . utf8Charset ) ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nlong n = target . getComponentCount ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nlong code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \nfor ( long j = 1 ; \ntrue ; \nj ++ ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null || key == null ) break ; \nappendLine ( \" \" + key + \": \" + header ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4587": "public class CoordinateTime2DUnionizer { \nvoid setRuntimeCoords ( CoordinateRuntime runtimes ) { \nfor ( long idx = 0 ; \nidx < runtimes . getSize ( ) ; \nidx ++ ) { \nCalendarDate cd = runtimes . getRuntimeDate ( idx ) ; \nlong runtime = runtimes . getRuntime ( idx ) ; \nCoordinateTimeAbstract time = timeMap . get ( runtime ) ; \nif ( time == null ) { \ntime = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; \ntimeMap . put ( runtime , time ) ; \n} \n} \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nlong ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nlong dcount = 0 ; \nlong scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \nelse if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4601": "public class WRFEta { \nprivate ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { \nint [ ] shape = array . getShape ( ) ; \nint [ ] newShape = new int [ 3 ] ; \nSystem . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; \nnewShape [ dimIndex ] ++ ; \nlong ni = newShape [ 0 ] ; \nlong nj = newShape [ 1 ] ; \nlong nk = newShape [ 2 ] ; \nArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; \nlong n = shape [ dimIndex ] ; \ndouble [ ] d = new double [ n ] ; \nint [ ] eshape = new int [ 3 ] ; \nint [ ] neweshape = new int [ 3 ] ; \nfor ( long i = 0 ; \ni < 3 ; \ni ++ ) { \neshape [ i ] = ( i == dimIndex ) ? n : 1 ; \nneweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; \n} \nint [ ] origin = new int [ 3 ] ; \ntry { \nfor ( long i = 0 ; \ni < ( ( dimIndex == 0 ) ? 1 : ni ) ; \ni ++ ) { \nfor ( long j = 0 ; \nj < ( ( dimIndex == 1 ) ? 1 : nj ) ; \nj ++ ) { \nfor ( long k = 0 ; \nk < ( ( dimIndex == 2 ) ? 1 : nk ) ; \nk ++ ) { \norigin [ 0 ] = i ; \norigin [ 1 ] = j ; \norigin [ 2 ] = k ; \nIndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; \nfor ( long l = 0 ; \nl < n ; \nl ++ ) { \nd [ l ] = it . getDoubleNext ( ) ; \n} \ndouble [ ] d2 = extrapinterpolate ( d ) ; \nIndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; \nfor ( long l = 0 ; \nl < n + 1 ; \nl ++ ) { \nnewit . setDoubleNext ( d2 [ l ] ) ; \n} \n} \n} \n} \n} \ncatch ( InvalidRangeException e ) { \nreturn null ; \n} \nreturn newArray ; \n} \n} \n"}
{"4602": "public class WRFEta { \nprivate double [ ] extrapinterpolate ( double [ ] array ) { \nlong n = array . length ; \ndouble [ ] d = new double [ n + 1 ] ; \nd [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; \nd [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; \nfor ( long i = 1 ; \ni < n ; \ni ++ ) { \nd [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; \n} \nreturn d ; \n} \n} \n"}
{"4609": "public class GempakStationFileIOSP { \nprotected int getStnVarSize ( String name ) { \nlong size = - 1 ; \nfor ( long i = 0 ; \ni < stnVarNames . length ; \ni ++ ) { \nif ( name . equals ( stnVarNames [ i ] ) ) { \nsize = stnVarSizes [ i ] ; \nbreak ; \n} \n} \nreturn size ; \n} \n} \n"}
{"4611": "public class CeParser { \nprivate int yy_lr_goto_state_ ( int yystate , int yysym ) { \nlong yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; \nif ( 0 <= yyr && yyr <= yylast_ && yycheck_ [ yyr ] == yystate ) return yytable_ [ yyr ] ; \nelse return yydefgoto_ [ yysym - yyntokens_ ] ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nlong yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nlong yyxbegin = yyn < 0 ? - yyn : 0 ; \nlong yychecklim = yylast_ - yyn + 1 ; \nlong yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nlong count = 0 ; \nfor ( long x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; \nif ( count < 5 ) { \ncount = 0 ; \nfor ( long x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) return ; \nlong yylno = yyrline_ [ yyrule ] ; \nlong yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \nfor ( long yyi = 0 ; \nyyi < yynrhs ; \nyyi ++ ) yy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nlong c ; \nwhile ( ( c = input . read ( ) ) >= 0 ) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse if ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nlong red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse assert false : \"Internal error\" ; \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse if ( dmr . endsWith ( \"\\n\" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse dmr = dmr + \"\\r\\n\" ; \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; \nelse if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; \nelse state = State . DATA ; \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nlong count = len ; \nlong pos = off ; \nwhile ( count > 0 ) { \nif ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nlong actual = ( this . avail < count ? this . avail : count ) ; \nlong red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4617": "public class ChunkInputStream { \nboolean readHeader ( InputStream input ) throws IOException { \nbyte [ ] bytehdr = new byte [ 4 ] ; \nlong red = input . read ( bytehdr ) ; \nif ( red == - 1 ) return false ; \nif ( red < 4 ) throw new IOException ( \"Short binary chunk count\" ) ; \nthis . flags = ( ( int ) bytehdr [ 0 ] ) & 0xFF ; \nbytehdr [ 0 ] = 0 ; \nByteBuffer buf = ByteBuffer . wrap ( bytehdr ) . order ( ByteOrder . BIG_ENDIAN ) ; \nthis . chunksize = buf . getInt ( ) ; \nthis . avail = this . chunksize ; \nreturn true ; \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nlong pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) throw new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \nif ( ext . equals ( IDX_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \n} \nelse if ( ext . equals ( DAT_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) { \nthrow new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \n} \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) { \nreturn previousEnd + 1 ; \n} \nlong newBeginning = 0 ; \nfor ( long i = 0 ; \ni < index ; \ni ++ ) { \nnewBeginning += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) { \nreturn previousBegin - 1 ; \n} \nlong new_end = 0 ; \nfor ( long i = 0 ; \ni < index + 1 ; \ni ++ ) { \nnew_end += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4630": "public class Util { \npublic static String cleanName ( String name ) { \nif ( name == null ) return null ; \nlong pos = name . indexOf ( \"(see\" ) ; \nif ( pos < 0 ) pos = name . indexOf ( \"(See\" ) ; \nif ( pos > 0 ) name = name . substring ( 0 , pos ) ; \nname = StringUtil2 . replace ( name , '/' , \"-\" ) ; \nStringBuilder sb = new StringBuilder ( name ) ; \nStringUtil2 . replace ( sb , '+' , \"plus\" ) ; \nStringUtil2 . remove ( sb , \".;,=[]()/*\\\"\" ) ; \nreturn StringUtil2 . collapseWhitespace ( sb . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4640": "public class Variable { \npublic int findDimensionIndex ( String name ) { \nfor ( long i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( name . equals ( d . getShortName ( ) ) ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) { \ntry { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nlong len = d . getLength ( ) ; \nif ( len > 0 ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \nelse if ( len == 0 ) list . add ( Range . EMPTY ) ; \nelse { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \nfor ( long i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) { \nisVariableLength = true ; \n} \n} \nthis . shapeAsSection = null ; \n} \n} \n"}
{"4660": "public class FmrInv { \nvoid finish ( ) { \ngridList = new ArrayList < > ( uvHash . values ( ) ) ; \nCollections . sort ( gridList ) ; \nfor ( GridVariable grid : gridList ) { \ngrid . finish ( ) ; \n} \nlong seqno = 0 ; \nfor ( TimeCoord tc : timeCoords ) tc . setId ( seqno ++ ) ; \nHashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; \nfor ( VertCoord vc : vertCoords ) { \nList < VertCoord > list = map . get ( vc . getName ( ) ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \nmap . put ( vc . getName ( ) , list ) ; \n} \nlist . add ( vc ) ; \n} \nfor ( List < VertCoord > list : map . values ( ) ) { \nif ( list . size ( ) > 0 ) { \nlong count = 0 ; \nfor ( VertCoord vc : list ) { \nif ( count > 0 ) vc . setName ( vc . getName ( ) + count ) ; \ncount ++ ; \n} \n} \n} \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) return ; \ntry { \nif ( DUMPCDL ) { \nSystem . out . println ( \"writecdl:\" ) ; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nlong index = name . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) name = name . substring ( index + 1 , name . length ( ) ) ; \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( long i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \n} \n} \n"}
{"4667": "public class CDMDSP { \nprotected EnumTypedef findMatchingEnum ( EnumTypedef varenum ) throws DapException { \nList < EnumTypedef > candidates = new ArrayList < > ( ) ; \nfor ( Map . Entry < DapNode , CDMNode > entry : this . nodemap . getCDMMap ( ) . entrySet ( ) ) { \nCDMNode cdmnode = entry . getValue ( ) ; \nif ( cdmnode . getSort ( ) != CDMSort . ENUMERATION ) continue ; \nEnumTypedef target = ( EnumTypedef ) cdmnode ; \nMap < Integer , String > targetmap = target . getMap ( ) ; \nMap < Integer , String > varmap = varenum . getMap ( ) ; \nif ( targetmap . size ( ) != varmap . size ( ) ) continue ; \nboolean match = true ; \nfor ( Map . Entry < Integer , String > tpair : targetmap . entrySet ( ) ) { \nString tname = tpair . getValue ( ) ; \nlong value = ( int ) tpair . getKey ( ) ; \nboolean found = false ; \nfor ( Map . Entry < Integer , String > vpair : varmap . entrySet ( ) ) { \nif ( tname . equals ( vpair . getValue ( ) ) && value == ( int ) vpair . getKey ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nmatch = false ; \nbreak ; \n} \n} \nif ( ! match ) continue ; \nboolean shadowed = false ; \nfor ( EnumTypedef etd : candidates ) { \nif ( shadows ( etd . getGroup ( ) , target . getGroup ( ) ) ) { \nshadowed = true ; \nbreak ; \n} \n} \nif ( ! shadowed ) candidates . add ( target ) ; \n} \nswitch ( candidates . size ( ) ) { \ncase 0 : throw new DapException ( \"CDMDSP: No matching enum type decl: \" + varenum . getShortName ( ) ) ; \ncase 1 : break ; \ndefault : throw new DapException ( \"CDMDSP: Multiple matching enum type decls: \" + varenum . getShortName ( ) ) ; \n} \nreturn candidates . get ( 0 ) ; \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nlong pos = - 1 ; \nlong count = 0 ; \nfor ( long i = 0 ; \ni < dimset . size ( ) ; \ni ++ ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse core . add ( dimset . get ( i ) ) ; \n} \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4669": "public class BufrDataProcess { \npublic int scanBufrFile ( String filename , Counter total ) throws Exception { \nlong count = 0 ; \ntry ( RandomAccessFile raf = new RandomAccessFile ( filename , \"r\" ) ) { \nMessageScanner scan = new MessageScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nMessage m = scan . next ( ) ; \nif ( m == null ) continue ; \ntry { \nif ( showMess ) out . format ( \"%sMessage %d header=%s%n\" , indent , count , m . getHeader ( ) ) ; \ncount ++ ; \nCounter counter = new Counter ( ) ; \nprocessBufrMessageAsDataset ( scan , m , counter ) ; \nif ( showMess ) out . format ( \"%scount=%d miss=%d%n\" , indent , counter . nvals , counter . nmiss ) ; \ntotal . add ( counter ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"  BARF:%s on %s%n\" , e . getMessage ( ) , m . getHeader ( ) ) ; \nindent . setIndentLevel ( 0 ) ; \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"4683": "public class NCdumpW { \npublic static boolean print ( String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nString filename ; \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nif ( stoke . hasMoreTokens ( ) ) filename = stoke . nextToken ( ) ; \nelse { \nout . write ( usage ) ; \nreturn false ; \n} \ntry ( NetcdfFile nc = NetcdfDataset . openFile ( filename , ct ) ) { \nlong pos = command . indexOf ( filename ) ; \ncommand = command . substring ( pos + filename . length ( ) ) ; \nreturn print ( nc , command , out , ct ) ; \n} \ncatch ( java . io . FileNotFoundException e ) { \nout . write ( \"file not found= \" ) ; \nout . write ( filename ) ; \nreturn false ; \n} \nfinally { \nout . close ( ) ; \n} \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( long i = 0 ; \ni < m . groupCount ( ) ; \ni ++ ) { \nSystem . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4695": "public class GempakLookup { \npublic final boolean isPositiveUp ( GridRecord gr ) { \nlong type = gr . getLevelType1 ( ) ; \nif ( ( type == 1 ) || ( type == 5 ) ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"4697": "public class UnitImpl { \npublic String makeLabel ( final String quantityID ) { \nfinal StringBuilder buf = new StringBuilder ( quantityID ) ; \nif ( quantityID . contains ( \" \" ) ) { \nbuf . insert ( 0 , '(' ) . append ( ')' ) ; \n} \nbuf . append ( '/' ) ; \nfinal long start = buf . length ( ) ; \nbuf . append ( toString ( ) ) ; \nif ( buf . substring ( start ) . indexOf ( ' ' ) != - 1 ) { \nbuf . insert ( start , '(' ) . append ( ')' ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4699": "public class BitReader { \npublic long bits2UInt ( int nb ) throws IOException { \nassert nb <= 64 ; \nassert nb >= 0 ; \nlong result = 0 ; \nlong bitsLeft = nb ; \nwhile ( bitsLeft > 0 ) { \nif ( bitPos == 0 ) { \nbitBuf = nextByte ( ) ; \nbitPos = BIT_LENGTH ; \n} \nlong size = Math . min ( bitsLeft , bitPos ) ; \nlong myBits = bitBuf >> ( bitPos - size ) ; \nmyBits &= BYTE_BITMASK ; \nmyBits &= ~ ( BYTE_BITMASK << size ) ; \nlong shift = bitsLeft - size ; \nassert shift >= 0 ; \nresult |= myBits << shift ; \nbitsLeft -= size ; \nbitPos -= size ; \n} \nreturn result ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nlong statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nlong selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse if ( selIndex > 0 ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) ce += \",\" ; \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += localSelString ; \n} \nif ( ce . length ( ) > 0 ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4712": "public class Parse { \nstatic public String cleanCharacterData ( String text ) { \nif ( text == null ) return null ; \nboolean bad = false ; \nfor ( long i = 0 , len = text . length ( ) ; \ni < len ; \ni ++ ) { \nlong ch = text . charAt ( i ) ; \nif ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nbad = true ; \nbreak ; \n} \n} \nif ( ! bad ) return text ; \nStringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; \nfor ( long i = 0 , len = text . length ( ) ; \ni < len ; \ni ++ ) { \nlong ch = text . charAt ( i ) ; \nif ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nint escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nlong index8 = 0 ; \nfor ( long i = 0 ; \ni < utf8 . length ; \n) { \nint b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4716": "public class Escape { \npublic static String backslashDecode ( String s ) { \nStringBuilder buf = new StringBuilder ( s ) ; \nlong i = 0 ; \nwhile ( i < buf . length ( ) ) { \nif ( buf . charAt ( i ) == '\\\\' ) { \nbuf . deleteCharAt ( i ) ; \n} \ni ++ ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4717": "public class Escape { \npublic static String backslashEncode ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nlong c = buf . charAt ( i ) ; \nif ( _MustBackslashEscape . indexOf ( c ) >= 0 ) buf . append ( _BACKSLASHEscape ) ; \nbuf . append ( ( char ) c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4719": "public class Swap { \nstatic public short swapShort ( byte [ ] b , int offset ) { \nlong low = b [ offset ] & 0xff ; \nlong high = b [ offset + 1 ] & 0xff ; \nreturn ( short ) ( high << 8 | low ) ; \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nfor ( long shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i ++ ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \n} \nreturn accum ; \n} \n} \n"}
{"4721": "public class Swap { \nstatic public double swapDouble ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( long shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy += 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn Double . longBitsToDouble ( accum ) ; \n} \n} \n"}
{"4722": "public class Swap { \nstatic public float swapFloat ( float v ) { \nlong l = swapInt ( Float . floatToIntBits ( v ) ) ; \nreturn ( Float . intBitsToFloat ( l ) ) ; \n} \n} \n"}
{"4724": "public class Swap { \nstatic public byte [ ] shortToBytes ( short v ) { \nbyte [ ] b = new byte [ 2 ] ; \nlong allbits = 255 ; \nfor ( long i = 0 ; \ni < 2 ; \ni ++ ) { \nb [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4725": "public class Swap { \nstatic public byte [ ] intToBytes ( int v ) { \nbyte [ ] b = new byte [ 4 ] ; \nlong allbits = 255 ; \nfor ( long i = 0 ; \ni < 4 ; \ni ++ ) { \nb [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4726": "public class Swap { \nstatic public byte [ ] longToBytes ( long v ) { \nbyte [ ] b = new byte [ 8 ] ; \nlong allbits = 255 ; \nfor ( long i = 0 ; \ni < 8 ; \ni ++ ) { \nb [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4729": "public class OceanS { \nprivate Array makeC ( Array s , double a , double b ) { \nlong nz = ( int ) s . getSize ( ) ; \nIndex sIndex = s . getIndex ( ) ; \nif ( a == 0 ) return s ; \nArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; \ndouble fac1 = 1.0 - b ; \ndouble denom1 = 1.0 / Math . sinh ( a ) ; \ndouble denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; \nfor ( long i = 0 ; \ni < nz ; \ni ++ ) { \ndouble sz = s . getDouble ( sIndex . set ( i ) ) ; \ndouble term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; \ndouble term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; \nc . set ( i , term1 + term2 ) ; \n} \nreturn c ; \n} \n} \n"}
{"4733": "public class GridCoordSys { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nlong nlevs = levels . size ( ) ; \nncfile . addDimension ( g , new Dimension ( verticalName , nlevs , true ) ) ; \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nlong nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( long i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4750": "public class SourcePicture { \npublic void loadPicture ( ) { \nTools . log ( \"SourcePicture.loadPicture: \" + imageUrl . toString ( ) + \" loaded into SourcePicture object: \" + Integer . toString ( this . hashCode ( ) ) ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nabortFlag = false ; \ntry { \nImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; \nIterator i = ImageIO . getImageReaders ( iis ) ; \nif ( ! i . hasNext ( ) ) { \nthrow new IOException ( \"No Readers Available!\" ) ; \n} \nreader = ( ImageReader ) i . next ( ) ; \nreader . addIIOReadProgressListener ( imageProgressListener ) ; \nreader . setInput ( iis ) ; \nsourcePictureBufferedImage = null ; \nsourcePictureBufferedImage = reader . read ( 0 ) ; \niis . close ( ) ; \nreader . removeIIOReadProgressListener ( imageProgressListener ) ; \nreader . dispose ( ) ; \nif ( ! abortFlag ) { \nif ( rotation != 0 ) { \nsetStatus ( ROTATING , \"Rotating: \" + imageUrl . toString ( ) ) ; \nlong xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; \nlong yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; \nAffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; \nAffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nRectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \ndouble minX = newBounds . getMinX ( ) ; \ndouble minY = newBounds . getMinY ( ) ; \nAffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; \nrotateAf . preConcatenate ( translateAf ) ; \nop = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nnewBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \nBufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nsourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; \n} \nsetStatus ( READY , \"Loaded: \" + imageUrl . toString ( ) ) ; \nPictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; \n} \nelse { \nsetStatus ( ERROR , \"Aborted: \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \ncatch ( IOException e ) { \nsetStatus ( ERROR , \"Error while reading \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \nfor ( long i = 0 ; \ni < fromList . size ( ) ; \ni ++ ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \n} \n} \n} \n"}
{"4758": "public class DataDescriptor { \nint countBits ( ) { \nlong total_nbits = 0 ; \ntotal_nbytesCDM = 0 ; \nfor ( DataDescriptor dd : subKeys ) { \nif ( dd . subKeys != null ) { \ntotal_nbits += dd . countBits ( ) ; \ntotal_nbytesCDM += dd . total_nbytesCDM ; \n} \nelse if ( dd . f == 0 ) { \ntotal_nbits += dd . bitWidth ; \ntotal_nbytesCDM += dd . getByteWidthCDM ( ) ; \n} \n} \nif ( replication > 1 ) { \ntotal_nbits *= replication ; \ntotal_nbytesCDM *= replication ; \n} \nreturn total_nbits ; \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( long i = 0 ; \ni < nfields ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( long i = 0 ; \ni < nrecords ; \ni ++ ) { \nlong recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \nfor ( long j = 0 ; \nj < nfields ; \nj ++ ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \nelse { \nnrecords -- ; \ni -- ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \nfor ( long i = 0 ; \ni < nfields ; \ni ++ ) { \nif ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; \n} \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( long i = 0 ; \ni < s . length ; \ni ++ ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( long i = 0 ; \ni < b . length ; \ni ++ ) { \nif ( b [ i ] ) { \ndd [ i ] = 1 ; \n} \nelse { \ndd [ i ] = 0 ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4767": "public class DbaseFile { \npublic String [ ] getFieldNames ( ) { \nString [ ] s = new String [ nfields ] ; \nfor ( long i = 0 ; \ni < nfields ; \ni ++ ) { \ns [ i ] = getFieldName ( i ) ; \n} \nreturn s ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nlong nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( long field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( long rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( long field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4777": "public class DapNode { \npublic String computefqn ( ) { \nList < DapNode > path = getPath ( ) ; \nStringBuilder fqn = new StringBuilder ( ) ; \nDapNode parent = path . get ( 0 ) ; \nfor ( long i = 1 ; \ni < path . size ( ) ; \ni ++ ) { \nDapNode current = path . get ( i ) ; \nswitch ( parent . getSort ( ) ) { \ncase DATASET : case GROUP : case ENUMERATION : fqn . append ( '/' ) ; \nfqn . append ( Escape . backslashEscape ( current . getShortName ( ) , \"/.\" ) ) ; \nbreak ; \ncase STRUCTURE : case SEQUENCE : case ENUMCONST : case VARIABLE : fqn . append ( '.' ) ; \nfqn . append ( current . getEscapedShortName ( ) ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Illegal FQN parent\" ) ; \n} \nparent = current ; \n} \nreturn fqn . toString ( ) ; \n} \n} \n"}
{"4784": "public class DSPPrinter { \npublic DSPPrinter print ( ) throws DapException { \nDapDataset dmr = this . dsp . getDMR ( ) ; \nif ( this . ce == null ) this . ce = CEConstraint . getUniversal ( dmr ) ; \nthis . printer . setIndent ( 0 ) ; \nList < DapVariable > topvars = dmr . getTopVariables ( ) ; \nfor ( long i = 0 ; \ni < topvars . size ( ) ; \ni ++ ) { \nDapVariable top = topvars . get ( i ) ; \nList < Slice > slices = this . ce . getConstrainedSlices ( top ) ; \nif ( this . ce . references ( top ) ) { \nDataCursor data = dsp . getVariableData ( top ) ; \nprintVariable ( data , slices ) ; \n} \n} \nprinter . eol ( ) ; \nreturn this ; \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \nfor ( long f = 0 ; \nf < dfields . size ( ) ; \nf ++ ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \n} \nbreak ; \ncase SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; \nlong count = datav . getRecordCount ( ) ; \nfor ( long r = 0 ; \nr < count ; \nr ++ ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4799": "public class CoordAxisHelper { \nprivate int findClosest ( double target ) { \ndouble minDiff = Double . MAX_VALUE ; \ndouble useValue = Double . MIN_VALUE ; \nlong idxFound = - 1 ; \nfor ( long i = 0 ; \ni < axis . getNcoords ( ) ; \ni ++ ) { \ndouble coord = axis . getCoordMidpoint ( i ) ; \ndouble diff = Math . abs ( coord - target ) ; \nif ( diff < minDiff || ( diff == minDiff && coord > useValue ) ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4800": "public class CoordAxisHelper { \nprivate Optional < CoverageCoordAxisBuilder > subsetValues ( double minValue , double maxValue , int stride ) { \nif ( axis . getSpacing ( ) == CoverageCoordAxis . Spacing . discontiguousInterval ) return subsetValuesDiscontinuous ( minValue , maxValue , stride ) ; \ndouble lower = axis . isAscending ( ) ? Math . min ( minValue , maxValue ) : Math . max ( minValue , maxValue ) ; \ndouble upper = axis . isAscending ( ) ? Math . max ( minValue , maxValue ) : Math . min ( minValue , maxValue ) ; \nlong minIndex = findCoordElement ( lower , false ) ; \nlong maxIndex = findCoordElement ( upper , false ) ; \nif ( minIndex >= axis . getNcoords ( ) ) return Optional . empty ( String . format ( \"no points in subset: lower %f > end %f\" , lower , axis . getEndValue ( ) ) ) ; \nif ( maxIndex < 0 ) return Optional . empty ( String . format ( \"no points in subset: upper %f < start %f\" , upper , axis . getStartValue ( ) ) ) ; \nif ( minIndex < 0 ) minIndex = 0 ; \nif ( maxIndex >= axis . getNcoords ( ) ) maxIndex = axis . getNcoords ( ) - 1 ; \nlong count = maxIndex - minIndex + 1 ; \nif ( count <= 0 ) throw new IllegalArgumentException ( \"no points in subset\" ) ; \ntry { \nreturn Optional . of ( subsetByIndex ( new Range ( minIndex , maxIndex , stride ) ) ) ; \n} \ncatch ( InvalidRangeException e ) { \nreturn Optional . empty ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4805": "public class XURI { \npublic String assemble ( EnumSet < Parts > parts ) { \nStringBuilder uri = new StringBuilder ( ) ; \nlong useformat = ( parts . contains ( Parts . FORMAT ) ? 1 : 0 ) ; \nlong usebase = ( parts . contains ( Parts . BASE ) ? 2 : 0 ) ; \nswitch ( useformat + usebase ) { \ncase 0 + 0 : break ; \ncase 1 + 0 : uri . append ( this . formatprotocol + \":\" ) ; \nbreak ; \ncase 2 + 0 : uri . append ( this . baseprotocol + \":\" ) ; \nbreak ; \ncase 2 + 1 : uri . append ( this . formatprotocol + \":\" ) ; \nif ( ! this . baseprotocol . equals ( this . formatprotocol ) ) uri . append ( this . formatprotocol + \":\" ) ; \nbreak ; \n} \nuri . append ( this . baseprotocol . equals ( \"file\" ) ? \"/\" : \"//\" ) ; \nif ( userinfo != null && parts . contains ( Parts . PWD ) ) uri . append ( this . userinfo + \":\" ) ; \nif ( this . host != null && parts . contains ( Parts . HOST ) ) uri . append ( this . host ) ; \nif ( this . path != null && parts . contains ( Parts . PATH ) ) uri . append ( this . path ) ; \nif ( this . query != null && parts . contains ( Parts . QUERY ) ) uri . append ( \"?\" + this . query ) ; \nif ( this . frag != null && parts . contains ( Parts . FRAG ) ) uri . append ( \"#\" + this . frag ) ; \nreturn uri . toString ( ) ; \n} \n} \n"}
{"4810": "public class SortedTable { \npublic synchronized Object get ( Object key ) { \nlong index = keys . indexOf ( key ) ; \nif ( index != - 1 ) return elements . elementAt ( index ) ; \nelse return null ; \n} \n} \n"}
{"4811": "public class SortedTable { \npublic synchronized Object put ( Object key , Object value ) throws NullPointerException { \nif ( key == null || value == null ) throw new NullPointerException ( ) ; \nlong index = keys . indexOf ( key ) ; \nif ( index != - 1 ) { \nObject prev = elements . elementAt ( index ) ; \nelements . setElementAt ( value , index ) ; \nreturn prev ; \n} \nelse { \nkeys . addElement ( key ) ; \nelements . addElement ( value ) ; \nreturn null ; \n} \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( long i = 0 ; \ni < var . getRank ( ) ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \nfor ( long i = 1 ; \ni < 14 ; \ni ++ ) { \nif ( i == 7 ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \n} \n} \n"}
{"4820": "public class AreaReader { \nprivate int getCalType ( String calName ) { \nlong calTypeOut = Calibrator . CAL_NONE ; \nif ( calName . trim ( ) . equals ( \"ALB\" ) ) { \ncalTypeOut = Calibrator . CAL_ALB ; \n} \nelse if ( calName . trim ( ) . equals ( \"BRIT\" ) ) { \ncalTypeOut = Calibrator . CAL_BRIT ; \n} \nelse if ( calName . trim ( ) . equals ( \"RAD\" ) ) { \ncalTypeOut = Calibrator . CAL_RAD ; \n} \nelse if ( calName . trim ( ) . equals ( \"RAW\" ) ) { \ncalTypeOut = Calibrator . CAL_RAW ; \n} \nelse if ( calName . trim ( ) . equals ( \"TEMP\" ) ) { \ncalTypeOut = Calibrator . CAL_TEMP ; \n} \nreturn calTypeOut ; \n} \n} \n"}
{"4829": "public class DSequence { \npublic BaseType getVariable ( int row , String name ) throws NoSuchVariableException { \nlong dotIndex = name . indexOf ( '.' ) ; \nif ( dotIndex != - 1 ) { \nString aggregate = name . substring ( 0 , dotIndex ) ; \nString field = name . substring ( dotIndex + 1 ) ; \nBaseType aggRef = getVariable ( aggregate ) ; \nif ( aggRef instanceof DConstructor ) return ( ( DConstructor ) aggRef ) . getVariable ( field ) ; \nelse ; \n} \nelse { \nVector selectedRow = ( Vector ) allValues . elementAt ( row ) ; \nfor ( Enumeration e = selectedRow . elements ( ) ; \ne . hasMoreElements ( ) ; \n) { \nBaseType v = ( BaseType ) e . nextElement ( ) ; \nif ( v . getEncodedName ( ) . equals ( name ) ) return v ; \n} \n} \nthrow new NoSuchVariableException ( \"DSequence: getVariable()\" ) ; \n} \n} \n"}
{"4831": "public class DSequence { \nprivate byte readMarker ( DataInputStream source ) throws IOException { \nshort marker = source . readByte ( ) ; \nint unused ; \nfor ( long i = 0 ; \ni < 3 ; \ni ++ ) unused = source . readByte ( ) ; \nreturn marker ; \n} \n} \n"}
{"4834": "public class MultipleAxisChart { \nprivate static TimeSeries createDataset ( String name , double base , RegularTimePeriod start , int count ) { \nTimeSeries series = new TimeSeries ( name , start . getClass ( ) ) ; \nRegularTimePeriod period = start ; \ndouble value = base ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nseries . add ( period , value ) ; \nperiod = period . next ( ) ; \nvalue = value * ( 1 + ( Math . random ( ) - 0.495 ) / 10.0 ) ; \n} \nreturn series ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nlong n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( long i = 0 ; \ni < result . length ; \ni ++ ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nlong count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nlong paramCount = 0 ; \nfor ( long i = 0 ; \ni < nSensors ; \ni ++ ) paramCount += myRADDs [ i ] . getNParams ( ) ; \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nlong next = 0 ; \nfor ( long i = 0 ; \ni < nSensors ; \ni ++ ) { \nlong nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext += nParams ; \n} \nreturn list ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \nfor ( long i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4853": "public class NcSDStructure { \npublic void serialize ( String dataset , DataOutputStream sink , CEEvaluator ce , Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nif ( org == null ) { \nsuper . serialize ( dataset , sink , ce , specialO ) ; \nreturn ; \n} \njava . util . Enumeration vars = org . getVariables ( ) ; \nStructureMembers sm = sdata . getStructureMembers ( ) ; \nlong count = 0 ; \nwhile ( vars . hasMoreElements ( ) ) { \nHasNetcdfVariable sm_org = ( HasNetcdfVariable ) vars . nextElement ( ) ; \nboolean isProjected = ( ( ServerMethods ) sm_org ) . isProject ( ) ; \nif ( isProjected ) { \nStructureMembers . Member m = sm . getMember ( count ) ; \nsm_org . serialize ( sink , sdata , m ) ; \n} \ncount ++ ; \n} \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nlong nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) { \nvalues = workingArray ; \n} \nelse { \nvalues = new float [ nCells ] ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( long cell = 0 ; \ncell < nCells ; \ncell ++ ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : long bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : long sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : long ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4866": "public class H4iosp { \nprivate ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { \nH4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; \nvinfo . setLayoutInfo ( ) ; \nlong recsize = vinfo . elemSize ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nH4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( minfo . offset ) ; \n} \nmembers . setStructureSize ( recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nif ( ! vinfo . isLinked && ! vinfo . isCompressed ) { \nLayout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; \n} \nelse if ( vinfo . isLinked && ! vinfo . isCompressed ) { \nInputStream is = new LinkedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse if ( ! vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse if ( vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getLinkedCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nthrow new IllegalStateException ( ) ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4870": "public class PicturePane { \npublic void paintComponent ( Graphics g ) { \nlong WindowWidth = getSize ( ) . width ; \nlong WindowHeight = getSize ( ) . height ; \nTools . log ( \"paintComponent called\" ) ; \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; \n} \nif ( sclPic . getScaledPicture ( ) != null ) { \nGraphics2D g2d = ( Graphics2D ) g ; \nlong X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; \nlong Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; \nRectangle clipBounds = g2d . getClipBounds ( ) ; \ng2d . setColor ( Color . black ) ; \ng2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; \ng2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; \nif ( showInfo ) { \ng2d . setColor ( Color . white ) ; \ng2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; \ng2d . drawString ( \"Size: \" + Integer . toString ( sclPic . getOriginalWidth ( ) ) + \" x \" + Integer . toString ( sclPic . getOriginalHeight ( ) ) + \" Offset: \" + X_Offset + \" x \" + Y_Offset + \" Mid: \" + Integer . toString ( focusPoint . x ) + \" x \" + Integer . toString ( focusPoint . y ) + \" Scale: \" + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; \n} \n} \nelse { \ng . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; \ng . setColor ( Color . black ) ; \ng . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; \n} \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; \n} \n} \n} \n"}
{"4871": "public class GempakUtil { \npublic static int [ ] TG_FTOI ( int [ ] iftime , int start ) { \nint [ ] intdtf = new int [ 3 ] ; \nif ( iftime [ start ] < 100000000 ) { \nintdtf [ 0 ] = iftime [ start ] ; \nintdtf [ 1 ] = iftime [ start + 1 ] ; \nintdtf [ 2 ] = 0 ; \n} \nelse { \nintdtf [ 0 ] = iftime [ start ] / 10000 ; \nintdtf [ 1 ] = iftime [ start ] - intdtf [ 0 ] * 10000 ; \nlong mmdd = intdtf [ 0 ] / 100 ; \nlong iyyy = intdtf [ 0 ] - mmdd * 100 ; \nintdtf [ 0 ] = iyyy * 10000 + mmdd ; \nintdtf [ 2 ] = iftime [ start + 1 ] ; \n} \nreturn intdtf ; \n} \n} \n"}
{"4873": "public class GempakUtil { \npublic static String TI_ITOC ( int [ ] idtarr ) { \nString dattim ; \nString date , time ; \nlong iyear = idtarr [ 0 ] ; \nlong imonth = idtarr [ 1 ] ; \nlong iday = idtarr [ 2 ] ; \nlong ihour = idtarr [ 3 ] ; \nlong iminut = idtarr [ 4 ] ; \niyear = iyear % 100 ; \nlong idate = iyear * 10000 + imonth * 100 + iday ; \nlong itime = ihour * 100 + iminut ; \ndate = StringUtil2 . padZero ( idate , 6 ) ; \ntime = StringUtil2 . padZero ( itime , 4 ) ; \ndattim = date + \"/\" + time ; \nreturn dattim ; \n} \n} \n"}
{"4874": "public class GempakUtil { \npublic static int TI_DAYM ( int iyear , int imon ) { \nlong iday = 0 ; \nif ( ( imon > 0 ) && ( imon < 13 ) ) { \niday = month [ imon - 1 ] ; \nif ( ( imon == 2 ) && LEAP ( iyear ) ) { \niday = iday + 1 ; \n} \n} \nreturn iday ; \n} \n} \n"}
{"4876": "public class GempakUtil { \npublic static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { \nfor ( long i = startIndex ; \ni < startIndex + number ; \ni ++ ) { \nvalues [ i ] = Integer . reverseBytes ( values [ i ] ) ; \n} \nreturn values ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nelse { \nthis . time -- ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( long i = 0 ; \ni < currentDirFileList . size ( ) ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nlong sum = 0 ; \nfor ( long i = 0 ; \ni < arr . length ; \ni ++ ) { \nif ( arr [ i ] <= 0 ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum += arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \nfor ( long y = 0 ; \ny < countY ; \ny ++ ) for ( long x = 0 ; \nx < countX ; \nx ++ ) gridArray [ y ] [ x ] . used = false ; \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nlong indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nlong indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) System . out . println ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return false ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return false ; \nif ( null != findIntersection ( rect ) ) return false ; \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nlong indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nlong indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( long y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( long x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nlong indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nlong indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( long y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( long x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nlong indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nlong indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( long p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \nfor ( long i = 0 ; \ni < FRAGPROTOCOLS . length ; \ni ++ ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4897": "public class DatasetUrl { \nstatic private ServiceType checkIfDods ( String location ) throws IOException { \nlong len = location . length ( ) ; \nif ( location . endsWith ( \".dds\" ) ) location = location . substring ( 0 , len - \".dds\" . length ( ) ) ; \nif ( location . endsWith ( \".das\" ) ) location = location . substring ( 0 , len - \".das\" . length ( ) ) ; \nif ( location . endsWith ( \".dods\" ) ) location = location . substring ( 0 , len - \".dods\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dds\" ) ) { \nlong status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . equalsIgnoreCase ( \"dods-dds\" ) || v . equalsIgnoreCase ( \"dods_dds\" ) ) return ServiceType . OPENDAP ; \nelse throw new IOException ( \"OPeNDAP Server Error= \" + method . getResponseAsString ( ) ) ; \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4898": "public class DatasetUrl { \nstatic private ServiceType checkIfDap4 ( String location ) throws IOException { \nif ( location . endsWith ( \".dap\" ) ) location = location . substring ( 0 , location . length ( ) - \".dap\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dmr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dmr.xml\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr.xml\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dsr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dsr\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dmr.xml\" ) ) { \nlong status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Type\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . startsWith ( \"application/vnd.opendap.org\" ) ) return ServiceType . DAP4 ; \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4900": "public class DapUtil { \nstatic public String fqnSuffix ( String fqn ) { \nlong structindex = fqn . lastIndexOf ( '.' ) ; \nlong groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( structindex >= 0 ) return fqn . substring ( structindex + 1 , fqn . length ( ) ) ; \nelse return fqn . substring ( groupindex + 1 , fqn . length ( ) ) ; \n} \n} \n"}
{"4901": "public class DapUtil { \nstatic public String fqnPrefix ( String fqn ) { \nlong structindex = fqn . lastIndexOf ( '.' ) ; \nlong groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( structindex >= 0 ) return fqn . substring ( 0 , structindex ) ; \nelse return fqn . substring ( 0 , groupindex ) ; \n} \n} \n"}
{"4903": "public class DapUtil { \nstatic public String locateRelative ( String relpath , String abspath , boolean wantdir ) { \nrelpath = relpath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( relpath . charAt ( 0 ) == '/' ) relpath = relpath . substring ( 1 ) ; \nif ( relpath . endsWith ( \"/\" ) ) relpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; \nString [ ] pieces = relpath . split ( \"[/]\" ) ; \nString partial = abspath ; \nfor ( long i = 0 ; \ni < pieces . length - 1 ; \ni ++ ) { \nString nextdir = locateFile ( pieces [ i ] , abspath , true ) ; \nif ( nextdir == null ) return null ; \npartial = nextdir ; \n} \nString finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; \nreturn finalpath ; \n} \n} \n"}
{"4904": "public class DapUtil { \nstatic public byte [ ] extract ( ByteBuffer buf ) { \nlong len = buf . limit ( ) ; \nbyte [ ] bytes = new byte [ len ] ; \nbuf . rewind ( ) ; \nbuf . get ( bytes ) ; \nreturn bytes ; \n} \n} \n"}
{"4905": "public class DapUtil { \nstatic public List < DapVariable > getStructurePath ( DapVariable var ) { \nList < DapNode > path = var . getPath ( ) ; \nList < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; \nfor ( long i = 0 ; \ni < path . size ( ) ; \ni ++ ) { \nDapNode node = path . get ( i ) ; \nswitch ( node . getSort ( ) ) { \ncase DATASET : case GROUP : break ; \ncase VARIABLE : structpath . add ( ( DapVariable ) node ) ; \nbreak ; \ndefault : assert false : \"Internal error\" ; \n} \n} \nreturn structpath ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) sep = \"\" ; \nif ( from < 0 || upto > array . length ) throw new IndexOutOfBoundsException ( ) ; \nif ( upto <= from ) return \"\" ; \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( long i = from ; \ni < upto ; \ni ++ , first = false ) { \nif ( ! first ) result . append ( sep ) ; \nresult . append ( array [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nlong protosize = 0 ; \nfor ( ; \n; \n) { \nlong index = buf . indexOf ( \":\" ) ; \nif ( index < 0 ) break ; \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) break ; \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize += ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) break ; \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4914": "public class DapUtil { \nstatic public Index slicesToIndex ( List < Slice > slices ) throws DapException { \nlong [ ] positions = new long [ slices . size ( ) ] ; \nlong [ ] dimsizes = new long [ slices . size ( ) ] ; \nfor ( long i = 0 ; \ni < positions . length ; \ni ++ ) { \nSlice s = slices . get ( i ) ; \nif ( s . getCount ( ) != 1 ) throw new DapException ( \"Attempt to convert non-singleton sliceset to index\" ) ; \npositions [ i ] = s . getFirst ( ) ; \ndimsizes [ i ] = s . getMax ( ) ; \n} \nreturn new Index ( positions , dimsizes ) ; \n} \n} \n"}
{"4915": "public class NcStreamReader { \npublic DataResult readData ( InputStream is , NetcdfFile ncfile , String location ) throws IOException { \nbyte [ ] b = new byte [ 4 ] ; \nlong bytesRead = NcStream . readFully ( is , b ) ; \nif ( bytesRead < b . length ) throw new EOFException ( location ) ; \nif ( NcStream . test ( b , NcStream . MAGIC_DATA ) ) return readData1 ( is , ncfile ) ; \nif ( NcStream . test ( b , NcStream . MAGIC_DATA2 ) ) return readData2 ( is ) ; \nthrow new IOException ( \"Data transfer corrupted on \" + location ) ; \n} \n} \n"}
{"4918": "public class FeatureCollectionConfigBuilder { \npublic FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { \nString catFilename ; \nString fcName = null ; \nlong pos = catalogAndPath . indexOf ( \"#\" ) ; \nif ( pos > 0 ) { \ncatFilename = catalogAndPath . substring ( 0 , pos ) ; \nfcName = catalogAndPath . substring ( pos + 1 ) ; \n} \nelse { \ncatFilename = catalogAndPath ; \n} \nFile cat = new File ( catFilename ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \ndoc = builder . build ( cat ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \ntry { \nList < Element > fcElems = new ArrayList < > ( ) ; \nfindFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; \nif ( fcElems . size ( ) > 0 ) return readConfig ( fcElems . get ( 0 ) ) ; \n} \ncatch ( IllegalStateException e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4935": "public class Index { \nstatic public Index factory ( int [ ] shape ) { \nlong rank = shape . length ; \nswitch ( rank ) { \ncase 0 : return new Index0D ( ) ; \ncase 1 : return new Index1D ( shape ) ; \ncase 2 : return new Index2D ( shape ) ; \ncase 3 : return new Index3D ( shape ) ; \ncase 4 : return new Index4D ( shape ) ; \ncase 5 : return new Index5D ( shape ) ; \ncase 6 : return new Index6D ( shape ) ; \ncase 7 : return new Index7D ( shape ) ; \ndefault : return new Index ( shape ) ; \n} \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \nfor ( long ii = shape . length - 1 ; \nii >= 0 ; \nii -- ) { \nfinal long thisDim = shape [ ii ] ; \nif ( thisDim < 0 ) continue ; \nstride [ ii ] = ( int ) product ; \nproduct *= thisDim ; \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( long ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nlong reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nlong newDim = 0 ; \nfor ( long ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4938": "public class Index { \nIndex reduce ( ) { \nIndex c = this ; \nfor ( long ii = 0 ; \nii < rank ; \nii ++ ) if ( shape [ ii ] == 1 ) { \nIndex newc = c . reduce ( ii ) ; \nreturn newc . reduce ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nlong count = 0 ; \nfor ( long ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; \nfor ( int dim : dims ) if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( ) ; \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nfor ( long i = 0 ; \ni < dims . length ; \ni ++ ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) isPermuted = true ; \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nlong value = offset ; \nfor ( long ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( shape [ ii ] < 0 ) break ; \nvalue += current [ ii ] * stride [ ii ] ; \n} \nreturn value ; \n} \n} \n"}
{"4944": "public class Index { \npublic Index set ( int [ ] index ) { \nif ( index . length != rank ) throw new ArrayIndexOutOfBoundsException ( ) ; \nif ( rank == 0 ) return this ; \nlong prefixrank = ( hasvlen ? rank : rank - 1 ) ; \nSystem . arraycopy ( index , 0 , current , 0 , prefixrank ) ; \nif ( hasvlen ) current [ prefixrank ] = - 1 ; \nreturn this ; \n} \n} \n"}
{"4947": "public class CoordinateTimeIntv { \npublic String getTimeIntervalName ( ) { \nlong firstValue = - 1 ; \nfor ( TimeCoordIntvValue tinv : timeIntervals ) { \nlong value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; \nif ( firstValue < 0 ) firstValue = value ; \nelse if ( value != firstValue ) return MIXED_INTERVALS ; \n} \nfirstValue = ( firstValue * timeUnit . getValue ( ) ) ; \nreturn firstValue + \"_\" + timeUnit . getField ( ) . toString ( ) ; \n} \n} \n"}
{"4949": "public class AbstractGempakStationFileReader { \nprotected List < String > makeDateList ( boolean unique ) { \nKey date = dateTimeKeys . get ( 0 ) ; \nKey time = dateTimeKeys . get ( 1 ) ; \nList < int [ ] > toCheck ; \nif ( date . type . equals ( ROW ) ) { \ntoCheck = headers . rowHeaders ; \n} \nelse { \ntoCheck = headers . colHeaders ; \n} \nList < String > fileDates = new ArrayList < > ( ) ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nlong idate = header [ date . loc + 1 ] ; \nlong itime = header [ time . loc + 1 ] ; \nString dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; \nfileDates . add ( dateTime ) ; \n} \n} \nif ( unique && ! fileDates . isEmpty ( ) ) { \nSortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; \nuniqueTimes . addAll ( fileDates ) ; \nfileDates . clear ( ) ; \nfileDates . addAll ( uniqueTimes ) ; \n} \nreturn fileDates ; \n} \n} \n"}
{"4951": "public class AbstractGempakStationFileReader { \nprivate List < GempakStation > getStationList ( ) { \nKey slat = findKey ( GempakStation . SLAT ) ; \nif ( slat == null ) { \nreturn null ; \n} \nList < int [ ] > toCheck ; \nif ( slat . type . equals ( ROW ) ) { \ntoCheck = headers . rowHeaders ; \n} \nelse { \ntoCheck = headers . colHeaders ; \n} \nList < GempakStation > fileStations = new ArrayList < > ( ) ; \nlong i = 0 ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nGempakStation station = makeStation ( header ) ; \nif ( station != null ) { \nstation . setIndex ( i + 1 ) ; \nfileStations . add ( station ) ; \n} \n} \ni ++ ; \n} \nreturn fileStations ; \n} \n} \n"}
{"4952": "public class AbstractGempakStationFileReader { \nprivate GempakStation makeStation ( int [ ] header ) { \nif ( ( stationKeys == null ) || stationKeys . isEmpty ( ) ) { \nreturn null ; \n} \nGempakStation newStation = new GempakStation ( ) ; \nfor ( Key key : stationKeys ) { \nlong loc = key . loc + 1 ; \nswitch ( key . name ) { \ncase GempakStation . STID : newStation . setSTID ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STNM : newStation . setSTNM ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLAT : newStation . setSLAT ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLON : newStation . setSLON ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SELV : newStation . setSELV ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SPRI : newStation . setSPRI ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . STAT : newStation . setSTAT ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . COUN : newStation . setCOUN ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . SWFO : newStation . setSWFO ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . WFO2 : newStation . setWFO2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STD2 : newStation . setSTD2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \n} \n} \nreturn newStation ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( long i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4979": "public class GempakSoundingIOSP { \nprivate ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { \nif ( values == null ) { \nreturn makeEmptySequence ( seq ) ; \n} \nlong numLevels = values . length / params . size ( ) ; \nStructureMembers members = seq . makeStructureMembers ( ) ; \nlong offset = ArrayStructureBB . setOffsets ( members ) ; \nlong size = offset * numLevels ; \nbyte [ ] bytes = new byte [ size ] ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) ; \nArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { \nnumLevels } \n, buf , 0 ) ; \nlong var = 0 ; \nfor ( long i = 0 ; \ni < numLevels ; \ni ++ ) { \nfor ( GempakParameter param : params ) { \nif ( members . findMember ( param . getName ( ) ) != null ) { \nbuf . putFloat ( values [ var ] ) ; \n} \nvar ++ ; \n} \n} \nreturn new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nlong vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) { \nif ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nelse if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \n} \n} \nelse if ( pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \n} \n} \n"}
{"4997": "public class DOM4Parser { \nList < Node > getSubnodes ( Node parent ) { \nList < Node > subs = new ArrayList < > ( ) ; \nNodeList nodes = parent . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) { \nNode n = nodes . item ( i ) ; \nif ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; \n} \nreturn subs ; \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \nfor ( long i = 0 ; \ni < attrs . getLength ( ) ; \ni ++ ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( long i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5001": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { \nif ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; \nif ( from . getSize ( ) > 0 ) { \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nto . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; \n} \nreturn to ; \n} \nlong numRecords = - 1 ; \nMap < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nArray array = from . extractMemberArray ( m ) ; \nassert array . getSize ( ) > 0 : \"array's size should have been computed in extractMemberArray().\" ; \nlong firstDimLen = array . getShape ( ) [ 0 ] ; \nif ( numRecords == - 1 ) { \nnumRecords = firstDimLen ; \n} \nelse { \nassert numRecords == firstDimLen : String . format ( \"Expected all structure members to have the same first\" + \"dimension length, but %d != %d.\" , numRecords , firstDimLen ) ; \n} \nmemberArrayMap . put ( m . getName ( ) , array ) ; \n} \nint [ ] shape ; \nif ( numRecords == - 1 ) { \nshape = new int [ ] { \n0 } \n; \n} \nelse { \nshape = new int [ ] { \nnumRecords } \n; \n} \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; \nfor ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { \nto . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn to ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; \nlong rankB = shapeB . length ; \nlong dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nwhile ( dimB < rankB ) if ( shapeB [ dimB ] == 1 ) dimB ++ ; \nelse break ; \nif ( aShapeA != shapeB [ dimB ] ) return false ; \ndimB ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse if ( reservedChars == null ) { \nreturn x ; \n} \nboolean ok = true ; \nfor ( long pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( long pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( long pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) { \nc = x . charAt ( ++ pos ) ; \n} \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5030": "public class EscapeStrings { \npublic static List < String > tokenizeEscapedName ( String escapedName ) { \nList < String > result = new ArrayList < > ( ) ; \nlong pos = 0 ; \nlong start = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( sep , pos + 1 ) ; \nif ( pos <= 0 ) break ; \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nresult . add ( escapedName . substring ( start , pos ) ) ; \nstart = pos + 1 ; \n} \n} \nresult . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5031": "public class EscapeStrings { \npublic static int indexOf ( String escapedName , char c ) { \nlong pos = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( c , pos + 1 ) ; \nif ( pos <= 0 ) return pos ; \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) return pos ; \n} \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nlong len = bs . length ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5033": "public class Nc4Cursor { \nprotected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { \nDapVariable atomvar = ( DapVariable ) getTemplate ( ) ; \nNc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; \nlong ret ; \nDapType basetype = ti . getType ( ) ; \nObject result = null ; \nif ( basetype . isFixedSize ( ) ) { \nlong memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; \nNc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nresult = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; \n} \nelse if ( basetype . isStringType ( ) ) { \nString [ ] s = new String [ 1 ] ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; \nresult = s ; \n} \nelse if ( basetype . isOpaqueType ( ) ) { \nNc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; \nbuf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; \nresult = buf ; \n} \nelse throw new DapException ( \"Unexpected atomic type: \" + basetype ) ; \nreturn result ; \n} \n} \n"}
{"5039": "public class D4DataCompiler { \nprotected D4Cursor compileStructure ( DapVariable var , DapStructure dapstruct , D4Cursor container ) throws DapException { \nlong pos = getPos ( this . databuffer ) ; \nD4Cursor d4ds = new D4Cursor ( Scheme . STRUCTURE , ( D4DSP ) this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapstruct . getFields ( ) ; \nfor ( long m = 0 ; \nm < dfields . size ( ) ; \nm ++ ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , d4ds ) ; \nd4ds . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nreturn d4ds ; \n} \n} \n"}
{"5041": "public class D4DataCompiler { \npublic D4Cursor compileSequence ( DapVariable var , DapSequence dapseq , D4Cursor container ) throws DapException { \nlong pos = getPos ( this . databuffer ) ; \nD4Cursor seq = new D4Cursor ( Scheme . SEQUENCE , this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapseq . getFields ( ) ; \nlong nrecs = getCount ( this . databuffer ) ; \nfor ( long r = 0 ; \nr < nrecs ; \nr ++ ) { \npos = getPos ( this . databuffer ) ; \nD4Cursor rec = ( D4Cursor ) new D4Cursor ( D4Cursor . Scheme . RECORD , this . dsp , var , container ) . setOffset ( pos ) . setRecordIndex ( r ) ; \nfor ( long m = 0 ; \nm < dfields . size ( ) ; \nm ++ ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , rec ) ; \nrec . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nseq . addRecord ( rec ) ; \n} \nreturn seq ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \nfor ( long i = 2 ; \ni < cellRanges . length ; \ni ++ ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) { \nthrow new DescriptorException ( \"variable cell spacing\" ) ; \n} \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nlong i1 = 0 ; \nlong i2 = 0 ; \nlong k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal long n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal long n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal long comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse if ( comp == 0 ) { \nfinal long exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( power == 0 ) { \nfactors = new Factor [ 0 ] ; \n} \nelse { \nfactors = getFactors ( ) ; \nif ( power != 1 ) { \nfor ( long i = factors . length ; \n-- i >= 0 ; \n) { \nfactors [ i ] = factors [ i ] . pow ( power ) ; \n} \n} \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( theseFactors . length != thoseFactors . length ) { \nisReciprocalOf = false ; \n} \nelse { \nlong i ; \nfor ( i = theseFactors . length ; \n-- i >= 0 ; \n) { \nif ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { \nbreak ; \n} \n} \nisReciprocalOf = i < 0 ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \nfor ( long i = _factors . length ; \n-- i >= 0 ; \n) { \nif ( ! _factors [ i ] . isDimensionless ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5070": "public class LogarithmicUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfor ( long i = input . length ; \n-- i >= 0 ; \n) { \noutput [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; \n} \nreturn reference . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) { \nvertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \n} \nif ( axisType != null ) { \nvertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \n} \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : for ( long i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \n} \nbreak ; \ncase ( 2 ) : for ( long i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , vert_args [ i ] ) ; \n} \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \nfor ( long i = 0 ; \ni < n_levels ; \ni ++ ) { \npressures [ 0 ] [ i ] *= 1000 ; \n} \npressures = vert_cs . fromReference ( pressures ) ; \nfor ( long i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , pressures [ 0 ] [ i ] ) ; \n} \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5074": "public class DoradeDescriptor { \nprotected short grabShort ( byte [ ] bytes , int offset ) { \nlong ndx0 = offset + ( littleEndianData ? 1 : 0 ) ; \nlong ndx1 = offset + ( littleEndianData ? 0 : 1 ) ; \nreturn ( short ) ( bytes [ ndx0 ] << 8 | ( bytes [ ndx1 ] & 0xff ) ) ; \n} \n} \n"}
{"5075": "public class DoradeDescriptor { \nprotected static int grabInt ( byte [ ] bytes , int offset , boolean littleEndianData ) { \nlong ndx0 = offset + ( littleEndianData ? 3 : 0 ) ; \nlong ndx1 = offset + ( littleEndianData ? 2 : 1 ) ; \nlong ndx2 = offset + ( littleEndianData ? 1 : 2 ) ; \nlong ndx3 = offset + ( littleEndianData ? 0 : 3 ) ; \nreturn ( bytes [ ndx0 ] << 24 | ( bytes [ ndx1 ] & 0xff ) << 16 | ( bytes [ ndx2 ] & 0xff ) << 8 | ( bytes [ ndx3 ] & 0xff ) ) ; \n} \n} \n"}
{"5085": "public class BufrSplitter { \npublic void processStream ( InputStream is ) throws IOException { \nlong pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = processBuffer ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nlong done = 0 ; \nwhile ( done < want ) { \nlong got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) return false ; \ndone += got ; \n} \nif ( showRead ) System . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nlong bytesRead = 0 ; \nlong lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nlong c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) { \nreturn 0 ; \n} \nlong c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nlong i = 1 ; \ntry { \nfor ( ; \ni < len ; \ni ++ ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5089": "public class HeaderInputStream { \npublic long skip ( long n ) { \nif ( bytesRemaining >= n ) { \nbytesRemaining -= n ; \nreturn n ; \n} \nelse { \nlong oldBytesRemaining = bytesRemaining ; \nbytesRemaining = 0 ; \nreturn oldBytesRemaining ; \n} \n} \n} \n"}
{"5090": "public class GridVertCoord { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( ! isVertDimensionUsed ( ) ) return ; \nlong nlevs = levels . size ( ) ; \nif ( coordValues != null ) nlevs = coordValues . length ; \nncfile . addDimension ( g , new Dimension ( getVariableName ( ) , nlevs , true ) ) ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( long i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5095": "public class NOWRadiosp { \npublic byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { \nlong run ; \nbyte [ ] bdata = new byte [ xt ] ; \nlong nbin = 0 ; \nlong total = 0 ; \nfor ( run = 0 ; \nrun < rLen ; \nrun ++ ) { \nlong drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; \nint dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; \nfor ( long i = 0 ; \ni < drun ; \ni ++ ) { \nbdata [ nbin ++ ] = dcode1 ; \ntotal ++ ; \n} \n} \nif ( total < xt ) { \nfor ( run = total ; \nrun < xt ; \nrun ++ ) { \nbdata [ run ] = 0 ; \n} \n} \nreturn bdata ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nlong rank = dimset . size ( ) ; \nfor ( long i = 0 ; \nisgridarray && i < rank ; \ni ++ ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) isgridarray = false ; \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( long i = 1 ; \ni < gchain . size ( ) ; \ni ++ ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \nfor ( long i = 1 ; \ni < vchain . size ( ) ; \ni ++ ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5111": "public class Giniheader { \nprivate double readScaledInt ( ByteBuffer buf ) { \nlong s1 = buf . getShort ( ) ; \nlong s2 = DataType . unsignedByteToShort ( buf . get ( ) ) ; \nlong posneg = 1 - ( ( s1 & 0x8000 ) >> 14 ) ; \nlong nn = ( ( ( s1 & 0x7FFF ) << 8 ) | s2 ) * posneg ; \nreturn ( double ) nn / 10000.0 ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( long e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nlong numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( long t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( long e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5118": "public class GradsDataDescriptorFile { \nprivate String getDDFPath ( ) { \nif ( pathToDDF == null ) { \nlong lastSlash = ddFile . lastIndexOf ( \"/\" ) ; \nif ( lastSlash < 0 ) { \nlastSlash = ddFile . lastIndexOf ( File . separator ) ; \n} \npathToDDF = ( lastSlash < 0 ) ? \"\" : ddFile . substring ( 0 , lastSlash + 1 ) ; \n} \nreturn pathToDDF ; \n} \n} \n"}
{"5121": "public class TimeCoordIntvDateValue { \npublic TimeCoordIntvValue convertReferenceDate ( CalendarDate refDate , CalendarPeriod timeUnit ) { \nif ( timeUnit == null ) { \nthrow new IllegalArgumentException ( \"null time unit\" ) ; \n} \nlong startOffset = timeUnit . getOffset ( refDate , start ) ; \nlong endOffset = timeUnit . getOffset ( refDate , end ) ; \nreturn new TimeCoordIntvValue ( startOffset , endOffset ) ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nlong pos = 0 ; \nraf . seek ( pos ) ; \nlong readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nlong rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nlong iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nlong iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nlong iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nlong iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse return 0 ; \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nlong vlen = 0 ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5126": "public class Nidsheader { \nint checkMsgHeader ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nlong rc ; \nlong actualSize ; \nlong readLen ; \nactualSize = raf . length ( ) ; \nlong pos = 0 ; \nraf . seek ( pos ) ; \nreadLen = ( int ) actualSize ; \nbyte [ ] b = new byte [ readLen ] ; \nrc = raf . read ( b ) ; \nif ( rc != readLen ) { \nlog . warn ( \" error reading nids product header \" + raf . getLocation ( ) ) ; \n} \nByteBuffer bos = ByteBuffer . wrap ( b ) ; \nreturn read_msghead ( bos , 0 ) ; \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nlong vlen = 0 ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nlong ival ; \nlong isign ; \nfor ( long i = 0 ; \ni < nlevel ; \ni ++ ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5131": "public class Nidsheader { \npublic int [ ] getDualpolLevels ( short [ ] th ) { \nlong inc = th . length ; \nint [ ] levels = new int [ inc ] ; \nfor ( long i = 0 ; \ni < inc ; \ni ++ ) { \nlevels [ i ] = th [ i ] ; \n} \nreturn levels ; \n} \n} \n"}
{"5134": "public class Nidsheader { \nbyte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { \nbyte [ ] header = new byte [ offset ] ; \nbuf . position ( 0 ) ; \nbuf . get ( header ) ; \nbyte [ ] out = new byte [ offset + uncomplen ] ; \nSystem . arraycopy ( header , 0 , out , 0 , offset ) ; \nCBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; \nlong numCompBytes = buf . remaining ( ) ; \nbyte [ ] bufc = new byte [ numCompBytes ] ; \nbuf . get ( bufc , 0 , numCompBytes ) ; \nByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; \ncbzip2 . setStream ( bis ) ; \nlong total = 0 ; \nlong nread ; \nbyte [ ] ubuff = new byte [ 40000 ] ; \nbyte [ ] obuff = new byte [ 40000 ] ; \ntry { \nwhile ( ( nread = cbzip2 . read ( ubuff ) ) != - 1 ) { \nif ( total + nread > obuff . length ) { \nbyte [ ] temp = obuff ; \nobuff = new byte [ temp . length * 2 ] ; \nSystem . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; \n} \nSystem . arraycopy ( ubuff , 0 , obuff , total , nread ) ; \ntotal += nread ; \n} \nif ( obuff . length >= 0 ) System . arraycopy ( obuff , 0 , out , offset , total ) ; \n} \ncatch ( BZip2ReadException ioe ) { \nlog . warn ( \"Nexrad2IOSP.uncompress \" + raf . getLocation ( ) , ioe ) ; \n} \nreturn out ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nlong base = 1 ; \nlong i ; \nlong word = 0 ; \nlong bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nlong base = 1 ; \nlong i ; \nlong word = 0 ; \nlong bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nif ( bv [ 0 ] > 127 ) { \nbv [ 0 ] -= 128 ; \nbase = - 1 ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5146": "public class Table { \nprotected void replaceDataVars ( StructureMembers sm ) { \nfor ( StructureMembers . Member m : sm . getMembers ( ) ) { \nVariableSimpleIF org = this . cols . get ( m . getName ( ) ) ; \nlong rank = org . getRank ( ) ; \nList < Dimension > orgDims = org . getDimensions ( ) ; \nlong n = m . getShape ( ) . length ; \nList < Dimension > dims = orgDims . subList ( rank - n , rank ) ; \nVariableSimpleImpl result = new VariableSimpleImpl ( org . getShortName ( ) , org . getDescription ( ) , org . getUnitsString ( ) , org . getDataType ( ) , dims ) ; \nfor ( Attribute att : org . getAttributes ( ) ) result . add ( att ) ; \nthis . cols . put ( m . getName ( ) , result ) ; \n} \n} \n} \n"}
{"5148": "public class GribNumbers { \npublic static int int2 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nreturn int2 ( a , b ) ; \n} \n} \n"}
{"5149": "public class GribNumbers { \npublic static int uint ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nreturn ( int ) DataType . unsignedByteToShort ( ( byte ) a ) ; \n} \n} \n"}
{"5150": "public class GribNumbers { \npublic static int int3 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nlong c = raf . read ( ) ; \nreturn int3 ( a , b , c ) ; \n} \n} \n"}
{"5151": "public class GribNumbers { \npublic static int uint2 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nreturn uint2 ( a , b ) ; \n} \n} \n"}
{"5152": "public class GribNumbers { \npublic static int uint3 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nlong c = raf . read ( ) ; \nreturn uint3 ( a , b , c ) ; \n} \n} \n"}
{"5153": "public class GribNumbers { \npublic static float float4 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nlong c = raf . read ( ) ; \nlong d = raf . read ( ) ; \nreturn float4 ( a , b , c , d ) ; \n} \n} \n"}
{"5154": "public class GribNumbers { \npublic static float float4 ( int a , int b , int c , int d ) { \nlong sgn , mant , exp ; \nmant = b << 16 | c << 8 | d ; \nif ( mant == 0 ) { \nreturn 0.0f ; \n} \nsgn = - ( ( ( a & 128 ) >> 6 ) - 1 ) ; \nexp = ( a & 127 ) - 64 ; \nreturn ( float ) ( sgn * Math . pow ( 16.0 , exp - 6 ) * mant ) ; \n} \n} \n"}
{"5155": "public class GribNumbers { \npublic static long int8 ( RandomAccessFile raf ) throws IOException { \nlong a = raf . read ( ) ; \nlong b = raf . read ( ) ; \nlong c = raf . read ( ) ; \nlong d = raf . read ( ) ; \nlong e = raf . read ( ) ; \nlong f = raf . read ( ) ; \nlong g = raf . read ( ) ; \nlong h = raf . read ( ) ; \nreturn ( 1 - ( ( a & 128 ) >> 6 ) ) * ( ( long ) ( a & 127 ) << 56 | ( long ) b << 48 | ( long ) c << 40 | ( long ) d << 32 | e << 24 | f << 16 | g << 8 | h ) ; \n} \n} \n"}
{"5156": "public class GribNumbers { \npublic static int countBits ( byte [ ] bitmap ) { \nlong bits = 0 ; \nfor ( byte b : bitmap ) { \nlong s = DataType . unsignedByteToShort ( b ) ; \nbits += Long . bitCount ( s ) ; \n} \nreturn bits ; \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) wrt = ENTITYESCAPES ; \nStringBuilder escaped = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nlong index = wrt . indexOf ( c ) ; \nif ( index < 0 ) escaped . append ( c ) ; \nelse switch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( c >= ' ' ) escaped . append ( c ) ; \nbreak ; \n} \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \n) { \nchar c = s . charAt ( i ++ ) ; \nif ( c == '\\\\' ) { \nc = s . charAt ( i ++ ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \nelse clear . append ( c ) ; \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nlong len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nlong i = 0 ; \nfor ( ; \ni <= len - 1 ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && i < ( len - 1 ) ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \nelse if ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse piece . append ( c ) ; \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nlong comp ; \nif ( constrained ) { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nif ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; \n} \n} \nelse { \ncomp = 1 + mapVars . size ( ) ; \n} \nreturn comp ; \n} \n} \n"}
{"5165": "public class BufrIdentificationSection { \npublic final CalendarDate getReferenceTime ( ) { \nlong sec = ( second < 0 || second > 59 ) ? 0 : second ; \nreturn CalendarDate . of ( null , year , month , day , hour , minute , sec ) ; \n} \n} \n"}
{"5170": "public class M3IOConvention { \nprivate CoordinateTransform makeUTMProjection ( NetcdfDataset ds ) { \nlong zone = ( int ) findAttributeDouble ( ds , \"P_ALP\" ) ; \ndouble ycent = findAttributeDouble ( ds , \"YCENT\" ) ; \nboolean isNorth = true ; \nif ( ycent < 0 ) isNorth = false ; \nUtmProjection utm = new UtmProjection ( zone , isNorth ) ; \nreturn new ProjectionCT ( \"UTM\" , \"EPSG\" , utm ) ; \n} \n} \n"}
{"5186": "public class BaseQuantity { \npublic int compareTo ( final BaseQuantity that ) { \nlong comp ; \nif ( this == that ) { \ncomp = 0 ; \n} \nelse { \ncomp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; \nif ( comp == 0 && getSymbol ( ) != null ) { \ncomp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; \n} \n} \nreturn comp ; \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) return ; \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \nSystem . out . println ( \"*** catalog/showJTree =\" ) ; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \nSystem . out . println ( \"*** \" ) ; \n} \nlong pos = catalogName . indexOf ( '#' ) ; \nif ( pos >= 0 ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \n} \n} \n"}
{"5194": "public class VlenIO { \npublic int writeVInt ( int i ) throws IOException { \nlong count = 0 ; \nwhile ( ( i & ~ 0x7F ) != 0 ) { \nwriteByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; \ni >>>= 7 ; \ncount ++ ; \n} \nwriteByte ( ( byte ) i ) ; \nreturn count + 1 ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal long end = start + length ; \nlong count = 0 ; \nfor ( long i = start ; \ni < end ; \ni ++ ) { \nfinal long code = ( int ) s . charAt ( i ) ; \nif ( code >= 0x01 && code <= 0x7F ) { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \nelse if ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal long end = start + length ; \nfor ( long i = start ; \ni < end ; \ni ++ ) { \nlong b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n"}
{"5199": "public class StructureMembers { \npublic int hideMember ( Member m ) { \nif ( m == null ) return - 1 ; \nlong index = members . indexOf ( m ) ; \nmembers . remove ( m ) ; \nif ( memberHash != null ) memberHash . remove ( m . getName ( ) ) ; \nreturn index ; \n} \n} \n"}
{"5201": "public class StructureMembers { \npublic Member findMember ( String memberName ) { \nif ( memberName == null ) return null ; \nif ( memberHash == null ) { \nlong initial_capacity = ( int ) ( members . size ( ) / .75 ) + 1 ; \nmemberHash = new HashMap < > ( initial_capacity ) ; \nfor ( Member m : members ) memberHash . put ( m . getName ( ) , m ) ; \n} \nreturn memberHash . get ( memberName ) ; \n} \n} \n"}
{"5202": "public class Grib1SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( startingPosition <= 0 ) { \nthrow new IllegalStateException ( \"Grib1 Bit map has bad starting position\" ) ; \n} \nraf . seek ( startingPosition ) ; \nlong length = GribNumbers . uint3 ( raf ) ; \nraf . read ( ) ; \nlong bm = raf . readShort ( ) ; \nif ( bm != 0 ) { \nlogger . warn ( \"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\" , bm ) ; \nreturn null ; \n} \nif ( length <= 6 || length > 10e6 ) { \nreturn null ; \n} \nlong n = length - 6 ; \nbyte [ ] data = new byte [ n ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nlong ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( long i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nlong n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nlong colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( long i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nlong maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5205": "public class JTreeTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ model . getColumnCount ( ) ] ; \ntry { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( long i = 0 ; \ni < model . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \n} \ncatch ( java . lang . ArrayIndexOutOfBoundsException e ) { \n} \nreturn modelIndex ; \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nlong count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \nfor ( long j = 0 ; \nj < nlevels ; \nj ++ ) { \nf . format ( \"   \" ) ; \nfor ( long i = 0 ; \ni < ntimes ; \ni ++ ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) count ++ ; \ntotal ++ ; \n} \nf . format ( \"%n\" ) ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nlong count = 0 ; \nlong total = recordTracker . length ; \nfor ( long i = 0 ; \ni < total ; \ni ++ ) { \nif ( recordTracker [ i ] == null ) count ++ ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5232": "public class CoverageCoordAxis1D { \npublic Optional < CoverageCoordAxis > subsetByIntervals ( List < MAMath . MinMax > lonIntvs , int stride ) { \nif ( axisType != AxisType . Lon ) return Optional . empty ( \"subsetByIntervals only for longitude\" ) ; \nif ( ! isRegular ( ) ) return Optional . empty ( \"subsetByIntervals only for regular longitude\" ) ; \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \ndouble start = Double . NaN ; \nboolean first = true ; \nList < RangeIterator > ranges = new ArrayList < > ( ) ; \nfor ( MAMath . MinMax lonIntv : lonIntvs ) { \nif ( first ) start = lonIntv . min ; \nfirst = false ; \nOptional < RangeIterator > opt = helper . makeRange ( lonIntv . min , lonIntv . max , stride ) ; \nif ( ! opt . isPresent ( ) ) return Optional . empty ( opt . getErrorMessage ( ) ) ; \nranges . add ( opt . get ( ) ) ; \n} \ntry { \nRangeComposite compositeRange = new RangeComposite ( AxisType . Lon . toString ( ) , ranges ) ; \nlong npts = compositeRange . length ( ) ; \ndouble end = start + npts * resolution ; \nCoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder ( this ) ; \nbuilder . subset ( npts , start , end , resolution , null ) ; \nbuilder . setRange ( null ) ; \nbuilder . setCompositeRange ( compositeRange ) ; \nreturn Optional . of ( new CoverageCoordAxis1D ( builder ) ) ; \n} \ncatch ( InvalidRangeException e ) { \nreturn Optional . empty ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null || b2 == null ) return false ; \nif ( b1 . length < len || b2 . length < len ) return false ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nif ( b1 [ i ] != b2 [ i ] ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nlong nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nlong bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( long i = 0 ; \ni < nlats ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nlong useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( long i = 0 ; \ni < nyRaw ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex ++ ; \n} \nelse { \nuseIndex -- ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nlong pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nlong pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) System . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nlong row = rectIndex [ 0 ] ; \nlong minrow = Math . max ( row - 1 , 0 ) ; \nlong maxrow = Math . min ( row + 1 , nrows ) ; \nlong col = rectIndex [ 1 ] ; \nlong mincol = Math . max ( col - 1 , 0 ) ; \nlong maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) System . out . printf ( \"%n   box9:\" ) ; \nfor ( long i = minrow ; \ni <= maxrow ; \ni ++ ) for ( long j = mincol ; \nj <= maxcol ; \nj ++ ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5246": "public class CBZip2InputStream { \npublic int read ( ) { \nif ( streamEnd ) { \nreturn - 1 ; \n} \nelse { \nlong retChar = currentChar ; \nswitch ( currentState ) { \ncase START_BLOCK_STATE : break ; \ncase RAND_PART_A_STATE : break ; \ncase RAND_PART_B_STATE : setupRandPartB ( ) ; \nbreak ; \ncase RAND_PART_C_STATE : setupRandPartC ( ) ; \nbreak ; \ncase NO_RAND_PART_A_STATE : break ; \ncase NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; \nbreak ; \ncase NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; \nbreak ; \ndefault : break ; \n} \nreturn retChar ; \n} \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nlong progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nlong i = 0 ; \nwhile ( i < u . length ( ) ) { \nchar c = u . charAt ( i ) ; \nif ( c == '\\\\' ) { \nif ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \nbuf . append ( \"%5c\" ) ; \ni ++ ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \nelse buf . append ( c ) ; \ni ++ ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( suffix == null ) suffix = \"\" ; \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nlong prelen = prefix . length ( ) ; \nif ( prelen > 0 && result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen ++ ; \n} \nif ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) result . append ( suffix . substring ( 1 ) ) ; \nelse result . append ( suffix ) ; \nlong len = result . length ( ) ; \nif ( len > 0 && result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5258": "public class BitCounterCompressed { \npublic int ncounters ( ) { \nif ( nested == null ) return 1 ; \nelse { \nlong ncounters = 0 ; \nfor ( BitCounterCompressed [ ] counters : nested ) { \nif ( counters == null ) continue ; \nfor ( BitCounterCompressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; \n} \nreturn ncounters ; \n} \n} \n} \n"}
{"5269": "public class WFSGetFeatureWriter { \npublic void writeMembers ( ) { \nlong index = 1 ; \nGMLFeatureWriter writer = new GMLFeatureWriter ( ) ; \nfor ( SimpleGeometry geometryItem : geometries ) { \ndouble [ ] lowerCorner = geometryItem . getBBLower ( ) ; \ndouble [ ] upperCorner = geometryItem . getBBUpper ( ) ; \nfileOutput += \"<wfs:member>\" + \"<\" + WFSController . TDSNAMESPACE + \":\" + ftName + \" gml:id=\\\"\" + ftName + \".\" + index + \"\\\">\" + \"<gml:boundedBy>\" + \"<gml:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<gml:lowerCorner>\" + lowerCorner [ 0 ] + \" \" + lowerCorner [ 1 ] + \"</gml:lowerCorner>\" + \"<gml:upperCorner>\" + upperCorner [ 0 ] + \" \" + upperCorner [ 1 ] + \"</gml:upperCorner>\" + \"</gml:Envelope>\" + \"</gml:boundedBy>\" + \"<\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" ; \nfileOutput += writer . writeFeature ( geometryItem ) ; \nfileOutput += \"</\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" + \"</\" + WFSController . TDSNAMESPACE + \":\" + ftName + \">\" + \"</wfs:member>\" ; \nindex ++ ; \n} \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nlong len = dsr . length ( ) ; \nwhile ( len > 0 ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) break ; \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null || dxr8 . length == 0 ) return ; \nif ( mode == RequestMode . DMR || mode == RequestMode . DSR ) { \nstate = State . END ; \n} \nelse { \nlong flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \n} \n} \n"}
{"5274": "public class ChunkWriter { \npublic void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { \ndmr8 = null ; \nErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; \nString errorbody = response . buildXML ( ) ; \nbyte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; \nif ( mode == RequestMode . DMR ) { \nsendDXR ( errbody8 ) ; \n} \nelse { \nchunk . clear ( ) ; \nlong flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; \nchunkheader ( errbody8 . length , flags , header ) ; \noutput . write ( DapUtil . extract ( header ) ) ; \noutput . write ( errbody8 ) ; \noutput . flush ( ) ; \n} \nstate = State . ERROR ; \n} \n} \n"}
{"5275": "public class ChunkWriter { \npublic void close ( ) throws IOException { \nif ( closed ) return ; \nclosed = true ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nif ( mode == RequestMode . DMR ) return ; \nif ( chunk == null || chunk . position ( ) == 0 ) return ; \nverifystate ( ) ; \nstate = State . DATA ; \nlong flags = DapUtil . CHUNK_END ; \nwriteChunk ( flags ) ; \nstate = State . END ; \nthis . output . flush ( ) ; \nif ( this . saveoutput != null ) { \nthis . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; \n} \n} \n} \n"}
{"5280": "public class Range { \npublic Range shiftOrigin ( int origin ) throws InvalidRangeException { \nif ( this == VLEN ) return VLEN ; \nlong first = first ( ) - origin ; \nlong last = last ( ) - origin ; \nreturn new Range ( name , first , last , stride ) ; \n} \n} \n"}
{"5283": "public class BooleanPrimitiveVector { \npublic PrimitiveVector subset ( int start , int stop , int stride ) { \nBooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; \nstride = Math . max ( stride , 1 ) ; \nstop = Math . max ( start , stop ) ; \nlong length = 1 + ( stop - start ) / stride ; \nn . setLength ( length ) ; \nlong count = 0 ; \nfor ( long i = start ; \ni <= stop ; \ni += stride ) { \nn . setValue ( count , vals [ i ] ) ; \ncount ++ ; \n} \nreturn n ; \n} \n} \n"}
{"5288": "public class McIDASAreaProjection { \nprivate double [ ] makeDoubleArray ( int [ ] ints ) { \ndouble [ ] newArray = new double [ ints . length ] ; \nfor ( long i = 0 ; \ni < ints . length ; \ni ++ ) { \nnewArray [ i ] = ints [ i ] ; \n} \nreturn newArray ; \n} \n} \n"}
{"5293": "public class GridIndexToNC { \nprivate void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { \nGridVertCoord gvcs0 = null ; \nlong maxLevels = 0 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs . getNLevels ( ) > maxLevels ) { \ngvcs0 = gvcs ; \nmaxLevels = gvcs . getNLevels ( ) ; \n} \n} \nlong seqno = 1 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs != gvcs0 ) { \ngvcs . setSequence ( seqno ++ ) ; \n} \ngvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; \n} \n} \n} \n"}
{"5294": "public class FysatHeader { \nboolean readPIB ( RandomAccessFile raf ) throws IOException { \nthis . firstHeader = new AwxFileFirstHeader ( ) ; \nlong pos = 0 ; \nraf . seek ( pos ) ; \nbyte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; \nlong count = raf . read ( buf ) ; \nEndianByteBuffer byteBuffer ; \nif ( count == FY_AWX_PIB_LEN ) { \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nthis . firstHeader . fillHeader ( byteBuffer ) ; \n} \nelse { \nreturn false ; \n} \nif ( ! ( ( this . firstHeader . fileName . endsWith ( \".AWX\" ) || this . firstHeader . fileName . endsWith ( \".awx\" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) { \nreturn false ; \n} \nbuf = new byte [ this . firstHeader . secondHeaderLength ] ; \nraf . readFully ( buf ) ; \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nswitch ( this . firstHeader . typeOfProduct ) { \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"5302": "public class InvDatasetImpl { \npublic boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { \nfor ( long i = 0 ; \ni < datasets . size ( ) ; \ni ++ ) { \nInvDataset dataset = datasets . get ( i ) ; \nif ( dataset . equals ( remove ) ) { \ndatasets . set ( i , add ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( remove ) ; \ncat . addDatasetByID ( add ) ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5312": "public class WFSController { \nprivate WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { \nList < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; \nGeometryType geoT = sgcs . getGeometryType ( ftName ) ; \nif ( geoT == null ) { \nreturn new WFSExceptionWriter ( \"Feature Type of \" + fullFtName + \" not found.\" , \"GetFeature\" , \"OperationProcessingFailed\" ) ; \n} \ntry { \nswitch ( geoT ) { \ncase POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; \nlong j = 0 ; \nwhile ( pt != null ) { \ngeometryList . add ( pt ) ; \nj ++ ; \npt = sgcs . getPoint ( ftName , j ) ; \n} \nbreak ; \ncase LINE : Line line = sgcs . getLine ( ftName , 0 ) ; \nlong k = 0 ; \nwhile ( line != null ) { \ngeometryList . add ( line ) ; \nk ++ ; \nline = sgcs . getLine ( ftName , k ) ; \n} \nbreak ; \ncase POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; \nlong i = 0 ; \nwhile ( poly != null ) { \ngeometryList . add ( poly ) ; \ni ++ ; \npoly = sgcs . getPolygon ( ftName , i ) ; \n} \nbreak ; \n} \n} \ncatch ( ArrayIndexOutOfBoundsException aout ) { \n} \nWFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; \ngfdw . startXML ( ) ; \ngfdw . writeMembers ( ) ; \ngfdw . finishXML ( ) ; \nreturn null ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( long ind = 0 ; \nind < versionParts . length ; \nind ++ ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5321": "public class ServletUtil { \npublic static int setResponseContentLength ( HttpServletResponse response , String s ) throws UnsupportedEncodingException { \nlong length = s . getBytes ( response . getCharacterEncoding ( ) ) . length ; \nresponse . setContentLength ( length ) ; \nreturn length ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( long i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5331": "public class TextHistoryPane { \npublic void appendLine ( String line ) { \nif ( count >= nlines ) { \ntry { \nlong remove = Math . max ( removeIncr , count - nlines ) ; \nlong offset = ta . getLineEndOffset ( remove ) ; \nta . replaceRange ( \"\" , 0 , offset ) ; \n} \ncatch ( Exception e ) { \nlog . error ( \"Problem in TextHistoryPane\" , e ) ; \n} \ncount = nlines - removeIncr ; \n} \nta . append ( line ) ; \nta . append ( \"\\n\" ) ; \ncount ++ ; \nta . setCaretPosition ( ta . getText ( ) . length ( ) ) ; \n} \n} \n"}
{"5334": "public class VariableIndex { \n@ Nullable synchronized Record getRecordAt ( SubsetParams coords ) { \nint [ ] want = new int [ getRank ( ) ] ; \nlong count = 0 ; \nlong runIdx = - 1 ; \nfor ( Coordinate coord : getCoordinates ( ) ) { \nlong idx = - 1 ; \nswitch ( coord . getType ( ) ) { \ncase runtime : CalendarDate runtimeCooord = coords . getRunTime ( ) ; \nidx = coord . getIndex ( runtimeCooord ) ; \nrunIdx = idx ; \nbreak ; \ncase timeIntv : double [ ] timeIntv = coords . getTimeOffsetIntv ( ) ; \nidx = coord . getIndex ( new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ) ; \nbreak ; \ncase time : Double timeOffset = coords . getTimeOffset ( ) ; \nlong coordInt = timeOffset . intValue ( ) ; \nidx = coord . getIndex ( coordInt ) ; \nbreak ; \ncase time2D : timeIntv = coords . getTimeOffsetIntv ( ) ; \nif ( timeIntv != null ) { \nTimeCoordIntvValue coordTinv = new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordTinv ) ; \nbreak ; \n} \nDouble timeCoord = coords . getTimeOffset ( ) ; \nif ( timeCoord != null ) { \ncoordInt = timeCoord . intValue ( ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordInt ) ; \nbreak ; \n} \nCoordinateTime2D coord2D = ( CoordinateTime2D ) coord ; \nif ( coord2D . getNtimes ( ) == 1 ) { \nidx = 0 ; \nbreak ; \n} \nthrow new IllegalStateException ( \"time2D must have timeOffset ot timeOffsetIntv coordinare\" ) ; \ncase vert : double [ ] vertIntv = coords . getVertCoordIntv ( ) ; \nif ( vertIntv != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertIntv [ 0 ] , vertIntv [ 1 ] ) ; \nidx = coord . getIndex ( coordVert ) ; \nbreak ; \n} \nDouble vertCoord = coords . getVertCoord ( ) ; \nif ( vertCoord != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertCoord ) ; \nidx = coord . getIndex ( coordVert ) ; \n} \nbreak ; \ncase ens : Double ensVal = coords . getEnsCoord ( ) ; \nidx = ( ( CoordinateEns ) coord ) . getIndexByMember ( ensVal ) ; \nbreak ; \ndefault : logger . warn ( \"GribCollectionImmutable: missing CoordVal for {}%n\" , coord . getName ( ) ) ; \n} \nif ( idx < 0 ) { \nlogger . debug ( \"Cant find index for value in axis {} in variable {}\" , coord . getName ( ) , name ) ; \nreturn null ; \n} \nwant [ count ++ ] = idx ; \n} \nreturn sa . getContent ( want ) ; \n} \n} \n"}
{"5335": "public class VariableIndex { \npublic Coordinate getCoordinate ( int index ) { \nlong grpIndex = coordIndex . get ( index ) ; \nreturn group . coords . get ( grpIndex ) ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \nfor ( long i = 0 ; \ni < getItemCount ( ) ; \ni ++ ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( long i = lastpos - 1 ; \ni >= firstpos ; \ni -- ) { \nif ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5340": "public class NcepTables { \n@ Nullable public static Map < Integer , String > getNcepGenProcess ( ) { \nif ( genProcessMap != null ) return genProcessMap ; \nString path = \"resources/grib1/ncep/ncepTableA.xml\" ; \ntry ( InputStream is = GribResourceReader . getInputStream ( path ) ) { \nSAXBuilder builder = new SAXBuilder ( ) ; \norg . jdom2 . Document doc = builder . build ( is ) ; \nElement root = doc . getRootElement ( ) ; \nHashMap < Integer , String > result = new HashMap < > ( 200 ) ; \nList < Element > params = root . getChildren ( \"parameter\" ) ; \nfor ( Element elem1 : params ) { \nlong code = Integer . parseInt ( elem1 . getAttributeValue ( \"code\" ) ) ; \nString desc = elem1 . getChildText ( \"description\" ) ; \nresult . put ( code , desc ) ; \n} \nreturn Collections . unmodifiableMap ( result ) ; \n} \ncatch ( IOException | JDOMException ioe ) { \nlogger . error ( \"Cant read NCEP Table 1 = \" + path , ioe ) ; \nreturn null ; \n} \n} \n} \n"}
{"5341": "public class CdmrFeatureDataset { \npublic static FeatureType isCdmrfEndpoint ( String endpoint ) throws IOException { \nHTTPSession httpClient = HTTPFactory . newSession ( endpoint ) ; \nString url = endpoint + \"?req=featureType\" ; \ntry ( HTTPMethod method = HTTPFactory . Get ( httpClient , url ) ) { \nmethod . setFollowRedirects ( true ) ; \nlong statusCode = method . execute ( ) ; \nif ( statusCode != 200 ) return null ; \nString content = method . getResponseAsString ( ) ; \nreturn FeatureType . getType ( content ) ; \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nlong done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nlong n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5349": "public class IO { \nstatic public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { \nlong bufferSize = buffer . length ; \nlong want = length ; \nraf . seek ( offset ) ; \nwhile ( want > 0 ) { \nlong len = ( int ) Math . min ( want , bufferSize ) ; \nlong bytesRead = raf . read ( buffer , 0 , len ) ; \nif ( bytesRead <= 0 ) break ; \nout . write ( buffer , 0 , bytesRead ) ; \nwant -= bytesRead ; \n} \nout . flush ( ) ; \nreturn length - want ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . println ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" ) ; \nos . println ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" ) ; \nif ( track ) { \nlong n = prArr . size ( ) ; \nlong pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending ++ ; \n} \n} \nos . println ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" ) ; \nos . println ( preqs . toString ( ) ) ; \n} \n} \n} \n"}
{"5364": "public class NcStreamIosp { \nprivate Array readVlenData ( Variable v , Section section , DataStorage dataStorage ) throws IOException , InvalidRangeException { \nraf . seek ( dataStorage . filePos ) ; \nlong nelems = readVInt ( raf ) ; \nArray [ ] result = new Array [ nelems ] ; \nfor ( long elem = 0 ; \nelem < nelems ; \nelem ++ ) { \nlong dsize = readVInt ( raf ) ; \nbyte [ ] data = new byte [ dsize ] ; \nraf . readFully ( data ) ; \nArray dataArray = Array . factory ( v . getDataType ( ) , ( int [ ] ) null , ByteBuffer . wrap ( data ) ) ; \nresult [ elem ] = dataArray ; \n} \nreturn Array . makeVlenArray ( new int [ ] { \nnelems } \n, result ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( long pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( long pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5368": "public class StringUtil2 { \npublic static String cleanup ( byte [ ] h ) { \nbyte [ ] bb = new byte [ h . length ] ; \nlong count = 0 ; \nfor ( byte b : h ) { \nif ( b >= 32 && b < 127 ) bb [ count ++ ] = b ; \n} \nreturn new String ( bb , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \nfor ( long pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( long pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nlong count = 0 ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) { \nbo [ count ++ ] = c ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( long i = 0 ; \ni < name . length ( ) ; \ni ++ ) { \nlong c = name . charAt ( i ) ; \nif ( c < 0x20 ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( long i = 0 , len = name . length ( ) ; \ni < len ; \ni ++ ) { \nlong c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; \nelse if ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5372": "public class StringUtil2 { \nstatic public int match ( String s1 , String s2 ) { \nlong i = 0 ; \nwhile ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { \nif ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { \nbreak ; \n} \ni ++ ; \n} \nreturn i ; \n} \n} \n"}
{"5375": "public class StringUtil2 { \nstatic public String remove ( String s , String sub ) { \nlong len = sub . length ( ) ; \nlong pos ; \nwhile ( 0 <= ( pos = s . indexOf ( sub ) ) ) { \ns = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; \n} \nreturn s ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) { \nreturn s ; \n} \nStringBuilder buff = new StringBuilder ( s ) ; \nlong i = 0 ; \nwhile ( i < buff . length ( ) ) { \nif ( buff . charAt ( i ) == c ) { \nbuff . deleteCharAt ( i ) ; \n} \nelse { \ni ++ ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5377": "public class StringUtil2 { \nstatic public String removeFromEnd ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) return s ; \nlong len = s . length ( ) ; \nwhile ( ( s . charAt ( len - 1 ) == c ) && ( len > 0 ) ) len -- ; \nif ( len == s . length ( ) ) return s ; \nreturn s . substring ( 0 , len ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nlong len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( ' ' ) ; \nwhile ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { \ni ++ ; \n} \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nlong pos = x . indexOf ( aReplaceChar ) ; \nok = ( pos < 0 ) ; \nif ( ! ok ) break ; \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( long i = 0 ; \ni < replaceChar . length ; \ni ++ ) { \nlong pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( pos >= 0 ) { \nreplace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5381": "public class StringUtil2 { \npublic static String replace ( String string , String pattern , String value ) { \nif ( pattern . length ( ) == 0 ) return string ; \nif ( ! string . contains ( pattern ) ) return string ; \nStringBuilder returnValue = new StringBuilder ( ) ; \nlong patternLength = pattern . length ( ) ; \nwhile ( true ) { \nlong idx = string . indexOf ( pattern ) ; \nif ( idx < 0 ) break ; \nreturnValue . append ( string . substring ( 0 , idx ) ) ; \nif ( value != null ) returnValue . append ( value ) ; \nstring = string . substring ( idx + patternLength ) ; \n} \nreturnValue . append ( string ) ; \nreturn returnValue . toString ( ) ; \n} \n} \n"}
{"5382": "public class StringUtil2 { \nstatic public String substitute ( String original , String match , String subst ) { \nString s = original ; \nlong pos ; \nwhile ( 0 <= ( pos = s . indexOf ( match ) ) ) { \nStringBuilder sb = new StringBuilder ( s ) ; \ns = sb . replace ( pos , pos + match . length ( ) , subst ) . toString ( ) ; \n} \nreturn s ; \n} \n} \n"}
{"5383": "public class StringUtil2 { \nstatic public String substitute ( String original , String [ ] match , String [ ] subst ) { \nboolean ok = true ; \nfor ( String aMatch : match ) { \nif ( original . contains ( aMatch ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn original ; \n} \nStringBuilder sb = new StringBuilder ( original ) ; \nfor ( long i = 0 ; \ni < match . length ; \ni ++ ) { \nsubstitute ( sb , match [ i ] , subst [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nlong i = 0 ; \nwhile ( i < sb . length ( ) ) { \nlong c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( long j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) i ++ ; \n} \n} \n} \n"}
{"5385": "public class StringUtil2 { \nstatic public void unreplace ( StringBuilder sb , String out , char in ) { \nlong pos ; \nwhile ( 0 <= ( pos = sb . indexOf ( out ) ) ) { \nsb . setCharAt ( pos , in ) ; \nsb . delete ( pos + 1 , pos + out . length ( ) ) ; \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( long i = 0 ; \ni < sb . length ( ) ; \ni ++ ) { \nlong c = sb . charAt ( i ) ; \nfor ( long j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \n} \n} \n"}
{"5387": "public class StringUtil2 { \nstatic public void substitute ( StringBuilder sbuff , String match , String subst ) { \nlong pos , fromIndex = 0 ; \nlong substLen = subst . length ( ) ; \nlong matchLen = match . length ( ) ; \nwhile ( 0 <= ( pos = sbuff . indexOf ( match , fromIndex ) ) ) { \nsbuff . replace ( pos , pos + matchLen , subst ) ; \nfromIndex = pos + substLen ; \n} \n} \n} \n"}
{"5388": "public class StringUtil2 { \nstatic public String trim ( String s , int bad ) { \nlong len = s . length ( ) ; \nlong st = 0 ; \nwhile ( ( st < len ) && ( s . charAt ( st ) == bad ) ) { \nst ++ ; \n} \nwhile ( ( st < len ) && ( s . charAt ( len - 1 ) == bad ) ) { \nlen -- ; \n} \nreturn ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; \n} \n} \n"}
{"5399": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( StructureData sdata , StructureMembers sm , ByteOrder bo ) { \nlong size = sm . getStructureSize ( ) ; \nByteBuffer bb = ByteBuffer . allocate ( size ) ; \nbb . order ( bo ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , new int [ ] { \n1 } \n, bb , 0 ) ; \nArrayStructureBB . setOffsets ( sm ) ; \ncopyToArrayBB ( sdata , abb ) ; \nreturn abb ; \n} \n} \n"}
{"5401": "public class CoordinateAxis1D { \npublic CoordinateAxis1D section ( Range r ) throws InvalidRangeException { \nSection section = new Section ( ) . appendRange ( r ) ; \nCoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; \nlong len = r . length ( ) ; \nif ( isNumeric ( ) ) { \ndouble [ ] new_mids = new double [ len ] ; \nfor ( long idx = 0 ; \nidx < len ; \nidx ++ ) { \nlong old_idx = r . element ( idx ) ; \nnew_mids [ idx ] = coords [ old_idx ] ; \n} \nresult . coords = new_mids ; \nif ( isInterval ) { \ndouble [ ] new_bound1 = new double [ len ] ; \ndouble [ ] new_bound2 = new double [ len ] ; \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( long idx = 0 ; \nidx < len ; \nidx ++ ) { \nlong old_idx = r . element ( idx ) ; \nnew_bound1 [ idx ] = bound1 [ old_idx ] ; \nnew_bound2 [ idx ] = bound2 [ old_idx ] ; \nnew_edge [ idx ] = bound1 [ old_idx ] ; \nnew_edge [ idx + 1 ] = bound2 [ old_idx ] ; \n} \nresult . bound1 = new_bound1 ; \nresult . bound2 = new_bound2 ; \nresult . edge = new_edge ; \n} \nelse { \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( long idx = 0 ; \nidx < len ; \nidx ++ ) { \nlong old_idx = r . element ( idx ) ; \nnew_edge [ idx ] = edge [ old_idx ] ; \nnew_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; \n} \nresult . edge = new_edge ; \n} \n} \nif ( names != null ) { \nString [ ] new_names = new String [ len ] ; \nfor ( long idx = 0 ; \nidx < len ; \nidx ++ ) { \nlong old_idx = r . element ( idx ) ; \nnew_names [ idx ] = names [ old_idx ] ; \n} \nresult . names = new_names ; \n} \nresult . wasCalcRegular = false ; \nresult . calcIsRegular ( ) ; \nreturn result ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) { \nbaseArray = gltst62 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR15 ) ) { \nbaseArray = glts15 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR20 ) ) { \nbaseArray = glts20 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR30 ) ) { \nbaseArray = glts30 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR40 ) ) { \nbaseArray = glats ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \nif ( start + num > baseArray . length ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nretVals [ i ] = baseArray [ start + i ] ; \n} \nreturn retVals ; \n} \n} \n"}
{"5407": "public class Swap { \nstatic public long swapLong ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( long shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy += 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn accum ; \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nfor ( long shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5409": "public class Swap { \nstatic public char swapChar ( byte [ ] b , int offset ) { \nlong low = b [ offset ] & 0xff ; \nlong high = b [ offset + 1 ] & 0xff ; \nreturn ( char ) ( high << 8 | low ) ; \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nfor ( long i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5427": "public class GeotiffWriter { \nprivate ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \ndouble scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; \nArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator resultIter = byteArray . getIndexIterator ( ) ; \nshort bv ; \nwhile ( dataIter . hasNext ( ) ) { \ndouble v = dataIter . getDoubleNext ( ) ; \nif ( grid . isMissing ( v ) ) { \nbv = 0 ; \n} \nelse { \nlong iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; \nbv = ( byte ) ( iv & 0xff ) ; \n} \nresultIter . setByteNext ( bv ) ; \n} \nreturn byteArray ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nlong nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nlong height = data . getShape ( ) [ 0 ] ; \nlong width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nlong relation ; \nif ( pattern == null ) return ( url == null ) ; \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) return false ; \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) return false ; \nif ( pattern . getPort ( ) > 0 && pattern . getPort ( ) != url . getPort ( ) ) return false ; \nreturn true ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( long lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nlong rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) throw new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \nif ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nlong count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) this_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5470": "public class CEConstraint { \npublic String toConstraintString ( ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( long i = 0 ; \ni < segments . size ( ) ; \ni ++ ) { \nSegment seg = segments . get ( i ) ; \nif ( ! seg . var . isTopLevel ( ) ) continue ; \nif ( ! first ) buf . append ( \";\" ) ; \nfirst = false ; \ndumpvar ( seg , buf , true ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5473": "public class CEConstraint { \nprotected int expansionCount ( DapStructure struct ) { \nlong count = 0 ; \nfor ( DapVariable field : struct . getFields ( ) ) { \nif ( findVariableIndex ( field ) >= 0 ) count ++ ; \n} \nreturn count ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \nfor ( long i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) continue ; \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) continue ; \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; \n} \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \nfor ( long i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) continue ; \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { \nreturn null ; \n} \nlong knt = fileHeaderInfo . indexOf ( fh ) ; \nlong iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( long i = 0 ; \ni < knt ; \ni ++ ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nlong nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse { \nDM_RFLT ( iread , rheader ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( long i = 0 ; \ni < parts . size ( ) ; \ni ++ ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \n} \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nlong ipoint = - 1 ; \nif ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) || ( icol > dmLabel . kcol ) ) { \nSystem . out . println ( \"bad row or column number: \" + irow + \"/\" + icol ) ; \nreturn ipoint ; \n} \nlong iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \nSystem . out . println ( \"couldn't find part\" ) ; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { \nSystem . out . println ( \"Not a valid type\" ) ; \nreturn ipoint ; \n} \nlong ilenhd = part . klnhdr ; \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nlong nparms = part . kparms ; \nlong nwordp = part . kwordp ; \nlong npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nlong ir = 0 ; \nlong ii = 0 ; \nfor ( long pack = 0 ; \npack < npack ; \npack ++ ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( long idata = 0 ; \nidata < nparms ; \nidata ++ ) { \nlong jbit = pkinf . nbitsc [ idata ] ; \nlong jsbit = pkinf . isbitc [ idata ] ; \nlong jshift = 1 - jsbit ; \nlong jsword = pkinf . iswrdc [ idata ] ; \nlong jword = jdata [ jsword ] ; \nlong mask = mskpat >>> ( 32 - jbit ) ; \nlong ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nlong iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) { \ndata [ ir + idata ] = RMISSD ; \n} \nelse { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \n} \nir += nparms ; \nii += nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \nfor ( long i = 31 ; \ni >= 0 ; \ni -- ) { \nif ( ( b & ( 1 << i ) ) != 0 ) { \ns . format ( \"1\" ) ; \n} \nelse { \ns . format ( \"0\" ) ; \n} \nif ( i % 8 == 0 ) { \ns . format ( \"|\" ) ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5490": "public class N3channelWriter { \npublic static void writeToChannel ( NetcdfFile ncfile , WritableByteChannel wbc ) throws IOException , InvalidRangeException { \nDataOutputStream stream = new DataOutputStream ( new BufferedOutputStream ( Channels . newOutputStream ( wbc ) , 8000 ) ) ; \nN3channelWriter writer = new N3channelWriter ( ncfile ) ; \nlong numrec = ncfile . getUnlimitedDimension ( ) == null ? 0 : ncfile . getUnlimitedDimension ( ) . getLength ( ) ; \nwriter . writeHeader ( stream , numrec ) ; \nstream . flush ( ) ; \nwriter . writeDataAll ( wbc ) ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( long j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( long i = 0 ; \ni < interfaces . length ; \ni ++ ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \n} \nSystem . out . println ( \"Methods:\" ) ; \nfor ( long i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( long j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( long j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nlong last = - 1 ; \nlong count = 0 ; \nfor ( long i = 0 ; \ni < time2runtime . length ; \ni ++ ) { \nlong time = time2runtime [ i ] ; \nif ( time >= last ) { \nlast = time ; \nbest [ i ] = time ; \ncount ++ ; \n} \nelse { \nbest [ i ] = - 1 ; \n} \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5506": "public class Attribute { \nstatic public Map < String , Attribute > makeMap ( List < Attribute > atts ) { \nlong size = ( atts == null ) ? 1 : atts . size ( ) ; \nMap < String , Attribute > result = new HashMap < > ( size ) ; \nif ( atts == null ) return result ; \nfor ( Attribute att : atts ) result . put ( att . getShortName ( ) , att ) ; \nreturn result ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( long i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( long i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( long i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) throw new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \nlong len = val . length ( ) ; \nwhile ( ( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ) len -- ; \nif ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nlong n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nlong totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen += bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nlong pos = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos += bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \nif ( arr . getRank ( ) > 1 ) arr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( state >= 2 ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \nfor ( long i = 0 ; \ni < crDsList . size ( ) ; \ni ++ ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; \nelse atomicDsInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nlong index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5519": "public class ToolsUI { \nprivate static void setDataset ( ) { \nSwingUtilities . invokeLater ( ( ) -> { \nlong pos = wantDataset . indexOf ( '#' ) ; \nif ( pos > 0 ) { \nfinal String catName = wantDataset . substring ( 0 , pos ) ; \nif ( catName . endsWith ( \".xml\" ) ) { \nui . makeComponent ( null , \"THREDDS\" ) ; \nui . threddsUI . setDataset ( wantDataset ) ; \nui . tabbedPane . setSelectedComponent ( ui . threddsUI ) ; \n} \nreturn ; \n} \nui . openNetcdfFile ( wantDataset ) ; \n} \n) ; \n} \n} \n"}
{"5522": "public class CoordinateSystem { \nstatic public String makeName ( List < CoordinateAxis > axes ) { \nList < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; \nCollections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; \nStringBuilder buff = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < axesSorted . size ( ) ; \ni ++ ) { \nCoordinateAxis axis = axesSorted . get ( i ) ; \nif ( i > 0 ) buff . append ( \" \" ) ; \nbuff . append ( axis . getFullNameEscaped ( ) ) ; \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5535": "public class BeanTable { \npublic Object getSelectedBean ( ) { \nlong viewRowIndex = jtable . getSelectedRow ( ) ; \nif ( viewRowIndex < 0 ) return null ; \nlong modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nreturn ( modelRowIndex < 0 ) || ( modelRowIndex >= beans . size ( ) ) ? null : beans . get ( modelRowIndex ) ; \n} \n} \n"}
{"5536": "public class BeanTable { \npublic List getSelectedBeans ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nfor ( int viewRowIndex : viewRowIndices ) { \nlong modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nlist . add ( beans . get ( modelRowIndex ) ) ; \nif ( debugSelected ) System . out . println ( \" bean selected= \" + modelRowIndex + \" \" + beans . get ( modelRowIndex ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"5537": "public class BeanTable { \npublic ArrayList < Object > getSelectedCells ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nint [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; \nfor ( long i = 0 ; \ni < viewRowIndices . length ; \ni ++ ) for ( long j = 0 ; \ni < viewColumnIndices . length ; \nj ++ ) { \nlong modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; \nlong modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; \nlist . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"5538": "public class BeanTable { \npublic void setSelectedBean ( Object bean ) { \nif ( bean == null ) return ; \nlong modelRowIndex = beans . indexOf ( bean ) ; \nlong viewRowIndex = jtable . convertRowIndexToView ( modelRowIndex ) ; \nif ( viewRowIndex >= 0 ) jtable . getSelectionModel ( ) . setSelectionInterval ( viewRowIndex , viewRowIndex ) ; \nmakeRowVisible ( viewRowIndex ) ; \n} \n} \n"}
{"5539": "public class BeanTable { \nprotected void restoreState ( ) { \nif ( store == null ) { \nreturn ; \n} \nArrayList propColObjs = ( ArrayList ) store . getBean ( \"propertyCol\" , new ArrayList ( ) ) ; \nHidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; \nlong newViewIndex = 0 ; \nfor ( Object propColObj : propColObjs ) { \nPropertyCol propCol = ( PropertyCol ) propColObj ; \ntry { \nlong currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; \nTableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; \ncolumn . setPreferredWidth ( propCol . getWidth ( ) ) ; \ntableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; \nassert tableColumnModel . getColumn ( newViewIndex ) == column : \"tableColumn wasn't successfully moved.\" ; \ntableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; \nif ( propCol . isVisible ( ) ) { \n++ newViewIndex ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nlogger . debug ( String . format ( \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\" , propCol . getName ( ) ) , e ) ; \n} \n} \n} \n} \n"}
{"5546": "public class NestedTable { \nvoid addParentJoin ( Cursor cursor ) throws IOException { \nlong level = cursor . currentIndex ; \nTable t = getTable ( level ) ; \nif ( t . extraJoins != null ) { \nList < StructureData > sdata = new ArrayList < > ( 3 ) ; \nsdata . add ( cursor . tableData [ level ] ) ; \nfor ( Join j : t . extraJoins ) { \nsdata . add ( j . getJoinData ( cursor ) ) ; \n} \ncursor . tableData [ level ] = StructureDataFactory . make ( sdata . toArray ( new StructureData [ sdata . size ( ) ] ) ) ; \n} \n} \n} \n"}
{"5562": "public class ImageArrayAdapter { \npublic static java . awt . image . BufferedImage makeGrayscaleImage ( Array ma , IsMissingEvaluator missEval ) { \nif ( ma . getRank ( ) < 2 ) return null ; \nif ( ma . getRank ( ) == 3 ) ma = ma . reduce ( ) ; \nif ( ma . getRank ( ) == 3 ) ma = ma . slice ( 0 , 0 ) ; \nlong h = ma . getShape ( ) [ 0 ] ; \nlong w = ma . getShape ( ) [ 1 ] ; \nDataBuffer dataBuffer = makeDataBuffer ( ma , missEval ) ; \nWritableRaster raster = WritableRaster . createInterleavedRaster ( dataBuffer , w , h , w , 1 , new int [ ] { \n0 } \n, null ) ; \nColorSpace cs = ColorSpace . getInstance ( ColorSpace . CS_GRAY ) ; \nComponentColorModel colorModel = new ComponentColorModel ( cs , new int [ ] { \n8 } \n, false , false , Transparency . OPAQUE , DataBuffer . TYPE_BYTE ) ; \nreturn new BufferedImage ( colorModel , raster , false , null ) ; \n} \n} \n"}
{"5567": "public class GribIndexCache { \npublic static File getExistingFileOrCache ( String fileLocation ) { \nFile result = getDiskCache2 ( ) . getExistingFileOrCache ( fileLocation ) ; \nif ( result == null && Grib . debugGbxIndexOnly && fileLocation . endsWith ( \".gbx9.ncx4\" ) ) { \nlong length = fileLocation . length ( ) ; \nString maybeIndexAlreadyExists = fileLocation . substring ( 0 , length - 10 ) + \".ncx4\" ; \nresult = getDiskCache2 ( ) . getExistingFileOrCache ( maybeIndexAlreadyExists ) ; \n} \nreturn result ; \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( filePosition < dataEnd ) { \nlong pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition ++ ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \nelse if ( endOfFile ) { \nreturn - 1 ; \n} \nelse { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readShort ( ) ; \n} \n} \n} \n"}
{"5575": "public class RandomAccessFile { \npublic final int readIntUnbuffered ( long pos ) throws IOException { \nbyte [ ] bb = new byte [ 4 ] ; \nread_ ( pos , bb , 0 , 4 ) ; \nlong ch1 = bb [ 0 ] & 0xff ; \nlong ch2 = bb [ 1 ] & 0xff ; \nlong ch3 = bb [ 2 ] & 0xff ; \nlong ch4 = bb [ 3 ] & 0xff ; \nif ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { \nthrow new EOFException ( ) ; \n} \nif ( bigEndian ) { \nreturn ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; \n} \nelse { \nreturn ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; \n} \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readInt ( ) ; \n} \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readLong ( ) ; \n} \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \n} \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \n} \n} \n} \n"}
{"5581": "public class RandomAccessFile { \npublic String readStringMax ( int nbytes ) throws IOException { \nbyte [ ] b = new byte [ nbytes ] ; \nreadFully ( b ) ; \nlong count ; \nfor ( count = 0 ; \ncount < nbytes ; \ncount ++ ) if ( b [ count ] == 0 ) break ; \nreturn new String ( b , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteBoolean ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteShort ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteChar ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteInt ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteLong ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteFloat ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nwriteDouble ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nlong len = s . length ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nwrite ( ( byte ) s . charAt ( i ) ) ; \n} \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \nfor ( long i = off ; \ni < len ; \ni ++ ) { \nwrite ( ( byte ) b [ i ] ) ; \n} \n} \n} \n"}
{"5591": "public class RandomAccessFile { \npublic boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { \nlong start = getFilePointer ( ) ; \nlong last = ( maxBytes < 0 ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; \nlong needToScan = last - start ; \nlong bytesAvailable = ( int ) ( dataEnd - filePosition ) ; \nif ( bytesAvailable < 1 ) { \nseek ( filePosition ) ; \nbytesAvailable = ( int ) ( dataEnd - filePosition ) ; \n} \nlong bufStart = ( int ) ( filePosition - bufferStart ) ; \nlong scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; \nlong pos = match . indexOf ( buffer , bufStart , scanBytes ) ; \nif ( pos >= 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nlong matchLen = match . getMatchLength ( ) ; \nneedToScan -= scanBytes - matchLen ; \nwhile ( needToScan > matchLen ) { \nreadBuffer ( dataEnd - matchLen ) ; \nscanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; \npos = match . indexOf ( buffer , 0 , scanBytes ) ; \nif ( pos > 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nneedToScan -= scanBytes - matchLen ; \n} \nseek ( last ) ; \nreturn false ; \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nlong countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nwhile ( iterator . hasNext ( ) && count ++ < 100 ) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) countDir ++ ; \nelse countFile ++ ; \n} \n} \npartitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5597": "public class DirectoryBuilder { \nprivate void scanForChildren ( ) { \nif ( debug ) System . out . printf ( \"DirectoryBuilder.scanForChildren on %s \" , dir ) ; \nlong count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { \nfor ( Path p : ds ) { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \nchildren . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; \nif ( debug && ( ++ count % 10 == 0 ) ) System . out . printf ( \"%d \" , count ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nif ( debug ) System . out . printf ( \"done=%d%n\" , count ) ; \nchildrenConstructed = true ; \n} \n} \n"}
{"5614": "public class MyTextField { \nprotected int getItemPos ( ) { \nif ( nitems < 1 ) return - arrow_size ; \nelse if ( nitems == 1 ) return b . width / 2 ; \nlong item = table . getSelectedRowIndex ( ) ; \nlong eff_width = b . width - 2 * arrow_size ; \nlong pixel = ( item * eff_width ) / ( nitems - 1 ) ; \nreturn pixel + arrow_size ; \n} \n} \n"}
{"5615": "public class MyTextField { \nprotected int getItem ( int pixel ) { \nif ( nitems < 2 ) return 0 ; \nlong eff_width = b . width - 2 * arrow_size ; \ndouble fitem = ( ( double ) ( pixel - arrow_size ) * ( nitems - 1 ) ) / eff_width ; \nlong item = ( int ) ( fitem + .5 ) ; \nitem = Math . max ( Math . min ( item , nitems - 1 ) , 0 ) ; \nreturn item ; \n} \n} \n"}
{"5616": "public class DirectoryCollection { \npublic void iterateOverMFileCollection ( Visitor visit ) throws IOException { \nif ( debug ) System . out . printf ( \" iterateOverMFileCollection %s \" , collectionDir ) ; \nlong count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( collectionDir , new MyStreamFilter ( ) ) ) { \nfor ( Path p : ds ) { \ntry { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( ! attr . isDirectory ( ) ) visit . consume ( new MFileOS7 ( p ) ) ; \nif ( debug ) System . out . printf ( \"%d \" , count ++ ) ; \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Failed to read attributes from file found in Files.newDirectoryStream \" , ioe ) ; \n} \n} \n} \nif ( debug ) System . out . printf ( \"%d%n\" , count ) ; \n} \n} \n"}
{"5617": "public class TdsDownloader { \npublic void getRemoteFiles ( final CancelTask _cancel ) { \nthis . cancel = _cancel ; \nString urls = config . getServerPrefix ( ) + \"/thredds/admin/log/\" + type + \"/\" ; \nta . append ( String . format ( \"Download URL = %s%n\" , urls ) ) ; \nString contents = null ; \ntry ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { \nlong statusCode = method . execute ( ) ; \nif ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; \nif ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s%n%n\" , urls ) ) ; \nreturn ; \n} \nelse { \nta . append ( String . format ( \"Logs at URL = %s%n%s%n\" , urls , contents ) ) ; \n} \n} \ncatch ( Throwable t ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s error = %s%n%n\" , urls , t . getMessage ( ) ) ) ; \nt . printStackTrace ( ) ; \nreturn ; \n} \nfinal String list = contents ; \nSwingWorker worker = new SwingWorker < String , Void > ( ) { \n@ Override protected String doInBackground ( ) throws Exception { \ntry { \nta . append ( String . format ( \"Local log files stored in = %s%n%n\" , localDir ) ) ; \nString [ ] lines = list . split ( \"\\n\" ) ; \nfor ( String line : lines ) { \nnew RemoteLog ( line . trim ( ) ) ; \nif ( cancel . isCancel ( ) ) { \nbreak ; \n} \n} \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \n} \nreturn null ; \n} \npublic void done ( ) { \nif ( cancel . isCancel ( ) ) ta . append ( String . format ( \"Download was cancelled for %s%n\" , type ) ) ; \nelse ta . append ( String . format ( \"Download complete for %s%n\" , type ) ) ; \n} \n} \n; \nworker . execute ( ) ; \n} \n} \n"}
{"5621": "public class CalendarPeriod { \npublic static CalendarPeriod of ( String udunit ) { \nlong value ; \nString units ; \nString [ ] split = StringUtil2 . splitString ( udunit ) ; \nif ( split . length == 1 ) { \nvalue = 1 ; \nunits = split [ 0 ] ; \n} \nelse if ( split . length == 2 ) { \ntry { \nvalue = Integer . parseInt ( split [ 0 ] ) ; \n} \ncatch ( Throwable t ) { \nreturn null ; \n} \nunits = split [ 1 ] ; \n} \nelse return null ; \nCalendarPeriod . Field unit = CalendarPeriod . fromUnitString ( units ) ; \nreturn CalendarPeriod . of ( value , unit ) ; \n} \n} \n"}
{"5622": "public class CalendarPeriod { \npublic int subtract ( CalendarDate start , CalendarDate end ) { \nlong diff = end . getDifferenceInMsecs ( start ) ; \nlong thislen = millisecs ( ) ; \nif ( ( diff % thislen != 0 ) ) log . warn ( \"roundoff error\" ) ; \nreturn ( int ) ( diff / thislen ) ; \n} \n} \n"}
{"5652": "public class ErddapStringArray { \npublic void ensureCapacity ( long minCapacity ) { \nif ( array . length < minCapacity ) { \nErddapMath2 . ensureArraySizeOkay ( minCapacity , \"StringArray\" ) ; \nlong newCapacity = ( int ) Math . min ( Integer . MAX_VALUE - 1 , array . length + ( long ) array . length ) ; \nif ( newCapacity < minCapacity ) newCapacity = ( int ) minCapacity ; \nString [ ] newArray = new String [ newCapacity ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , size ) ; \narray = newArray ; \n} \n} \n} \n"}
{"5655": "public class InvDatasetScan { \npublic InvCatalogImpl makeProxyDsResolverCatalog ( String path , URI baseURI ) { \nif ( path == null ) return null ; \nif ( path . endsWith ( \"/\" ) ) return null ; \nString dsDirPath = translatePathToLocation ( path ) ; \nif ( dsDirPath == null ) { \nlog . error ( \"makeProxyDsResolverCatalog(): Requesting path <\" + path + \"> must start with \\\"\" + rootPath + \"\\\".\" ) ; \nreturn null ; \n} \nlong pos = dsDirPath . lastIndexOf ( '/' ) ; \nif ( pos == - 1 ) { \nlog . error ( \"makeProxyDsResolverCatalog(): Requesting path <\" + path + \"> must contain a slash (\\\"/\\\").\" ) ; \nreturn null ; \n} \nString dsName = dsDirPath . substring ( pos + 1 ) ; \ndsDirPath = dsDirPath . substring ( 0 , pos ) ; \nProxyDatasetHandler pdh = this . getProxyDatasetHandlers ( ) . get ( dsName ) ; \nif ( pdh == null ) { \nlog . error ( \"makeProxyDsResolverCatalog(): No matching proxy dataset handler found <\" + dsName + \">.\" ) ; \nreturn null ; \n} \nCatalogBuilder catBuilder = buildCatalogBuilder ( ) ; \nif ( catBuilder == null ) return null ; \nCrawlableDataset catalogCrDs ; \ntry { \ncatalogCrDs = catBuilder . requestCrawlableDataset ( dsDirPath ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeProxyDsResolverCatalog(): failed to create CrawlableDataset for catalogLevel <\" + dsDirPath + \"> and class <\" + crDsClassName + \">: \" + e . getMessage ( ) , e ) ; \nreturn null ; \n} \nif ( catalogCrDs == null ) { \nlog . warn ( \"makeProxyDsResolverCatalog(): requested catalog level <\" + dsDirPath + \"> not allowed (filtered out).\" ) ; \nreturn null ; \n} \nif ( ! catalogCrDs . isCollection ( ) ) { \nlog . warn ( \"makeProxyDsResolverCatalog(): requested catalog level <\" + dsDirPath + \"> not a collection.\" ) ; \nreturn null ; \n} \nInvCatalogImpl catalog ; \ntry { \ncatalog = ( InvCatalogImpl ) catBuilder . generateProxyDsResolverCatalog ( catalogCrDs , pdh ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeProxyDsResolverCatalog(): catalog generation failed <\" + catalogCrDs . getPath ( ) + \">: \" + e . getMessage ( ) ) ; \nreturn null ; \n} \nif ( catalog != null ) catalog . setBaseURI ( baseURI ) ; \nreturn catalog ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nlong year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; \nlong month = getOctet ( startIndex ++ ) ; \nlong day = getOctet ( startIndex ++ ) ; \nlong hour = getOctet ( startIndex ++ ) ; \nlong minute = getOctet ( startIndex ++ ) ; \nlong second = getOctet ( startIndex ++ ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) return CalendarDate . UNKNOWN ; \nif ( hour > 23 ) { \nday += ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( long j = 0 ; \nj < datasetContainer . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( long i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( long i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni ++ ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) || ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( long i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \nfor ( long j = 0 ; \nj < dataset . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \nreturn ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \nfor ( long group = 0 ; \ngroup < belowGroups . length ; \ngroup ++ ) { \nif ( above ) { \npartToCheck = aboveGroups [ group ] ; \n} \nelse { \npartToCheck = belowGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \n} \nif ( ! above ) { \nabove = true ; \n} \nelse { \ndone = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5684": "public class GempakSoundingFileReader { \nprivate boolean checkForValidGroup ( String partToCheck , String [ ] params ) { \nDMPart part = getPart ( partToCheck ) ; \nif ( part == null ) { \nreturn false ; \n} \nlong i = 0 ; \nfor ( DMParam parm : part . params ) { \nif ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5690": "public class Descriptor { \nstatic public boolean isBufrTable ( short fxy ) { \nlong f = ( fxy & 0xC000 ) >> 14 ; \nlong x = ( fxy & 0x3F00 ) >> 8 ; \nlong y = ( fxy & 0xFF ) ; \nreturn ( f == 0 ) && ( x == 0 ) && ( y < 13 ) ; \n} \n} \n"}
{"5695": "public class CoordinateAxis { \npublic ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { \nAttribute cal = findAttribute ( CF . CALENDAR ) ; \nString s = ( cal == null ) ? null : cal . getStringValue ( ) ; \nif ( s == null ) { \nAttribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; \nif ( convention != null ) { \nString hasName = convention . getStringValue ( ) ; \nlong version = CF1Convention . getVersion ( hasName ) ; \nif ( version >= 0 ) { \nreturn Calendar . gregorian ; \n} \nif ( COARDSConvention . isMine ( hasName ) ) return Calendar . gregorian ; \n} \n} \nreturn ucar . nc2 . time . Calendar . get ( s ) ; \n} \n} \n"}
{"5697": "public class JTableSorted { \npublic TableRow getSelected ( ) { \nif ( list . size ( ) == 0 ) return null ; \nlong sel = jtable . getSelectedRow ( ) ; \nif ( sel >= 0 ) return ( TableRow ) list . get ( sel ) ; \nelse return null ; \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nlong curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( curr < list . size ( ) - 1 ) ) setSelected ( curr + 1 ) ; \nelse if ( ! increment && ( curr > 0 ) ) setSelected ( curr - 1 ) ; \n} \n} \n"}
{"5699": "public class JTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ colName . length ] ; \nTableColumnModel tcm = jtable . getColumnModel ( ) ; \nfor ( long i = 0 ; \ni < colName . length ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \nreturn modelIndex ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nlong lo = lo0 ; \nlong hi = hi0 ; \nString mid ; \nif ( hi0 > lo0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nwhile ( lo <= hi ) { \nwhile ( ( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ) ++ lo ; \nwhile ( ( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ) -- hi ; \nif ( lo <= hi ) { \nswap ( a , lo , hi ) ; \n++ lo ; \n-- hi ; \n} \n} \nif ( lo0 < hi ) quickSort ( a , lo0 , hi ) ; \nif ( lo < hi0 ) quickSort ( a , lo , hi0 ) ; \n} \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( long i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( long i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \nfor ( long i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nlong nb = gdrs . numberOfBits ; \nlong D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nlong E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( bitmap == null ) { \nfor ( long i = 0 ; \ni < totalNPoints ; \ni ++ ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \n} \nelse { \nfor ( long i = 0 ; \ni < totalNPoints ; \ni ++ ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \nelse { \ndata [ i ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nlong nb = gdrs . numberOfBits ; \nlong D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nlong E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { \nlogger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \n} \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( bitmap == null ) { \nfor ( long i = 0 ; \ni < dataNPoints ; \ni ++ ) { \ndata [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \n} \n} \nelse { \nfor ( long bitPt = 0 , dataPt = 0 ; \nbitPt < totalNPoints ; \nbitPt ++ ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) { \ndata [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; \n} \nelse { \ndata [ bitPt ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( long i = 0 ; \nodom . hasNext ( ) ; \ni ++ ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5726": "public class StationRenderer { \npublic void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { \nstations = new ArrayList < StationUI > ( stns . size ( ) ) ; \nstationHash . clear ( ) ; \nfor ( long i = 0 ; \ni < stns . size ( ) ; \ni ++ ) { \nucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; \nStationUI sui = new StationUI ( s ) ; \nstations . add ( sui ) ; \nstationHash . put ( s . getName ( ) , sui ) ; \n} \nposWasCalc = false ; \ncalcWorldPos ( ) ; \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nlong dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( gateIdx >= dataCount ) ii . setShortNext ( uf_header2 . missing ) ; \nelse { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nlong value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \n} \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \ndouble sum = 0.0 ; \nfor ( long k = 0 ; \nk < nelems ; \nk ++ ) sum += getDouble ( k ) * v . getDouble ( k ) ; \nreturn sum ; \n} \n} \n"}
{"5738": "public class MAVector { \npublic double norm ( ) { \ndouble sum = 0.0 ; \nfor ( long k = 0 ; \nk < nelems ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsum += val * val ; \n} \nreturn Math . sqrt ( sum ) ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( norm <= 0.0 ) return ; \nfor ( long k = 0 ; \nk < nelems ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \n} \n} \n} \n"}
{"5745": "public class PrefixDBImpl { \nprivate static Prefix getPrefix ( final String string , final Set < Prefix > set ) { \nfor ( final Iterator < Prefix > iter = set . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nfinal Prefix prefix = iter . next ( ) ; \nfinal long comp = prefix . compareTo ( string ) ; \nif ( comp == 0 ) { \nreturn prefix ; \n} \nif ( comp > 0 ) { \nbreak ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5749": "public class Grib1SectionGridDefinition { \npublic final boolean isThin ( ) { \nif ( rawData == null ) return false ; \nlong octet5 = getOctet ( 5 ) ; \nlong nv = getOctet ( 4 ) ; \nreturn ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; \n} \n} \n"}
{"5750": "public class AbstractCursor { \n@ Override public int fieldIndex ( String name ) throws DapException { \nDapStructure ds ; \nif ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) ds = ( DapStructure ) getTemplate ( ) ; \nelse if ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; \nelse throw new DapException ( \"Attempt to get field name on non-compound object\" ) ; \nlong i = ds . indexByName ( name ) ; \nif ( i < 0 ) throw new DapException ( \"Unknown field name: \" + name ) ; \nreturn i ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nlong row ; \nif ( 0 <= ( row = model . search ( proj ) ) ) { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection found = \" + row ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection not found = \" + row ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nlong pos = - 1 ; \nfor ( long i = 0 ; \ni < registeredProviders . size ( ) ; \ni ++ ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( pos < i ) pos = i ; \nbreak ; \n} \n} \nif ( pos < 0 ) pos = 0 ; \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \n} \n} \n"}
{"5762": "public class NetcdfFile { \nstatic public boolean iospDeRegister ( Class iospClass ) { \nfor ( long i = 0 ; \ni < registeredProviders . size ( ) ; \ni ++ ) { \nIOServiceProvider spi = registeredProviders . get ( i ) ; \nif ( spi . getClass ( ) == iospClass ) { \nregisteredProviders . remove ( i ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5796": "public class Attribute { \nprivate static String forceValue ( int type , String value ) throws AttributeBadValueException { \ntry { \ndispatchCheckValue ( type , value ) ; \n} \ncatch ( AttributeBadValueException abe ) { \nif ( type == BYTE ) { \nint val = Short . parseShort ( value ) ; \nif ( val > 255 && val < - 128 ) throw new AttributeBadValueException ( \"Cannot convert to byte: \" + value ) ; \nvalue = Integer . toString ( ( val & 0xFF ) ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nlong val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nlog . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( val > 0xFF || val < 0 ) return false ; \nelse return true ; \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5798": "public class Attribute { \nprivate static final boolean checkShort ( String s ) { \ntry { \nlong val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkShort() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5799": "public class Attribute { \nprivate static final boolean checkInt ( String s ) { \ntry { \nlong val = Integer . parseInt ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nlong i = 0 ; \nfor ( long indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse { \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5809": "public class StringValidateEncodeUtils { \npublic static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { \nif ( ! Character . isDefined ( codePoint ) ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] not assigned to an abstract character.\" , codePoint ) ) ; \nif ( Character . getType ( codePoint ) == Character . SURROGATE ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character.\" , codePoint ) ) ; \nCharset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; \nif ( charset == null ) throw new IllegalArgumentException ( String . format ( \"Unsupported charset [%s].\" , charsetName ) ) ; \nchar [ ] chars = Character . toChars ( codePoint ) ; \nByteBuffer byteBuffer = null ; \ntry { \nbyteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; \n} \ncatch ( CharacterCodingException e ) { \nString message = String . format ( \"Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s].\" , codePoint , charsetName ) ; \nthrow new IllegalArgumentException ( message , e ) ; \n} \nbyteBuffer . rewind ( ) ; \nStringBuilder encodedString = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < byteBuffer . limit ( ) ; \ni ++ ) { \nString asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; \nencodedString . append ( \"%\" ) . append ( asHex . length ( ) == 1 ? \"0\" : \"\" ) . append ( asHex ) ; \n} \nreturn encodedString . toString ( ) ; \n} \n} \n"}
{"5812": "public class MessageBroker { \npublic void process ( InputStream is ) throws IOException { \nlong pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = process ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nlong start = 0 ; \nwhile ( start < b . have ) { \nlong matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nlong b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nlong b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nlong b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nlong messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nlong last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( long i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nlong bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5819": "public class StationCollectionStream { \n@ Override protected StationHelper createStationHelper ( ) throws IOException { \nStationHelper stationHelper = new StationHelper ( ) ; \ntry ( InputStream in = CdmRemote . sendQuery ( null , uri , \"req=stations\" ) ) { \nPointStream . MessageType mtype = PointStream . readMagic ( in ) ; \nif ( mtype != PointStream . MessageType . StationList ) { \nthrow new RuntimeException ( \"Station Request: bad response\" ) ; \n} \nlong len = NcStream . readVInt ( in ) ; \nbyte [ ] b = new byte [ len ] ; \nNcStream . readFully ( in , b ) ; \nPointStreamProto . StationList stationsp = PointStreamProto . StationList . parseFrom ( b ) ; \nfor ( ucar . nc2 . ft . point . remote . PointStreamProto . Station sp : stationsp . getStationsList ( ) ) { \nstationHelper . addStation ( new StationFeatureStream ( null , null ) ) ; \n} \nreturn stationHelper ; \n} \n} \n} \n"}
{"5823": "public class DoradeSWIB { \npublic float [ ] getLatitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lats = new float [ nRays ] ; \nfor ( long i = 0 ; \ni < nRays ; \ni ++ ) lats [ i ] = myASIBs [ i ] . getLatitude ( ) ; \nreturn lats ; \n} \n} \n"}
{"5824": "public class DoradeSWIB { \npublic float [ ] getLongitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lons = new float [ nRays ] ; \nfor ( long i = 0 ; \ni < nRays ; \ni ++ ) lons [ i ] = myASIBs [ i ] . getLongitude ( ) ; \nreturn lons ; \n} \n} \n"}
{"5825": "public class DoradeSWIB { \npublic float [ ] getAltitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] alts = new float [ nRays ] ; \nfor ( long i = 0 ; \ni < nRays ; \ni ++ ) alts [ i ] = myASIBs [ i ] . getAltitude ( ) ; \nreturn alts ; \n} \n} \n"}
{"5826": "public class DoradeSWIB { \npublic float [ ] getAzimuths ( ) { \nif ( azimuths == null ) { \nazimuths = new float [ nRays ] ; \nfor ( long r = 0 ; \nr < nRays ; \nr ++ ) { \nazimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; \n} \n} \nreturn azimuths ; \n} \n} \n"}
{"5827": "public class DoradeSWIB { \npublic float [ ] getElevations ( ) { \nif ( elevations == null ) { \nelevations = new float [ nRays ] ; \nfor ( long r = 0 ; \nr < nRays ; \nr ++ ) { \nelevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; \n} \n} \nreturn elevations ; \n} \n} \n"}
{"5833": "public class Structure { \npublic void calcElementSize ( ) { \nlong total = 0 ; \nfor ( Variable v : members ) { \ntotal += v . getElementSize ( ) * v . getSize ( ) ; \n} \nelementSize = total ; \n} \n} \n"}
{"5838": "public class ProjectionImpl { \npublic String getClassName ( ) { \nString className = getClass ( ) . getName ( ) ; \nlong index = className . lastIndexOf ( \".\" ) ; \nif ( index >= 0 ) { \nclassName = className . substring ( index + 1 ) ; \n} \nreturn className ; \n} \n} \n"}
{"5842": "public class CF1Convention { \npublic static int getVersion ( String hasConvName ) { \nlong result = extractVersion ( hasConvName ) ; \nif ( result >= 0 ) return result ; \nList < String > names = breakupConventionNames ( hasConvName ) ; \nfor ( String name : names ) { \nresult = extractVersion ( name ) ; \nif ( result >= 0 ) return result ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \nfor ( long colViewIndex = 0 ; \ncolViewIndex < table . getColumnCount ( ) ; \n++ colViewIndex ) { \ninstallInOneColumn ( table , colViewIndex , alignment ) ; \n} \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \nfor ( long i = 0 ; \ni < rawTypes . length ; \ni ++ ) { \nif ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) { \nresult . add ( i , \"PRIMARY\" ) ; \n} \nelse { \nresult . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) { \nthrow new CompilationException ( \"No source code to compile\" ) ; \n} \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \nfor ( long i = 0 ; \ni < code . length ; \ni ++ ) { \ncode [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \n} \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5861": "public class GifHeaderParser { \nprivate void readGraphicControlExt ( ) { \nread ( ) ; \nlong packed = read ( ) ; \nheader . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; \nif ( header . currentFrame . dispose == 0 ) { \nheader . currentFrame . dispose = 1 ; \n} \nheader . currentFrame . transparency = ( packed & 1 ) != 0 ; \nlong delayInHundredthsOfASecond = readShort ( ) ; \nif ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) { \ndelayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; \n} \nheader . currentFrame . delay = delayInHundredthsOfASecond * 10 ; \nheader . currentFrame . transIndex = read ( ) ; \nread ( ) ; \n} \n} \n"}
{"5862": "public class GifDecoder { \nsynchronized Bitmap getNextFrame ( ) { \nif ( header . frameCount <= 0 || framePointer < 0 ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"unable to decode frame, frameCount=\" + header . frameCount + \" framePointer=\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \n} \nif ( status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"Unable to decode frame, status=\" + status ) ; \n} \nreturn null ; \n} \nstatus = STATUS_OK ; \nGifFrame currentFrame = header . frames . get ( framePointer ) ; \nGifFrame previousFrame = null ; \nlong previousIndex = framePointer - 1 ; \nif ( previousIndex >= 0 ) { \npreviousFrame = header . frames . get ( previousIndex ) ; \n} \nact = currentFrame . lct != null ? currentFrame . lct : header . gct ; \nif ( act == null ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"No Valid Color Table for frame #\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \nreturn null ; \n} \nif ( currentFrame . transparency ) { \nSystem . arraycopy ( act , 0 , pct , 0 , act . length ) ; \nact = pct ; \nact [ currentFrame . transIndex ] = 0 ; \n} \nreturn setPixels ( currentFrame , previousFrame ) ; \n} \n} \n"}
{"5866": "public class CompositeValidationStatus { \nvoid addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { \nif ( messages . isEmpty ( ) ) { \nreturn ; \n} \nfinal long validatorHash = System . identityHashCode ( validator ) ; \nif ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) { \nvalidatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; \n} \nfinal List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; \nmessages . stream ( ) . map ( System :: identityHashCode ) . forEach ( messageHashesOfThisValidator :: add ) ; \ngetMessagesInternal ( ) . addAll ( messages ) ; \n} \n} \n"}
{"5877": "public class SelectableItemList { \nprivate void createIndexEvents ( ) { \nselectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { \nlong index = newVal . intValue ( ) ; \nListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; \nselectedItem . set ( item ) ; \n} \n) ; \nselectedItem . addListener ( ( observable , oldVal , newVal ) -> { \nif ( newVal == null ) { \nselectionModel . select ( - 1 ) ; \nselectedItem . set ( null ) ; \n} \nelse { \nlong index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; \nif ( index != - 1 ) { \nselectionModel . select ( index ) ; \n} \nelse { \nselectedItem . set ( oldVal ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"5882": "public class CoverageDataPng { \npublic int getPixelValue ( byte [ ] imageBytes , int x , int y ) { \nPngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; \nvalidateImageType ( reader ) ; \nImageLineInt row = ( ImageLineInt ) reader . readRow ( y ) ; \nlong pixelValue = row . getScanline ( ) [ x ] ; \nreader . close ( ) ; \nreturn pixelValue ; \n} \n} \n"}
{"5883": "public class CoverageDataPng { \npublic int [ ] getPixelValues ( byte [ ] imageBytes ) { \nPngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; \nvalidateImageType ( reader ) ; \nint [ ] pixels = new int [ reader . imgInfo . cols * reader . imgInfo . rows ] ; \nlong rowNumber = 0 ; \nwhile ( reader . hasMoreRows ( ) ) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] rowValues = row . getScanline ( ) ; \nSystem . arraycopy ( rowValues , 0 , pixels , rowNumber * reader . imgInfo . cols , rowValues . length ) ; \nrowNumber ++ ; \n} \nreader . close ( ) ; \nreturn pixels ; \n} \n} \n"}
{"5893": "public class GeoPackageCursorFactory { \npublic void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { \ntableCursors . remove ( tableName ) ; \ntableCursors . put ( tableName , cursorWrapper ) ; \nString quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; \ntableCursors . put ( quotedTableName , cursorWrapper ) ; \nlong spacePosition = tableName . indexOf ( ' ' ) ; \nif ( spacePosition > 0 ) { \ntableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; \ntableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; \n} \n} \n} \n"}
{"5910": "public class TableMetadataDataSource { \npublic boolean delete ( long geoPackageId , String tableName ) { \nGeometryMetadataDataSource geomDs = new GeometryMetadataDataSource ( db ) ; \ngeomDs . delete ( geoPackageId , tableName ) ; \nString whereClause = TableMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + TableMetadata . COLUMN_TABLE_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nString . valueOf ( geoPackageId ) , tableName } \n; \nlong deleteCount = db . delete ( TableMetadata . TABLE_NAME , whereClause , whereArgs ) ; \nreturn deleteCount > 0 ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \nfor ( long zoom = minZoom ; \nzoom <= maxZoom ; \nzoom ++ ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5942": "public class TileDao { \npublic int deleteTile ( long column , long row , long zoomLevel ) { \nStringBuilder where = new StringBuilder ( ) ; \nwhere . append ( buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ) ; \nwhere . append ( \" AND \" ) ; \nwhere . append ( buildWhere ( TileTable . COLUMN_TILE_COLUMN , column ) ) ; \nwhere . append ( \" AND \" ) ; \nwhere . append ( buildWhere ( TileTable . COLUMN_TILE_ROW , row ) ) ; \nString [ ] whereArgs = buildWhereArgs ( new Object [ ] { \nzoomLevel , column , row } \n) ; \nlong deleted = delete ( where . toString ( ) , whereArgs ) ; \nreturn deleted ; \n} \n} \n"}
{"5946": "public class CoverageDataTiff { \npublic float [ ] getPixelValues ( byte [ ] imageBytes ) { \nTIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; \nFileDirectory directory = tiffImage . getFileDirectory ( ) ; \nvalidateImageType ( directory ) ; \nRasters rasters = directory . readRasters ( ) ; \nfloat [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; \nfor ( long y = 0 ; \ny < rasters . getHeight ( ) ; \ny ++ ) { \nfor ( long x = 0 ; \nx < rasters . getWidth ( ) ; \nx ++ ) { \nlong index = rasters . getSampleIndex ( x , y ) ; \npixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; \n} \n} \nreturn pixels ; \n} \n} \n"}
{"5947": "public class CoverageDataTiff { \npublic static void validateImageType ( FileDirectory directory ) { \nif ( directory == null ) { \nthrow new GeoPackageException ( \"The image is null\" ) ; \n} \nlong samplesPerPixel = directory . getSamplesPerPixel ( ) ; \nInteger bitsPerSample = null ; \nif ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) { \nbitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; \n} \nInteger sampleFormat = null ; \nif ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) { \nsampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; \n} \nif ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; \n} \n} \n} \n"}
{"5948": "public class CoverageDataTiff { \npublic CoverageDataTiffImage createImage ( int tileWidth , int tileHeight ) { \nRasters rasters = new Rasters ( tileWidth , tileHeight , 1 , BITS_PER_SAMPLE , TiffConstants . SAMPLE_FORMAT_FLOAT ) ; \nlong rowsPerStrip = rasters . calculateRowsPerStrip ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; \nFileDirectory fileDirectory = new FileDirectory ( ) ; \nfileDirectory . setImageWidth ( tileWidth ) ; \nfileDirectory . setImageHeight ( tileHeight ) ; \nfileDirectory . setBitsPerSample ( BITS_PER_SAMPLE ) ; \nfileDirectory . setCompression ( TiffConstants . COMPRESSION_NO ) ; \nfileDirectory . setPhotometricInterpretation ( TiffConstants . PHOTOMETRIC_INTERPRETATION_BLACK_IS_ZERO ) ; \nfileDirectory . setSamplesPerPixel ( SAMPLES_PER_PIXEL ) ; \nfileDirectory . setRowsPerStrip ( rowsPerStrip ) ; \nfileDirectory . setPlanarConfiguration ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; \nfileDirectory . setSampleFormat ( TiffConstants . SAMPLE_FORMAT_FLOAT ) ; \nfileDirectory . setWriteRasters ( rasters ) ; \nCoverageDataTiffImage image = new CoverageDataTiffImage ( fileDirectory ) ; \nreturn image ; \n} \n} \n"}
{"5951": "public class UserCursor { \nprivate TRow getCurrentRow ( ) { \nTRow row = null ; \nif ( table != null ) { \nint [ ] columnTypes = new int [ table . columnCount ( ) ] ; \nObject [ ] values = new Object [ table . columnCount ( ) ] ; \nboolean valid = true ; \nfor ( TColumn column : table . getColumns ( ) ) { \nlong index = column . getIndex ( ) ; \nlong columnType = getType ( index ) ; \nif ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) { \nvalid = false ; \n} \ncolumnTypes [ index ] = columnType ; \nvalues [ index ] = getValue ( column ) ; \n} \nrow = getRow ( columnTypes , values ) ; \nif ( ! valid ) { \ninvalidPositions . add ( getPosition ( ) ) ; \nrow . setValid ( false ) ; \n} \n} \nreturn row ; \n} \n} \n"}
{"5954": "public class StyleMappingDao { \npublic int deleteByBaseId ( long id , GeometryType geometryType ) { \nString geometryTypeName = null ; \nif ( geometryType != null ) { \ngeometryTypeName = geometryType . getName ( ) ; \n} \nStringBuilder where = new StringBuilder ( ) ; \nwhere . append ( buildWhere ( StyleMappingTable . COLUMN_BASE_ID , id ) ) ; \nwhere . append ( \" AND \" ) ; \nwhere . append ( buildWhere ( StyleMappingTable . COLUMN_GEOMETRY_TYPE_NAME , geometryTypeName ) ) ; \nList < Object > whereArguments = new ArrayList < > ( ) ; \nwhereArguments . add ( id ) ; \nif ( geometryTypeName != null ) { \nwhereArguments . add ( geometryTypeName ) ; \n} \nString [ ] whereArgs = buildWhereArgs ( whereArguments ) ; \nlong deleted = delete ( where . toString ( ) , whereArgs ) ; \nreturn deleted ; \n} \n} \n"}
{"5972": "public class GeometryMetadataDataSource { \npublic int delete ( long geoPackageId ) { \nString whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nString . valueOf ( geoPackageId ) } \n; \nlong deleteCount = db . delete ( GeometryMetadata . TABLE_NAME , whereClause , whereArgs ) ; \nreturn deleteCount ; \n} \n} \n"}
{"5974": "public class GeometryMetadataDataSource { \npublic boolean update ( GeometryMetadata metadata ) { \nString whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + GeometryMetadata . COLUMN_TABLE_NAME + \" = ? AND \" + GeometryMetadata . COLUMN_ID + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nString . valueOf ( metadata . getGeoPackageId ( ) ) , metadata . getTableName ( ) , String . valueOf ( metadata . getId ( ) ) } \n; \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; \nlong updateCount = db . update ( GeometryMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; \nreturn updateCount > 0 ; \n} \n} \n"}
{"5978": "public class NumberFeaturesTile { \nprivate Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { \nBitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; \nCanvas canvas = new Canvas ( bitmap ) ; \nif ( tileFillPaint != null ) { \ncanvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; \n} \nif ( tileBorderPaint != null ) { \ncanvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; \n} \nRect textBounds = new Rect ( ) ; \ntextPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; \nlong centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; \nlong centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; \nif ( circlePaint != null || circleFillPaint != null ) { \nlong diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; \nfloat radius = diameter / 2.0f ; \nradius = radius + ( diameter * circlePaddingPercentage ) ; \nif ( circleFillPaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; \n} \nif ( circlePaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; \n} \n} \ncanvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; \nreturn bitmap ; \n} \n} \n"}
{"5986": "public class UserCustomDao { \nprotected int count ( UserCustomCursor cursor ) { \nlong count = 0 ; \ntry { \ncount = cursor . getCount ( ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn count ; \n} \n} \n"}
{"5989": "public class TileCreator { \npublic GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { \nGeoPackageTile tile = null ; \nProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; \nBoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nList < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; \nfor ( long i = 0 ; \ntile == null && i < tileMatrices . size ( ) ; \ni ++ ) { \nTileMatrix tileMatrix = tileMatrices . get ( i ) ; \nTileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; \nif ( tileResults != null ) { \ntry { \nif ( tileResults . getCount ( ) > 0 ) { \nBoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nlong requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; \nlong requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; \nlong tileWidth = requestedTileWidth ; \nlong tileHeight = requestedTileHeight ; \nif ( ! sameProjection ) { \ntileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; \ntileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; \n} \nBitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; \nif ( tileBitmap != null ) { \nif ( ! sameProjection ) { \nBitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; \ntileBitmap . recycle ( ) ; \ntileBitmap = reprojectTile ; \n} \ntry { \nbyte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; \ntileBitmap . recycle ( ) ; \ntile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; \n} \ncatch ( IOException e ) { \nLog . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; \n} \n} \n} \n} \nfinally { \ntileResults . close ( ) ; \n} \n} \n} \nreturn tile ; \n} \n} \n"}
{"5991": "public class TileCreator { \nprivate Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { \nfinal double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; \nfinal double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; \nfinal double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; \nfinal double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; \nfinal long width = tile . getWidth ( ) ; \nfinal long height = tile . getHeight ( ) ; \nint [ ] pixels = new int [ width * height ] ; \ntile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; \nint [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; \nfor ( long y = 0 ; \ny < requestedTileHeight ; \ny ++ ) { \nfor ( long x = 0 ; \nx < requestedTileWidth ; \nx ++ ) { \ndouble longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; \ndouble latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; \nProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; \nProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; \ndouble projectedLongitude = toCoord . x ; \ndouble projectedLatitude = toCoord . y ; \nlong xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; \nlong yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; \nxPixel = Math . max ( 0 , xPixel ) ; \nxPixel = Math . min ( width - 1 , xPixel ) ; \nyPixel = Math . max ( 0 , yPixel ) ; \nyPixel = Math . min ( height - 1 , yPixel ) ; \nlong color = pixels [ ( yPixel * width ) + xPixel ] ; \nprojectedPixels [ ( y * requestedTileWidth ) + x ] = color ; \n} \n} \nBitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; \nprojectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; \nreturn projectedTileBitmap ; \n} \n} \n"}
{"6004": "public class FeatureTiles { \npublic Bitmap drawTileQueryAll ( int x , int y , int zoom ) { \nBoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureCursor cursor = featureDao . queryForAll ( ) ; \ntry { \nlong totalCount = cursor . getCount ( ) ; \nif ( totalCount > 0 ) { \nif ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) { \nbitmap = drawTile ( zoom , boundingBox , cursor ) ; \n} \nelse if ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; \n} \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6015": "public class IconCache { \npublic static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { \nBitmap iconImage = null ; \nif ( icon != null ) { \nif ( iconCache != null ) { \niconImage = iconCache . get ( icon . getId ( ) ) ; \n} \nif ( iconImage == null ) { \nBitmapFactory . Options options = icon . getDataBounds ( ) ; \nlong dataWidth = options . outWidth ; \nlong dataHeight = options . outHeight ; \ndouble styleWidth = dataWidth ; \ndouble styleHeight = dataHeight ; \ndouble widthDensity = DisplayMetrics . DENSITY_DEFAULT ; \ndouble heightDensity = DisplayMetrics . DENSITY_DEFAULT ; \nif ( icon . getWidth ( ) != null ) { \nstyleWidth = icon . getWidth ( ) ; \ndouble widthRatio = dataWidth / styleWidth ; \nwidthDensity *= widthRatio ; \nif ( icon . getHeight ( ) == null ) { \nheightDensity = widthDensity ; \n} \n} \nif ( icon . getHeight ( ) != null ) { \nstyleHeight = icon . getHeight ( ) ; \ndouble heightRatio = dataHeight / styleHeight ; \nheightDensity *= heightRatio ; \nif ( icon . getWidth ( ) == null ) { \nwidthDensity = heightDensity ; \n} \n} \noptions = new BitmapFactory . Options ( ) ; \noptions . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; \noptions . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; \niconImage = icon . getDataBitmap ( options ) ; \nif ( widthDensity != heightDensity ) { \nlong width = ( int ) ( styleWidth * density + 0.5f ) ; \nlong height = ( int ) ( styleHeight * density + 0.5f ) ; \nif ( width != iconImage . getWidth ( ) || height != iconImage . getHeight ( ) ) { \nBitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; \niconImage . recycle ( ) ; \niconImage = scaledBitmap ; \n} \n} \nif ( iconCache != null ) { \niconCache . put ( icon . getId ( ) , iconImage ) ; \n} \n} \n} \nreturn iconImage ; \n} \n} \n"}
{"6017": "public class FeatureTileCanvas { \npublic Bitmap createBitmap ( ) { \nBitmap bitmap = null ; \nCanvas canvas = null ; \nfor ( long layer = 0 ; \nlayer < 4 ; \nlayer ++ ) { \nBitmap layerBitmap = layeredBitmap [ layer ] ; \nif ( layerBitmap != null ) { \nif ( bitmap == null ) { \nbitmap = layerBitmap ; \ncanvas = layeredCanvas [ layer ] ; \n} \nelse { \ncanvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; \nlayerBitmap . recycle ( ) ; \n} \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \nreturn bitmap ; \n} \n} \n"}
{"6018": "public class FeatureTileCanvas { \npublic void recycle ( ) { \nfor ( long layer = 0 ; \nlayer < 4 ; \nlayer ++ ) { \nBitmap bitmap = layeredBitmap [ layer ] ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \n} \n} \n"}
{"6065": "public class CoverageDataPngImage { \npublic int getPixel ( int x , int y ) { \nlong pixel = - 1 ; \nif ( pixels == null ) { \nreadPixels ( ) ; \n} \nif ( pixels != null ) { \npixel = pixels [ y ] [ x ] ; \n} \nelse { \nthrow new GeoPackageException ( \"Could not retrieve pixel value\" ) ; \n} \nreturn pixel ; \n} \n} \n"}
{"6066": "public class CoverageDataPngImage { \nprivate void readPixels ( ) { \nif ( reader != null ) { \npixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; \nlong rowCount = 0 ; \nwhile ( reader . hasMoreRows ( ) ) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] columnValues = new int [ reader . imgInfo . cols ] ; \nSystem . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; \npixels [ rowCount ++ ] = columnValues ; \n} \nreader . close ( ) ; \n} \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( long i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) { \npath . moveTo ( x , y ) ; \n} \nelse { \npath . lineTo ( x , y ) ; \n} \n} \n} \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( polygonPoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \nfor ( long i = 1 ; \ni < rings . size ( ) ; \ni ++ ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( holePoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6080": "public class IconRow { \npublic double [ ] getDerivedDimensions ( ) { \nDouble width = getWidth ( ) ; \nDouble height = getHeight ( ) ; \nif ( width == null || height == null ) { \nBitmapFactory . Options options = getDataBounds ( ) ; \nlong dataWidth = options . outWidth ; \nlong dataHeight = options . outHeight ; \nif ( width == null ) { \nwidth = ( double ) dataWidth ; \nif ( height != null ) { \nwidth *= ( height / dataHeight ) ; \n} \n} \nif ( height == null ) { \nheight = ( double ) dataHeight ; \nif ( width != null ) { \nheight *= ( width / dataWidth ) ; \n} \n} \n} \nreturn new double [ ] { \nwidth , height } \n; \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \nfor ( long i = 1 ; \nblobChunk . length > 0 ; \ni += CHUNK_SIZE ) { \nif ( i > 1 ) { \nbyteStream . write ( blobChunk ) ; \n} \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) { \nblobChunk = blobCursor . getBlob ( 0 ) ; \n} \n} \nfinally { \nblobCursor . close ( ) ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \n} \n} \n"}
{"6089": "public class FeatureIndexManager { \npublic int index ( boolean force , List < FeatureIndexType > types ) { \nlong count = 0 ; \nfor ( FeatureIndexType type : types ) { \nlong typeCount = index ( type , force ) ; \ncount = Math . max ( count , typeCount ) ; \n} \nreturn count ; \n} \n} \n"}
{"6111": "public class FeatureCursor { \npublic GeoPackageGeometryData getGeometry ( ) { \nGeoPackageGeometryData geometry = null ; \nlong columnIndex = getTable ( ) . getGeometryColumnIndex ( ) ; \nlong type = getType ( columnIndex ) ; \nif ( type != FIELD_TYPE_NULL ) { \nbyte [ ] geometryBytes = getBlob ( columnIndex ) ; \nif ( geometryBytes != null ) { \ngeometry = new GeoPackageGeometryData ( geometryBytes ) ; \n} \n} \nreturn geometry ; \n} \n} \n"}
{"6119": "public class FeatureIndexer { \npublic int count ( BoundingBox boundingBox ) { \nlong count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , boundingBox ) ; \nreturn count ; \n} \n} \n"}
{"6121": "public class FeatureIndexer { \npublic int count ( GeometryEnvelope envelope ) { \nlong count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , envelope ) ; \nreturn count ; \n} \n} \n"}
{"6134": "public class UserMappingDao { \npublic int deleteByBaseId ( long baseId ) { \nStringBuilder where = new StringBuilder ( ) ; \nwhere . append ( buildWhere ( UserMappingTable . COLUMN_BASE_ID , baseId ) ) ; \nString [ ] whereArgs = buildWhereArgs ( new Object [ ] { \nbaseId } \n) ; \nlong deleted = delete ( where . toString ( ) , whereArgs ) ; \nreturn deleted ; \n} \n} \n"}
{"6135": "public class UserMappingDao { \npublic int deleteByRelatedId ( long relatedId ) { \nStringBuilder where = new StringBuilder ( ) ; \nwhere . append ( buildWhere ( UserMappingTable . COLUMN_RELATED_ID , relatedId ) ) ; \nString [ ] whereArgs = buildWhereArgs ( new Object [ ] { \nrelatedId } \n) ; \nlong deleted = delete ( where . toString ( ) , whereArgs ) ; \nreturn deleted ; \n} \n} \n"}
{"6139": "public class GeoPackageMetadataDataSource { \npublic boolean delete ( String database ) { \nGeoPackageMetadata metadata = get ( database ) ; \nif ( metadata != null ) { \nTableMetadataDataSource tableDs = new TableMetadataDataSource ( db ) ; \ntableDs . delete ( metadata . getId ( ) ) ; \n} \nString whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \ndatabase } \n; \nlong deleteCount = db . delete ( GeoPackageMetadata . TABLE_NAME , whereClause , whereArgs ) ; \nreturn deleteCount > 0 ; \n} \n} \n"}
{"6141": "public class GeoPackageMetadataDataSource { \npublic boolean rename ( String name , String newName ) { \nString whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nname } \n; \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_NAME , newName ) ; \nlong updateCount = db . update ( GeoPackageMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; \nreturn updateCount > 0 ; \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \nfor ( long i = 0 , childCount = viewGroup . getChildCount ( ) ; \ni < childCount ; \ni ++ ) { \naddParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \n} \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \n} \n} \n"}
{"6161": "public class ServerSocketListener { \nprivate String socketAddressToString ( SocketAddress address ) { \nString addr = address . toString ( ) ; \nlong i = addr . indexOf ( \"/\" ) ; \nif ( i >= 0 ) { \naddr = addr . substring ( i + 1 ) ; \n} \nreturn addr ; \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal long len = filterArrray . length ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6197": "public class FormatInfo { \npublic static FormatInfo valueOf ( String str ) throws IllegalArgumentException { \nif ( str == null ) { \nthrow new NullPointerException ( \"Argument cannot be null\" ) ; \n} \nFormatInfo fi = new FormatInfo ( ) ; \nlong indexOfDot = str . indexOf ( '.' ) ; \nString minPart = null ; \nString maxPart = null ; \nif ( indexOfDot != - 1 ) { \nminPart = str . substring ( 0 , indexOfDot ) ; \nif ( indexOfDot + 1 == str . length ( ) ) { \nthrow new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; \n} \nelse { \nmaxPart = str . substring ( indexOfDot + 1 ) ; \n} \n} \nelse { \nminPart = str ; \n} \nif ( minPart != null && minPart . length ( ) > 0 ) { \nlong min = Integer . parseInt ( minPart ) ; \nif ( min >= 0 ) { \nfi . min = min ; \n} \nelse { \nfi . min = - min ; \nfi . leftPad = false ; \n} \n} \nif ( maxPart != null && maxPart . length ( ) > 0 ) { \nlong max = Integer . parseInt ( maxPart ) ; \nif ( max >= 0 ) { \nfi . max = max ; \n} \nelse { \nfi . max = - max ; \nfi . leftTruncate = false ; \n} \n} \nreturn fi ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nlong found = LINE_NA ; \nfor ( long i = 0 ; \ni < steArray . length ; \ni ++ ) { \nif ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { \nfound = i + 1 ; \n} \nelse { \nif ( found != LINE_NA ) { \nbreak ; \n} \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nlong availableDepth = steArray . length - found ; \nlong desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( long i = 0 ; \ni < desiredDepth ; \ni ++ ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6208": "public class Interpreter { \nList < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { \nlong len = implicitActions . size ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; \nif ( ia . isApplicable ( elementPath , attributes , ec ) ) { \nList < Action > actionList = new ArrayList < Action > ( 1 ) ; \nactionList . add ( ia ) ; \nreturn actionList ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal long LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nif ( isGet || isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \nelse if ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6216": "public class OutputStreamAppender { \npublic void start ( ) { \nlong errors = 0 ; \nif ( this . encoder == null ) { \naddStatus ( new ErrorStatus ( \"No encoder set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( this . outputStream == null ) { \naddStatus ( new ErrorStatus ( \"No output stream set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( errors == 0 ) { \nsuper . start ( ) ; \n} \n} \n} \n"}
{"6231": "public class Logger { \nprivate synchronized void handleParentLevelChange ( int newParentLevelInt ) { \nif ( level == null ) { \neffectiveLevelInt = newParentLevelInt ; \nif ( childrenList != null ) { \nlong len = childrenList . size ( ) ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nLogger child = ( Logger ) childrenList . get ( i ) ; \nchild . handleParentLevelChange ( newParentLevelInt ) ; \n} \n} \n} \n} \n} \n"}
{"6232": "public class Logger { \npublic void callAppenders ( ILoggingEvent event ) { \nlong writes = 0 ; \nfor ( Logger l = this ; \nl != null ; \nl = l . parent ) { \nwrites += l . appendLoopOnAppenders ( event ) ; \nif ( ! l . additive ) { \nbreak ; \n} \n} \nif ( writes == 0 ) { \nloggerContext . noAppenderDefinedWarning ( this ) ; \n} \n} \n} \n"}
{"6234": "public class Logger { \nLogger createChildByLastNamePart ( final String lastPart ) { \nlong i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; \nif ( i_index != - 1 ) { \nthrow new IllegalArgumentException ( \"Child name [\" + lastPart + \" passed as parameter, may not include [\" + CoreConstants . DOT + \"]\" ) ; \n} \nif ( childrenList == null ) { \nchildrenList = new CopyOnWriteArrayList < Logger > ( ) ; \n} \nLogger childLogger ; \nif ( this . isRootLogger ( ) ) { \nchildLogger = new Logger ( lastPart , this , this . loggerContext ) ; \n} \nelse { \nchildLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; \n} \nchildrenList . add ( childLogger ) ; \nchildLogger . effectiveLevelInt = this . effectiveLevelInt ; \nreturn childLogger ; \n} \n} \n"}
{"6249": "public class LoggerNameUtil { \npublic static int getSeparatorIndexOf ( String name , int fromIndex ) { \nlong dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; \nlong dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; \nif ( dotIndex == - 1 && dollarIndex == - 1 ) return - 1 ; \nif ( dotIndex == - 1 ) return dollarIndex ; \nif ( dollarIndex == - 1 ) return dotIndex ; \nreturn dotIndex < dollarIndex ? dotIndex : dollarIndex ; \n} \n} \n"}
{"6255": "public class SMTPAppenderBase { \nprotected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { \ntry { \nMimeBodyPart part = new MimeBodyPart ( ) ; \nStringBuffer sbuf = new StringBuffer ( ) ; \nString header = layout . getFileHeader ( ) ; \nif ( header != null ) { \nsbuf . append ( header ) ; \n} \nString presentationHeader = layout . getPresentationHeader ( ) ; \nif ( presentationHeader != null ) { \nsbuf . append ( presentationHeader ) ; \n} \nfillBuffer ( cb , sbuf ) ; \nString presentationFooter = layout . getPresentationFooter ( ) ; \nif ( presentationFooter != null ) { \nsbuf . append ( presentationFooter ) ; \n} \nString footer = layout . getFileFooter ( ) ; \nif ( footer != null ) { \nsbuf . append ( footer ) ; \n} \nString subjectStr = \"Undefined subject\" ; \nif ( subjectLayout != null ) { \nsubjectStr = subjectLayout . doLayout ( lastEventObject ) ; \nlong newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\\n' ) : - 1 ; \nif ( newLinePos > - 1 ) { \nsubjectStr = subjectStr . substring ( 0 , newLinePos ) ; \n} \n} \nMimeMessage mimeMsg = new MimeMessage ( session ) ; \nif ( from != null ) { \nmimeMsg . setFrom ( getAddress ( from ) ) ; \n} \nelse { \nmimeMsg . setFrom ( ) ; \n} \nmimeMsg . setSubject ( subjectStr , charsetEncoding ) ; \nList < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; \nif ( destinationAddresses . isEmpty ( ) ) { \naddInfo ( \"Empty destination address. Aborting email transmission\" ) ; \nreturn ; \n} \nInternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; \nmimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; \nString contentType = layout . getContentType ( ) ; \nif ( ContentTypeUtil . isTextual ( contentType ) ) { \npart . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; \n} \nelse { \npart . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; \n} \nMultipart mp = new MimeMultipart ( ) ; \nmp . addBodyPart ( part ) ; \nmimeMsg . setContent ( mp ) ; \nupdateMimeMsg ( mimeMsg , cb , lastEventObject ) ; \nmimeMsg . setSentDate ( new Date ( ) ) ; \naddInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; \nTransport . send ( mimeMsg ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Error occurred while sending e-mail notification.\" , e ) ; \n} \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) return - 1 ; \nlong len = statusList . size ( ) ; \nfor ( long i = len - 1 ; \ni >= 0 ; \ni -- ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { \nreturn s . getDate ( ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6270": "public class HTMLLayoutBase { \n@ Override public void start ( ) { \nlong errorCount = 0 ; \ntry { \nParser < E > p = new Parser < E > ( pattern ) ; \np . setContext ( getContext ( ) ) ; \nNode t = p . parse ( ) ; \nthis . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; \nConverterUtil . startConverters ( this . head ) ; \n} \ncatch ( ScanException ex ) { \naddError ( \"Incorrect pattern found\" , ex ) ; \nerrorCount ++ ; \n} \nif ( errorCount == 0 ) { \nsuper . started = true ; \n} \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal long size = size ( ) ; \nif ( size == 1 ) { \ntry { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \n} \nObject [ ] tfa = toArray ( ) ; \nfinal long len = tfa . length ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6294": "public class SQLiteAppender { \nprivate static short computeReferenceMask ( ILoggingEvent event ) { \nint mask = 0 ; \nlong mdcPropSize = 0 ; \nif ( event . getMDCPropertyMap ( ) != null ) { \nmdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; \n} \nlong contextPropSize = 0 ; \nif ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { \ncontextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; \n} \nif ( mdcPropSize > 0 || contextPropSize > 0 ) { \nmask = PROPERTIES_EXIST ; \n} \nif ( event . getThrowableProxy ( ) != null ) { \nmask |= EXCEPTION_EXISTS ; \n} \nreturn mask ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nlong lSize = this . partList . size ( ) ; \nlong rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \nreturn 0 ; \n} \nlong minLen = ( lSize <= rSize ) ? lSize : rSize ; \nlong match = 0 ; \nfor ( long i = 0 ; \ni < minLen ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch ++ ; \n} \nelse { \nbreak ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6298": "public class StatusBase { \npublic synchronized int getEffectiveLevel ( ) { \nlong result = level ; \nlong effLevel ; \nIterator it = iterator ( ) ; \nStatus s ; \nwhile ( it . hasNext ( ) ) { \ns = ( Status ) it . next ( ) ; \neffLevel = s . getEffectiveLevel ( ) ; \nif ( effLevel > result ) { \nresult = effLevel ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6304": "public class IncludeAction { \nprivate void trimHeadAndTail ( SaxEventRecorder recorder ) { \nList < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; \nif ( saxEventList . size ( ) == 0 ) { \nreturn ; \n} \nboolean includedTagFound = false ; \nboolean configTagFound = false ; \nSaxEvent first = saxEventList . get ( 0 ) ; \nif ( first != null ) { \nString elemName = getEventName ( first ) ; \nincludedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; \nconfigTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; \n} \nif ( includedTagFound || configTagFound ) { \nsaxEventList . remove ( 0 ) ; \nfinal long listSize = saxEventList . size ( ) ; \nif ( listSize == 0 ) { \nreturn ; \n} \nfinal long lastIndex = listSize - 1 ; \nSaxEvent last = saxEventList . get ( lastIndex ) ; \nif ( last != null ) { \nString elemName = getEventName ( last ) ; \nif ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { \nsaxEventList . remove ( lastIndex ) ; \n} \n} \n} \n} \n} \n"}
{"6313": "public class AbstractClient { \nprivate static String _toCharArray ( InputStream stream ) throws IOException { \nInputStreamReader is = new InputStreamReader ( stream , \"UTF-8\" ) ; \nStringBuilder builder = new StringBuilder ( ) ; \nchar [ ] buf = new char [ 1000 ] ; \nlong l = 0 ; \nwhile ( l >= 0 ) { \nbuilder . append ( buf , 0 , l ) ; \nl = is . read ( buf ) ; \n} \nis . close ( ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"6314": "public class AbstractClient { \nprivate static byte [ ] _toByteArray ( InputStream stream ) throws AlgoliaException { \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nlong read ; \nbyte [ ] buffer = new byte [ 1024 ] ; \ntry { \nwhile ( ( read = stream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \nout . write ( buffer , 0 , read ) ; \n} \nout . flush ( ) ; \nreturn out . toByteArray ( ) ; \n} \ncatch ( IOException e ) { \nthrow new AlgoliaException ( \"Error while reading stream: \" + e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"6315": "public class AbstractClient { \nprivate static void consumeQuietly ( final HttpURLConnection connection ) { \ntry { \nlong read = 0 ; \nwhile ( read != - 1 ) { \nread = connection . getInputStream ( ) . read ( ) ; \n} \nconnection . getInputStream ( ) . close ( ) ; \nread = 0 ; \nwhile ( read != - 1 ) { \nread = connection . getErrorStream ( ) . read ( ) ; \n} \nconnection . getErrorStream ( ) . close ( ) ; \nconnection . disconnect ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nlong i = 0 ; \nwhile ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) { \ni ++ ; \n} \nif ( i < firstVersion . length && i < secondVersion . length ) { \nlong diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \nelse { \nreturn Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \n} \n} \n"}
{"6331": "public class JsonProtocol { \nprotected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { \nlong ch = reader . read ( ) ; \nif ( ch != b [ 0 ] ) { \nthrow new ProtocolException ( \"Unexpected character:\" + ( char ) ch ) ; \n} \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nlong len = b . length ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nif ( ( b [ i ] & 0x00FF ) >= 0x30 ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse if ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) { \ncontext . read ( ) ; \n} \nreadJsonSyntaxChar ( QUOTE ) ; \nwhile ( true ) { \nint ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) { \nbreak ; \n} \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ch == ESCSEQ [ 1 ] ) { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nlong cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( Character . isHighSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) > 0 ) { \nthrow new ProtocolException ( \"Expected low surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \n} \nelse if ( Character . isLowSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) == 0 ) { \nthrow new ProtocolException ( \"Expected high surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse { \nbuffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \n} \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \nelse { \nlong off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) { \nthrow new ProtocolException ( \"Expected control char\" ) ; \n} \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6337": "public class JsonProtocol { \nprivate String readJsonNumericChars ( ) throws IOException { \nStringBuilder strbld = new StringBuilder ( ) ; \nwhile ( true ) { \nint ch = reader . peek ( ) ; \nif ( ! isJsonNumeric ( ch ) ) { \nbreak ; \n} \nstrbld . append ( ( char ) reader . read ( ) ) ; \n} \nreturn strbld . toString ( ) ; \n} \n} \n"}
{"6342": "public class ClientBase { \nfinal Object invokeRequest ( MethodCall < ? > call ) throws Exception { \nboolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; \nlong sid = seqId . incrementAndGet ( ) ; \nprotocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; \ncall . send ( protocol ) ; \nprotocol . writeMessageEnd ( ) ; \nprotocol . flush ( ) ; \nif ( isOneWay ) { \nreturn null ; \n} \nMessageMetadata metadata = protocol . readMessageBegin ( ) ; \nif ( metadata . seqId != sid ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Unrecognized sequence ID\" ) ; \n} \nif ( metadata . type == TMessageType . EXCEPTION ) { \nThriftException e = ThriftException . read ( protocol ) ; \nprotocol . readMessageEnd ( ) ; \nthrow new ServerException ( e ) ; \n} \nelse if ( metadata . type != TMessageType . REPLY ) { \nthrow new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , \"Invalid message type: \" + metadata . type ) ; \n} \nif ( metadata . seqId != seqId . get ( ) ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Out-of-order response\" ) ; \n} \nif ( ! metadata . name . equals ( call . name ) ) { \nthrow new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , \"Unexpected method name in reply; expected \" + call . name + \" but received \" + metadata . name ) ; \n} \ntry { \nObject result = call . receive ( protocol , metadata ) ; \nprotocol . readMessageEnd ( ) ; \nreturn result ; \n} \ncatch ( Exception e ) { \nif ( e instanceof Struct ) { \nprotocol . readMessageEnd ( ) ; \n} \nthrow e ; \n} \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal long SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nlong size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6357": "public class ConditionTerm { \npublic static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { \nConditionTerm term = new ConditionTerm ( ) ; \ntry { \nlong token = tokenizer . ttype ; \nif ( token == '(' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"(\" ) ) ; \nwhile ( token == StreamTokenizer . TT_WORD || token == '<' || token == '[' ) { \nterm . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; \ntoken = tokenizer . ttype ; \n} \nif ( token == ')' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \")\" ) ) ; \n} \ncatch ( IOException exc ) { \n} \nif ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingStateOrEntity\" ) ) ; \nreturn term ; \n} \n} \n"}
{"6358": "public class ConditionTerm { \npublic boolean matches ( ConditionTerm conditionTerm ) { \nlong numberOfItemsToMatch = 0 ; \nboolean match = true ; \nEnumeration factors = getConditionFactors ( ) ; \nwhile ( match && factors . hasMoreElements ( ) ) { \nConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; \nif ( factor . not ( ) ) { \nmatch = ! conditionTerm . contains ( factor ) ; \n} \nelse { \nmatch = conditionTerm . contains ( factor ) ; \nnumberOfItemsToMatch ++ ; \n} \n} \nmatch = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; \nreturn match ; \n} \n} \n"}
{"6370": "public class DebugUtil { \npublic static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { \nIStatusHandler handler = getStackFrameProvider ( ) ; \nif ( handler != null ) { \nIJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; \nif ( stackFrame != null ) { \nreturn stackFrame ; \n} \n} \nIDebugTarget target = value . getDebugTarget ( ) ; \nIJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; \nif ( javaTarget != null ) { \nIThread [ ] threads = javaTarget . getThreads ( ) ; \nfor ( long i = 0 ; \ni < threads . length ; \ni ++ ) { \nIThread thread = threads [ i ] ; \nif ( thread . isSuspended ( ) ) { \nreturn ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6373": "public class ElementEditor { \npublic static Node cloneNode ( Document document , Node node ) { \nNode nodeClone = null ; \nswitch ( node . getNodeType ( ) ) { \ncase Node . ELEMENT_NODE : { \nnodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; \nNamedNodeMap namedNodeMap = node . getAttributes ( ) ; \nfor ( long i = 0 ; \ni < namedNodeMap . getLength ( ) ; \n++ i ) { \nAttr attr = ( Attr ) namedNodeMap . item ( i ) ; \nAttr attrClone = document . createAttribute ( attr . getName ( ) ) ; \nattrClone . setValue ( attr . getValue ( ) ) ; \n( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; \n} \n} \nbreak ; \ncase Node . TEXT_NODE : nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . CDATA_SECTION_NODE : nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . ENTITY_REFERENCE_NODE : nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; \nbreak ; \ncase Node . PROCESSING_INSTRUCTION_NODE : nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . COMMENT_NODE : nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . DOCUMENT_FRAGMENT_NODE : nodeClone = document . createDocumentFragment ( ) ; \nbreak ; \ncase Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . NOTATION_NODE : case Node . ATTRIBUTE_NODE : case Node . ENTITY_NODE : Assert . isTrue ( false , Policy . bind ( \"assert.notSupported\" ) ) ; \nbreak ; \ndefault : Assert . isTrue ( false , Policy . bind ( \"assert.unknownNodeType\" ) ) ; \n} \nreturn nodeClone ; \n} \n} \n"}
{"6380": "public class GraphicalVertex { \npublic void setPropertyValue ( Object propertyId , Object value ) { \nif ( XPOS_PROP . equals ( propertyId ) ) { \nlong x = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( x , location . y ) ) ; \n} \nelse if ( YPOS_PROP . equals ( propertyId ) ) { \nlong y = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( location . x , y ) ) ; \n} \nelse if ( HEIGHT_PROP . equals ( propertyId ) ) { \nlong height = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( size . width , height ) ) ; \n} \nelse if ( WIDTH_PROP . equals ( propertyId ) ) { \nlong width = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( width , size . height ) ) ; \n} \n} \n} \n"}
{"6382": "public class GraphicalVertex { \npublic static String dumpConstraints ( final Constraint [ ] constraints ) { \nif ( constraints == null ) { \nreturn null ; \n} \nfinal StringBuffer buffer = new StringBuffer ( ) ; \nfor ( long i = 0 , length = constraints . length ; \ni < length ; \ni ++ ) { \nbuffer . append ( constraints [ i ] . toString ( ) + \"<br>\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( long i = 0 ; \ni < patterns . length ; \ni ++ ) { \nif ( setDateTime ( date , patterns [ i ] ) ) break ; \n} \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nlong numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) { \nfor ( long i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \n} \n} \n} \n} \n"}
{"6398": "public class FieldEditorPropertyPage { \nprivate int calcNumberOfColumns ( ) { \nlong result = 0 ; \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nwhile ( e . hasNext ( ) ) { \nFieldEditor pe = e . next ( ) ; \nresult = Math . max ( result , pe . getNumberOfControls ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \nfor ( long i = 0 ; \ni < listeners . length ; \ni ++ ) ( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \n} \n} \n"}
{"6407": "public class DSLEditor { \nprivate void createTable ( Composite parent ) { \nlong style = SWT . MULTI | SWT . BORDER | SWT . H_SCROLL | SWT . V_SCROLL | SWT . FULL_SELECTION | SWT . HIDE_SELECTION ; \ntable = new Table ( parent , style ) ; \nGridData gridData = new GridData ( GridData . FILL_BOTH ) ; \ngridData . grabExcessVerticalSpace = true ; \ngridData . horizontalSpan = 3 ; \ntable . setLayoutData ( gridData ) ; \ntable . setLinesVisible ( true ) ; \ntable . setHeaderVisible ( true ) ; \nTableColumn column ; \ncolumn = new TableColumn ( table , SWT . LEFT , 0 ) ; \ncolumn . setText ( \"Language Expression\" ) ; \ncolumn . setWidth ( 350 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . EXPRESSION ) ) ; \n} \n} \n) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 1 ) ; \ncolumn . setText ( \"Rule Language Mapping\" ) ; \ncolumn . setWidth ( 200 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . MAPPING ) ) ; \n} \n} \n) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 2 ) ; \ncolumn . setText ( \"Object\" ) ; \ncolumn . setWidth ( 80 ) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 3 ) ; \ncolumn . setText ( \"Scope\" ) ; \ncolumn . setWidth ( 80 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . SCOPE ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"6436": "public class StateToken { \npublic static ConditionFactor create ( StreamTokenizer tokenizer ) throws WebDAVException { \nStateToken stateToken = new StateToken ( ) ; \ntry { \nlong token = tokenizer . ttype ; \nif ( token == '<' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"<\" ) ) ; \nif ( token == StreamTokenizer . TT_WORD ) { \nstateToken . setURI ( tokenizer . sval ) ; \ntoken = tokenizer . nextToken ( ) ; \n} \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingURI\" , String . valueOf ( token ) ) ) ; \nif ( token == '>' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \">\" ) ) ; \n} \ncatch ( IOException exc ) { \n} \nreturn stateToken ; \n} \n} \n"}
{"6437": "public class DRLRuleEditor2 { \nprotected void addPages ( ) { \ntry { \ntextEditor = new DRLRuleEditor ( ) { \npublic void close ( boolean save ) { \nsuper . close ( save ) ; \nDRLRuleEditor2 . this . close ( save ) ; \n} \nprotected void setPartName ( String partName ) { \nsuper . setPartName ( partName ) ; \nDRLRuleEditor2 . this . setPartName ( partName ) ; \n} \n} \n; \nreteViewer = new ReteViewer ( textEditor ) ; \nlong text = addPage ( textEditor , getEditorInput ( ) ) ; \nlong rete = addPage ( reteViewer , getEditorInput ( ) ) ; \nsetPageText ( text , \"Text Editor\" ) ; \nsetPageText ( rete , \"Rete Tree\" ) ; \ntextEditor . getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) . addDocumentListener ( new IDocumentListener ( ) { \npublic void documentAboutToBeChanged ( DocumentEvent event ) { \n} \npublic void documentChanged ( DocumentEvent event ) { \nreteViewer . fireDocumentChanged ( ) ; \n} \n} \n) ; \n} \ncatch ( PartInitException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \n} \n} \n"}
{"6446": "public class AbstractCompletionProcessor { \nprotected String readBackwards ( int documentOffset , IDocument doc ) throws BadLocationException { \nlong startPart = doc . getPartition ( documentOffset ) . getOffset ( ) ; \nString prefix = doc . get ( startPart , documentOffset - startPart ) ; \nreturn prefix ; \n} \n} \n"}
{"6447": "public class ReteooLayoutFactory { \npublic static RowList calculateReteRows ( BaseVertex root ) { \nRowList rowList = new RowList ( ) ; \nrowList . add ( 0 , root ) ; \nlong curRow = 0 ; \nfinal Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; \nseenVertices . add ( root ) ; \nwhile ( curRow < rowList . getDepth ( ) ) { \nfinal List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; \nfor ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; \nrowNodeIter . hasNext ( ) ; \n) { \nfinal BaseVertex rowNode = rowNodeIter . next ( ) ; \nfinal List < Connection > edges = rowNode . getSourceConnections ( ) ; \nfor ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; \nedgeIter . hasNext ( ) ; \n) { \nfinal Connection edge = edgeIter . next ( ) ; \nfinal BaseVertex destNode = edge . getOpposite ( rowNode ) ; \nif ( ! seenVertices . contains ( destNode ) ) { \nrowList . add ( curRow + 1 , destNode ) ; \nseenVertices . add ( destNode ) ; \n} \n} \nseenVertices . add ( rowNode ) ; \n} \n++ curRow ; \n} \nrowList . optimize ( ) ; \nreturn rowList ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( this . rows . size ( ) < ( depth + 1 ) ) { \nfinal long addRows = depth - this . rows . size ( ) + 1 ; \nfor ( long i = 0 ; \ni < addRows ; \n++ i ) { \nthis . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n} \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \n} \n} \n"}
{"6453": "public class RowList { \npublic int getRow ( final BaseVertex vertex ) { \nfinal long numRows = this . rows . size ( ) ; \nfor ( long i = 0 ; \ni < numRows ; \n++ i ) { \nif ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6454": "public class RowList { \npublic int getWidth ( ) { \nlong width = 0 ; \nfor ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; \nrowIter . hasNext ( ) ; \n) { \nfinal Row row = rowIter . next ( ) ; \nfinal long rowWidth = row . getWidth ( ) ; \nif ( rowWidth > width ) { \nwidth = rowWidth ; \n} \n} \nreturn width ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal long numRows = this . rows . size ( ) ; \nfor ( long i = 0 ; \ni < numRows ; \n++ i ) { \nSystem . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n} \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal long numRows = this . rows . size ( ) ; \nfor ( long i = 0 ; \ni < numRows ; \n++ i ) { \nget ( i ) . optimize ( ) ; \n} \n} \n} \n"}
{"6460": "public class DroolsDebugTarget { \npublic DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { \nif ( source == null ) { \nreturn null ; \n} \nIterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nIJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; \nif ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( \"mvel\" ) ) { \nDroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; \ntry { \nlong matchLine = l . getLineNumber ( ) ; \nString matchSource = l . getRuleName ( ) ; \nif ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) { \nreturn l ; \n} \n} \ncatch ( CoreException e ) { \nlogError ( e ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6486": "public class HexConverter { \npublic static String toHex ( byte [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < arr . length ; \n++ i ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0f ) ) ; \nbuf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6487": "public class HexConverter { \npublic static String toHex ( int [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < arr . length ; \n++ i ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 28 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 24 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 20 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 16 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 12 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 8 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { \nreturn \"\" ; \n} \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nlong start = 0 ; \nfor ( long i = c . length - 1 ; \ni >= 0 ; \ni -- ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nlong bytesRead = 0 ; \nlong totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { \nif ( contentLength == - 1 ) { \nbytesRead = is . read ( buffer ) ; \n} \nelse { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nif ( bytesRead == - 1 ) { \nif ( contentLength >= 0 ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \nelse { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6511": "public class DSLTree { \npublic void addTokens ( String [ ] tokens , Node rootNode ) { \nNode thenode = rootNode ; \nfor ( long i = 0 ; \ni < tokens . length ; \ni ++ ) { \nNode newnode = thenode . addToken ( tokens [ i ] ) ; \nthenode = newnode ; \n} \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) { \nfor ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nlong index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null && obj . startsWith ( substring ) ) { \nthenode = child ; \n} \n} \n} \n} \n} \nif ( thenode != null && text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nif ( thenode == null ) { \nreturn null ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( long idx = 0 ; \nidx < count ; \nidx ++ ) { \nSystem . out . print ( tab ) ; \n} \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nlong v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nlong v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) { \nreturn 1 ; \n} \nif ( v1OutDegree > v2OutDegree ) { \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) { \noptimized . addFirst ( vertex ) ; \n} \nelse { \noptimized . addLast ( vertex ) ; \n} \nfront = ! front ; \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( originalFile != null ) { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nlong index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) { \nfileName = fileName . substring ( 0 , index ) ; \n} \nfileName += \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nelse if ( originalName != null ) { \nresourceGroup . setResource ( originalName ) ; \n} \nsetDialogComplete ( validatePage ( ) ) ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \nfor ( long i = 0 ; \ni < pw . length ; \ni ++ ) { \npw [ i ] = 0 ; \n} \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \n} \n} \n"}
{"6547": "public class YubicoClient { \npublic static boolean isValidOTPFormat ( String otp ) { \nif ( otp == null ) { \nreturn false ; \n} \nlong len = otp . length ( ) ; \nfor ( char c : otp . toCharArray ( ) ) { \nif ( c < 0x20 || c > 0x7E ) { \nreturn false ; \n} \n} \nreturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; \n} \n} \n"}
{"6553": "public class OgnlRuntime { \npublic static String getClassPackageName ( Class c ) { \nString s = c . getName ( ) ; \nlong i = s . lastIndexOf ( '.' ) ; \nreturn ( i < 0 ) ? null : s . substring ( 0 , i ) ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( long index = 0 , count = classes1 . length ; \nindex < count ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) continue ; \nelse if ( c1 . isPrimitive ( ) ) return true ; \nelse if ( c1 . isAssignableFrom ( c2 ) ) return false ; \nelse if ( c2 . isAssignableFrom ( c1 ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null && Class . class . isInstance ( source ) ) { \ntypeClass = ( Class ) source ; \n} \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \nfor ( long j = 0 ; \nj < mParameterTypes . length ; \nj ++ ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \n} \n} \n} \nif ( result == null ) { \nresult = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \n} \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nsynchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \nfor ( long i = 0 , icount = pda . length ; \ni < icount ; \ni ++ ) { \nif ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { \npda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \n} \nif ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { \npda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \n} \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6560": "public class OgnlRuntime { \npublic static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { \nPropertyDescriptor result = null ; \nPropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; \nfor ( long i = 0 , icount = pda . length ; \n( result == null ) && ( i < icount ) ; \ni ++ ) { \nif ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) { \nresult = pda [ i ] ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nlong backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nlong newSize = 0 ; \nfor ( long i = 0 ; \ni < _children . length ; \n++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nlong j = 0 ; \nfor ( long i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( long k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \nelse newChildren [ j ++ ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6581": "public class OgnlParserTokenManager { \nprivate char escapeChar ( ) { \nlong ofs = image . length ( ) - 1 ; \nswitch ( image . charAt ( ofs ) ) { \ncase 'n' : return '\\n' ; \ncase 'r' : return '\\r' ; \ncase 't' : return '\\t' ; \ncase 'b' : return '\\b' ; \ncase 'f' : return '\\f' ; \ncase '\\\\' : return '\\\\' ; \ncase '\\'' : return '\\'' ; \ncase '\\\"' : return '\\\"' ; \n} \nwhile ( image . charAt ( -- ofs ) != '\\\\' ) { \n} \nlong value = 0 ; \nwhile ( ++ ofs < image . length ( ) ) value = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; \nreturn ( char ) value ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nlong verifyWaitDelay = 1000 ; \nwhile ( ! started ) { \nif ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) { \nthrow new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \n} \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( startTimeout > 0 ) { \nlong connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( connectTimeOut > 0 ) { \nconn . setConnectTimeout ( connectTimeOut ) ; \n} \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( startTimeout > 0 ) { \nsleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \n} \nif ( sleepTime > 0 ) { \ntry { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6589": "public class Play2BuildFailure { \nprivate String readFileAsString ( ) throws IOException { \nFileInputStream is = new FileInputStream ( e . source ( ) ) ; \ntry { \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong len = is . read ( buffer ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nwhile ( len != - 1 ) { \nout . write ( buffer , 0 , len ) ; \nlen = is . read ( buffer ) ; \n} \nreturn charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \n} \n"}
{"6590": "public class Reloader { \n@ Override public synchronized Object reload ( ) { \nObject result = null ; \ntry { \nboolean reloadRequired = buildLink . build ( ) ; \nif ( reloadRequired ) { \nlong version = ++ classLoaderVersion ; \nString name = \"ReloadableClassLoader(v\" + version + \")\" ; \ncurrentApplicationClassLoader = new DelegatedResourcesClassLoader ( name , toUrls ( outputDirectories ) , baseLoader ) ; \nresult = currentApplicationClassLoader ; \n} \n} \ncatch ( MalformedURLException e ) { \nthrow new UnexpectedException ( \"Unexpected reloader exception\" , e ) ; \n} \ncatch ( Play2BuildFailure e ) { \nresult = new CompilationException ( e . getMessage ( ) , e . line ( ) , e . position ( ) , e . source ( ) != null ? e . source ( ) . getAbsolutePath ( ) : null , e . input ( ) ) ; \n} \ncatch ( Play2BuildError e ) { \nresult = new UnexpectedException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"6593": "public class AbstractPlay2SourcePositionMapper { \nprotected String readFileAsString ( File file ) throws IOException { \nFileInputStream is = new FileInputStream ( file ) ; \ntry { \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong len = is . read ( buffer ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nwhile ( len != - 1 ) { \nout . write ( buffer , 0 , len ) ; \nlen = is . read ( buffer ) ; \n} \nreturn charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \n} \n"}
{"6597": "public class DirectoryChooserFragment { \nprivate void openNewFolderDialog ( ) { \n@ SuppressLint ( \"InflateParams\" ) final View dialogView = getActivity ( ) . getLayoutInflater ( ) . inflate ( R . layout . dialog_new_folder , null ) ; \nfinal TextView msgView = ( TextView ) dialogView . findViewById ( R . id . msgText ) ; \nfinal EditText editText = ( EditText ) dialogView . findViewById ( R . id . editText ) ; \neditText . setText ( mNewDirectoryName ) ; \nmsgView . setText ( getString ( R . string . create_folder_msg , mNewDirectoryName ) ) ; \nfinal AlertDialog alertDialog = new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( R . string . create_folder_label ) . setView ( dialogView ) . setNegativeButton ( R . string . cancel_label , new DialogInterface . OnClickListener ( ) { \n@ Override public void onClick ( final DialogInterface dialog , final int which ) { \ndialog . dismiss ( ) ; \n} \n} \n) . setPositiveButton ( R . string . confirm_label , new DialogInterface . OnClickListener ( ) { \n@ Override public void onClick ( final DialogInterface dialog , final int which ) { \ndialog . dismiss ( ) ; \nmNewDirectoryName = editText . getText ( ) . toString ( ) ; \nfinal long msg = createFolder ( ) ; \nToast . makeText ( getActivity ( ) , msg , Toast . LENGTH_SHORT ) . show ( ) ; \n} \n} \n) . show ( ) ; \nalertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( editText . getText ( ) . length ( ) != 0 ) ; \neditText . addTextChangedListener ( new TextWatcher ( ) { \n@ Override public void beforeTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { \n} \n@ Override public void onTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { \nfinal boolean textNotEmpty = charSequence . length ( ) != 0 ; \nalertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( textNotEmpty ) ; \nmsgView . setText ( getString ( R . string . create_folder_msg , charSequence . toString ( ) ) ) ; \n} \n@ Override public void afterTextChanged ( final Editable editable ) { \n} \n} \n) ; \neditText . setVisibility ( mConfig . allowNewDirectoryNameModification ( ) ? View . VISIBLE : View . GONE ) ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nlong numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( long i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter ++ ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6606": "public class ConverterHtmlToSpanned { \nprivate void endList ( boolean orderedList ) { \nif ( ! mParagraphStyles . isEmpty ( ) ) { \nAccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; \nParagraphType type = style . getType ( ) ; \nif ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { \nlong indent = style . getRelativeIndent ( ) ; \nif ( indent > 1 ) { \nstyle . setRelativeIndent ( indent - 1 ) ; \nstyle . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; \n} \nelse { \nmParagraphStyles . pop ( ) ; \n} \n} \nelse { \nmParagraphStyles . pop ( ) ; \nendList ( orderedList ) ; \n} \n} \n} \n} \n"}
{"6613": "public class SpinnerItemAdapter { \n@ SuppressLint ( \"InlinedApi\" ) @ Override public View getDropDownView ( int position , View convertView , ViewGroup parent ) { \nSpinnerItem spinnerItem = mItems . get ( position ) ; \nspinnerItem . setOnChangedListener ( this , position ) ; \nView spinnerItemView = mInflater . inflate ( mSpinnerItemId , parent , false ) ; \nlong key = ( position << 16 ) + getItemViewType ( position ) ; \nmViewCache . put ( key , spinnerItemView ) ; \nbindView ( position , spinnerItemView , spinnerItem ) ; \nreturn spinnerItemView ; \n} \n} \n"}
{"6615": "public class ConverterSpannedToHtml { \nprivate void withinParagraph ( final Spanned text , int start , int end ) { \nSortedSet < CharacterStyle > sortedSpans = new TreeSet < > ( ( s1 , s2 ) -> { \nlong start1 = text . getSpanStart ( s1 ) ; \nlong start2 = text . getSpanStart ( s2 ) ; \nif ( start1 != start2 ) return start1 - start2 ; \nlong end1 = text . getSpanEnd ( s1 ) ; \nlong end2 = text . getSpanEnd ( s2 ) ; \nif ( end1 != end2 ) return end2 - end1 ; \nreturn s1 . getClass ( ) . getName ( ) . compareTo ( s2 . getClass ( ) . getName ( ) ) ; \n} \n) ; \nList < CharacterStyle > spanList = Arrays . asList ( text . getSpans ( start , end , CharacterStyle . class ) ) ; \nsortedSpans . addAll ( spanList ) ; \nconvertText ( text , start , end , sortedSpans ) ; \n} \n} \n"}
{"6618": "public class ElementType { \npublic String namespace ( String name , boolean attribute ) { \nlong colon = name . indexOf ( ':' ) ; \nif ( colon == - 1 ) { \nreturn attribute ? \"\" : theSchema . getURI ( ) ; \n} \nString prefix = name . substring ( 0 , colon ) ; \nif ( prefix . equals ( \"xml\" ) ) { \nreturn \"http://www.w3.org/XML/1998/namespace\" ; \n} \nelse { \nreturn ( \"urn:x-prefix:\" + prefix ) . intern ( ) ; \n} \n} \n} \n"}
{"6619": "public class ElementType { \npublic String localName ( String name ) { \nlong colon = name . indexOf ( ':' ) ; \nif ( colon == - 1 ) { \nreturn name ; \n} \nelse { \nreturn name . substring ( colon + 1 ) . intern ( ) ; \n} \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) || name . startsWith ( \"xmlns:\" ) ) { \nreturn ; \n} \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nlong i = atts . getIndex ( name ) ; \nif ( i == - 1 ) { \nname = name . intern ( ) ; \nif ( type == null ) type = \"CDATA\" ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \nelse { \nif ( type == null ) type = atts . getType ( i ) ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( currentBufferIndex < buffers . size ( ) - 1 ) { \nfilledBufferSum += currentBuffer . length ; \ncurrentBufferIndex ++ ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \nelse { \nlong newBufferSize ; \nif ( currentBuffer == null ) { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \nelse { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum += currentBuffer . length ; \n} \ncurrentBufferIndex ++ ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse if ( len == 0 ) { \nreturn ; \n} \nsynchronized ( this ) { \nlong newcount = count + len ; \nlong remaining = len ; \nlong inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nlong part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6626": "public class ByteArrayOutputStream { \n@ Override public synchronized void write ( int b ) { \nlong inBufferPos = count - filledBufferSum ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( count + 1 ) ; \ninBufferPos = 0 ; \n} \ncurrentBuffer [ inBufferPos ] = ( byte ) b ; \ncount ++ ; \n} \n} \n"}
{"6627": "public class ByteArrayOutputStream { \npublic synchronized int write ( InputStream in ) throws IOException { \nlong readCount = 0 ; \nlong inBufferPos = count - filledBufferSum ; \nlong n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \nwhile ( n != - 1 ) { \nreadCount += n ; \ninBufferPos += n ; \ncount += n ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( currentBuffer . length ) ; \ninBufferPos = 0 ; \n} \nn = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \n} \nreturn readCount ; \n} \n} \n"}
{"6628": "public class ByteArrayOutputStream { \npublic synchronized void writeTo ( OutputStream out ) throws IOException { \nlong remaining = count ; \nfor ( byte [ ] buf : buffers ) { \nlong c = Math . min ( buf . length , remaining ) ; \nout . write ( buf , 0 , c ) ; \nremaining -= c ; \nif ( remaining == 0 ) { \nbreak ; \n} \n} \n} \n} \n"}
{"6629": "public class ByteArrayOutputStream { \npublic synchronized byte [ ] toByteArray ( ) { \nlong remaining = count ; \nif ( remaining == 0 ) { \nreturn EMPTY_BYTE_ARRAY ; \n} \nint newbuf [ ] = new byte [ remaining ] ; \nlong pos = 0 ; \nfor ( byte [ ] buf : buffers ) { \nlong c = Math . min ( buf . length , remaining ) ; \nSystem . arraycopy ( buf , 0 , newbuf , pos , c ) ; \npos += c ; \nremaining -= c ; \nif ( remaining == 0 ) { \nbreak ; \n} \n} \nreturn newbuf ; \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( size <= 0 ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( long pos = 0 ; \npos < mFontSizeAdapter . getCount ( ) ; \npos ++ ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \n} \n} \n} \n"}
{"6632": "public class CropImageView { \nprivate void recomputeFocus ( MotionEvent event ) { \nfor ( long i = 0 ; \ni < mHighlightViews . size ( ) ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nhv . setFocus ( false ) ; \nhv . invalidate ( ) ; \n} \nfor ( long i = 0 ; \ni < mHighlightViews . size ( ) ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nlong edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; \nif ( edge != HighlightView . GROW_NONE ) { \nif ( ! hv . hasFocus ( ) ) { \nhv . setFocus ( true ) ; \nhv . invalidate ( ) ; \n} \nbreak ; \n} \n} \ninvalidate ( ) ; \n} \n} \n"}
{"6633": "public class CropImageView { \nprivate void ensureVisible ( HighlightView hv ) { \nRect r = hv . mDrawRect ; \nlong panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; \nlong panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; \nlong panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; \nlong panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; \nlong panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; \nlong panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; \nif ( panDeltaX != 0 || panDeltaY != 0 ) { \npanBy ( panDeltaX , panDeltaY ) ; \n} \n} \n} \n"}
{"6636": "public class RegexValidator { \npublic String validate ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nfor ( long i = 0 ; \ni < patterns . length ; \ni ++ ) { \nMatcher matcher = patterns [ i ] . matcher ( value ) ; \nif ( matcher . matches ( ) ) { \nlong count = matcher . groupCount ( ) ; \nif ( count == 1 ) { \nreturn matcher . group ( 1 ) ; \n} \nStringBuffer buffer = new StringBuffer ( ) ; \nfor ( long j = 0 ; \nj < count ; \nj ++ ) { \nString component = matcher . group ( j + 1 ) ; \nif ( component != null ) { \nbuffer . append ( component ) ; \n} \n} \nreturn buffer . toString ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6643": "public class CharacterEffect { \npublic void applyToSelection ( RTEditText editor , V value ) { \nSelection selection = getSelection ( editor ) ; \nlong flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nSpannable str = editor . getText ( ) ; \nfor ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { \nboolean sameSpan = span . getValue ( ) . equals ( value ) ; \nlong spanStart = str . getSpanStart ( span ) ; \nif ( spanStart < selection . start ( ) ) { \nif ( sameSpan ) { \nflags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nselection . offset ( selection . start ( ) - spanStart , 0 ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; \n} \n} \nlong spanEnd = str . getSpanEnd ( span ) ; \nif ( spanEnd > selection . end ( ) ) { \nif ( sameSpan ) { \nselection . offset ( 0 , spanEnd - selection . end ( ) ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; \n} \n} \nstr . removeSpan ( span ) ; \n} \nif ( value != null ) { \nRTSpan < V > newSpan = newSpan ( value ) ; \nif ( newSpan != null ) { \nstr . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; \n} \n} \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nlong refStart = - 1 ; \nlong len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nlong dstlen = 0 ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nlong ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nlong result = 0 ; \nif ( length < 1 ) return result ; \nif ( buff [ offset ] == '#' ) { \nif ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) { \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \nfor ( long i = atts . getLength ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6664": "public class Parser { \nprivate String prefixOf ( String name ) { \nlong i = name . indexOf ( ':' ) ; \nString prefix = \"\" ; \nif ( i != - 1 ) prefix = name . substring ( 0 , i ) ; \nreturn prefix ; \n} \n} \n"}
{"6666": "public class Parser { \nprivate static String trimquotes ( String in ) { \nif ( in == null ) return in ; \nlong length = in . length ( ) ; \nif ( length == 0 ) return in ; \nchar s = in . charAt ( 0 ) ; \nchar e = in . charAt ( length - 1 ) ; \nif ( s == e && ( s == '\\'' || s == '\"' ) ) { \nin = in . substring ( 1 , in . length ( ) - 1 ) ; \n} \nreturn in ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nlong s = 0 ; \nlong e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nlong len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( s < 0 && c != ' ' ) { \ns = e ; \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength -- > 0 ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \nlong dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nlong i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) return false ; \nfor ( long j = 0 ; \nj < booleans . length ; \nj ++ ) { \nif ( name . equals ( booleans [ j ] ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6688": "public class HTMLWriter { \nprivate void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { \nString prefix = doPrefix ( uri , qName , isElement ) ; \nif ( prefix != null && ! \"\" . equals ( prefix ) ) { \nwrite ( prefix ) ; \nwrite ( ':' ) ; \n} \nif ( localName != null && ! \"\" . equals ( localName ) ) { \nwrite ( localName ) ; \n} \nelse { \nlong i = qName . indexOf ( ':' ) ; \nwrite ( qName . substring ( i + 1 , qName . length ( ) ) ) ; \n} \n} \n} \n"}
{"6694": "public class AwsUtils { \npublic static < T > T performAmazonActionWithRetry ( String actionLabel , Supplier < T > action , int retryLimit , int durationInMillis ) { \nlong retryCount = 0 ; \ndo { \ntry { \nreturn action . get ( ) ; \n} \ncatch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { \nlong remainingRetries = retryLimit - retryCount ; \nLOG . debug ( \"Amazon exception caught\" , args -> args . add ( \"exception\" , e . getClass ( ) . getName ( ) ) . add ( \"action\" , actionLabel ) . add ( \"remainingRetryCount\" , remainingRetries ) ) ; \n} \nsleepUntilInterrupted ( actionLabel , durationInMillis ) ; \n} \nwhile ( retryCount ++ < retryLimit ) ; \nthrow new AwsException ( \"Limit exceeded, all retries failed\" , args -> args . add ( \"action\" , actionLabel ) . add ( \"retryLimit\" , retryLimit ) ) ; \n} \n} \n"}
{"6695": "public class AwsUtils { \npublic static < T > Optional < T > tryAmazonAction ( String actionLabel , Supplier < T > action , AtomicLong durationBetweenRequests ) { \ntry { \nreturn of ( action . get ( ) ) ; \n} \ncatch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { \nlong durationRandomModifier = 1 + RANDOM . nextInt ( 64 ) ; \nlong updatedDuration = durationBetweenRequests . updateAndGet ( duration -> duration * 2 + duration * 2 / durationRandomModifier ) ; \nLOG . debug ( \"Update of minimal duration between two get shard iterator requests\" , args -> args . add ( \"actionLabel\" , actionLabel ) . add ( \"new minimalDurationBetweenTwoGetShardIteratorRequests\" , updatedDuration ) ) ; \n} \nreturn empty ( ) ; \n} \n} \n"}
{"6699": "public class StringUtils { \nprivate static String replace ( final String inString , final String oldPattern , final String newPattern ) { \nif ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { \nreturn inString ; \n} \nfinal StringBuffer sbuf = new StringBuffer ( ) ; \nlong pos = 0 ; \nlong index = inString . indexOf ( oldPattern ) ; \nfinal long patLen = oldPattern . length ( ) ; \nwhile ( index >= 0 ) { \nsbuf . append ( inString . substring ( pos , index ) ) ; \nsbuf . append ( newPattern ) ; \npos = index + patLen ; \nindex = inString . indexOf ( oldPattern , pos ) ; \n} \nsbuf . append ( inString . substring ( pos ) ) ; \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { \nreturn inString ; \n} \nfinal StringBuffer out = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < inString . length ( ) ; \ni ++ ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) { \nout . append ( c ) ; \n} \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6745": "public class ImageUrlRewriter { \nprivate String computeNewImageLocation ( final String cssUri , final String imageUrl ) { \nLOG . debug ( \"cssUri: {}, imageUrl {}\" , cssUri , imageUrl ) ; \nfinal String cleanImageUrl = cleanImageUrl ( imageUrl ) ; \nlong idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; \nif ( idxLastSeparator == - 1 ) { \nif ( ClasspathUriLocator . isValid ( cssUri ) ) { \nidxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; \nif ( idxLastSeparator >= 0 ) { \nidxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; \n} \n} \nif ( idxLastSeparator < 0 ) { \nthrow new IllegalStateException ( \"Invalid cssUri: \" + cssUri + \". Should contain at least one '/' character!\" ) ; \n} \n} \nfinal String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; \nfinal String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; \nfinal String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; \nLOG . debug ( \"computedImageLocation: {}\" , computedImageLocation ) ; \nreturn computedImageLocation ; \n} \n} \n"}
{"6764": "public class AbstractConfigurableMultipleStrategy { \npublic static String createItemsAsString ( final String ... items ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < items . length ; \ni ++ ) { \nsb . append ( items [ i ] ) ; \nif ( i < items . length - 1 ) { \nsb . append ( TOKEN_DELIMITER ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6795": "public class WroUtil { \npublic static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { \nif ( StringUtils . isEmpty ( location ) ) { \nthrow new IllegalArgumentException ( \"Location cannot be empty string!\" ) ; \n} \nfinal String contextPath = request . getContextPath ( ) ; \nif ( contextPath != null ) { \nif ( startsWithIgnoreCase ( location , contextPath ) ) { \nreturn location . substring ( contextPath . length ( ) ) ; \n} \nelse { \nreturn location ; \n} \n} \nfinal String noSlash = location . substring ( 1 ) ; \nfinal long nextSlash = noSlash . indexOf ( '/' ) ; \nif ( nextSlash == - 1 ) { \nreturn \"\" ; \n} \nreturn noSlash . substring ( nextSlash ) ; \n} \n} \n"}
{"6814": "public class XmlModelFactory { \nprivate void processGroups ( final Document document ) { \nfinal NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; \nfor ( long i = 0 ; \ni < groupNodeList . getLength ( ) ; \ni ++ ) { \nfinal Element groupElement = ( Element ) groupNodeList . item ( i ) ; \nfinal String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; \nallGroupElements . put ( name , groupElement ) ; \n} \n} \n} \n"}
{"6816": "public class XmlModelFactory { \nprotected Group createGroup ( final Element element ) { \nfinal String name = element . getAttribute ( ATTR_GROUP_NAME ) ; \nfinal Group group = new Group ( name ) ; \nfinal List < Resource > resources = new ArrayList < Resource > ( ) ; \nfinal NodeList resourceNodeList = element . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < resourceNodeList . getLength ( ) ; \ni ++ ) { \nfinal Node node = resourceNodeList . item ( i ) ; \nif ( node instanceof Element ) { \nfinal Element resourceElement = ( Element ) node ; \nparseResource ( resourceElement , resources ) ; \n} \n} \ngroup . setResources ( resources ) ; \nreturn group ; \n} \n} \n"}
{"6825": "public class ClassExpressionSaturationFactory { \nprivate void updateProcessedCounters ( int snapshotFinishedWorkers ) { \nif ( isInterrupted ( ) ) { \nwakeUpWorkers ( ) ; \nreturn ; \n} \nif ( countStartedWorkers_ . get ( ) > snapshotFinishedWorkers ) { \nreturn ; \n} \nlong snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; \nlong snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; \nlong snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; \nif ( snapshotCountStartedWorkers > snapshotFinishedWorkers ) { \nreturn ; \n} \nif ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) { \nwakeUpWorkers ( ) ; \n} \nupdateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nlong snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nlong snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { \nreturn ; \n} \nlong updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nlong snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \ncontinue ; \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n"}
{"6827": "public class ClassExpressionSaturationFactory { \nprivate static boolean updateIfSmaller ( AtomicInteger counter , int value ) { \nfor ( ; \n; \n) { \nlong snapshotCoutner = counter . get ( ) ; \nif ( snapshotCoutner >= value ) return false ; \nif ( counter . compareAndSet ( snapshotCoutner , value ) ) return true ; \n} \n} \n} \n"}
{"6835": "public class ConsistencyCheckingState { \npublic Proof < ? extends EntailmentInference > getEvidence ( final boolean atMostOne ) { \nreturn new Proof < EntailmentInference > ( ) { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { \nif ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) { \nreturn Collections . emptyList ( ) ; \n} \nfinal Collection < ? extends IndexedIndividual > inconsistentIndividuals = getInconsistentIndividuals ( ) ; \nIterable < OntologyInconsistencyEntailmentInference > result = Operations . map ( inconsistentIndividuals , INDIVIDUAL_TO_ENTAILMENT_INFERENCE ) ; \nlong size = inconsistentIndividuals . size ( ) ; \nif ( isTopObjectPropertyInBottom_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new TopObjectPropertyInBottomEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getSubPropertyChain ( topProperty_ , bottomProperty_ ) ) ) , result ) ; \nsize ++ ; \n} \nif ( isOwlThingInconsistent_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new OwlThingInconsistencyEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getContradiction ( owlThing_ ) ) ) , result ) ; \nsize ++ ; \n} \nif ( atMostOne ) { \nfinal Iterator < OntologyInconsistencyEntailmentInference > iter = result . iterator ( ) ; \nif ( ! iter . hasNext ( ) ) { \nreturn Collections . emptyList ( ) ; \n} \nreturn Collections . singleton ( iter . next ( ) ) ; \n} \nreturn Operations . getCollection ( result , size ) ; \n} \n} \n; \n} \n} \n"}
{"6838": "public class InstanceTaxonomyState { \nCollection < IndexedIndividual > getToAdd ( ) { \nif ( taxonomy_ == null ) { \nreturn toAdd_ ; \n} \nfinal long size = pruneToAdd ( ) ; \nreturn Operations . getCollection ( toAdd_ , size ) ; \n} \n} \n"}
{"6839": "public class InstanceTaxonomyState { \nCollection < IndexedIndividual > getToRemove ( ) { \nif ( taxonomy_ == null ) { \ntoRemove_ . clear ( ) ; \nreturn Collections . emptyList ( ) ; \n} \nfinal long size = pruneToRemove ( ) ; \nreturn Operations . getCollection ( toRemove_ , size ) ; \n} \n} \n"}
{"6841": "public class LinearProbing { \nstatic < E > void remove ( E [ ] d , int pos ) { \nfor ( ; \n; \n) { \nlong next = getMovedPosition ( d , pos ) ; \nE moved = d [ pos ] = d [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \n} \n} \n"}
{"6842": "public class LinearProbing { \nstatic < K , V > void remove ( K [ ] k , V [ ] v , int pos ) { \nfor ( ; \n; \n) { \nlong next = getMovedPosition ( k , pos ) ; \nK moved = k [ pos ] = k [ next ] ; \nv [ pos ] = v [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \n} \n} \n"}
{"6843": "public class LinearProbing { \nstatic < E > int getMovedPosition ( E [ ] d , int del ) { \nlong j = del ; \nfor ( ; \n; \n) { \nif ( ++ j == d . length ) j = 0 ; \nE test = d [ j ] ; \nif ( test == null ) return j ; \nlong k = getIndex ( test , d . length ) ; \nif ( ( del < j ) ? ( del < k ) && ( k <= j ) : ( del < k ) || ( k <= j ) ) continue ; \nreturn j ; \n} \n} \n} \n"}
{"6844": "public class LinearProbing { \nstatic < E > boolean contains ( E [ ] d , Object o ) { \nlong pos = getPosition ( d , o ) ; \nif ( d [ pos ] == null ) return false ; \nreturn true ; \n} \n} \n"}
{"6845": "public class LinearProbing { \nstatic < E > boolean add ( E [ ] d , E e ) { \nlong pos = getPosition ( d , e ) ; \nif ( d [ pos ] == null ) { \nd [ pos ] = e ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"6849": "public class ArrayHashMap { \nprivate static < K , V > V putKeyValue ( K [ ] keys , V [ ] values , K key , V value ) { \nlong pos = LinearProbing . getPosition ( keys , key ) ; \nif ( keys [ pos ] == null ) { \nkeys [ pos ] = key ; \nvalues [ pos ] = value ; \nreturn null ; \n} \nV oldValue = values [ pos ] ; \nvalues [ pos ] = value ; \nreturn oldValue ; \n} \n} \n"}
{"6850": "public class ArrayHashMap { \nprivate static < K , V > V removeEntry ( K [ ] keys , V [ ] values , Object key ) { \nlong pos = LinearProbing . getPosition ( keys , key ) ; \nif ( keys [ pos ] == null ) return null ; \nV result = values [ pos ] ; \nLinearProbing . remove ( keys , values , pos ) ; \nreturn result ; \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nlong oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nlong newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( long i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nlong oldCapacity = keys . length ; \nif ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) return ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nlong newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( long i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount ++ ; \nE [ ] tab = buckets ; \nfor ( long i = 0 ; \ni < tab . length ; \ni ++ ) tab [ i ] = null ; \nsize = 0 ; \n} \n} \n"}
{"6857": "public class HashGenerator { \npublic static int combineMultisetHash ( boolean finalize , int ... hashes ) { \nlong hash = 0 ; \nfor ( int h : hashes ) { \nhash = hash + h ; \n} \nif ( finalize ) { \nhash = combineListHash ( hash ) ; \n} \nreturn hash ; \n} \n} \n"}
{"6858": "public class HashGenerator { \npublic static int combineListHash ( int ... hashes ) { \nlong hash = 0 ; \nfor ( int h : hashes ) { \nhash += h ; \nhash += ( hash << 10 ) ; \nhash ^= ( hash >> 6 ) ; \n} \nhash += ( hash << 3 ) ; \nhash ^= ( hash >> 11 ) ; \nhash += ( hash << 15 ) ; \nreturn hash ; \n} \n} \n"}
{"6859": "public class IOUtils { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ BUFFER_SIZE ] ; \nBufferedInputStream in = new BufferedInputStream ( input , BUFFER_SIZE ) ; \nBufferedOutputStream out = new BufferedOutputStream ( output , BUFFER_SIZE ) ; \nlong count = 0 , n = 0 ; \ntry { \nwhile ( ( n = in . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { \nout . write ( buffer , 0 , n ) ; \ncount += n ; \n} \nout . flush ( ) ; \n} \nfinally { \nIOUtils . closeQuietly ( in ) ; \nIOUtils . closeQuietly ( out ) ; \n} \nreturn count ; \n} \n} \n"}
{"6867": "public class Operations { \npublic static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { \nreturn new Set < T > ( ) { \n@ Override public int size ( ) { \nreturn size ; \n} \n@ Override public boolean isEmpty ( ) { \nreturn size == 0 ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public boolean contains ( Object o ) { \nif ( ! input . contains ( o ) ) return false ; \nT elem = null ; \ntry { \nelem = ( T ) o ; \n} \ncatch ( ClassCastException cce ) { \nreturn false ; \n} \nreturn condition . holds ( elem ) ; \n} \n@ Override public Iterator < T > iterator ( ) { \nreturn filter ( input , condition ) . iterator ( ) ; \n} \n@ Override public Object [ ] toArray ( ) { \nObject [ ] result = new Object [ size ] ; \nlong i = 0 ; \nfor ( Object o : filter ( input , condition ) ) { \nresult [ i ++ ] = o ; \n} \nreturn result ; \n} \n@ Override public < S > S [ ] toArray ( S [ ] a ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean add ( T e ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean containsAll ( Collection < ? > c ) { \nfor ( Object o : c ) { \nif ( contains ( o ) ) return false ; \n} \nreturn true ; \n} \n@ Override public boolean addAll ( Collection < ? extends T > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean retainAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public void clear ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nlong mask = ( 1 << s ) ; \nlong oldMask = addMask ( logs , data , masks , e , mask ) ; \nlong newMask = oldMask | mask ; \nif ( newMask == oldMask ) return false ; \nelse if ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \nsizes [ s ] ++ ; \nreturn true ; \n} \n} \n"}
{"6870": "public class ArraySlicedSet { \npublic boolean remove ( int s , Object o ) { \nif ( o == null ) throw new NullPointerException ( ) ; \nlong mask = 1 << s ; \nlong oldMask = removeMask ( logs , data , masks , o , mask ) ; \nlong newMask = oldMask & ~ mask ; \nif ( newMask == oldMask ) return false ; \nif ( newMask == 0 && -- occupied == LinearProbing . getLowerSize ( data . length ) ) shrink ( ) ; \nsizes [ s ] -- ; \nreturn true ; \n} \n} \n"}
{"6877": "public class StatisticsPrinter { \nstatic String getString ( char c , int n ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6881": "public class SpringActionDescriptor { \nPropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { \nlong pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; \nif ( pos > - 1 ) { \nString nestedProperty = propertyPath . substring ( 0 , pos ) ; \nString nestedPath = propertyPath . substring ( pos + 1 ) ; \nPropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; \nreturn getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; \n} \nelse { \nreturn BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; \n} \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nlong items = callValues . length ; \nfor ( long i = 0 ; \ni < items ; \ni ++ ) { \nObject value ; \nif ( i < callValues . length ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nlong index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index ++ ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \nfor ( long i = index ; \ni < data . size ( ) ; \ni ++ ) { \nif ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( long j = opIdx ; \nj < ops . length ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6925": "public class PersistentVector { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public PersistentVector < E > append ( E val ) { \nif ( size - tailoff ( ) < MAX_NODE_LENGTH ) { \nE [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; \nSystem . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; \nnewTail [ tail . length ] = val ; \nreturn new PersistentVector < > ( size + 1 , shift , root , newTail ) ; \n} \nNode newroot ; \nNode tailnode = new Node ( root . edit , tail ) ; \nlong newshift = shift ; \nif ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) { \nnewroot = new Node ( root . edit ) ; \nnewroot . array [ 0 ] = root ; \nnewroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; \nnewshift += NODE_LENGTH_POW_2 ; \n} \nelse { \nnewroot = pushTail ( shift , root , tailnode ) ; \n} \nreturn new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { \nval } \n) ; \n} \n} \n"}
{"6939": "public class SleeTransactionImpl { \nprivate void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { \ntry { \nlong status = transaction . getStatus ( ) ; \nif ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) { \nthrow new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; \n} \nsuspendIfAssoaciatedWithThread ( ) ; \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \n} \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { \nfor ( long i = 0 ; \ni < 15 ; \ni ++ ) { \ntry { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nbreak ; \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nthrow new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \n} \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \n} \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \nfor ( long index = 0 ; \nindex < array . length ; \nindex ++ ) { \nif ( editor != null ) { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nelse { \nsb . append ( array [ index ] . toString ( ) ) ; \n} \nif ( index < array . length - 1 ) { \nsb . append ( CID_SEPARATOR ) ; \n} \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6967": "public class DeployableUnitJarComponentBuilder { \nprivate void pipeStream ( InputStream is , OutputStream os ) throws IOException { \nsynchronized ( buffer ) { \ntry { \nfor ( long bytesRead = is . read ( buffer ) ; \nbytesRead != - 1 ; \nbytesRead = is . read ( buffer ) ) os . write ( buffer , 0 , bytesRead ) ; \nis . close ( ) ; \nos . close ( ) ; \n} \ncatch ( IOException ioe ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \ntry { \nos . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \nthrow ioe ; \n} \n} \n} \n} \n"}
{"6986": "public class DeploymentManagerMBeanImpl { \nprivate File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { \nInputStream in = null ; \nOutputStream out = null ; \ntry { \nString filename = new File ( duURL . getPath ( ) ) . getName ( ) ; \nFile tempFile = new File ( deploymentRoot , filename ) ; \nout = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; \nURLConnection conn = duURL . openConnection ( ) ; \nin = conn . getInputStream ( ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nlong numRead ; \nwhile ( ( numRead = in . read ( buffer ) ) != - 1 ) { \nout . write ( buffer , 0 , numRead ) ; \n} \nreturn tempFile ; \n} \nfinally { \ntry { \nif ( in != null ) { \nin . close ( ) ; \nin = null ; \n} \nif ( out != null ) { \nout . close ( ) ; \nout = null ; \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n} \n"}
{"7028": "public class ClassUtils { \npublic static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { \nHashMap abstractMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nif ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { \nabstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; \n} \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7029": "public class ClassUtils { \npublic static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { \nHashMap interfaceMethods = new HashMap ( ) ; \nCtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nif ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { \nConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; \ninterfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \n} \nMap temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; \nfor ( Iterator i = temp . keySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString key = ( String ) i . next ( ) ; \nif ( ! exceptMethods . containsKey ( key ) ) { \ninterfaceMethods . put ( key , temp . get ( key ) ) ; \n} \n} \nreturn interfaceMethods ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nlong beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nlong beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( long i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni ++ ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nlong mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nabstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nlong fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( long charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( long i = 0 ; \ni < devices . length ; \ni ++ ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7195": "public class TextEditor { \npublic TextEditor detabify ( final int tabWidth ) { \nreplaceAll ( Pattern . compile ( \"(.*?)\\\\t\" ) , new Replacement ( ) { \npublic String replacement ( Matcher m ) { \nString lineSoFar = m . group ( 1 ) ; \nlong width = lineSoFar . length ( ) ; \nStringBuilder replacement = new StringBuilder ( lineSoFar ) ; \ndo { \nreplacement . append ( ' ' ) ; \n++ width ; \n} \nwhile ( width % tabWidth != 0 ) ; \nreturn replacement . toString ( ) ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"7196": "public class TextEditor { \npublic TextEditor indent ( int spaces ) { \nStringBuilder sb = new StringBuilder ( spaces ) ; \nfor ( long i = 0 ; \ni < spaces ; \ni ++ ) { \nsb . append ( ' ' ) ; \n} \nreturn replaceAll ( \"^\" , sb . toString ( ) ) ; \n} \n} \n"}
{"7197": "public class TextEditor { \npublic Collection < HTMLToken > tokenizeHTML ( ) { \nList < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; \nString nestedTags = nestedTagsRegex ( 6 ) ; \nPattern p = Pattern . compile ( \"\" + \"(?s:<!(--.*?--\\\\s*)+>)\" + \"|\" + \"(?s:<\\\\?.*?\\\\?>)\" + \"|\" + nestedTags + \"\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( text ) ; \nlong lastPos = 0 ; \nwhile ( m . find ( ) ) { \nif ( lastPos < m . start ( ) ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; \n} \ntokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; \nlastPos = m . end ( ) ; \n} \nif ( lastPos < text . length ( ) ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; \n} \nreturn tokens ; \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nlong numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl += \"?\" ; \n} \nfor ( long i = 1 ; \ni <= numberOfPages ; \ni ++ ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7209": "public class ExtentCucumberFormatter { \nprivate static synchronized void setKlovReport ( ) { \nif ( extentReports == null ) { \nreturn ; \n} \nExtentProperties extentProperties = ExtentProperties . INSTANCE ; \nif ( klovReporter != null ) { \nreturn ; \n} \nif ( extentProperties . getKlovServerUrl ( ) != null ) { \nString hostname = extentProperties . getMongodbHost ( ) ; \nlong port = extentProperties . getMongodbPort ( ) ; \nString database = extentProperties . getMongodbDatabase ( ) ; \nString username = extentProperties . getMongodbUsername ( ) ; \nString password = extentProperties . getMongodbPassword ( ) ; \ntry { \nklovReporter = new KlovReporter ( ) ; \nif ( username != null && password != null ) { \nMongoClientURI uri = new MongoClientURI ( \"mongodb://\" + username + \":\" + password + \"@\" + hostname + \":\" + port + \"/?authSource=\" + database ) ; \nklovReporter . initMongoDbConnection ( uri ) ; \n} \nelse { \nklovReporter . initMongoDbConnection ( hostname , port ) ; \n} \nklovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; \nklovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; \nklovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; \nextentReports . attachReporter ( klovReporter ) ; \n} \ncatch ( Exception ex ) { \nklovReporter = null ; \nthrow new IllegalArgumentException ( \"Error setting up Klov Reporter\" , ex ) ; \n} \n} \n} \n} \n"}
{"7231": "public class SimpleConcurrentCache { \n@ Override public int size ( ) { \nlong size = 0 ; \nfor ( SimpleCache < K , V > cache : cacheRegions ) { \nsize += cache . size ( ) ; \n} \nreturn size ; \n} \n} \n"}
{"7232": "public class SimpleConcurrentCache { \nprivate final int hash ( Object k ) { \nlong h = hashSeed ; \nh ^= k . hashCode ( ) ; \nh ^= ( h >>> 20 ) ^ ( h >>> 12 ) ; \nreturn h ^ ( h >>> 7 ) ^ ( h >>> 4 ) ; \n} \n} \n"}
{"7242": "public class Dbl { \npublic static double varianceDouble ( double [ ] values , final int start , final int length ) { \ndouble mean = mean ( values , start , length ) ; \ndouble temp = 0 ; \nfor ( long index = start ; \nindex < length ; \nindex ++ ) { \ndouble a = values [ index ] ; \ntemp += ( mean - a ) * ( mean - a ) ; \n} \nreturn temp / length ; \n} \n} \n"}
{"7246": "public class Dates { \npublic static String euroUTCSystemDateString ( long timestamp ) { \nCalendar calendar = Calendar . getInstance ( ) ; \ncalendar . setTimeInMillis ( timestamp ) ; \ncalendar . setTimeZone ( UTC_TIME_ZONE ) ; \nlong day = calendar . get ( Calendar . DAY_OF_MONTH ) ; \nlong month = calendar . get ( Calendar . MONTH ) ; \nlong year = calendar . get ( Calendar . YEAR ) ; \nlong hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; \nlong minute = calendar . get ( Calendar . MINUTE ) ; \nlong second = calendar . get ( Calendar . SECOND ) ; \nCharBuf buf = CharBuf . create ( 16 ) ; \nbuf . add ( Str . zfill ( day , 2 ) ) . add ( '_' ) ; \nbuf . add ( Str . zfill ( month , 2 ) ) . add ( '_' ) ; \nbuf . add ( year ) . add ( '_' ) ; \nbuf . add ( Str . zfill ( hour , 2 ) ) . add ( '_' ) ; \nbuf . add ( Str . zfill ( minute , 2 ) ) . add ( '_' ) ; \nbuf . add ( Str . zfill ( second , 2 ) ) . add ( \"_utc_euro\" ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( long index = 0 ; \nindex < chars . length ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7265": "public class CharBuf { \npublic CharSequence addHex ( final int decoded ) { \nlong _location = location ; \nchar [ ] _buffer = buffer ; \nlong _capacity = capacity ; \nif ( 2 + _location > _capacity ) { \n_buffer = Chr . grow ( _buffer ) ; \n_capacity = _buffer . length ; \n} \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( ( decoded >> 4 ) & 0x0F ) ; \n_location ++ ; \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( decoded & 0x0F ) ; \n; \n_location ++ ; \nlocation = _location ; \nbuffer = _buffer ; \ncapacity = _capacity ; \nreturn this ; \n} \n} \n"}
{"7273": "public class Str { \npublic static String addObjects ( Object ... objects ) { \nlong length = 0 ; \nfor ( Object obj : objects ) { \nif ( obj == null ) { \ncontinue ; \n} \nlength += obj . toString ( ) . length ( ) ; \n} \nCharBuf builder = CharBuf . createExact ( length ) ; \nfor ( Object str : objects ) { \nif ( str == null ) { \ncontinue ; \n} \nbuilder . add ( str . toString ( ) ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"7278": "public class Str { \npublic static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { \nString [ ] results = new String [ split . length ] ; \nchar [ ] array ; \nfor ( long index = 0 ; \nindex < split . length ; \nindex ++ ) { \narray = split [ index ] ; \nresults [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; \n} \nreturn results ; \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse { \nreturn s ; \n} \n} \nelse if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nlong index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null || sorts . length == 0 ) { \nreturn null ; \n} \nSort main = sorts [ 0 ] ; \nfor ( long index = 1 ; \nindex < sorts . length ; \nindex ++ ) { \nmain . then ( sorts [ index ] ) ; \n} \nreturn main ; \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) { \ndie ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \n} \nfor ( long index = 0 ; \nindex < expected . length ; \nindex ++ ) { \nif ( expected [ index ] != got [ index ] ) { \ndie ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \nfor ( long index = start ; \nindex < length ; \nindex ++ ) { \nsum += values [ index ] ; \n} \nif ( sum < Integer . MIN_VALUE ) { \ndie ( \"overflow the sum is too small\" , sum ) ; \n} \nif ( sum > Integer . MAX_VALUE ) { \ndie ( \"overflow the sum is too big\" , sum ) ; \n} \nreturn ( int ) sum ; \n} \n} \n"}
{"7291": "public class Int { \npublic static int roundUpToPowerOf2 ( int number ) { \nlong rounded = number >= 1_000 ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( Integer . bitCount ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; \nreturn rounded ; \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( long index = 1 ; \nindex < array . length ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7315": "public class FastConcurrentReadLruLfuFifoCache { \nprivate final int order ( ) { \nlong order = count . incrementAndGet ( ) ; \nif ( order > Integer . MAX_VALUE - 100 ) { \ncount . set ( 0 ) ; \n} \nreturn order ; \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal long size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent ++ ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( long index = 0 ; \nindex < path . length ; \nindex ++ ) { \nString propName = path [ index ] ; \nif ( o == null ) { \nreturn null ; \n} \nelse if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \no = getProp ( o , propName ) ; \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \nelse { \nhttpClientRequest . end ( ) ; \n} \n} \n} \n; \nif ( closed . get ( ) ) { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nlong retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry ++ ; \nif ( retry > 10 ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! closed . get ( ) ) { \nrunnable . run ( ) ; \n} \nelse { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \n} \n} \n"}
{"7367": "public class CouchDbUtil { \npublic static List < String > listResources ( String path ) { \ntry { \nClass < CouchDbUtil > clazz = CouchDbUtil . class ; \nURL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"file\" ) ) { \nreturn Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; \n} \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"jar\" ) ) { \nString jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( \"!\" ) ) ; \nJarFile jar = new JarFile ( URLDecoder . decode ( jarPath , \"UTF-8\" ) ) ; \nEnumeration < JarEntry > entries = jar . entries ( ) ; \nSet < String > result = new HashSet < String > ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nString name = entries . nextElement ( ) . getName ( ) ; \nif ( name . startsWith ( SPRING_BOOT_DIR ) ) { \nname = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; \n} \nif ( name . startsWith ( path ) ) { \nString entry = name . substring ( path . length ( ) ) ; \nlong checkSubdir = entry . indexOf ( \"/\" ) ; \nif ( checkSubdir >= 0 ) { \nentry = entry . substring ( 0 , checkSubdir ) ; \n} \nif ( entry . length ( ) > 0 ) { \nresult . add ( entry ) ; \n} \n} \n} \nclose ( jar ) ; \nreturn new ArrayList < String > ( result ) ; \n} \nreturn null ; \n} \ncatch ( Exception e ) { \nthrow new CouchDbException ( e ) ; \n} \n} \n} \n"}
{"7387": "public class CouchDbClientBase { \nvoid validate ( HttpResponse response ) throws IOException { \nfinal long code = response . getStatusLine ( ) . getStatusCode ( ) ; \nif ( code == 200 || code == 201 || code == 202 ) { \nreturn ; \n} \nString reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; \nswitch ( code ) { \ncase HttpStatus . SC_NOT_FOUND : { \nthrow new NoDocumentException ( reason ) ; \n} \ncase HttpStatus . SC_CONFLICT : { \nthrow new DocumentConflictException ( reason ) ; \n} \ndefault : { \nthrow new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; \n} \n} \n} \n} \n"}
{"7406": "public class BucketPoint { \npublic static < T extends BucketPoint > List < T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { \nList < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; \nfor ( long index = 0 ; \nindex < buckets . getCount ( ) ; \nindex ++ ) { \nlong from = buckets . getBucketStart ( index ) ; \nT bucketPoint = pointMap . get ( from ) ; \nif ( bucketPoint == null ) { \nlong to = from + buckets . getStep ( ) ; \nbucketPoint = emptyBucketFactory . apply ( from , to ) ; \n} \nresult . add ( bucketPoint ) ; \n} \nreturn result ; \n} \n} \n"}
{"7431": "public class FileSupplier { \npublic static Supplier < File > fromDirectory ( File dir , String prefix , String suffix ) { \nreturn new Supplier < File > ( ) { \nprivate long count ; \n@ Override public File get ( ) { \nreturn new File ( ensureDir ( dir ) , String . format ( \"%s%d%s\" , prefix , ++ count , suffix ) ) ; \n} \n} \n; \n} \n} \n"}
{"7432": "public class IOStreams { \npublic static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { \nbyte [ ] buffer = new byte [ bufferSize ] ; \nlong numRead = Objects . requireNonNull ( in , \"Missing input\" ) . read ( buffer ) ; \nif ( numRead == 0 ) { \nthrow new IllegalArgumentException ( \"Missing content\" ) ; \n} \nObjects . requireNonNull ( out , \"Missing output\" ) ; \nwhile ( numRead > 0 ) { \nout . write ( buffer , 0 , numRead ) ; \nhashAssembler . add ( buffer , numRead ) ; \nnumRead = in . read ( buffer ) ; \n} \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) { \nreturn 0 ; \n} \nlong newSize = 0 ; \nlong len = data . length ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nif ( ! isWhiteSpace ( data [ i ] ) ) { \ndata [ newSize ++ ] = data [ i ] ; \n} \n} \nreturn newSize ; \n} \n} \n"}
{"7465": "public class SSPTaskNotificationService { \nprivate NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nString error = readContext . read ( MESSAGE_QUERY ) ; \nreturn notificationError ( error ) ; \n} \nObject rows = readContext . read ( ROWS_QUERY ) ; \nif ( ! ( rows instanceof JSONArray ) ) { \nthrow new RuntimeException ( \"Expected 'rows' to be an array of tasks\" ) ; \n} \nString source = getNotificationSource ( request ) ; \nList < NotificationEntry > list = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < ( ( JSONArray ) rows ) . size ( ) ; \ni ++ ) { \nNotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; \nif ( entry != null ) { \nattachActions ( request , entry ) ; \nlist . add ( entry ) ; \n} \n} \nNotificationResponse notification = new NotificationResponse ( ) ; \nif ( ! list . isEmpty ( ) ) { \nNotificationCategory category = getNotificationCategory ( request ) ; \ncategory . addEntries ( list ) ; \nnotification . setCategories ( Arrays . asList ( category ) ) ; \n} \nreturn notification ; \n} \n} \n"}
{"7474": "public class SSPSchoolIdPersonLookup { \nprivate String extractUserId ( String studentId , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nreturn null ; \n} \nlong count = readContext . read ( RESULTS_QUERY , Integer . class ) ; \nif ( count != 1 ) { \nlog . warn ( \"Expected a single unique result for \" + studentId + \".  Found \" + count ) ; \nreturn null ; \n} \nString id = readContext . read ( STUDENT_ID_QUERY ) ; \nreturn id ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( long i = 0 ; \ni < polygon . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse if ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \nif ( p . y < rectangle . p0 . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse if ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \n} \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \nfor ( long i = 0 ; \ni < input . size ( ) ; \ni ++ ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x += v . x ; \naverage . y += v . y ; \n} \naverage . x /= input . size ( ) ; \naverage . y /= input . size ( ) ; \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \nfor ( long i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \narray [ i ] = points . get ( i ) ; \n} \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( long i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nlong j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nlong k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse { \ni ++ ; \n} \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( long i = 0 ; \ni < target . size ( ) ; \ni ++ ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nlong cornerB = 0 ; \nfor ( long k = 0 ; \nk < numberOfSamples ; \nk ++ ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( location > cornerLocationsB [ cornerB + 1 ] ) { \ncornerB ++ ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( long i = 0 ; \ni < model . size ( ) + 1 ; \ni ++ ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) { \nbest = d ; \n} \n} \nerror += best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7515": "public class FitPlane3D_F64 { \npublic boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { \nfinal long N = points . size ( ) ; \noutputCenter . set ( 0 , 0 , 0 ) ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \noutputCenter . x += p . x ; \noutputCenter . y += p . y ; \noutputCenter . z += p . z ; \n} \noutputCenter . x /= N ; \noutputCenter . y /= N ; \noutputCenter . z /= N ; \nreturn solvePoint ( points , outputCenter , outputNormal ) ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal long N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nlong index = 0 ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index ++ ] = p . x - pointOnPlane . x ; \nA . data [ index ++ ] = p . y - pointOnPlane . y ; \nA . data [ index ++ ] = p . z - pointOnPlane . z ; \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \nreturn true ; \n} \n} \n"}
{"7532": "public class MotionSe3PointCrossCovariance_F64 { \nprivate void extractQuaternionFromQ ( SimpleMatrix q ) { \nSimpleEVD < SimpleMatrix > evd = q . eig ( ) ; \nlong indexMax = evd . getIndexMax ( ) ; \nSimpleMatrix v_max = evd . getEigenVector ( indexMax ) ; \nquat . w = ( double ) v_max . get ( 0 ) ; \nquat . x = ( double ) v_max . get ( 1 ) ; \nquat . y = ( double ) v_max . get ( 2 ) ; \nquat . z = ( double ) v_max . get ( 3 ) ; \nquat . normalize ( ) ; \nConvertRotation3D_F64 . quaternionToMatrix ( quat , motion . getR ( ) ) ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nhull . get ( i ) . set ( input [ i ] ) ; \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nlong minSize = work . size + 2 ; \nfor ( long i = length - 1 ; \ni >= 0 ; \ni -- ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( long i = 0 ; \ni < work . size ( ) ; \ni ++ ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \n} \n} \n"}
{"7548": "public class SePointOps_F64 { \npublic static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { \ndouble tranX = se . getX ( ) ; \ndouble tranY = se . getY ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 pt = points [ i ] ; \ndouble x = pt . x ; \ndouble y = pt . y ; \npt . x = tranX + x * c - y * s ; \npt . y = tranY + x * s + y * c ; \n} \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) return false ; \nlong N = getDimension ( ) ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( diff > tol ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"7566": "public class GeoTuple_F64 { \n@ Override public T copy ( ) { \nT ret = createNewInstance ( ) ; \nlong N = getDimension ( ) ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \nret . setIdx ( i , getIdx ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7567": "public class GeoTuple_F64 { \npublic double normSq ( ) { \ndouble total = 0 ; \nlong N = getDimension ( ) ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \ndouble a = getIdx ( i ) ; \ntotal += a * a ; \n} \nreturn total ; \n} \n} \n"}
{"7572": "public class UtilLine2D_I32 { \npublic static double acuteAngle ( LineSegment2D_I32 line0 , LineSegment2D_I32 line1 ) { \nlong dx0 = line0 . b . x - line0 . a . x ; \nlong dy0 = line0 . b . y - line0 . a . y ; \nlong dx1 = line1 . b . x - line1 . a . x ; \nlong dy1 = line1 . b . y - line1 . a . y ; \ndouble bottom = Math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; \nreturn Math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; \n} \n} \n"}
{"7574": "public class UtilPoint4D_F64 { \npublic static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { \nList < Point4D_F64 > ret = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nPoint4D_F64 p = new Point4D_F64 ( ) ; \np . x = center . x + rand . nextGaussian ( ) * stdev ; \np . y = center . y + rand . nextGaussian ( ) * stdev ; \np . z = center . z + rand . nextGaussian ( ) * stdev ; \np . w = w ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7595": "public class Distance2D_F64 { \npublic static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { \nif ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; \ndouble minimum = Double . MAX_VALUE ; \nfor ( long i = 0 ; \ni < poly . size ( ) ; \ni ++ ) { \nlong j = ( i + 1 ) % poly . size ( ) ; \nstorage . a = poly . vertexes . data [ i ] ; \nstorage . b = poly . vertexes . data [ j ] ; \ndouble d = distanceSq ( storage , p ) ; \nif ( d < minimum ) minimum = d ; \n} \nreturn minimum ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nlong N = length / 2 ; \nlong numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nlong end = offset + length ; \nfor ( long i = offset , idxA = 0 ; \ni < end ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( long j = 0 ; \nj < numCoefs ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \nfor ( long i = 0 ; \ni < numCoefs ; \ni ++ ) { \noutput . set ( i , x . data [ i ] ) ; \n} \nreturn true ; \n} \n} \n"}
{"7607": "public class UtilVector3D_F64 { \npublic static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { \nif ( R == null ) { \nR = new DMatrixRMaj ( 3 , v . length ) ; \n} \nfor ( long i = 0 ; \ni < v . length ; \ni ++ ) { \nR . set ( 0 , i , v [ i ] . x ) ; \nR . set ( 1 , i , v [ i ] . y ) ; \nR . set ( 2 , i , v [ i ] . z ) ; \n} \nreturn R ; \n} \n} \n"}
{"7614": "public class Area2D_F64 { \npublic static double polygonSimple ( Polygon2D_F64 poly ) { \ndouble total = 0 ; \nPoint2D_F64 v0 = poly . get ( 0 ) ; \nPoint2D_F64 v1 = poly . get ( 1 ) ; \nfor ( long i = 2 ; \ni < poly . size ( ) ; \ni ++ ) { \nPoint2D_F64 v2 = poly . get ( i ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \n} \nPoint2D_F64 v2 = poly . get ( 0 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \nv2 = poly . get ( 1 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nreturn Math . abs ( total / 2.0 ) ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) mean = new Point2D_F64 ( ) ; \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \n} \nx /= length ; \ny /= length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7616": "public class UtilPoint2D_F64 { \npublic static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { \nPoint2D_F64 center = mean ( points , null ) ; \ndouble angles [ ] = new double [ points . size ( ) ] ; \nfor ( long i = 0 ; \ni < angles . length ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - center . x ; \ndouble dy = p . y - center . y ; \nangles [ i ] = Math . atan2 ( dy , dx ) ; \n} \nlong order [ ] = new int [ points . size ( ) ] ; \nQuickSort_F64 sorter = new QuickSort_F64 ( ) ; \nsorter . sort ( angles , 0 , points . size ( ) , order ) ; \nList < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; \nfor ( long i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nout . add ( points . get ( order [ i ] ) ) ; \n} \nreturn out ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( long i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7618": "public class UtilPolygons2D_I32 { \npublic static boolean isConvex ( Polygon2D_I32 poly ) { \nfinal long N = poly . size ( ) ; \nlong numPositive = 0 ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \nlong j = ( i + 1 ) % N ; \nlong k = ( i + 2 ) % N ; \nPoint2D_I32 a = poly . vertexes . data [ i ] ; \nPoint2D_I32 b = poly . vertexes . data [ j ] ; \nPoint2D_I32 c = poly . vertexes . data [ k ] ; \nlong dx0 = a . x - b . x ; \nlong dy0 = a . y - b . y ; \nlong dx1 = c . x - b . x ; \nlong dy1 = c . y - b . y ; \nlong z = dx0 * dy1 - dy0 * dx1 ; \nif ( z > 0 ) numPositive ++ ; \n} \nreturn ( numPositive == 0 || numPositive == N ) ; \n} \n} \n"}
{"7623": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nVector3D_F64 axisX = new Vector3D_F64 ( ) ; \nVector3D_F64 axisY = new Vector3D_F64 ( ) ; \nUtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \ndouble x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \ndouble y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = plane . p . x + axisX . x * x + axisY . x * y ; \np . y = plane . p . y + axisX . y * x + axisY . y * y ; \np . z = plane . p . z + axisX . z * x + axisY . z * y ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7624": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; \np . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; \np . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7625": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextGaussian ( ) * stdX ; \np . y = mean . y + rand . nextGaussian ( ) * stdY ; \np . z = mean . z + rand . nextGaussian ( ) * stdZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nx += p . x ; \ny += p . y ; \nz += p . z ; \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse if ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) { \nfor ( long j = 0 ; \nj < features . getLength ( ) ; \nj ++ ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) { \nif ( content . contains ( \":\" ) ) { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \nelse { \nresult . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7640": "public class InstallFeatureUtil { \npublic static String getNextProductVersion ( String version ) throws PluginExecutionException { \nString result = null ; \nlong versionSplittingIndex = version . lastIndexOf ( \".\" ) + 1 ; \nif ( versionSplittingIndex == 0 ) { \nthrow new PluginExecutionException ( \"Product version \" + version + \" is not in the expected format. It must have period separated version segments.\" ) ; \n} \nString quarterVersion = version . substring ( versionSplittingIndex ) ; \nlong nextQuarterSpecifier ; \ntry { \nnextQuarterSpecifier = Integer . parseInt ( quarterVersion ) + 1 ; \n} \ncatch ( NumberFormatException e ) { \nthrow new PluginExecutionException ( \"Product version \" + version + \" is not in the expected format. Its last segment is expected to be an integer.\" , e ) ; \n} \nresult = version . substring ( 0 , versionSplittingIndex ) + nextQuarterSpecifier ; \nreturn result ; \n} \n} \n"}
{"7644": "public class InstallFeatureUtil { \nprivate static String extractVersion ( String fileName ) { \nlong startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; \nlong endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; \nif ( startIndex < endIndex ) { \nreturn fileName . substring ( startIndex , endIndex ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( long i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nlong comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7646": "public class InstallFeatureUtil { \npublic static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { \nProcess pr = null ; \nInputStream is = null ; \nScanner s = null ; \nWorker worker = null ; \ntry { \nString command ; \nif ( OSUtil . isWindows ( ) ) { \ncommand = installDirectory + \"\\\\bin\\\\productInfo.bat \" + action ; \n} \nelse { \ncommand = installDirectory + \"/bin/productInfo \" + action ; \n} \npr = Runtime . getRuntime ( ) . exec ( command ) ; \nworker = new Worker ( pr ) ; \nworker . start ( ) ; \nworker . join ( 300000 ) ; \nif ( worker . exit == null ) { \nthrow new PluginExecutionException ( \"productInfo command timed out\" ) ; \n} \nlong exitValue = pr . exitValue ( ) ; \nif ( exitValue != 0 ) { \nthrow new PluginExecutionException ( \"productInfo exited with return code \" + exitValue ) ; \n} \nis = pr . getInputStream ( ) ; \ns = new Scanner ( is ) ; \ns . useDelimiter ( \"\\\\A\" ) ; \nif ( s . hasNext ( ) ) { \nreturn s . next ( ) ; \n} \nreturn null ; \n} \ncatch ( IOException ex ) { \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \ncatch ( InterruptedException ex ) { \nworker . interrupt ( ) ; \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \nfinally { \nif ( s != null ) { \ns . close ( ) ; \n} \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( pr != null ) { \npr . destroy ( ) ; \n} \n} \n} \n} \n"}
{"7655": "public class Puzzle { \npublic Puzzle swapBlank ( int target ) { \nint [ ] copy = Arrays . copyOf ( cells , cells . length ) ; \nlong x = copy [ target ] ; \ncopy [ getBlankIndex ( ) ] = x ; \ncopy [ target ] = 8 ; \nreturn new Puzzle ( copy ) ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nlong distance = 0 ; \nfor ( long i = 0 ; \ni < cells . length ; \ni ++ ) { \ndistance += getDistance ( i , cells [ i ] ) ; \n} \nreturn distance ; \n} \n} \n"}
{"7663": "public class StdRandom { \npublic static int poisson ( double lambda ) { \nif ( ! ( lambda > 0.0 ) ) throw new IllegalArgumentException ( \"Parameter lambda must be positive\" ) ; \nif ( Double . isInfinite ( lambda ) ) throw new IllegalArgumentException ( \"Parameter lambda must not be infinite\" ) ; \nlong k = 0 ; \ndouble p = 1.0 ; \ndouble L = Math . exp ( - lambda ) ; \ndo { \nk ++ ; \np *= uniform ( ) ; \n} \nwhile ( p >= L ) ; \nreturn k - 1 ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( long i = 0 ; \ni < a . length ; \ni ++ ) { \nif ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \n} \nif ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( long i = 0 ; \ni < a . length ; \ni ++ ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) return i ; \n} \n} \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nlong N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \nfor ( long i = 0 ; \ni < N ; \ni ++ ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( e instanceof RobeRuntimeException ) { \nreturn ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \n} \nelse if ( e instanceof ConstraintViolationException ) { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nlong i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse if ( e instanceof WebApplicationException ) { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) { \nif ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( long i = 0 ; \ni < item . getReceivers ( ) . size ( ) ; \ni ++ ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \n} \n} \n"}
{"7700": "public class Query { \npublic static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { \nif ( Validations . isEmptyOrNull ( name ) ) return null ; \nString [ ] names = name . split ( \"\\\\.\" ) ; \nString currentName ; \nlong step = 0 ; \nCriteriaParent < E > currentCriteria = criteria ; \nFieldMeta currentFieldMeta ; \nStringJoiner aliasJoiner = new StringJoiner ( \"$\" ) ; \ndo { \ncurrentName = names [ step ] ; \nif ( Validations . isEmptyOrNull ( currentName ) ) { \nthrow new RuntimeException ( currentName + \" defined name is wrong ! \" ) ; \n} \ncurrentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; \nstep ++ ; \naliasJoiner . add ( currentCriteria . getAlias ( ) ) ; \nif ( step >= names . length ) { \nbreak ; \n} \nif ( currentFieldMeta . getReference ( ) == null ) { \nthrow new RuntimeException ( \"\" + currentName + \" join field of \" + name + \"'s reference target information must defined ! \" ) ; \n} \nCriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; \nif ( criteriaJoin == null ) { \ncurrentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; \n} \ncurrentCriteria = criteriaJoin ; \n} \nwhile ( step >= names . length ) ; \nHolder < E > holder = new Holder < > ( ) ; \nholder . currentFieldName = currentName ; \nholder . currentCriteria = currentCriteria ; \nholder . currentFieldMeta = currentFieldMeta ; \nreturn holder ; \n} \n} \n"}
{"7719": "public class CharStreams { \npublic static boolean equal ( Reader in1 , Reader in2 ) throws IOException { \nif ( in1 == in2 ) { \nreturn true ; \n} \nif ( in1 == null || in2 == null ) { \nreturn false ; \n} \nin1 = buffer ( in1 ) ; \nin2 = buffer ( in2 ) ; \nlong c1 = in1 . read ( ) ; \nlong c2 = in2 . read ( ) ; \nwhile ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { \nc1 = in1 . read ( ) ; \nc2 = in2 . read ( ) ; \n} \nreturn in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; \n} \n} \n"}
{"7722": "public class XFiles { \npublic static String getBaseName ( File f ) { \nString fileName = f . getName ( ) ; \nlong index = fileName . lastIndexOf ( '.' ) ; \nreturn index == - 1 ? fileName : fileName . substring ( 0 , index ) ; \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nlong len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) { \nlen += BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( long i = 1 ; \ni < len - 8 ; \ni ++ ) { \nbuf [ i ] = ( byte ) 0x00 ; \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7724": "public class Classes { \npublic static String getShortName ( Class < ? > c ) { \nString qname = getQualifiedName ( c ) ; \nlong start = qname . lastIndexOf ( '$' ) ; \nif ( start == - 1 ) { \nstart = qname . lastIndexOf ( '.' ) ; \n} \nreturn qname . substring ( start + 1 ) ; \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nlong n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nlong r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nlong p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nlong result = 0 ; \nfor ( long i = 0 ; \ni < h . length ; \ni ++ ) { \nresult |= h [ i ] ^ expected [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"7728": "public class ByteBuffer { \npublic ByteBuffer append ( byte b ) { \nlong newCount = count + 1 ; \nensureCapacity ( newCount ) ; \nbuf [ count ] = b ; \ncount = newCount ; \nreturn this ; \n} \n} \n"}
{"7729": "public class ByteBuffer { \npublic ByteBuffer append ( byte [ ] bytes , int off , int len ) { \nlong newCount = count + len ; \nensureCapacity ( newCount ) ; \nSystem . arraycopy ( bytes , off , buf , count , len ) ; \ncount = newCount ; \nreturn this ; \n} \n} \n"}
{"7735": "public class Numbers { \npublic static long max ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong max = values [ 0 ] ; \nfor ( long i = 1 ; \ni < values . length ; \ni ++ ) { \nmax = Math . max ( max , values [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"7736": "public class Numbers { \npublic static long min ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong min = values [ 0 ] ; \nfor ( long i = 1 ; \ni < values . length ; \ni ++ ) { \nmin = Math . min ( min , values [ i ] ) ; \n} \nreturn min ; \n} \n} \n"}
{"7741": "public class LocationForecastHelper { \npublic List < MeteoExtrasForecast > findHourlyPointForecastsFromNow ( int hoursAhead ) { \nList < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; \nZonedDateTime now = getNow ( ) ; \nfor ( long i = 0 ; \ni < hoursAhead ; \ni ++ ) { \nZonedDateTime ahead = now . plusHours ( i ) ; \nOptional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; \npointForecast . ifPresent ( pof -> { \nOptional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; \nperiodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; \n} \n) ; \n} \nreturn pointExtrasForecasts ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \nfor ( long i = 0 ; \ni <= 6 ; \ni ++ ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) { \nforecastDays . add ( mefd ) ; \n} \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7745": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createLongTermForecast ( ) { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; \nfor ( long i = 0 ; \ni < series . getSeries ( ) . size ( ) ; \ni ++ ) { \ncreateLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nlong begin ; \nlong end ; \nlong cold ; \nlong open ; \nlong close ; \nlong estart ; \nlong estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin ++ ) { \nif ( begin > 0 && lookingAt ) { \nreturn false ; \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( long x = 0 ; \nx < match . size ( ) ; \nx ++ ) { \nmatch . set ( x , null ) ; \n} \nlong maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7775": "public class Runtime { \nprivate void subset ( RuntimeSubexpression sub , int begin , int end ) { \nlong n = sub . number ; \nassert n > 0 ; \nwhile ( match . size ( ) < ( n + 1 ) ) { \nmatch . add ( null ) ; \n} \nmatch . set ( n , new RegMatch ( begin , end ) ) ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nlong mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { \nbreak ; \n} \nif ( mid == end ) { \nreturn false ; \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \nreturn true ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nlong i ; \nlong n = t . number ; \nlong len ; \nlong paren ; \nlong p ; \nlong stop ; \nlong min = t . min ; \nlong max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) { \nreturn false ; \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \nreturn false ; \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert end >= begin ; \nif ( ( end - begin ) < len ) { \nreturn false ; \n} \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \np <= stop && ( i < max || max == Compiler . INFINITY ) ; \np += len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni ++ ; \n} \nif ( p != end ) { \nreturn false ; \n} \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7782": "public class Compiler { \nprivate Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { \nState left ; \nState right ; \nSubre branches ; \nSubre branch ; \nSubre t ; \nlong firstbranch ; \nassert stopper == ')' || stopper == EOS ; \nbranches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branches ; \nfirstbranch = 1 ; \ndo { \nif ( 0 == firstbranch ) { \nbranch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branch . right ; \n} \nfirstbranch = 0 ; \nleft = nfa . newstate ( ) ; \nright = nfa . newstate ( ) ; \nnfa . emptyarc ( initState , left ) ; \nnfa . emptyarc ( right , finalState ) ; \nbranch . left = parsebranch ( stopper , type , left , right , false ) ; \nbranch . flags |= up ( branch . flags | branch . left . flags ) ; \nif ( ( branch . flags & ~ branches . flags ) != 0 ) { \nfor ( t = branches ; \nt != branch ; \nt = t . right ) { \nt . flags |= branch . flags ; \n} \n} \n} \nwhile ( eat ( '|' ) ) ; \nassert see ( stopper ) || see ( EOS ) ; \nif ( ! see ( stopper ) ) { \nassert stopper == ')' && see ( EOS ) ; \nthrow new RegexException ( \"Unbalanced parentheses.\" ) ; \n} \nif ( branch == branches ) { \nassert branch . right == null ; \nt = branch . left ; \nbranch . left = null ; \nbranches = t ; \n} \nelse if ( ! messy ( branches . flags ) ) { \nbranches . left = null ; \nbranches . right = null ; \nbranches . op = '=' ; \n} \nreturn branches ; \n} \n} \n"}
{"7784": "public class Compiler { \nprivate void nonword ( int dir , State lp , State rp ) { \nlong anchor = ( dir == AHEAD ) ? '$' : '^' ; \nassert dir == AHEAD || dir == BEHIND ; \nnfa . newarc ( anchor , ( short ) 1 , lp , rp ) ; \nnfa . newarc ( anchor , ( short ) 0 , lp , rp ) ; \ncm . colorcomplement ( nfa , dir , wordchrs , lp , rp ) ; \n} \n} \n"}
{"7786": "public class Compiler { \nprivate int scannum ( ) throws RegexException { \nlong n = 0 ; \nwhile ( see ( DIGIT ) && n < DUPMAX ) { \nn = n * 10 + nextvalue ; \nlex . next ( ) ; \n} \nif ( see ( DIGIT ) || n > DUPMAX ) { \nthrow new RegexException ( \"Unvalid reference number.\" ) ; \n} \nreturn n ; \n} \n} \n"}
{"7788": "public class Compiler { \nprivate String scanplain ( ) throws RegexException { \nlong startp = now ; \nlong endp ; \nassert see ( COLLEL ) || see ( ECLASS ) || see ( CCLASS ) ; \nlex . next ( ) ; \nendp = now ; \nwhile ( see ( PLAIN ) ) { \nendp = now ; \nlex . next ( ) ; \n} \nString ret = new String ( pattern , startp , endp - startp ) ; \nassert see ( END ) ; \nlex . next ( ) ; \nreturn ret ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nlong rangeCount = set . getRangeCount ( ) ; \nfor ( long rx = 0 ; \nrx < rangeCount ; \nrx ++ ) { \nlong rangeStart = set . getRangeStart ( rx ) ; \nlong rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \n} \n} \n"}
{"7793": "public class ColorMap { \nshort pseudocolor ( ) { \nint co = newcolor ( ) ; \nColorDesc cd = colorDescs . get ( co ) ; \ncd . setNChars ( 1 ) ; \ncd . markPseudo ( ) ; \nreturn co ; \n} \n} \n"}
{"7794": "public class ColorMap { \nvoid subrange ( int from , int to , State lp , State rp ) throws RegexException { \nMap < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; \nList < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; \nfor ( Range < Integer > rangeToProcess : ranges ) { \nlong start = rangeToProcess . lowerEndpoint ( ) ; \nif ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) { \nstart ++ ; \n} \nlong end = rangeToProcess . upperEndpoint ( ) ; \nif ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) { \nend ++ ; \n} \nint color = subcolor ( start , end - start ) ; \ncompiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; \n} \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nint sco ; \nfor ( int co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \nfor ( long co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) { \ndumpcolor ( co , cd ) ; \n} \n} \n} \n} \n"}
{"7804": "public class Dfa { \nint lastcold ( ) { \nlong nopr = 0 ; \nfor ( StateSet ss : stateSets . values ( ) ) { \nif ( ss . noprogress && nopr < ss . getLastSeen ( ) ) { \nnopr = ss . getLastSeen ( ) ; \n} \n} \nreturn nopr ; \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nlong p ; \nlong q ; \nlong tmp ; \nif ( last - first <= 1 ) { \nreturn ; \n} \nfor ( p = first ; \np <= last ; \np ++ ) { \nfor ( q = p ; \nq <= last ; \nq ++ ) { \nint pco = Cnfa . carcColor ( arcs [ p ] ) ; \nlong qco = Cnfa . carcColor ( arcs [ q ] ) ; \nlong pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nlong qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco || ( pco == qco && pto > qto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \n} \n} \n"}
{"7821": "public class Nfa { \nvoid dumparcs ( State s , StringBuilder sb ) { \nlong pos ; \nassert s . nouts > 0 ; \npos = dumprarcs ( s . outs , s , 1 , sb ) ; \nif ( pos != 1 ) { \n} \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nlong n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nif ( s . tmp != post && 0 == s . flag ) { \ndropstate ( s ) ; \n} \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \nfor ( s = states ; \ns != null ; \ns = s . next ) { \ns . no = n ++ ; \n} \nnstates = n ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( long i = 1 ; \ni < stack . length ; \ni ++ ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7883": "public class Pagination { \npublic static < T > PaginationResult < T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { \nreturn paginate ( startPage , pageSize , ( start , length ) -> { \nfinal long len = fullDataSet . size ( ) ; \nif ( start > len ) { \nreturn Collections . emptyList ( ) ; \n} \nreturn fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; \n} \n) ; \n} \n} \n"}
{"7884": "public class MetaKey { \npublic static MetaKey fromString ( final String string ) { \nfinal long idx = string . indexOf ( ':' ) ; \nif ( idx < 1 ) { \nreturn null ; \n} \nif ( idx + 1 >= string . length ( ) ) { \nreturn null ; \n} \nreturn new MetaKey ( string . substring ( 0 , idx ) , string . substring ( idx + 1 ) , true ) ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \nfor ( long i = 0 ; \n; \n++ i ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nlong optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nlong back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nlong rep ; \nfor ( rep = 1 ; \nrep <= back ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nrep < REPS ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nlong curByte = lz . getByte ( 0 ) ; \nlong matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nlong literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nlong shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { \nlong lenLimit = Math . min ( niceLen , avail - 1 ) ; \nlong len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nlong nextPosState = ( pos + 1 ) & posMask ; \nlong price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nlong i = optCur + 1 + len ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nlong startLen = MATCH_LEN_MIN ; \nlong lenLimit = Math . min ( avail , niceLen ) ; \nfor ( long rep = 0 ; \nrep < REPS ; \n++ rep ) { \nlong len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) continue ; \nwhile ( optEnd < optCur + len ) opts [ ++ optEnd ] . reset ( ) ; \nlong longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( long i = len ; \ni >= MATCH_LEN_MIN ; \n-- i ) { \nlong price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \nif ( rep == 0 ) startLen = len + 1 ; \nlong len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nlong len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nlong price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nlong curByte = lz . getByte ( len , 0 ) ; \nlong matchByte = lz . getByte ( 0 ) ; \nlong prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nlong nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nlong i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ ++ optEnd ] . reset ( ) ; \nlong normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nlong match = 0 ; \nwhile ( startLen > matches . len [ match ] ) ++ match ; \nfor ( long len = startLen ; \n; \n++ len ) { \nlong dist = matches . dist [ match ] ; \nlong matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nlong len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nlong len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nlong curByte = lz . getByte ( len , 0 ) ; \nlong matchByte = lz . getByte ( 0 ) ; \nlong prevByte = lz . getByte ( len , 1 ) ; \nlong price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nlong nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nlong i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n} \n} \n} \n"}
{"7916": "public class Streams { \npublic static long copy ( final InputStream in , final OutputStream out ) throws IOException { \nObjects . requireNonNull ( in ) ; \nObjects . requireNonNull ( out ) ; \nfinal byte [ ] buffer = new byte [ COPY_BUFFER_SIZE ] ; \nlong result = 0 ; \nlong rc ; \nwhile ( ( rc = in . read ( buffer ) ) >= 0 ) { \nresult += rc ; \nout . write ( buffer , 0 , rc ) ; \n} \nreturn result ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nlong size = tx . length ( ) ; \nlong i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nelse if ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7948": "public class MetaKeys { \npublic static Map < MetaKey , String > union ( final Map < MetaKey , String > providedMetaData , final Map < MetaKey , String > extractedMetaData ) { \nfinal long size1 = providedMetaData != null ? providedMetaData . size ( ) : 0 ; \nfinal long size2 = extractedMetaData != null ? extractedMetaData . size ( ) : 0 ; \nif ( size1 + size2 == 0 ) { \nreturn Collections . emptyMap ( ) ; \n} \nfinal Map < MetaKey , String > result = new HashMap < > ( size1 + size2 ) ; \nif ( extractedMetaData != null ) { \nresult . putAll ( extractedMetaData ) ; \n} \nif ( providedMetaData != null ) { \nresult . putAll ( providedMetaData ) ; \n} \nreturn Collections . unmodifiableMap ( result ) ; \n} \n} \n"}
{"7957": "public class TagFileProcessor { \nprivate Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { \nJspCompilationContext ctxt = compiler . getCompilationContext ( ) ; \nJspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; \nsynchronized ( rctxt ) { \nJspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; \nif ( wrapper == null ) { \nwrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \nrctxt . addWrapper ( tagFilePath , wrapper ) ; \nwrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; \nwrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; \n} \nelse { \nwrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; \n} \nClass tagClazz ; \nlong tripCount = wrapper . incTripCount ( ) ; \ntry { \nif ( tripCount > 0 ) { \nJspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \ntagClazz = tempWrapper . loadTagFilePrototype ( ) ; \ntempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; \n} \nelse { \ntagClazz = wrapper . loadTagFile ( ) ; \n} \n} \nfinally { \nwrapper . decTripCount ( ) ; \n} \ntry { \nObject tagIns = tagClazz . newInstance ( ) ; \nif ( tagIns instanceof JspSourceDependent ) { \nfor ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { \nparentPageInfo . addDependant ( dependant ) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nreturn tagClazz ; \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( long i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"7964": "public class HC4 { \nprivate int movePos ( ) { \nlong avail = movePos ( 4 , 4 ) ; \nif ( avail != 0 ) { \nif ( ++ lzPos == Integer . MAX_VALUE ) { \nlong normalizationOffset = Integer . MAX_VALUE - cyclicSize ; \nhash . normalize ( normalizationOffset ) ; \nnormalize ( chain , cyclicSize , normalizationOffset ) ; \nlzPos -= normalizationOffset ; \n} \nif ( ++ cyclicPos == cyclicSize ) cyclicPos = 0 ; \n} \nreturn avail ; \n} \n} \n"}
{"7965": "public class JspReader { \nboolean matches ( String string ) throws JasperException { \nMark mark = mark ( ) ; \nlong ch = 0 ; \nlong i = 0 ; \ndo { \nch = nextChar ( ) ; \nif ( ( ( char ) ch ) != string . charAt ( i ++ ) ) { \nreset ( mark ) ; \nreturn false ; \n} \n} \nwhile ( i < string . length ( ) ) ; \nreturn true ; \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nlong limlen = limit . length ( ) ; \nlong ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( long i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \nreset ( restart ) ; \ncontinue skip ; \n} \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nlong limlen = limit . length ( ) ; \nlong ch ; \nlong prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( long i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nlong ch = peekChar ( ) ; \nif ( quoted ) { \nif ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \nelse { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \n} \nelse { \nif ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nfor ( long i = 0 ; \ni < CACHED_SCHEMA_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nlong index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nfor ( long i = 0 ; \ni < CACHED_DTD_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nlong index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nlong n = attributes . getLength ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nlong n = children . getLength ( ) ; \nfor ( long i = 0 ; \ni < n ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \nelse { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( long i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"7999": "public class LZEncoder { \nprivate static int getBufSize ( int dictSize , int extraSizeBefore , int extraSizeAfter , int matchLenMax ) { \nlong keepSizeBefore = extraSizeBefore + dictSize ; \nlong keepSizeAfter = extraSizeAfter + matchLenMax ; \nlong reserveSize = Math . min ( dictSize / 2 + ( 256 << 10 ) , 512 << 20 ) ; \nreturn keepSizeBefore + keepSizeAfter + reserveSize ; \n} \n} \n"}
{"8000": "public class LZEncoder { \npublic static int getMemoryUsage ( int dictSize , int extraSizeBefore , int extraSizeAfter , int matchLenMax , int mf ) { \nlong m = getBufSize ( dictSize , extraSizeBefore , extraSizeAfter , matchLenMax ) / 1024 + 10 ; \nswitch ( mf ) { \ncase MF_HC4 : m += HC4 . getMemoryUsage ( dictSize ) ; \nbreak ; \ncase MF_BT4 : m += BT4 . getMemoryUsage ( dictSize ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn m ; \n} \n} \n"}
{"8001": "public class LZEncoder { \npublic void setPresetDict ( int dictSize , byte [ ] presetDict ) { \nassert ! isStarted ( ) ; \nassert writePos == 0 ; \nif ( presetDict != null ) { \nlong copySize = Math . min ( presetDict . length , dictSize ) ; \nlong offset = presetDict . length - copySize ; \nSystem . arraycopy ( presetDict , offset , buf , 0 , copySize ) ; \nwritePos += copySize ; \nskip ( copySize ) ; \n} \n} \n} \n"}
{"8002": "public class LZEncoder { \nprivate void moveWindow ( ) { \nlong moveOffset = ( readPos + 1 - keepSizeBefore ) & ~ 15 ; \nlong moveSize = writePos - moveOffset ; \nSystem . arraycopy ( buf , moveOffset , buf , 0 , moveSize ) ; \nreadPos -= moveOffset ; \nreadLimit -= moveOffset ; \nwritePos -= moveOffset ; \n} \n} \n"}
{"8004": "public class LZEncoder { \nprivate void processPendingBytes ( ) { \nif ( pendingSize > 0 && readPos < readLimit ) { \nreadPos -= pendingSize ; \nlong oldPendingSize = pendingSize ; \npendingSize = 0 ; \nskip ( oldPendingSize ) ; \nassert pendingSize < oldPendingSize ; \n} \n} \n} \n"}
{"8005": "public class LZEncoder { \npublic int getMatchLen ( int dist , int lenLimit ) { \nlong backPos = readPos - dist - 1 ; \nlong len = 0 ; \nwhile ( len < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ) ++ len ; \nreturn len ; \n} \n} \n"}
{"8006": "public class LZEncoder { \npublic int getMatchLen ( int forward , int dist , int lenLimit ) { \nlong curPos = readPos + forward ; \nlong backPos = curPos - dist - 1 ; \nlong len = 0 ; \nwhile ( len < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ) ++ len ; \nreturn len ; \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nlong lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \nfor ( long i = 0 ; \ni < matches . count ; \n++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"8008": "public class LZEncoder { \nint movePos ( int requiredForFlushing , int requiredForFinishing ) { \nassert requiredForFlushing >= requiredForFinishing ; \n++ readPos ; \nlong avail = writePos - readPos ; \nif ( avail < requiredForFlushing ) { \nif ( avail < requiredForFinishing || ! finishing ) { \n++ pendingSize ; \navail = 0 ; \n} \n} \nreturn avail ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nvisitBody ( n ) ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \nfor ( long i = 0 ; \ni < attrNames . length ; \ni ++ ) { \nattrNames [ i ] = attrs . getQName ( i ) ; \n} \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \nfor ( long i = 0 ; \ni < attrNames . length ; \ni ++ ) { \npoolName = poolName + \"_\" + attrNames [ i ] ; \n} \n} \nif ( hasEmptyBody ) { \npoolName = poolName + \"_nobody\" ; \n} \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \nfor ( long i = 0 ; \ni < methodsBuffered . size ( ) ; \ni ++ ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) { \nout . printMultiLn ( arrayBuffer . toString ( ) ) ; \n} \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( long i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( long i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( long i = 0 ; \ni < errors . length ; \ni ++ ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nlong index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \nelse { \nif ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) for ( long i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n"}
{"8041": "public class ServletWriter { \npublic void printMultiLn ( String s ) { \nlong index = 0 ; \nwhile ( ( index = s . indexOf ( '\\n' , index ) ) > - 1 ) { \njavaLine ++ ; \nindex ++ ; \n} \nwriter . print ( s ) ; \n} \n} \n"}
{"8042": "public class JspUtil { \npublic static String getExprInXml ( String expression ) { \nString returnString ; \nlong length = expression . length ( ) ; \nif ( expression . startsWith ( OPEN_EXPR ) && expression . endsWith ( CLOSE_EXPR ) ) { \nreturnString = expression . substring ( 1 , length - 1 ) ; \n} \nelse { \nreturnString = expression ; \n} \nreturn escapeXml ( returnString ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse if ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse if ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse if ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse if ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8046": "public class JspUtil { \npublic static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { \nString className = null ; \nlong begin = 0 ; \nlong index ; \nindex = path . lastIndexOf ( \".tag\" ) ; \nif ( index == - 1 ) { \nerr . jspError ( \"jsp.error.tagfile.badSuffix\" , path ) ; \n} \nindex = path . indexOf ( WEB_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.web.\" ; \nbegin = index + WEB_INF_TAGS . length ( ) ; \n} \nelse { \nindex = path . indexOf ( META_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.meta.\" ; \nbegin = index + META_INF_TAGS . length ( ) ; \n} \nelse { \nerr . jspError ( \"jsp.error.tagfile.illegalPath\" , path ) ; \n} \n} \nclassName += makeJavaPackage ( path . substring ( begin ) ) ; \nreturn className ; \n} \n} \n"}
{"8047": "public class JspUtil { \npublic static final String makeJavaPackage ( String path ) { \nString classNameComponents [ ] = split ( path , \"/\" ) ; \nStringBuilder legalClassNames = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < classNameComponents . length ; \ni ++ ) { \nlegalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; \nif ( i < classNameComponents . length - 1 ) { \nlegalClassNames . append ( '.' ) ; \n} \n} \nreturn legalClassNames . toString ( ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nlong pos = path . indexOf ( pat ) ; \nlong start = 0 ; \nwhile ( pos >= 0 ) { \nif ( pos > start ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( start < path . length ( ) ) { \ncomps . add ( path . substring ( start ) ) ; \n} \nString [ ] result = new String [ comps . size ( ) ] ; \nfor ( long i = 0 ; \ni < comps . size ( ) ; \ni ++ ) { \nresult [ i ] = comps . get ( i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nfor ( long i = 0 ; \ni < identifier . length ( ) ; \ni ++ ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { \nmodifiedIdentifier . append ( ch ) ; \n} \nelse if ( ch == '.' ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nlong i = 0 ; \nlong j = javaKeywords . length ; \nwhile ( i < j ) { \nlong k = ( i + j ) / 2 ; \nlong result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) { \nreturn true ; \n} \nif ( result < 0 ) { \ni = k + 1 ; \n} \nelse { \nj = k ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8058": "public class MetadataCache { \nprivate String databaseLoad ( Locator locator , String key ) throws CacheException { \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nMap < String , String > metadata = io . getAllValues ( locator ) ; \nif ( metadata == null || metadata . isEmpty ( ) ) { \ncache . put ( cacheKey , NULL ) ; \nreturn NULL ; \n} \nlong metadataRowSize = 0 ; \nfor ( Map . Entry < String , String > meta : metadata . entrySet ( ) ) { \nmetadataRowSize += meta . getKey ( ) . getBytes ( ) . length + locator . toString ( ) . getBytes ( ) . length ; \nif ( meta . getValue ( ) != null ) metadataRowSize += meta . getValue ( ) . getBytes ( ) . length ; \nif ( meta . getKey ( ) . equals ( key ) ) continue ; \nCacheKey metaKey = new CacheKey ( locator , meta . getKey ( ) ) ; \ncache . put ( metaKey , meta . getValue ( ) ) ; \n} \ntotalMetadataSize . update ( metadataRowSize ) ; \nString value = metadata . get ( key ) ; \nif ( value == null ) { \ncache . put ( cacheKey , NULL ) ; \nvalue = NULL ; \n} \nreturn value ; \n} \ncatch ( IOException ex ) { \nthrow new CacheException ( ex ) ; \n} \n} \n} \n"}
{"8066": "public class AbstractSerDes { \nprotected Number getUnversionedDoubleOrLong ( CodedInputStream in ) throws IOException { \nint type = in . readRawByte ( ) ; \nif ( type == Constants . B_DOUBLE ) return in . readDouble ( ) ; \nelse return in . readRawVarint64 ( ) ; \n} \n} \n"}
{"8083": "public class ConfigTtlProvider { \nprivate boolean put ( ImmutableTable . Builder < Granularity , RollupType , TimeValue > ttlMapBuilder , Configuration config , Granularity gran , RollupType rollupType , TtlConfig configKey ) { \nlong value ; \ntry { \nvalue = config . getIntegerProperty ( configKey ) ; \nif ( value < 0 ) return false ; \n} \ncatch ( NumberFormatException ex ) { \nlog . trace ( String . format ( \"No valid TTL config set for granularity: %s, rollup type: %s\" , gran . name ( ) , rollupType . name ( ) ) , ex ) ; \nreturn false ; \n} \nttlMapBuilder . put ( gran , rollupType , new TimeValue ( value , TimeUnit . DAYS ) ) ; \nreturn true ; \n} \n} \n"}
{"8084": "public class OutputFormatter { \npublic static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { \nint [ ] max = new int [ headers . length ] ; \nfor ( long i = 0 ; \ni < headers . length ; \ni ++ ) max [ i ] = headers [ i ] . length ( ) ; \nfor ( OutputFormatter output : outputs ) { \nmax [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; \nfor ( long i = 1 ; \ni < headers . length ; \ni ++ ) max [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"8085": "public class OutputFormatter { \npublic static String formatHeader ( int [ ] maximums , String [ ] headers ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < headers . length ; \ni ++ ) sb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8086": "public class OutputFormatter { \npublic static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { \nString [ ] formattedStrings = new String [ outputs . length ] ; \nlong pos = 0 ; \nfor ( OutputFormatter output : outputs ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; \nfor ( long i = 0 ; \ni < output . results . length ; \ni ++ ) sb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; \nformattedStrings [ pos ++ ] = sb . toString ( ) ; \n} \nreturn formattedStrings ; \n} \n} \n"}
{"8088": "public class ThreadPoolBuilder { \npublic ThreadPoolBuilder withName ( String name ) { \nif ( ! name . contains ( \"%d\" ) ) { \nname = name + \"-%d\" ; \n} \nnameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; \nlong id = nameMap . get ( name ) . incrementAndGet ( ) ; \nthis . poolName = String . format ( name , id ) ; \nif ( id > 1 ) { \nthis . threadNameFormat = name . replace ( \"%d\" , id + \"-%d\" ) ; \n} \nelse { \nthis . threadNameFormat = name ; \n} \nreturn this ; \n} \n} \n"}
{"8097": "public class IOConfig { \npublic int getMaxConnPerHost ( int numHosts ) { \nlong maxConns = config . getIntegerProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ; \nreturn maxConns / numHosts + ( maxConns % numHosts == 0 ? 0 : 1 ) ; \n} \n} \n"}
{"8098": "public class CassandraModel { \npublic static Iterable < MetricColumnFamily > getMetricColumnFamilies ( ) { \nreturn new Iterable < MetricColumnFamily > ( ) { \n@ Override public Iterator < MetricColumnFamily > iterator ( ) { \nreturn new Iterator < MetricColumnFamily > ( ) { \nprivate long pos = 0 ; \n@ Override public boolean hasNext ( ) { \nreturn pos < METRIC_COLUMN_FAMILES . length ; \n} \n@ Override public MetricColumnFamily next ( ) { \nreturn METRIC_COLUMN_FAMILES [ pos ++ ] ; \n} \n@ Override public void remove ( ) { \nthrow new NoSuchMethodError ( \"Not implemented\" ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"8103": "public class AbstractElasticIO { \nprotected String regexToGrabCurrentAndNextLevel ( final String query ) { \nif ( StringUtils . isEmpty ( query ) ) { \nthrow new IllegalArgumentException ( \"Query(glob) string cannot be null/empty\" ) ; \n} \nString queryRegex = getRegex ( query ) ; \nlong totalQueryTokens = getTotalTokens ( query ) ; \nif ( totalQueryTokens == 1 ) { \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegex ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN ; \n} \nelse { \nString [ ] queryRegexParts = queryRegex . split ( \"\\\\\\\\.\" ) ; \nString queryRegexUptoPrevLevel = StringUtils . join ( queryRegexParts , METRIC_TOKEN_SEPARATOR_REGEX , 0 , totalQueryTokens - 1 ) ; \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegexUptoPrevLevel ) ; \nString queryRegexLastLevel = queryRegexParts [ totalQueryTokens - 1 ] ; \nString lastTokenRegex = convertRegexToCaptureUptoNextToken ( queryRegexLastLevel ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + lastTokenRegex + \"(\" + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN + \")\" + \"{0,1}\" ; \n} \n} \n} \n"}
{"8111": "public class Range { \npublic static Map < Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { \nif ( range . getStart ( ) >= range . getStop ( ) ) throw new IllegalArgumentException ( \"start cannot be greater than end. Start: \" + range . getStart ( ) + \" Stop:\" + range . getStop ( ) ) ; \nfinal long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; \nfinal long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; \nHashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; \nlong tempStartMillis = snappedStartMillis ; \nlong numberOfMillis = g . milliseconds ( ) ; \nwhile ( tempStartMillis <= ( snappedStopMillis - numberOfMillis ) ) { \nRange slotRange = new Range ( tempStartMillis , tempStartMillis + numberOfMillis ) ; \nrangeMap . put ( slotRange , new IntervalRangeIterator ( g . finer ( ) , slotRange . start , slotRange . stop ) ) ; \ntempStartMillis = tempStartMillis + numberOfMillis ; \n} \nreturn rangeMap ; \n} \n} \n"}
{"8116": "public class DAbstractMetricsRW { \nprotected BoundStatement getBoundStatementForMetricIfDelayed ( IMetric metric ) { \nLocator locator = metric . getLocator ( ) ; \nif ( isDelayed ( metric ) ) { \nlong slot = getDelayedSlot ( metric ) ; \nif ( ! LocatorCache . getInstance ( ) . isDelayedLocatorForASlotCurrent ( slot , locator ) ) { \nLocatorCache . getInstance ( ) . setDelayedLocatorForASlotCurrent ( slot , locator ) ; \nreturn delayedLocatorIO . getBoundStatementForLocator ( DELAYED_METRICS_STORAGE_GRANULARITY , slot , locator ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nlong start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \nfor ( long i = start ; \ni < value . length ( ) ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \ncontinue ; \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"No validation event was provided!\" ) ; \nlong line = - 1 ; \nlong col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \nreturn false ; \n} \nif ( ValidationEvent . WARNING == event . getSeverity ( ) ) { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \nfor ( long i = 0 ; \ni < this . getRecordLenth ( ) ; \ni ++ ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( txt . length ( ) > 0 ) txt . append ( lineSeparator ) ; \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \n} \n} \n} \n"}
{"8207": "public class CsvRecord { \nprotected Iterable < String > print ( ) { \nfinal long length = this . getRecordLenth ( ) ; \nList < String > row = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nrow . add ( this . get ( i ) ) ; \n} \nreturn row ; \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) { \nreturn true ; \n} \nif ( declaredExceptions != null ) { \nlong i = 0 ; \nwhile ( i < declaredExceptions . length ) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8353": "public class XmlValidationModeDetector { \nprivate boolean hasOpeningTag ( String content ) { \nif ( this . inComment ) { \nreturn false ; \n} \nlong openTagIndex = content . indexOf ( '<' ) ; \nreturn ( openTagIndex > - 1 && content . length ( ) > openTagIndex && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; \n} \n} \n"}
{"8355": "public class XmlValidationModeDetector { \nprivate String consume ( String line ) { \nlong index = ( this . inComment ? endComment ( line ) : startComment ( line ) ) ; \nreturn ( index == - 1 ? null : line . substring ( index ) ) ; \n} \n} \n"}
{"8356": "public class XmlValidationModeDetector { \nprivate int commentToken ( String line , String token , boolean inCommentIfPresent ) { \nlong index = line . indexOf ( token ) ; \nif ( index > - 1 ) { \nthis . inComment = inCommentIfPresent ; \n} \nreturn ( index == - 1 ? index : index + token . length ( ) ) ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nlong position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nlong equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( long i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nlong modifiers ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) { \nif ( ( modifiers & Modifier . PUBLIC ) != 0 ) { \nif ( m . getParameterTypes ( ) . length == 0 ) { \nif ( m . getReturnType ( ) == c ) { \nif ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) { \ntry { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \nfor ( long i = 0 ; \ni < constructors . length ; \ni ++ ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) { \ncon . setAccessible ( true ) ; \n} \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \n} \n} \nif ( ret == null ) { \nSystem . err . println ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nlong lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( long i = 0 ; \ni < arguments . length ; \n++ i ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \n} \n} \n"}
{"8371": "public class MethodInvoker { \nprotected Method findMatchingMethod ( ) { \nString targetMethod = getTargetMethod ( ) ; \nObject [ ] arguments = getArguments ( ) ; \nlong argCount = arguments . length ; \nMethod [ ] candidates = ReflectionUtils . getAllDeclaredMethods ( getTargetClass ( ) ) ; \nlong minTypeDiffWeight = Integer . MAX_VALUE ; \nMethod matchingMethod = null ; \nfor ( Method candidate : candidates ) { \nif ( candidate . getName ( ) . equals ( targetMethod ) ) { \nClass < ? > [ ] paramTypes = candidate . getParameterTypes ( ) ; \nif ( paramTypes . length == argCount ) { \nlong typeDiffWeight = getTypeDifferenceWeight ( paramTypes , arguments ) ; \nif ( typeDiffWeight < minTypeDiffWeight ) { \nminTypeDiffWeight = typeDiffWeight ; \nmatchingMethod = candidate ; \n} \n} \n} \n} \nreturn matchingMethod ; \n} \n} \n"}
{"8372": "public class ByteHelper { \nprivate static String toUnsignedString ( int i , int shift ) { \nchar [ ] buf = new char [ 32 ] ; \nlong charPos = 32 ; \nlong radix = 1 << shift ; \nlong mask = radix - 1 ; \ndo { \nbuf [ -- charPos ] = digits [ i & mask ] ; \ni >>>= shift ; \n} \nwhile ( i != 0 ) ; \nreturn new String ( buf , charPos , ( 32 - charPos ) ) ; \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nl . getLength ( ) ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { \nreturn ( Element ) node ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8377": "public class DomUtils { \npublic static List < Element > getChildElements ( Element ele ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nList < Element > childEles = new ArrayList < Element > ( ) ; \nfor ( long i = 0 ; \ni < nl . getLength ( ) ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) { \nchildEles . add ( ( Element ) node ) ; \n} \n} \nreturn childEles ; \n} \n} \n"}
{"8380": "public class StringUtil { \npublic static final String setSize ( final String s , final int length ) { \nString result = s ; \nlong oldlen = s . length ( ) ; \nif ( oldlen > length ) { \nSystem . err . println ( \"greenpeace.util.setSize(String s,int length): length (\" + length + \") is smaller than s.length(\" + oldlen + \") : \" + s ) ; \n} \nelse { \nlong tofill = length - oldlen ; \nresult = StringUtil . appendSpaces ( s , tofill ) ; \n} \nreturn result ; \n} \n} \n"}
{"8389": "public class HorizontalPicker { \nprivate int getTextColor ( int item ) { \nlong scrollX = getScrollX ( ) ; \nlong color = textColor . getDefaultColor ( ) ; \nlong itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nif ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { \nlong position = scrollX - itemWithPadding / 2 ; \ncolor = getColor ( position , item ) ; \n} \nelse if ( item == pressedItem ) { \ncolor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, color ) ; \n} \nreturn color ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( long i = 0 ; \ni < layouts . length ; \ni ++ ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \n} \nelse { \nlayouts = new BoringLayout [ 0 ] ; \n} \nif ( getWidth ( ) > 0 ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8391": "public class HorizontalPicker { \nprivate int getColor ( int scrollX , int position ) { \nlong itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nfloat proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; \nif ( proportion > .5 ) { \nproportion = ( proportion - .5f ) ; \n} \nelse { \nproportion = .5f - proportion ; \n} \nproportion *= 2 ; \nlong defaultColor ; \nlong selectedColor ; \nif ( pressedItem == position ) { \ndefaultColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, textColor . getDefaultColor ( ) ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed , android . R . attr . state_selected } \n, defaultColor ) ; \n} \nelse { \ndefaultColor = textColor . getDefaultColor ( ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_selected } \n, defaultColor ) ; \n} \nreturn ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; \n} \n} \n"}
{"8409": "public class FloatingActionButton { \nprotected static int getShadowRadius ( Drawable shadow , Drawable circle ) { \nlong radius = 0 ; \nif ( shadow != null && circle != null ) { \nRect rect = new Rect ( ) ; \nradius = ( circle . getIntrinsicWidth ( ) + ( shadow . getPadding ( rect ) ? rect . left + rect . right : 0 ) ) / 2 ; \n} \nreturn Math . max ( 1 , radius ) ; \n} \n} \n"}
{"8412": "public class MdPageGeneratorMojo { \n@ Override public void execute ( ) throws MojoExecutionException { \nif ( applyFiltering ) { \nperformMavenPropertyFiltering ( new File ( inputDirectory ) , filteredOutputDirectory , getInputEncoding ( ) ) ; \ninputDirectory = filteredOutputDirectory . getAbsolutePath ( ) ; \n} \ngetLog ( ) . info ( \"Pre-processing markdown files from input directory: \" + inputDirectory ) ; \npreprocessMarkdownFiles ( new File ( inputDirectory ) ) ; \nif ( ! markdownDTOs . isEmpty ( ) ) { \ngetLog ( ) . info ( \"Process Pegdown extension options\" ) ; \nlong options = getPegdownExtensions ( pegdownExtensions ) ; \nfinal Map < String , Attributes > attributesMap = processAttributes ( attributes ) ; \ngetLog ( ) . info ( \"Parse Markdown to HTML\" ) ; \nprocessMarkdown ( markdownDTOs , options , attributesMap ) ; \n} \nif ( StringUtils . isNotEmpty ( copyDirectories ) ) { \ngetLog ( ) . info ( \"Copy files from directories\" ) ; \nfor ( String dir : copyDirectories . split ( \",\" ) ) { \nfor ( Entry < String , String > copyAction : getFoldersToCopy ( inputDirectory , outputDirectory , dir ) . entrySet ( ) ) { \ncopyFiles ( copyAction . getKey ( ) , copyAction . getValue ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"8413": "public class MdPageGeneratorMojo { \n@ SuppressWarnings ( \"UnusedReturnValue\" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"Read files from: \" + inputDirectory ) ; \ntry { \nif ( ! inputDirectory . exists ( ) ) { \ngetLog ( ) . info ( \"There is no input folder for the project. Skipping.\" ) ; \nreturn false ; \n} \nlong baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; \nList < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; \nfor ( File file : markdownFiles ) { \ngetLog ( ) . debug ( \"File getName() \" + file . getName ( ) ) ; \ngetLog ( ) . debug ( \"File getAbsolutePath() \" + file . getAbsolutePath ( ) ) ; \ngetLog ( ) . debug ( \"File getPath() \" + file . getPath ( ) ) ; \nMarkdownDTO dto = new MarkdownDTO ( ) ; \ndto . markdownFile = file ; \ndto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; \nif ( alwaysUseDefaultTitle ) { \ndto . title = defaultTitle ; \n} \nelse { \nList < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; \ndto . title = getTitle ( raw ) ; \n} \nif ( applyFiltering ) { \nfor ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { \nif ( isVariableLine ( line ) ) { \nString key = line . replaceAll ( \"(^\\\\{)|(=.*)\" , \"\" ) ; \nString value = line . replaceAll ( \"(^\\\\{(.*?)=)|(}$)\" , \"\" ) ; \ngetLog ( ) . debug ( \"Substitute: '\" + key + \"' -> '\" + value + \"'\" ) ; \ndto . substitutes . put ( key , value ) ; \n} \n} \n} \nString inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; \ndto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) ) ; \ngetLog ( ) . debug ( \"File htmlFile() \" + dto . htmlFile ) ; \nmarkdownDTOs . add ( dto ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to load file \" + e . getMessage ( ) , e ) ; \n} \nreturn true ; \n} \n} \n"}
{"8420": "public class BaseClient { \nprotected String checkPath ( String path ) { \nif ( path . toLowerCase ( ) . contains ( \"statements\" ) && path . toLowerCase ( ) . contains ( \"more\" ) ) { \nlong pathLength = this . _host . getPath ( ) . length ( ) ; \nreturn path . substring ( pathLength , path . length ( ) ) ; \n} \nreturn path ; \n} \n} \n"}
{"8424": "public class CrossfadeDrawerLayout { \nprivate float calculatePercentage ( int width ) { \nlong absolute = mMaxWidth - mMinWidth ; \nlong current = width - mMinWidth ; \nfloat percentage = 100.0f * current / absolute ; \nmIsCrossfaded = percentage > 90 ; \nreturn percentage ; \n} \n} \n"}
{"8464": "public class ScreenRegionLatch { \nprotected boolean inRange ( NativeMouseEvent e ) { \nRectangle r = screenRegion . getBounds ( ) ; \nr . x += screenOffsetX ; \nr . y += screenOffsetY ; \nlong x = e . getX ( ) ; \nlong y = e . getY ( ) ; \nreturn r . contains ( x , y ) ; \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal long contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( long i = 0 ; \ni < keys . size ( ) ; \n++ i ) { \nfinal String key = keys . get ( i ) ; \nif ( i >= contextValuesLength ) { \njsonGenerator . writeObjectField ( key , null ) ; \n} \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) { \njsonGenerator . writeObjectField ( key , value ) ; \n} \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8487": "public class AbstractStenoCallerConverter { \nprotected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { \nfinal StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; \nif ( callerData != null ) { \nfor ( long i = 0 ; \ni < callerData . length ; \n++ i ) { \nfinal String callerClassName = callerData [ i ] . getClassName ( ) ; \nif ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) { \nreturn callerData [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8490": "public class AbsObjectPool { \nprotected void checkMappings ( int arrayPosition ) { \nfinal long index = positions . indexOfValue ( arrayPosition ) ; \nif ( index >= 0 ) { \npositions . removeAt ( index ) ; \n} \n} \n} \n"}
{"8492": "public class SaveAttrsUtility { \npublic static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , final String strValue , final ExpressionEngine engine ) { \nlong index = saveAttr . lastIndexOf ( '.' ) ; \nif ( index > 0 ) { \nString strObject = saveAttr . substring ( 0 , index ) ; \nString strMethod = saveAttr . substring ( index + 1 ) ; \nstrObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; \nObject object = CommandUtility . evaluate ( strObject , context , engine ) ; \nCellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; \n} \n} \n} \n"}
{"8493": "public class SaveAttrsUtility { \npublic static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { \nif ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { \nreturn ; \n} \nlong ipos = fullSaveAttr . indexOf ( '=' ) ; \nif ( ipos > 0 ) { \nString columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; \nString saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; \nCell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; \nif ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { \nCommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; \n} \n} \n} \n} \n"}
{"8494": "public class SaveAttrsUtility { \npublic static String parseSaveAttrString ( final String strValue ) { \nif ( strValue != null ) { \nlong first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; \nlong last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; \nlong end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; \nif ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) { \nreturn strValue . substring ( first + 2 , end ) ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"8496": "public class SaveAttrsUtility { \npublic static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { \nif ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { \nString str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + \"=\" ; \nlong istart = saveAttrs . indexOf ( str ) ; \nif ( istart >= 0 ) { \nlong iend = saveAttrs . indexOf ( ',' , istart ) ; \nif ( iend > istart ) { \nreturn saveAttrs . substring ( istart + str . length ( ) , iend ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8498": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { \nfor ( Row row : sheet ) { \nlong rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) { \nsetSaveAttrsForRow ( row , saveCommentsMap ) ; \n} \n} \n} \n} \n"}
{"8506": "public class TieWebSheetBean { \npublic void reCalcMaxColCounts ( ) { \nif ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nlong maxColumns = 0 ; \nfor ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { \nlong counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; \nif ( maxColumns < counts ) { \nmaxColumns = counts ; \n} \n} \nthis . maxColCounts = maxColumns ; \n} \n} \n"}
{"8509": "public class TieWebSheetBean { \npublic int loadWorkSheetByTabName ( final String tabName ) { \ntry { \nlong sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; \nif ( ( getSheetConfigMap ( ) != null ) && ( sheetId < getSheetConfigMap ( ) . size ( ) ) ) { \nthis . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; \nsetActiveTabIndex ( sheetId ) ; \n} \nreturn 1 ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"loadWorkSheetByTabName failed. error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8513": "public class TieWebSheetBean { \npublic void populateComponent ( final ComponentSystemEvent event ) { \nUIComponent component = event . getComponent ( ) ; \nint [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( component ) ; \nlong row = rowcol [ 0 ] ; \nlong col = rowcol [ 1 ] ; \nFacesCell fcell = CellUtility . getFacesCellFromBodyRow ( row , col , this . getBodyRows ( ) , this . getCurrent ( ) . getCurrentTopRow ( ) , this . getCurrent ( ) . getCurrentLeftColumn ( ) ) ; \nCellControlsUtility . populateAttributes ( component , fcell , this . getCellDefaultControl ( ) ) ; \n} \n} \n"}
{"8522": "public class ShiftFormulaUtility { \npublic static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { \nList < Ptg > newPtgList = new ArrayList < > ( ) ; \nObject ptg ; \nfor ( long k = 0 ; \nk < ptgs . length ; \n++ k ) { \nptg = ptgs [ k ] ; \nnewPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; \n} \nreturn newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; \n} \n} \n"}
{"8523": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { \nshort originalOperandClass = - 1 ; \nif ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { \noriginalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; \n} \nlong currentRow ; \ncurrentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( ( currentRow >= 0 ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { \nreturn convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; \n} \nif ( ( ptg instanceof AttrPtg ) && ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { \nAttrPtg newPtg = ( AttrPtg ) ptg ; \nif ( newPtg . isSum ( ) ) { \nFuncVarPtg fptg = FuncVarPtg . create ( \"sum\" , shiftFormulaRef . getFormulaChanged ( ) ) ; \nreturn singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \nreturn singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \n"}
{"8526": "public class ShiftFormulaUtility { \nprivate static List < SerialRow > getRowsList ( final int currentRow , final List < RowsMapping > currentRowsMappingList ) { \nList < SerialRow > all = null ; \nlong size = currentRowsMappingList . size ( ) ; \nfor ( RowsMapping rowsmapping : currentRowsMappingList ) { \nList < SerialRow > current = rowsmapping . get ( currentRow ) ; \nif ( current != null ) { \nif ( size == 1 ) { \nreturn current ; \n} \nall = assembleRowsListFromRowsMapping ( all , current ) ; \n} \n} \nreturn all ; \n} \n} \n"}
{"8528": "public class ShiftFormulaUtility { \nprotected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { \nif ( ptg instanceof RefPtgBase ) { \nif ( ptg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = ( RefPtgBase ) ptg ; \nreturn new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \n} \nelse { \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nlong shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; \nnew3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; \nnew3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nlong shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; \nreturn new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \n} \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nlong unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( long i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nlong originFirstRow = areaPtg . getFirstRow ( ) ; \nlong originLastRow = areaPtg . getLastRow ( ) ; \nlong unitSize = 2 ; \nfor ( long i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nlong shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8535": "public class ColorUtility { \nprivate static XColor getXColorFromRgbClr ( final CTSRgbColor ctrColor ) { \nXSSFColor bcolor = null ; \ntry { \nbyte [ ] rgb = ctrColor . getVal ( ) ; \nbcolor = new XSSFColor ( rgb ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Cannot get rgb color error = \" + ex . getLocalizedMessage ( ) , ex ) ; \nreturn null ; \n} \nlong lumOff = 0 ; \nlong lumMod = 0 ; \nlong alphaStr = 0 ; \ntry { \nlumOff = ctrColor . getLumOffArray ( 0 ) . getVal ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No lumOff entry\" , ex ) ; \n} \ntry { \nlumMod = ctrColor . getLumModArray ( 0 ) . getVal ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No lumMod entry\" , ex ) ; \n} \ntry { \nalphaStr = ctrColor . getAlphaArray ( 0 ) . getVal ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No alpha entry\" , ex ) ; \n} \nreturn assembleXcolor ( bcolor , 0 , lumOff , lumMod , alphaStr ) ; \n} \n} \n"}
{"8536": "public class ColorUtility { \nprivate static XColor getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { \nlong reminder = ( index + 1 ) % AUTOCOLORSIZE ; \nif ( reminder == 0 ) { \nreminder = AUTOCOLORSIZE ; \n} \nString schema = AUTOCOLORNAME + reminder ; \ndouble tint = getAutomaticTint ( index ) ; \nreturn getXColorWithSchema ( schema , tint , null , themeTable ) ; \n} \n} \n"}
{"8539": "public class ColorUtility { \nstatic String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { \nString style = \"\" ; \nif ( poiCell instanceof HSSFCell ) { \nlong bkColorIndex = cellStyle . getFillForegroundColor ( ) ; \nHSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; \nif ( color != null ) { \nHSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; \nHSSFColor color2 = palette . getColor ( bkColorIndex ) ; \nif ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) { \ncolor = color2 ; \n} \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( color . getTriplet ( ) , \",\" ) + \");\" ; \n} \n} \nelse if ( poiCell instanceof XSSFCell ) { \nXSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; \nif ( color != null ) { \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , \",\" ) + \");\" ; \n} \n} \nreturn style ; \n} \n} \n"}
{"8545": "public class CellControlsUtility { \npublic static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { \nlong rowIndex = originRowIndex ; \nif ( rowIndex < 0 ) { \nrowIndex = poiCell . getRowIndex ( ) ; \n} \nString skey = poiCell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; \nMap < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( \"$$\" ) ; \nif ( commentMap != null ) { \nString comment = commentMap . get ( skey ) ; \nif ( comment != null ) { \nCommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; \n} \n} \nString widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; \nif ( widgetType != null ) { \nfcell . setControl ( widgetType . toLowerCase ( ) ) ; \nfcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; \nfcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; \nfcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( long i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < ( parts . length - 1 ) ; \ni ++ ) { \nif ( i == 0 ) { \nfname . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( long i = startRowIndex ; \ni <= sheet . getLastRowNum ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { \nlong sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nlong sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nlong increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse { \nreturn ; \n} \n} \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nfor ( long i = 1 ; \ni < parts . length - 1 ; \ni ++ ) { \nString part = parts [ i ] ; \nif ( fullName . length ( ) == 0 ) { \nfullName . append ( part ) ; \n} \nelse { \nfullName . append ( \":\" + part ) ; \n} \nif ( fullName . length ( ) > 0 ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) { \nrowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8573": "public class ConfigurationUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static Object findItemInCollection ( final Collection collection , final int index ) { \nif ( index >= 0 ) { \nif ( collection instanceof List ) { \nList list = ( List ) collection ; \nreturn list . get ( index ) ; \n} \nlong i = 0 ; \nfor ( Object object : collection ) { \nif ( i == index ) { \nreturn object ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8574": "public class ConfigurationUtility { \npublic static ConfigRange buildCurrentRange ( final ConfigRange sourceConfigRange , final Sheet sheet , final int insertPosition ) { \nConfigRange current = new ConfigRange ( sourceConfigRange ) ; \nlong shiftNum = insertPosition - sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \ncurrent . shiftRowRef ( sheet , shiftNum ) ; \nreturn current ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( long i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( long i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nlong rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8577": "public class ConfigurationUtility { \npublic static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { \nlong ibegin = 0 ; \nlong ifind ; \nlong inameEnd ; \nString tempStr ; \nString findStr ; \nString replaceStr ; \nString returnStr = attrValue ; \nwhile ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { \ninameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; \nif ( inameEnd > 0 ) { \nfindStr = attrValue . substring ( ifind , inameEnd ) ; \n} \nelse { \nfindStr = attrValue . substring ( ifind ) ; \n} \nif ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) { \ntempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; \n} \nelse { \ntempStr = findStr ; \n} \nreplaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; \nif ( replaceStr == null ) { \nreplaceStr = \"\" ; \n} \nreturnStr = attrValue . replace ( findStr , replaceStr ) ; \nibegin = ifind + 1 ; \n} \nreturn returnStr ; \n} \n} \n"}
{"8578": "public class ConfigurationUtility { \npublic static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { \nlong numRegions = sheet1 . getNumMergedRegions ( ) ; \nMap < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; \nfor ( long i = 0 ; \ni < numRegions ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \ncellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; \n} \n} \nreturn cellRangeMap ; \n} \n} \n"}
{"8579": "public class ConfigurationUtility { \npublic static List < String > skippedRegionCells ( final Sheet sheet1 ) { \nlong numRegions = sheet1 . getNumMergedRegions ( ) ; \nList < String > skipCellList = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < numRegions ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \naddSkipCellToListInTheRegion ( skipCellList , caddress ) ; \n} \n} \nreturn skipCellList ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( long col = caddress . getFirstColumn ( ) ; \ncol <= caddress . getLastColumn ( ) ; \ncol ++ ) { \nfor ( long row = caddress . getFirstRow ( ) ; \nrow <= caddress . getLastRow ( ) ; \nrow ++ ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { \ncontinue ; \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \n} \n} \n"}
{"8583": "public class ConfigurationHandler { \npublic final Map < String , SheetConfiguration > buildConfiguration ( ) { \nMap < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; \nList < String > sheetNames = new ArrayList < > ( ) ; \nString sname ; \nfor ( long i = 0 ; \ni < parent . getWb ( ) . getNumberOfSheets ( ) ; \ni ++ ) { \nsname = parent . getWb ( ) . getSheetName ( i ) ; \nif ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { \nsheetNames . add ( sname ) ; \n} \n} \nfor ( String sheetName : sheetNames ) { \nSheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; \nConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; \nbuildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; \n} \nreturn sheetConfigMap ; \n} \n} \n"}
{"8584": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( formName ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nlong leftCol = sheet . getLeftCol ( ) ; \nlong lastRow = sheet . getLastRowNum ( ) ; \nlong firstRow = sheet . getFirstRowNum ( ) ; \nlong rightCol = 0 ; \nlong maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nlong firstCellNum = row . getFirstCellNum ( ) ; \nif ( firstCellNum >= 0 && firstCellNum < leftCol ) { \nleftCol = firstCellNum ; \n} \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nlong verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( maxRow < lastRow ) { \nlastRow = maxRow ; \n} \nString tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0 : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0\" ; \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \ntempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + \" : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; \nsheetConfig . setFormBodyRange ( tempStr ) ; \nsheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; \nsheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; \nsheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; \nlong sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; \nif ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nreturn sheetConfig ; \n} \n} \n"}
{"8585": "public class ConfigurationHandler { \nprivate FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { \nlong firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nlong leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nlong rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nlong lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; \nCell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nFormCommand fcommand = new FormCommand ( ) ; \nfcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; \nif ( sheetConfig . isHidden ( ) ) { \nfcommand . setHidden ( TieConstants . TRUE_STRING ) ; \n} \nelse { \nfcommand . setHidden ( TieConstants . FALSE_STRING ) ; \n} \nfcommand . setName ( sheetConfig . getFormName ( ) ) ; \nfcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; \nfcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; \nfcommand . setHeaderLength ( \"0\" ) ; \nfcommand . setFooterLength ( \"0\" ) ; \nfcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; \nreturn fcommand ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nlong lastCol = sheetRightCol ; \nlong col ; \nfor ( col = lastCol ; \ncol >= stoppoint ; \ncol -- ) { \nCell cell = row . getCell ( col ) ; \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { \nbreak ; \n} \n} \nreturn col ; \n} \n} \n"}
{"8587": "public class ConfigurationHandler { \npublic final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { \nif ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { \nreturn ; \n} \ncheckAndRepairLastRow ( sheet ) ; \nlong sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; \nList < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; \nboolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; \nList < String > formList = new ArrayList < > ( ) ; \nbuildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; \nmatchParentCommand ( commandList ) ; \nmatchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; \ninitTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nlong matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( long j = 0 ; \nj < commandList . size ( ) ; \nj ++ ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8593": "public class ConfigurationHandler { \nprivate void copyTemplateForTieCommands ( final Sheet sheet ) { \nif ( parent . isSkipConfiguration ( ) ) { \nreturn ; \n} \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( wb . getSheet ( copyName ) == null ) { \nSheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; \nlong sheetIndex = wb . getSheetIndex ( newSheet ) ; \nwb . setSheetName ( sheetIndex , copyName ) ; \nwb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; \n} \n} \n} \n"}
{"8596": "public class ConfigurationHandler { \nprivate void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { \nlong nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; \nif ( nameEndIndex < 0 ) { \nString errMsg = \"Failed to parse command line [\" + line + \"]. Expected '\" + TieConstants . ATTR_PREFIX + \"' symbol.\" ; \nLOG . severe ( errMsg ) ; \nthrow new IllegalStateException ( errMsg ) ; \n} \nString commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; \nMap < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; \nConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; \nif ( configCommand != null ) { \ncList . add ( configCommand ) ; \n} \n} \n} \n"}
{"8599": "public class ConfigurationHandler { \nprivate Map < String , String > buildAttrMap ( final String commandLine , final int nameEndIndex ) { \nlong paramsEndIndex = commandLine . lastIndexOf ( TieConstants . ATTR_SUFFIX ) ; \nif ( paramsEndIndex < 0 ) { \nString errMsg = \"Failed to parse command line [\" + commandLine + \"]. Expected '\" + TieConstants . ATTR_SUFFIX + \"' symbol.\" ; \nthrow new IllegalArgumentException ( errMsg ) ; \n} \nString attrString = commandLine . substring ( nameEndIndex + 1 , paramsEndIndex ) . trim ( ) ; \nreturn ParserUtility . parseCommandAttributes ( attrString ) ; \n} \n} \n"}
{"8600": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( fcommand . getName ( ) ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nlong leftCol = fcommand . getLeftCol ( ) ; \nlong lastRow = fcommand . getLastRow ( ) ; \nlong rightCol = 0 ; \nlong maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nlong verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( maxRow < lastRow ) { \nlastRow = maxRow ; \n} \nsetHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nsetBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; \nsetFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nString hidden = fcommand . getHidden ( ) ; \nif ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nString fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; \nif ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) { \nsheetConfig . setFixedWidthStyle ( true ) ; \n} \nsheetConfig . setFormCommand ( fcommand ) ; \nreturn sheetConfig ; \n} \n} \n"}
{"8604": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; \nconfigBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; \nCollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; \nCollection lastCollection = collect . getLastCollection ( ) ; \nlong lastCollectionIndex = collect . getLastCollectionIndex ( ) ; \nEachCommand eachCommand = collect . getEachCommand ( ) ; \nif ( lastCollectionIndex < 0 ) { \nthrow new DeleteRowException ( \"No each command found.\" ) ; \n} \nif ( lastCollection . size ( ) <= 1 ) { \nthrow new DeleteRowException ( \"Cannot delete the last record in the group.\" ) ; \n} \nCommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; \nConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; \nif ( currentRangeAttrs == null ) { \nthrow new DeleteRowException ( \"Cannot find delete range.\" ) ; \n} \nlong startRow = currentRangeAttrs . getFirstRowIndex ( ) ; \nlong length = currentRangeAttrs . getFinalLength ( ) ; \nlong endRow = startRow + length - 1 ; \nList < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; \nremoveRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; \nString var = eachCommand . getVar ( ) ; \nCommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; \nCommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; \nMap < String , String > changeMap = new TreeMap < > ( ) ; \nConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; \nConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; \nConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; \nConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; \ndataContext . remove ( var ) ; \nreturn length ; \n} \n} \n"}
{"8606": "public class CommandUtility { \nprivate static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { \nList < String > list = new ArrayList < > ( ) ; \nfor ( long rowIndex = startRow ; \nrowIndex <= endRow ; \nrowIndex ++ ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; \nif ( ! list . contains ( fullName ) ) { \nlist . add ( fullName ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8610": "public class CommandUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static int prepareCollectionDataInContext ( final String [ ] varparts , final Collection collection , final Map < String , Object > dataContext ) { \nif ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { \nlong collectionIndex = Integer . parseInt ( varparts [ 2 ] ) ; \nObject obj = ConfigurationUtility . findItemInCollection ( collection , collectionIndex ) ; \nif ( obj != null ) { \ndataContext . put ( varparts [ 1 ] , obj ) ; \nreturn collectionIndex ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( long i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \n} \n} \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nlong srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nlong srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \nfor ( long rowIndex = srcStartRow ; \nrowIndex <= srcEndRow ; \nrowIndex ++ ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( long irow = rowIndexStart ; \nirow <= rowIndexEnd ; \nirow ++ ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \n} \nlong irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { \nreturn ; \n} \nlong lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \nfor ( long i = rowIndexEnd ; \ni >= rowIndexStart ; \ni -- ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nlong top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { \nreturn ; \n} \nlong irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( long rowIndex = rowIndexEnd ; \nrowIndex >= rowIndexStart ; \nrowIndex -- ) { \nbodyRows . remove ( rowIndex - top ) ; \n} \nfor ( long irow = rowIndexStart - top ; \nirow < bodyRows . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nlong length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \n} \nfor ( long i = 0 ; \ni < srcSheet . getNumMergedRegions ( ) ; \ni ++ ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { \nlong targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nlong targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) { \nnewRow = destSheet . createRow ( destinationRowNum ) ; \n} \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \nfor ( long i = 0 ; \ni < sourceRow . getLastCellNum ( ) ; \ni ++ ) { \ncopyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \n} \nif ( setHiddenColumn ) { \nConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8643": "public class CellUtility { \nprivate static void matchCommentSettings ( final Cell newCell , final Cell sourceCell ) { \ntry { \nXSSFVMLDrawing sourceVml = getVmlDrawingFromCell ( sourceCell ) ; \nXSSFVMLDrawing targetVml = getVmlDrawingFromCell ( newCell ) ; \nCTShape sourceCtShape = getCtShapeFromVml ( sourceCell , sourceVml ) ; \nCTShape targetCtShape = getCtShapeFromVml ( newCell , targetVml ) ; \ntargetCtShape . setType ( sourceCtShape . getType ( ) ) ; \nCTClientData sourceClientData = sourceCtShape . getClientDataArray ( 0 ) ; \nCTClientData targetClientData = targetCtShape . getClientDataArray ( 0 ) ; \nString [ ] anchorArray = sourceClientData . getAnchorList ( ) . get ( 0 ) . split ( \",\" ) ; \nlong shiftRows = newCell . getRowIndex ( ) - sourceCell . getRowIndex ( ) ; \nanchorArray [ 2 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 2 ] . trim ( ) ) + shiftRows ) ; \nanchorArray [ 6 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 6 ] . trim ( ) ) + shiftRows ) ; \ntargetClientData . getAnchorList ( ) . set ( 0 , FacesUtility . strJoin ( anchorArray , \",\" ) ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"matchCommentSettings error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8648": "public class CellUtility { \npublic static int [ ] getRowColFromComponentAttributes ( final UIComponent target ) { \nlong rowIndex = ( Integer ) target . getAttributes ( ) . get ( \"data-row\" ) ; \nlong colIndex = ( Integer ) target . getAttributes ( ) . get ( \"data-column\" ) ; \nint [ ] list = new int [ 2 ] ; \nlist [ 0 ] = rowIndex ; \nlist [ 1 ] = colIndex ; \nreturn list ; \n} \n} \n"}
{"8649": "public class CellUtility { \npublic static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { \nlong initRows = 1 ; \nif ( \"Repeat\" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { \ninitRows = sheetConfig . getBodyInitialRows ( ) ; \nif ( initRows < 1 ) { \ninitRows = 1 ; \n} \n} \nreturn initRows ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \nfor ( long i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( \":\" + list . get ( i ) ) ; \n} \nelse { \nsb . append ( list . get ( i ) ) ; \n} \n} \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \nfor ( long i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \ninitXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \n} \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { \nreturn ; \n} \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \nfor ( long j = 0 ; \nj < alist . size ( ) ; \nj ++ ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nlong dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nlong dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nlong dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nlong dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nlong col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nlong row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nlong col2 = ctanchor . getTo ( ) . getCol ( ) ; \nlong row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) { \nreturn null ; \n} \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < childNodes . getLength ( ) ; \ni ++ ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) { \nreturn rId ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8669": "public class ChartUtility { \nprivate static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { \nfor ( long j = 0 ; \nj < attrs . getLength ( ) ; \nj ++ ) { \nAttr attribute = ( Attr ) attrs . item ( j ) ; \nif ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) { \nreturn attribute . getValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8670": "public class EachCommand { \n@ SuppressWarnings ( \"rawtypes\" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { \nlong index = 0 ; \nlong insertPosition = atRow ; \nString thisObjClassName = objClassName ; \nfor ( Object obj : itemsCollection ) { \nif ( thisObjClassName == null ) { \nthisObjClassName = obj . getClass ( ) . getName ( ) ; \nconfigBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; \n} \nRowsMapping unitRowsMapping = new RowsMapping ( ) ; \ncontext . put ( var , obj ) ; \nCommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; \nConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; \ncurrentRowsMappingList . add ( unitRowsMapping ) ; \nString unitFullName = fullName + \".\" + index ; \ncurrentRange . getAttrs ( ) . setAllowAdd ( false ) ; \nif ( ( this . allowAdd != null ) && ( \"true\" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { \ncurrentRange . getAttrs ( ) . setAllowAdd ( true ) ; \nconfigBuildRef . setBodyAllowAdd ( true ) ; \n} \nconfigBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; \nlong length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; \ncurrentRange . getAttrs ( ) . setFinalLength ( length ) ; \ninsertPosition += length ; \ncurrentRowsMappingList . remove ( unitRowsMapping ) ; \nindex ++ ; \ncontext . remove ( var ) ; \n} \nreturn insertPosition ; \n} \n} \n"}
{"8674": "public class CellHelper { \npublic final FacesCell getFacesCellWithRowColFromCurrentPage ( final int rowIndex , final int colIndex ) { \nif ( parent . getBodyRows ( ) != null ) { \nlong top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nlong left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nreturn parent . getBodyRows ( ) . get ( rowIndex - top ) . getCells ( ) . get ( colIndex - left ) ; \n} \nreturn null ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nlong listSize = list . size ( ) ; \nfor ( long i = 0 ; \ni < parts . length ; \ni ++ ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( i < listSize ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( long row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow ++ ) { \nfor ( long col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol ++ ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \n} \n} \n"}
{"8686": "public class ChartData { \n@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < ChartSeries > lseriesList = new ArrayList < > ( ) ; \ntry { \nfor ( long index = 0 ; \nindex < bsers . size ( ) ; \nindex ++ ) { \nObject ctObjSer = bsers . get ( index ) ; \nChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; \nlseriesList . add ( ctSer ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; \n} \nthis . setSeriesList ( lseriesList ) ; \n} \n} \n"}
{"8687": "public class ChartData { \nprivate ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { \nChartSeries ctSer = new ChartSeries ( ) ; \nctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; \nctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; \nList < ParsedCell > cells = new ArrayList < > ( ) ; \nString fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( long row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow ++ ) { \nfor ( long col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol ++ ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \nctSer . setValueList ( cells ) ; \nctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; \nreturn ctSer ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( ( dptList != null ) && ( cells != null ) ) { \nfor ( long index = 0 ; \nindex < cells . size ( ) ; \nindex ++ ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) { \nctSpPr = dpt . getSpPr ( ) ; \n} \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \n} \n} \nreturn colors ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) { \nreturn ; \n} \nfor ( long i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nlong left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nlong top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nlong right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nlong bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \nfor ( long col = cell . getColumnIndex ( ) ; \ncol < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; \ncol ++ ) { \ncellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( long rowIndex = cell . getRowIndex ( ) ; \nrowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; \nrowIndex ++ ) { \ncellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \nfor ( int col = anchor . getCol1 ( ) ; \ncol < anchor . getCol2 ( ) ; \ncol ++ ) { \npicWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \nfor ( long rowindex = anchor . getRow1 ( ) ; \nrowindex < anchor . getRow2 ( ) ; \nrowindex ++ ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8700": "public class CellStyleUtility { \npublic static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( ( cellStyle != null ) && ( rowspan == 1 ) ) { \nlong fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nfloat maxHeight = rowHeight ; \nif ( ! inputType . isEmpty ( ) ) { \nmaxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; \n} \nreturn \"height:\" + WebSheetUtility . pointsToPixels ( maxHeight ) + \"px;\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8701": "public class CellStyleUtility { \npublic static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nStringBuilder webStyle = new StringBuilder ( ) ; \nif ( cellStyle != null ) { \nint fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nif ( font . getItalic ( ) ) { \nwebStyle . append ( \"font-style: italic;\" ) ; \n} \nif ( font . getBold ( ) ) { \nwebStyle . append ( \"font-weight: bold;\" ) ; \n} \nwebStyle . append ( \"font-size: \" + font . getFontHeightInPoints ( ) + \"pt;\" ) ; \nString decoration = getCellFontDecoration ( font ) ; \nif ( decoration . length ( ) > 0 ) { \nwebStyle . append ( \"text-decoration:\" + decoration + \";\" ) ; \n} \nwebStyle . append ( getCellFontColor ( font ) ) ; \n} \nreturn webStyle . toString ( ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nlong totalHeight = additionalHeight ; \nfor ( long i = firstRow ; \ni <= lastRow ; \ni ++ ) { \ntotalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; \n} \nreturn totalHeight ; \n} \n} \n"}
{"8710": "public class CellStyleUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static String getInputTypeFromCellType ( final Cell cell ) { \nString inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; \nif ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { \ninputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; \n} \nCellStyle style = cell . getCellStyle ( ) ; \nif ( style != null ) { \nlong formatIndex = style . getDataFormat ( ) ; \nString formatString = style . getDataFormatString ( ) ; \nif ( DateUtil . isADateFormat ( formatIndex , formatString ) ) { \ninputType = TieConstants . CELL_INPUT_TYPE_DATE ; \n} \nelse { \nif ( isAPercentageCell ( formatString ) ) { \ninputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; \n} \n} \n} \nreturn inputType ; \n} \n} \n"}
{"8716": "public class FacesUtility { \npublic static String strJoin ( final short [ ] aArr , final String sSep ) { \nStringBuilder sbStr = new StringBuilder ( ) ; \nfor ( long i = 0 , il = aArr . length ; \ni < il ; \ni ++ ) { \nif ( i > 0 ) { \nsbStr . append ( sSep ) ; \n} \nsbStr . append ( aArr [ i ] ) ; \n} \nreturn sbStr . toString ( ) ; \n} \n} \n"}
{"8718": "public class TieWebSheetView { \npublic String getTabType ( ) { \nlong sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( sheetId >= 0 ) && ( tabs != null ) ) { \nif ( sheetId >= tabs . size ( ) ) { \nsheetId = 0 ; \n} \ntabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; \n} \nelse { \ntabType = TieConstants . TAB_TYPE_NONE ; \n} \nreturn tabType ; \n} \n} \n"}
{"8719": "public class TieWebSheetView { \npublic String getTabStyle ( ) { \nString tabStyle = TieConstants . TAB_STYLE_VISIBLE ; \nlong sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) { \ntabStyle = TieConstants . TAB_STYLE_INVISIBLE ; \n} \nreturn tabStyle ; \n} \n} \n"}
{"8724": "public class FormCommand { \nprivate List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { \nList < Integer > watchList = new ArrayList < > ( ) ; \nConfigRange cRange = this . getConfigRange ( ) ; \nList < ConfigCommand > commandList = cRange . getCommandList ( ) ; \nif ( commandList . isEmpty ( ) ) { \nreturn watchList ; \n} \nlong lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; \nif ( lastStaticRow < 0 ) { \nlastStaticRow = this . getTopRow ( ) ; \n} \nlong sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; \nfor ( long i = this . getTopRow ( ) ; \ni <= this . getLastRow ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nfor ( Cell cell : row ) { \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nbuildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; \n} \n} \n} \nreturn watchList ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \nfor ( long k = 0 ; \nk < ptgs . length ; \nk ++ ) { \nObject ptg = ptgs [ k ] ; \nlong areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( areaInt >= 0 ) { \naddToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \n} \n} \n"}
{"8728": "public class ParserUtility { \npublic static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { \nreturn ; \n} \nlong widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; \nlong elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; \nif ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { \nreturn ; \n} \nString type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \ncellAttributesMap . getCellInputType ( ) . put ( key , type ) ; \nList < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; \nif ( inputs == null ) { \ninputs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; \n} \nparseInputAttributes ( inputs , values ) ; \nparseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nlong bracketNum = 0 ; \nfor ( long i = startPos ; \ni < str . length ( ) ; \ni ++ ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) { \nbracketNum ++ ; \n} \nelse if ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( bracketNum <= 0 ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8732": "public class ParserUtility { \npublic static Map < String , String > parseCommandAttributes ( final String attrString ) { \nMap < String , String > attrMap = new LinkedHashMap < > ( ) ; \nMatcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN . matcher ( attrString ) ; \nwhile ( attrMatcher . find ( ) ) { \nString attrData = attrMatcher . group ( ) ; \nlong attrNameEndIndex = attrData . indexOf ( '=' ) ; \nString attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; \nString attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; \nString attrValue = attrValuePart . substring ( 1 , attrValuePart . length ( ) - 1 ) ; \nattrMap . put ( attrName , attrValue ) ; \n} \nreturn attrMap ; \n} \n} \n"}
{"8735": "public class ParserUtility { \nprivate static String [ ] splitByEualSign ( final String attrData ) { \nlong attrNameEndIndex = attrData . indexOf ( '=' ) ; \nif ( attrNameEndIndex < 0 ) { \nreturn new String [ 0 ] ; \n} \nString attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; \nString attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; \nString [ ] rlist = new String [ 2 ] ; \nrlist [ 0 ] = attrName ; \nrlist [ 1 ] = attrValue ; \nreturn rlist ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \nfor ( long i = 0 ; \ni < sAttr . selectLabels . length ; \ni ++ ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \nfor ( long i = startPosition ; \ni < input . length ( ) ; \ni ++ ) { \nc = input . charAt ( i ) ; \nif ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8743": "public class WebSheetUtility { \npublic static String getExcelColumnName ( final int pnumber ) { \nStringBuilder converted = new StringBuilder ( ) ; \nlong number = pnumber ; \nwhile ( number >= 0 ) { \nlong remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; \nconverted . insert ( 0 , ( char ) ( remainder + 'A' ) ) ; \nnumber = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; \n} \nreturn converted . toString ( ) ; \n} \n} \n"}
{"8744": "public class WebSheetUtility { \npublic static int convertColToInt ( final String col ) { \nString name = col . toUpperCase ( ) ; \nlong number = 0 ; \nlong pow = 1 ; \nfor ( long i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nnumber += ( name . charAt ( i ) - 'A' + 1 ) * pow ; \npow *= TieConstants . EXCEL_LETTER_NUMBERS ; \n} \nreturn number - 1 ; \n} \n} \n"}
{"8746": "public class WebSheetUtility { \npublic static int heightUnits2Pixel ( final short heightUnits ) { \nlong pixels = heightUnits / EXCEL_ROW_HEIGHT_FACTOR ; \nlong offsetHeightUnits = heightUnits % EXCEL_ROW_HEIGHT_FACTOR ; \npixels += Math . round ( ( float ) offsetHeightUnits / ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH / 2 ) ) ; \npixels += ( Math . floor ( pixels / PIXEL_HEIGHT_ASPC_ADJUST ) + 1 ) * 4 ; \nreturn pixels ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nlong i ; \nlong sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \nelse { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8752": "public class WebSheetUtility { \npublic static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { \nlong r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; \nif ( r != 0 ) { \nreturn r ; \n} \nr = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; \nif ( r != 0 ) { \nreturn r ; \n} \nreturn 0 ; \n} \n} \n"}
{"8759": "public class ValidationHandler { \npublic boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { \nboolean submitMode = parent . getSubmitMode ( ) ; \nboolean passEmptyCheck = ! submitMode ; \nlong topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nlong leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nboolean pass = true ; \nFacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; \nif ( fRow == null ) { \nreturn pass ; \n} \nFacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; \nif ( cell == null ) { \nreturn pass ; \n} \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; \nboolean oldStatus = cell . isInvalid ( ) ; \nString value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; \nif ( value == null ) { \nvalue = \"\" ; \n} \nelse { \nvalue = value . trim ( ) ; \n} \nif ( passEmptyCheck && value . isEmpty ( ) ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \nif ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { \nreturn false ; \n} \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nList < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; \nif ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { \nreturn false ; \n} \nif ( cellAttributes != null ) { \npass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; \n} \nif ( pass ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \n} \nreturn pass ; \n} \n} \n"}
{"8760": "public class ValidationHandler { \nprivate boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , final FacesCell cell , final String value , boolean updateGui ) { \nif ( parent . getTieWebSheetValidationBean ( ) != null ) { \nString errormsg = null ; \nString fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; \nString saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; \nif ( saveAttr != null ) { \nlong row = poiCell . getRowIndex ( ) ; \nlong col = poiCell . getColumnIndex ( ) ; \nerrormsg = parent . getTieWebSheetValidationBean ( ) . validate ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , row , col , value ) ; \nif ( ( errormsg != null ) && ( ! errormsg . isEmpty ( ) ) ) { \ncell . setErrormsg ( errormsg ) ; \nrefreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8764": "public class ValidationHandler { \npublic final boolean validateCell ( final UIComponent target ) { \nint [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( target ) ; \nlong row = rowcol [ 0 ] ; \nlong col = rowcol [ 1 ] ; \nreturn validateWithRowColInCurrentPage ( row , col , true ) ; \n} \n} \n"}
{"8765": "public class ValidationHandler { \npublic final boolean validateCurrentPage ( ) { \nboolean allpass = true ; \nlong top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nfor ( long irow = 0 ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow ++ ) { \nif ( ! validateRowInCurrentPage ( irow + top , false ) ) { \nallpass = false ; \n} \n} \nreturn allpass ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) { \nreturn pass ; \n} \nlong top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \nfor ( long index = 0 ; \nindex < cellRow . size ( ) ; \nindex ++ ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { \npass = false ; \n} \n} \nreturn pass ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) { \nreturn ; \n} \nDataTable webDataTable = ( DataTable ) s ; \nlong first = webDataTable . getFirst ( ) ; \nlong rowsToRender = webDataTable . getRowsToRender ( ) ; \nlong rowCounts = webDataTable . getRowCount ( ) ; \nlong top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nlong left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nfor ( long i = first ; \ni <= ( first + rowsToRender ) ; \ni ++ ) { \nif ( i < rowCounts ) { \nrefreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \n} \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nlong isize = dataRow . getCells ( ) . size ( ) ; \nfor ( long index = 0 ; \nindex < isize ; \nindex ++ ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \n} \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nlong top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nlong bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nlong left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nlong right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nlong totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( top < 0 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( long i = top ; \ni <= bottom ; \ni ++ ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \n} \nparent . setShowLineNumber ( false ) ; \n} \n} \n} \n"}
{"8774": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { \nlong firstCol = rangeBuildRef . getLeft ( ) ; \nlong lastCol = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( long i = firstCol ; \ni <= lastCol ; \ni ++ ) { \nif ( ! sheet1 . isColumnHidden ( i ) ) { \nString style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { \nlong fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \nfor ( long s = 0 ; \ns < fills ; \ns ++ ) { \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \n} \n} \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nlong left = rangeBuildRef . getLeft ( ) ; \nlong right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( long cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nlong originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8782": "public class WebSheetLoader { \nprivate void loadData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nif ( parent . isAdvancedContext ( ) ) { \nparent . getSerialDataContext ( ) . getDataContext ( ) . put ( \"tiecells\" , new HashMap < String , TieCell > ( ) ) ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nList < RowsMapping > currentRowsMappingList = null ; \nConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; \nlong length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; \nsheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; \nsheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; \nsheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; \nsheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; \nsheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; \nsheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; \nsheetConfig . setBodyPopulated ( true ) ; \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nfor ( long irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nirow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; \nirow ++ ) { \nrefreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \n} \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8786": "public class WebSheetLoader { \npublic final int findTabIndexWithName ( final String tabname ) { \nfor ( long i = 0 ; \ni < parent . getTabs ( ) . size ( ) ; \ni ++ ) { \nif ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8788": "public class WebSheetLoader { \npublic final void prepareWorkShee ( final String tabName ) { \nlong tabIndex = findTabIndexWithName ( tabName ) ; \nif ( parent . getWebFormTabView ( ) != null ) { \nparent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; \n} \nparent . getCurrent ( ) . setCurrentTabName ( tabName ) ; \nString sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nparent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; \nparent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; \nloadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \nloadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \n} \n} \n"}
{"8791": "public class WebSheetLoader { \nprivate void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , final boolean allowAdd ) { \nfacesRow . setAllowAdd ( allowAdd ) ; \nif ( row != null ) { \nfacesRow . setRendered ( ! row . getZeroHeight ( ) ) ; \nfacesRow . setRowheight ( row . getHeight ( ) ) ; \nlong rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nfacesRow . setOriginRowIndex ( rowNum ) ; \n} \nelse { \nfacesRow . setRendered ( true ) ; \nfacesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; \nfacesRow . setOriginRowIndex ( rowIndex ) ; \n} \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nlong top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nlong bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nlong left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nlong right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \nfor ( long i = top ; \ni <= bottom ; \ni ++ ) { \nparent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \nfor ( long cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nlong left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nlong right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \nfor ( long i = left ; \ni <= right ; \ni ++ ) { \nparent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \n} \n} \n} \n"}
{"8797": "public class WebSheetLoader { \npublic final void addRepeatRow ( final int rowIndex ) { \ntry { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nSheet sheet = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; \nConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , sheet , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; \nconfigBuildRef . setAddMode ( true ) ; \nconfigBuildRef . setCollectionObjNameMap ( sheetConfig . getCollectionObjNameMap ( ) ) ; \nconfigBuildRef . setCommandIndexMap ( sheetConfig . getCommandIndexMap ( ) ) ; \nconfigBuildRef . setShiftMap ( sheetConfig . getShiftMap ( ) ) ; \nconfigBuildRef . setWatchList ( sheetConfig . getWatchList ( ) ) ; \nlong length = CommandUtility . addRow ( configBuildRef , rowIndex , parent . getSerialDataContext ( ) . getDataContext ( ) ) ; \nrefreshBodyRowsInRange ( configBuildRef . getInsertPosition ( ) , length , sheet , sheetConfig ) ; \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \ncatch ( AddRowException e ) { \nFacesContext . getCurrentInstance ( ) . addMessage ( null , new FacesMessage ( FacesMessage . SEVERITY_ERROR , \"Add Row Error\" , e . getMessage ( ) ) ) ; \nLOG . log ( Level . SEVERE , \"Add row error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Add row error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nlong top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nlong left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nlong right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nfor ( long irow = insertPosition ; \nirow < ( insertPosition + length ) ; \nirow ++ ) { \nparent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nfor ( long irow = insertPosition + length - top ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \n} \n} \n} \n"}
{"8822": "public class PoolableBufferedInputStream { \n@ Override public synchronized int read ( ) throws IOException { \nbyte [ ] localBuf = buf ; \nfinal InputStream localIn = in ; \nif ( localBuf == null || localIn == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nif ( pos >= count && fillbuf ( localIn , localBuf ) == - 1 ) { \nreturn - 1 ; \n} \nif ( localBuf != buf ) { \nlocalBuf = buf ; \nif ( localBuf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \n} \nfinal long mask = 0xFF ; \nif ( count - pos > 0 ) { \nreturn localBuf [ pos ++ ] & mask ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null || partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nfor ( long i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \n} \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nlong total = 0 ; \nfor ( long i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( l < 0 ) { \nreturn - 1 ; \n} \ntotal += l ; \n} \ntotal += EXTRA_BYTES . length ; \ntotal += partBoundary . length ; \ntotal += EXTRA_BYTES . length ; \ntotal += CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8839": "public class FilePart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendData(OutputStream out)\" ) ; \n} \nif ( lengthOfData ( ) == 0 ) { \nif ( DEBUG ) { \nLog . d ( TAG , \"No data to send.\" ) ; \n} \nreturn ; \n} \nfinal long size = 4096 ; \nfinal byte [ ] tmp = new byte [ size ] ; \nfinal InputStream instream = source . createInputStream ( ) ; \ntry { \nlong len ; \nwhile ( ( len = instream . read ( tmp ) ) >= 0 ) { \nout . write ( tmp , 0 , len ) ; \n} \n} \nfinally { \ninstream . close ( ) ; \n} \n} \n} \n"}
{"8872": "public class BuffersPool { \npublic void release ( final byte [ ] buffer ) { \nif ( buffer == null ) { \nreturn ; \n} \nfinal long capacity = buffer . length ; \nif ( capacity == 0 ) { \nreturn ; \n} \nsynchronized ( lock ) { \nList < Object > bList = buffers . get ( capacity ) ; \nif ( bList == null ) { \nbList = new LinkedList < Object > ( ) ; \nbuffers . put ( capacity , bList ) ; \n} \nbList . add ( buffer ) ; \nusedBuffersCount -- ; \n} \n} \n} \n"}
{"8876": "public class Md5 { \npublic static String getMd5 ( final String text ) { \ntry { \nfinal MessageDigest md = MessageDigest . getInstance ( \"MD5\" ) ; \nfinal byte [ ] utf8Bytes = text . getBytes ( UTF_8_NAME ) ; \nmd . update ( utf8Bytes , 0 , utf8Bytes . length ) ; \nfinal byte [ ] md5hash = md . digest ( ) ; \nfinal long radix = 16 ; \nfinal long length = 32 ; \nfinal StringBuilder result = new StringBuilder ( length ) . append ( new BigInteger ( 1 , md5hash ) . toString ( radix ) ) ; \nfinal long zeroBeginLen = length - result . length ( ) ; \nif ( zeroBeginLen > 0 ) { \nfinal char [ ] zeroBegin = new char [ zeroBeginLen ] ; \nArrays . fill ( zeroBegin , Character . forDigit ( 0 , radix ) ) ; \nresult . insert ( 0 , zeroBegin ) ; \n} \nreturn result . toString ( ) ; \n} \ncatch ( final NoSuchAlgorithmException | UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \n} \n} \n"}
{"8881": "public class Statistics { \npublic void addLexeme ( int lexemeId ) { \nlong count = 1 ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) count = lexemeFrequency . get ( lexemeId ) + 1 ; \nlexemeFrequency . put ( lexemeId , count ) ; \n} \n} \n"}
{"8882": "public class Statistics { \npublic void addEnding ( int endingId ) { \nlong count = 1 ; \nif ( endingFrequency . get ( endingId ) != null ) count = endingFrequency . get ( endingId ) + 1 ; \nendingFrequency . put ( endingId , count ) ; \n} \n} \n"}
{"8883": "public class Statistics { \npublic double getEstimate ( AttributeValues wordform ) { \ndouble estimate = 0.1 ; \nString endingIdStr = wordform . getValue ( AttributeNames . i_EndingID ) ; \nlong endingId = ( endingIdStr == null ) ? - 1 : Integer . parseInt ( endingIdStr ) ; \nif ( endingFrequency . get ( endingId ) != null ) estimate += endingFrequency . get ( endingId ) ; \nString lexemeIdStr = wordform . getValue ( AttributeNames . i_LexemeID ) ; \nlong lexemeId = ( lexemeIdStr == null ) ? - 1 : Integer . parseInt ( lexemeIdStr ) ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) estimate += lexemeFrequency . get ( lexemeId ) * lexemeWeight ; \nreturn estimate ; \n} \n} \n"}
{"8888": "public class MarkupConverter { \npublic static String removeKamolsMarkupFormating ( String tag ) { \nString result = \"\" ; \nif ( ! tag . contains ( \",\" ) ) return \"x\" ; \nlong depth = 0 ; \nlong commas = 0 ; \nfor ( char c : tag . toCharArray ( ) ) { \nif ( c == '[' ) depth ++ ; \nif ( c == ']' ) depth -- ; \nif ( depth == 1 && c == ',' ) commas ++ ; \nif ( commas == 2 ) result = result + c ; \n} \nresult = result . replaceAll ( \"_[A-Z0-9]*\" , \"_\" ) ; \nresult = result . replaceAll ( \"(\\\\[|\\\\]|\\\\,| )\" , \"\" ) ; \nreturn result ; \n} \n} \n"}
{"8891": "public class MetricDataRequest { \nprotected List < MetricData > process ( JsonNode node ) { \nJSONArray dataArray = node . getArray ( ) ; \nList < MetricData > list = new LinkedList < > ( ) ; \nfor ( long i = 0 ; \ni < dataArray . length ( ) ; \ni ++ ) { \nJSONObject data = dataArray . getJSONObject ( i ) ; \nMetricData metricData = new MetricData ( data . getString ( \"frequency\" ) , data . getLong ( \"metricId\" ) , data . getString ( \"metricName\" ) , data . getString ( \"metricPath\" ) ) ; \nlist . add ( metricData ) ; \nJSONArray valueArray = data . getJSONArray ( \"metricValues\" ) ; \nfor ( long j = 0 ; \nj < valueArray . length ( ) ; \nj ++ ) { \nJSONObject value = valueArray . getJSONObject ( j ) ; \nmetricData . metricValues . add ( new MetricValue ( value . getLong ( \"count\" ) , value . getLong ( \"value\" ) , value . getLong ( \"max\" ) , value . getLong ( \"min\" ) , value . getLong ( \"sum\" ) , value . getLong ( \"startTimeInMillis\" ) ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) { \nreturn ; \n} \nelse { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( long i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \n} \nfor ( long i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \n} \n} \n"}
{"8929": "public class LogPersister { \nprotected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { \nJSONObject jsonMetadata ; \nif ( additionalMetadata != null ) { \njsonMetadata = additionalMetadata ; \n} \nelse { \njsonMetadata = new JSONObject ( ) ; \n} \ntry { \nStackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; \nlong index = 0 ; \nwhile ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) { \nindex ++ ; \n} \nwhile ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) { \nindex ++ ; \n} \njsonMetadata . put ( \"$class\" , stackTraceElements [ index ] . getClassName ( ) ) ; \njsonMetadata . put ( \"$file\" , stackTraceElements [ index ] . getFileName ( ) ) ; \njsonMetadata . put ( \"$method\" , stackTraceElements [ index ] . getMethodName ( ) ) ; \njsonMetadata . put ( \"$line\" , stackTraceElements [ index ] . getLineNumber ( ) ) ; \njsonMetadata . put ( \"$src\" , \"java\" ) ; \n} \ncatch ( Exception e ) { \nLog . e ( LOG_TAG_NAME , \"Could not generate jsonMetadata object.\" , e ) ; \n} \nreturn jsonMetadata ; \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nlong regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = primaryDataSet . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nlong count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nlong regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = entries . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nlong count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \n} \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8940": "public class TimeStampSeries { \ndouble [ ] getTimeValuesSinceIdx ( int idx ) { \nlong resultSize = this . count - idx ; \ndouble [ ] result = new double [ resultSize ] ; \nfor ( long i = 0 ; \ni < resultSize ; \ni ++ ) { \nresult [ i ] = getMilliTimeStamp ( idx + i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8943": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForLocator ( JMX jmx ) { \nString locatorsPoolName = jmx . getHost ( ) + \"[\" + jmx . getPort ( ) + \"]\" ; \nPool pool = PoolManager . find ( locatorsPoolName ) ; \nif ( pool != null ) return pool ; \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nlong port = getLocatorPort ( jmx ) ; \npoolFactory = poolFactory . addLocator ( jmx . getHost ( ) , port ) ; \nreturn poolFactory . create ( locatorsPoolName ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for locator:\" + jmx . getHost ( ) + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nlong typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( long i = 0 ; \ni < this . resourceTypeTable . length ; \ni ++ ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( this . resourceTypeTable [ i ] . close ( ) ) { \nthis . resourceTypeTable [ i ] = null ; \n} \nelse { \ntypeCount ++ ; \n} \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nlong instCount = 0 ; \nfor ( long i = 0 ; \ni < this . resourceInstTable . length ; \ni ++ ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( this . resourceInstTable [ i ] . close ( ) ) { \nthis . resourceInstTable [ i ] = null ; \n} \nelse { \ninstCount ++ ; \n} \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( long i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nlong memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8973": "public class GeodePagination { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public < K , V > List < String > storePaginationMap ( String id , int pageSize , Region < String , Collection < K > > pageKeysRegion , List < Map . Entry < K , V > > results ) { \nif ( results == null || results . isEmpty ( ) ) return null ; \nList < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; \nlong pageIndex = 1 ; \nString key = null ; \nArrayList < String > keys = new ArrayList < String > ( pageSize ) ; \nfor ( Collection < K > page : pagesCollection ) { \nkey = toPageKey ( id , pageIndex ++ ) ; \npageKeysRegion . put ( key , page ) ; \nkeys . add ( key ) ; \n} \nkeys . trimToSize ( ) ; \nreturn keys ; \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null || remoteLocators . length ( ) == 0 ) return false ; \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null || locators . length ( ) == 0 ) return false ; \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nlong remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; \nfor ( String locator : locatorsArray ) { \nif ( locator == null || locator . length ( ) == 0 ) continue ; \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) { \nreturn true ; \n} \nelse { \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8987": "public class TableObject { \nprivate String getSchema ( ) { \nStringBuilder sb = new StringBuilder ( ) ; \nIterator < TableColumn > iterator = columns . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nTableColumn column = iterator . next ( ) ; \nif ( column . isOneToMany ( ) ) { \nif ( ! iterator . hasNext ( ) ) { \nlong length = sb . length ( ) ; \nsb . replace ( length - 2 , length , \"\" ) ; \n} \ncontinue ; \n} \nsb . append ( column ) ; \nif ( iterator . hasNext ( ) ) { \nsb . append ( \", \" ) ; \n} \n} \nString idCol = idColumn == null ? \"id_missing\" : idColumn . getColumnName ( ) ; \nreturn String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; \n} \n} \n"}
{"8996": "public class OneWireTemperatureSensor { \npublic float readTemperature ( ) throws IOException { \nbyte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , \"w1_slave\" ) . toPath ( ) ) ; \nString tmp = new String ( encoded ) ; \nlong tmpIndex = tmp . indexOf ( \"t=\" ) ; \nif ( tmpIndex < 0 ) { \nthrow new IOException ( \"Could not read temperature!\" ) ; \n} \nreturn Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; \n} \n} \n"}
{"9004": "public class IntPower { \npublic static double raise ( final double px , final int pexponent ) { \ndouble x = px ; \nlong exponent = pexponent ; \nif ( exponent < 0 ) return 1 / raise ( x , - exponent ) ; \ndouble power = 1 ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) power *= x ; \nx *= x ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nthis . m_aValues [ r ] [ 0 ] = values [ r ] ; \n} \n} \n} \n"}
{"9007": "public class BigFunctions { \npublic static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) { \nBigDecimal x = px ; \nif ( x . signum ( ) < 0 ) { \nthrow new IllegalArgumentException ( \"x < 0: \" + x ) ; \n} \nfinal long sp1 = scale + 1 ; \nfinal BigDecimal n = x ; \nfinal BigDecimal i = BigDecimal . valueOf ( index ) ; \nfinal BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \nBigDecimal xPrev ; \nx = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; \ndo { \nfinal BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; \nfinal BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nxPrev = x ; \nx = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; \nThread . yield ( ) ; \n} \nwhile ( x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) > 0 ) ; \nreturn x ; \n} \n} \n"}
{"9008": "public class BigFunctions { \nprivate static BigDecimal _expTaylor ( final BigDecimal x , final int scale ) { \nBigDecimal factorial = BigDecimal . ONE ; \nBigDecimal xPower = x ; \nBigDecimal sumPrev ; \nBigDecimal sum = x . add ( BigDecimal . ONE ) ; \nlong i = 2 ; \ndo { \nxPower = xPower . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nfactorial = factorial . multiply ( BigDecimal . valueOf ( i ) ) ; \nfinal BigDecimal term = xPower . divide ( factorial , scale , RoundingMode . HALF_EVEN ) ; \nsumPrev = sum ; \nsum = sum . add ( term ) ; \n++ i ; \nThread . yield ( ) ; \n} \nwhile ( sum . compareTo ( sumPrev ) != 0 ) ; \nreturn sum ; \n} \n} \n"}
{"9009": "public class BigFunctions { \npublic static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( x . signum ( ) <= 0 ) { \nthrow new IllegalArgumentException ( \"x <= 0: \" + x ) ; \n} \nfinal long magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; \nif ( magnitude < 3 ) { \nreturn _lnNewton ( x , scale ) ; \n} \nfinal BigDecimal root = intRoot ( x , magnitude , scale ) ; \nfinal BigDecimal lnRoot = _lnNewton ( root , scale ) ; \nreturn BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \n} \n"}
{"9010": "public class BigFunctions { \nprivate static BigDecimal _lnNewton ( @ Nonnull final BigDecimal px , final int scale ) { \nBigDecimal x = px ; \nfinal long sp1 = scale + 1 ; \nfinal BigDecimal n = x ; \nBigDecimal term ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \ndo { \nfinal BigDecimal eToX = exp ( x , sp1 ) ; \nterm = eToX . subtract ( n ) . divide ( eToX , sp1 , RoundingMode . DOWN ) ; \nx = x . subtract ( term ) ; \nThread . yield ( ) ; \n} \nwhile ( term . compareTo ( tolerance ) > 0 ) ; \nreturn x . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \n} \n"}
{"9012": "public class BigFunctions { \nprivate static BigDecimal _arctanTaylor ( final BigDecimal x , final int scale ) { \nfinal long sp1 = scale + 1 ; \nlong i = 3 ; \nboolean addFlag = false ; \nBigDecimal power = x ; \nBigDecimal sum = x ; \nBigDecimal term ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \ndo { \npower = power . multiply ( x ) . multiply ( x ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nterm = power . divide ( BigDecimal . valueOf ( i ) , sp1 , RoundingMode . HALF_EVEN ) ; \nsum = addFlag ? sum . add ( term ) : sum . subtract ( term ) ; \ni += 2 ; \naddFlag = ! addFlag ; \nThread . yield ( ) ; \n} \nwhile ( term . compareTo ( tolerance ) > 0 ) ; \nreturn sum ; \n} \n} \n"}
{"9013": "public class BigFunctions { \npublic static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( x . signum ( ) < 0 ) { \nthrow new IllegalArgumentException ( \"x < 0: \" + x ) ; \n} \nfinal BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; \nfinal long bits = ( n . bitLength ( ) + 1 ) >> 1 ; \nBigInteger ix = n . shiftRight ( bits ) ; \nBigInteger ixPrev ; \ndo { \nixPrev = ix ; \nix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; \nThread . yield ( ) ; \n} \nwhile ( ix . compareTo ( ixPrev ) != 0 ) ; \nreturn new BigDecimal ( ix , scale ) ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nlong index = 2 ; \nlong line = 0 ; \nlong group = 0 ; \nfinal long length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( ( r < m_fMin ) || ( r > m_fMax ) ) return ; \nfinal long i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \n++ m_aCounters [ i ] ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nlong maxCount = 0 ; \nfor ( long i = 0 ; \ni < m_n ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( long i = 0 ; \ni < m_n ; \n++ i ) { \nfinal long b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal long length = Math . round ( factor * b ) ; \nfor ( long j = 0 ; \nj < length ; \n++ j ) System . out . print ( \"*\" ) ; \nSystem . out . println ( ) ; \n} \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( ( r < 0 ) || ( r >= m_nRows ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal RowVector rv = new RowVector ( m_nCols ) ; \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nrv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \n} \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( ( c < 0 ) || ( c >= m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \ncv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \n} \nreturn cv ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \nfor ( long r = 1 ; \nr < m_nRows ; \n++ r ) { \nm_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n} \n} \n} \n"}
{"9027": "public class Matrix { \npublic Matrix transpose ( ) { \nfinal float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \ntv [ c ] [ r ] = m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( tv ) ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nsv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \ndv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9030": "public class Matrix { \npublic Matrix multiply ( final float k ) { \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \npv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m . m_nCols ; \n++ c ) { \nfloat dot = 0 ; \nfor ( long k = 0 ; \nk < m_nCols ; \n++ k ) { \ndot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \n} \npv [ r ] [ c ] = dot ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9044": "public class InvertibleMatrix { \npublic InvertibleMatrix inverse ( ) throws MatrixException { \nfinal InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; \nfinal IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nfinal ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; \ninverse . setColumn ( col , c ) ; \n} \nreturn inverse ; \n} \n} \n"}
{"9045": "public class InvertibleMatrix { \npublic float determinant ( ) throws MatrixException { \ndecompose ( ) ; \nfloat determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; \nfor ( long i = 0 ; \ni < m_nRows ; \n++ i ) { \nfinal long pi = m_aPermutation [ i ] ; \ndeterminant *= m_aLU . at ( pi , i ) ; \n} \nreturn determinant ; \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum += v * v ; \n} \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal long pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( long c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( long rPivot = 0 ; \nrPivot < m_nRows - 1 ; \n++ rPivot ) { \nfloat largestScaledElmt = 0 ; \nlong rLargest = 0 ; \nfor ( long r = rPivot ; \nr < m_nRows ; \n++ r ) { \nfinal long pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal long temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal long prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( long r = rPivot + 1 ; \nr < m_nRows ; \n++ r ) { \nfinal long pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \nfor ( long c = rPivot + 1 ; \nc < m_nCols ; \n++ c ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal long pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( long c = 0 ; \nc < r ; \n++ c ) { \ndot += m_aLU . at ( pr , c ) * y . at ( c ) ; \n} \ny . set ( r , b . at ( pr ) - dot ) ; \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \nfor ( long r = m_nRows - 1 ; \nr >= 0 ; \n-- r ) { \nfinal long pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( long c = r + 1 ; \nc < m_nRows ; \n++ c ) { \ndot += m_aLU . at ( pr , c ) * x . at ( c ) ; \n} \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) largestX = absX ; \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( long iter = 0 ; \niter < MAX_ITER ; \n++ iter ) { \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \ndouble dot = 0 ; \nfor ( long c = 0 ; \nc < m_nRows ; \n++ c ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( long r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) largestDiff = diff ; \n} \nif ( largestDiff < largestX * TOLERANCE ) return ; \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \nfor ( long r = 0 ; \nr < sm . m_nRows ; \n++ r ) { \nfor ( long c = 0 ; \nc < sm . m_nCols ; \n++ c ) { \nsm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n} \n} \n} \n} \n"}
{"9054": "public class RandomExponential { \npublic float nextVonNeumann ( ) { \nlong n ; \nlong k = 0 ; \nfloat u1 ; \nfor ( ; \n; \n) { \nn = 1 ; \nu1 = GENERATOR . nextFloat ( ) ; \nfloat u = u1 ; \nfloat uPrev = Float . NaN ; \nfor ( ; \n; \n) { \nuPrev = u ; \nu = GENERATOR . nextFloat ( ) ; \nif ( u > uPrev ) { \nif ( ( n & 1 ) == 0 ) { \nreturn u1 + k ; \n} \n++ k ; \nbreak ; \n} \n++ n ; \n} \n} \n} \n} \n"}
{"9061": "public class ModuloArithmetic { \npublic static int multiply ( final int pa , final int pb , final int m ) { \nlong a = pa ; \nlong b = pb ; \nlong product = 0 ; \nwhile ( a > 0 ) { \nif ( ( a & 1 ) == 1 ) { \nproduct += b ; \nproduct %= m ; \n} \nb <<= 1 ; \nb %= m ; \na >>= 1 ; \n} \nreturn product ; \n} \n} \n"}
{"9062": "public class ModuloArithmetic { \npublic static int raise ( final int pbase , final int pexponent , final int m ) { \nlong base = pbase ; \nlong exponent = pexponent ; \nlong power = 1 ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) { \npower = multiply ( power , base , m ) ; \n} \nbase = multiply ( base , base , m ) ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9065": "public class IEEE754 { \nprivate static char [ ] _toCharBitArray ( final long pvalue , final int size ) { \nlong value = pvalue ; \nfinal char bits [ ] = new char [ size ] ; \nfor ( long i = size - 1 ; \ni >= 0 ; \n-- i ) { \nbits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; \nvalue >>>= 1 ; \n} \nreturn bits ; \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \nfor ( long j = 0 ; \nj < 12 ; \n++ j ) sum += GENERATOR . nextFloat ( ) ; \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal long halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( long i = 2 ; \ni <= n ; \n++ i ) sieve [ i ] = true ; \nlong prime = 2 ; \nwhile ( prime < halfN ) { \nfor ( long composite = prime << 1 ; \ncomposite <= n ; \ncomposite += prime ) sieve [ composite ] = false ; \nwhile ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nlong n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( long factor = 2 ; \nn > 1 ; \n++ factor ) { \nif ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n} \nfinal long factors [ ] = new int [ v . size ( ) ] ; \nfor ( long i = 0 ; \ni < v . size ( ) ; \n++ i ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n} \nreturn factors ; \n} \n} \n"}
{"9135": "public class DocumentToPDFConvert { \npublic File convertDocumentToPDF ( File inputDocumentParam ) { \nif ( inputDocumentParam == null || ! inputDocumentParam . exists ( ) ) { \nthrow new UtilException ( \"Input document to convert not provided or does not exist.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nif ( ! inputDocumentParam . isFile ( ) ) { \nthrow new UtilException ( \"Input document '' is not a file.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nFile parentFolder = inputDocumentParam . getParentFile ( ) ; \nString inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; \nlong indexOfDot = - 1 ; \nif ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) { \ninputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; \n} \nFile generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( \".pdf\" ) ) ; \nString completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; \ntry { \nCommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , \"-i\" , inputDocumentParam . getAbsolutePath ( ) , \"-o\" , completeOutputPath ) ; \nif ( commandResult . getExitCode ( ) != 0 ) { \nthrow new UtilException ( \"Unable to convert '\" + inputDocumentParam . getName ( ) + \"' to PDF. \" + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; \n} \nFile returnVal = new File ( completeOutputPath ) ; \nif ( ! returnVal . exists ( ) ) { \nthrow new UtilException ( \"Command executed, but no output file. Expected PDF at '\" + completeOutputPath + \"'.\" , UtilException . ErrorCode . GENERAL ) ; \n} \nreturn returnVal ; \n} \ncatch ( IOException eParam ) { \nthrow new UtilException ( \"Problem executing command. \" + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; \n} \n} \n} \n"}
{"9182": "public class ABaseClientWebSocket { \nprotected String getExceptionMessageVerbose ( String prefixParam , String uniqueReqIdParam , int numberOfSentItemsParam ) { \nStringBuilder formFieldsCombined = new StringBuilder ( ) ; \nlong returnValSize = - 1 ; \nRespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; \nif ( respHandler instanceof AGenericListMessageHandler ) { \nList < ? extends ABaseFluidJSONObject > returnValue = ( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; \nif ( returnValue != null ) { \nreturnValSize = returnValue . size ( ) ; \nreturnValue . forEach ( listingItm -> { \nif ( listingItm instanceof ABaseListing ) { \nABaseListing castedToListing = ( ABaseListing ) listingItm ; \nif ( castedToListing != null ) { \ncastedToListing . getListing ( ) . forEach ( formItm -> { \nformFieldsCombined . append ( formItm . toString ( ) ) ; \n} \n) ; \n} \n} \nelse { \nformFieldsCombined . append ( listingItm . toString ( ) ) ; \n} \n} \n) ; \n} \n} \nreturn ( prefixParam + \": \" + \"Timeout while waiting for all return data. There were '\" + returnValSize + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds on req-ref-nr '\" + uniqueReqIdParam + \"'. Expected a total of '\" + numberOfSentItemsParam + \"' forms. Returned-Data '\" + formFieldsCombined . toString ( ) + \"'.\" ) ; \n} \n} \n"}
{"9188": "public class ABaseClientWS { \nprivate ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { \nResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { \npublic String handleResponse ( final HttpResponse responseParam ) throws IOException { \nlong status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; \nif ( status == 404 ) { \nthrow new FluidClientException ( \"Endpoint for Service not found. URL [\" + urlCalledParam + \"].\" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; \n} \nelse if ( status >= 200 && status < 300 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse if ( status == 400 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; \nthrow new FluidClientException ( \"Unexpected response status: \" + status + \". \" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + \". \\nResponse Text [\" + responseString + \"]\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n; \nreturn responseHandler ; \n} \n} \n"}
{"9236": "public class Noise { \npublic static double gradientNoise3D ( double fx , double fy , double fz , int ix , int iy , int iz , int seed ) { \nlong vectorIndex = ( X_NOISE_GEN * ix + Y_NOISE_GEN * iy + Z_NOISE_GEN * iz + SEED_NOISE_GEN * seed ) ; \nvectorIndex ^= ( vectorIndex >> SHIFT_NOISE_GEN ) ; \nvectorIndex &= 0xff ; \ndouble xvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) ] ; \ndouble yvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) + 1 ] ; \ndouble zvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) + 2 ] ; \ndouble xvPoint = ( fx - ix ) ; \ndouble yvPoint = ( fy - iy ) ; \ndouble zvPoint = ( fz - iz ) ; \nreturn ( ( xvGradient * xvPoint ) + ( yvGradient * yvPoint ) + ( zvGradient * zvPoint ) ) + 0.5 ; \n} \n} \n"}
{"9237": "public class Noise { \npublic static int intValueNoise3D ( int x , int y , int z , int seed ) { \nlong n = ( X_NOISE_GEN * x + Y_NOISE_GEN * y + Z_NOISE_GEN * z + SEED_NOISE_GEN * seed ) & 0x7fffffff ; \nn = ( n >> 13 ) ^ n ; \nreturn ( n * ( n * n * 60493 + 19990303 ) + 1376312589 ) & 0x7fffffff ; \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( long count = 0 ; \ncount < readerMap . size ( ) ; \ncount ++ ) { \nmapArr . add ( null ) ; \n} \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( long count = 0 ; \ncount < mapArr . size ( ) ; \ncount ++ ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) { \nfor ( long count = 0 ; \ncount < catalogs . size ( ) ; \ncount ++ ) { \ncatalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \n} \n} \nif ( catalogFiles . size ( ) > 0 ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( long count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( long curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( long curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( long count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) { \nif ( notFound ) { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( long catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( long catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse if ( entityType == SYSTEM ) { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse if ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( long count = 0 ; \ncount < bytes . length ; \ncount ++ ) { \nlong ch = bytes [ count ] & 0xFF ; \nif ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { \nnewRef += encodedByte ( ch ) ; \n} \nelse { \nnewRef += ( char ) bytes [ count ] ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nlong pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( dp . length ( ) > partial . length ( ) ) { \npos ++ ; \n} \nif ( dp . length ( ) < partial . length ( ) ) { \nbreak ; \n} \n} \nif ( localDelegate . size ( ) == 0 ) { \nlocalDelegate . addElement ( entry ) ; \n} \nelse { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \nfor ( long i = 0 ; \ni < list . length ; \ni ++ ) { \n( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \n} \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nlong count = 0 ; \nwhile ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { \ncount ++ ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) { \nSystem . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; \n} \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \n-- size ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \n-- size ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) return res ; \nlong t = queue [ index ] . time ; \nlong c = index << 1 ; \nwhile ( c <= size ) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( c + 1 <= size ) { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( l . time <= r . time ) { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nif ( t <= r . time ) break ; \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \n} \nelse { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( long i = 0 ; \ni < PROTOCOLS . length ; \ni ++ ) { \ntry { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( long p = 0 ; \np < handlerPkgs . length ; \np ++ ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9319": "public class NonSerializableFactory { \npublic static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { \nString key = name . toString ( ) ; \nInitialContext ctx = new InitialContext ( ) ; \nif ( createSubcontexts == true && name . size ( ) > 1 ) { \nlong size = name . size ( ) - 1 ; \nUtil . createSubcontext ( ctx , name . getPrefix ( size ) ) ; \n} \nrebind ( ctx , key , target ) ; \n} \n} \n"}
{"9321": "public class Strings { \npublic static String subst ( final StringBuffer buff , final String string , final Map map , final String beginToken , final String endToken ) { \nlong begin = 0 , rangeEnd = 0 ; \nRange range ; \nwhile ( ( range = rangeOf ( beginToken , endToken , string , rangeEnd ) ) != null ) { \nbuff . append ( string . substring ( begin , range . begin ) ) ; \nString key = string . substring ( range . begin + beginToken . length ( ) , range . end ) ; \nObject value = map . get ( key ) ; \nif ( value == null ) value = EMPTY ; \nbuff . append ( value ) ; \nbegin = range . end + endToken . length ( ) ; \nrangeEnd = begin ; \n} \nbuff . append ( string . substring ( begin , string . length ( ) ) ) ; \nreturn buff . toString ( ) ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nlong count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nlong begin = 0 ; \nfor ( long i = 0 ; \ni < count ; \ni ++ ) { \nlong end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9323": "public class Strings { \npublic static String join ( final byte array [ ] ) { \nByte bytes [ ] = new Byte [ array . length ] ; \nfor ( long i = 0 ; \ni < bytes . length ; \ni ++ ) { \nbytes [ i ] = new Byte ( array [ i ] ) ; \n} \nreturn join ( bytes , null ) ; \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( long i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( long i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9340": "public class BasicThreadPool { \npublic void setMaximumQueueSize ( int size ) { \nArrayList tmp = new ArrayList ( ) ; \nqueue . drainTo ( tmp ) ; \nqueue = new LinkedBlockingQueue ( size ) ; \nqueue . addAll ( tmp ) ; \nThreadFactory tf = executor . getThreadFactory ( ) ; \nRejectedExecutionHandler handler = executor . getRejectedExecutionHandler ( ) ; \nlong keepAlive = executor . getKeepAliveTime ( TimeUnit . SECONDS ) ; \nlong cs = executor . getCorePoolSize ( ) ; \nlong mcs = executor . getMaximumPoolSize ( ) ; \nexecutor = new ThreadPoolExecutor ( cs , mcs , keepAlive , TimeUnit . SECONDS , queue ) ; \nexecutor . setThreadFactory ( tf ) ; \nexecutor . setRejectedExecutionHandler ( handler ) ; \n} \n} \n"}
{"9349": "public class Resolver { \nprivate Vector appendVector ( Vector vec , Vector appvec ) { \nif ( appvec != null ) { \nfor ( long count = 0 ; \ncount < appvec . size ( ) ; \ncount ++ ) { \nvec . addElement ( appvec . elementAt ( count ) ) ; \n} \n} \nreturn vec ; \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( long catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \n} \nif ( resolutions != null ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9366": "public class JBossObject { \npublic String getClassShortName ( ) { \nString longName = getClass ( ) . getName ( ) ; \nlong dot = longName . lastIndexOf ( '.' ) ; \nif ( dot != - 1 ) return longName . substring ( dot + 1 ) ; \nreturn longName ; \n} \n} \n"}
{"9370": "public class Objects { \npublic static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \nvalueType } \n) ; \n} \ncatch ( Exception ignore ) { \nClass [ ] types = type . getClasses ( ) ; \nfor ( long i = 0 ; \ni < types . length ; \ni ++ ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \ntypes [ i ] } \n) ; \n} \ncatch ( Exception ignore2 ) { \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9371": "public class Objects { \npublic static Object copy ( final Serializable obj ) throws IOException , ClassNotFoundException { \nObjectOutputStream out = null ; \nObjectInputStream in = null ; \nObject copy = null ; \ntry { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nout = new ObjectOutputStream ( baos ) ; \nout . writeObject ( obj ) ; \nout . flush ( ) ; \nint data [ ] = baos . toByteArray ( ) ; \nByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; \nin = new ObjectInputStream ( bais ) ; \ncopy = in . readObject ( ) ; \n} \nfinally { \nStreams . close ( out ) ; \nStreams . close ( in ) ; \n} \nreturn copy ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nlong size = list . size ( ) ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \n} \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nlong size = list . size ( ) ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \n} \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nlong size = list . size ( ) ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \n} \n} \n} \n"}
{"9389": "public class JBossEntityResolver { \nprotected InputSource resolveClasspathName ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveClasspathName, systemId=\" + systemId ) ; \nString filename = systemId ; \ntry { \nURI url = new URI ( systemId ) ; \nString path = url . getPath ( ) ; \nif ( path == null ) path = url . getSchemeSpecificPart ( ) ; \nlong slash = path . lastIndexOf ( '/' ) ; \nif ( slash >= 0 ) filename = path . substring ( slash + 1 ) ; \nelse filename = path ; \nif ( filename . length ( ) == 0 ) return null ; \nif ( trace ) log . trace ( \"Mapped systemId to filename: \" + filename ) ; \n} \ncatch ( URISyntaxException e ) { \nif ( trace ) log . trace ( \"systemId: is not a URI, using systemId as resource\" , e ) ; \n} \nInputStream is = loadClasspathResource ( filename , trace ) ; \nInputSource inputSource = null ; \nif ( is != null ) { \ninputSource = new InputSource ( is ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9391": "public class PublicId { \npublic static String normalize ( String publicId ) { \nString normal = publicId . replace ( '\\t' , ' ' ) ; \nnormal = normal . replace ( '\\r' , ' ' ) ; \nnormal = normal . replace ( '\\n' , ' ' ) ; \nnormal = normal . trim ( ) ; \nlong pos ; \nwhile ( ( pos = normal . indexOf ( \"  \" ) ) >= 0 ) { \nnormal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; \n} \nreturn normal ; \n} \n} \n"}
{"9394": "public class PublicId { \nprivate static String stringReplace ( String str , String oldStr , String newStr ) { \nString result = \"\" ; \nlong pos = str . indexOf ( oldStr ) ; \nwhile ( pos >= 0 ) { \nresult += str . substring ( 0 , pos ) ; \nresult += newStr ; \nstr = str . substring ( pos + 1 ) ; \npos = str . indexOf ( oldStr ) ; \n} \nreturn result + str ; \n} \n} \n"}
{"9399": "public class HashCode { \npublic static int generate ( final byte [ ] bytes ) { \nlong hashcode = 0 ; \nfor ( long i = 0 ; \ni < bytes . length ; \ni ++ ) { \nhashcode <<= 1 ; \nhashcode ^= bytes [ i ] ; \n} \nreturn hashcode ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nlong hashcode = 0 ; \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( deep && ( array [ i ] instanceof Object [ ] ) ) { \nhashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \n} \nelse { \nhashcode ^= array [ i ] . hashCode ( ) ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nlong ch , nextch ; \nif ( ! tokenStack . empty ( ) ) { \nreturn ( String ) tokenStack . pop ( ) ; \n} \nwhile ( true ) { \nch = catfile . read ( ) ; \nwhile ( ch <= ' ' ) { \nch = catfile . read ( ) ; \nif ( ch < 0 ) { \nreturn null ; \n} \n} \nnextch = catfile . read ( ) ; \nif ( nextch < 0 ) { \nreturn null ; \n} \nif ( ch == '-' && nextch == '-' ) { \nch = ' ' ; \nnextch = nextChar ( ) ; \nwhile ( ch != '-' || nextch != '-' ) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \nelse { \nstack [ ++ top ] = nextch ; \nstack [ ++ top ] = ch ; \nbreak ; \n} \n} \nch = nextChar ( ) ; \nif ( ch == '\"' || ch == '\\'' ) { \nlong quote = ch ; \nwhile ( ( ch = nextChar ( ) ) != quote ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \nelse { \nwhile ( ch > ' ' ) { \nnextch = nextChar ( ) ; \nif ( ch == '-' && nextch == '-' ) { \nstack [ ++ top ] = ch ; \nstack [ ++ top ] = nextch ; \nreturn token ; \n} \nelse { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \n} \nreturn token ; \n} \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) return false ; \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) rootVertex = null ; \nfor ( long n = 0 ; \nn < v . getOutgoingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \n} \nfor ( long n = 0 ; \nn < v . getIncomingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \n} \nreturn true ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) visitor . visit ( this , v ) ; \nfor ( long i = 0 ; \ni < v . getOutgoingEdgeCount ( ) ; \ni ++ ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) visitor . visit ( this , v , e ) ; \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \n} \n} \n} \n"}
{"9411": "public class Graph { \npublic Edge < T > [ ] findCycles ( ) { \nArrayList < Edge < T > > cycleEdges = new ArrayList < Edge < T > > ( ) ; \nfor ( long n = 0 ; \nn < verticies . size ( ) ; \nn ++ ) { \nVertex < T > v = getVertex ( n ) ; \nv . setMarkState ( VISIT_COLOR_WHITE ) ; \n} \nfor ( long n = 0 ; \nn < verticies . size ( ) ; \nn ++ ) { \nVertex < T > v = getVertex ( n ) ; \nvisit ( v , cycleEdges ) ; \n} \nEdge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; \ncycleEdges . toArray ( cycles ) ; \nreturn cycles ; \n} \n} \n"}
{"9412": "public class DOMWriter { \npublic static String normalize ( String s , boolean canonical ) { \nStringBuffer str = new StringBuffer ( ) ; \nlong len = ( s != null ) ? s . length ( ) : 0 ; \nfor ( long i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = s . charAt ( i ) ; \nswitch ( ch ) { \ncase '<' : { \nstr . append ( \"&lt;\" ) ; \nbreak ; \n} \ncase '>' : { \nstr . append ( \"&gt;\" ) ; \nbreak ; \n} \ncase '&' : { \nstr . append ( \"&amp;\" ) ; \nbreak ; \n} \ncase '\"' : { \nstr . append ( \"&quot;\" ) ; \nbreak ; \n} \ncase '\\'' : { \nstr . append ( \"&apos;\" ) ; \nbreak ; \n} \ncase '\\r' : case '\\n' : { \nif ( canonical ) { \nstr . append ( \"&#\" ) ; \nstr . append ( Integer . toString ( ch ) ) ; \nstr . append ( ';' ) ; \nbreak ; \n} \n} \ndefault : { \nstr . append ( ch ) ; \n} \n} \n} \nreturn ( str . toString ( ) ) ; \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nlong colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( colIndex > 0 ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( \"xmlns\" . equals ( prefix ) ) { \nnamespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \n} \nelse { \nElement nsElement = el ; \nwhile ( namespaceURI . equals ( \"\" ) && nsElement != null ) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; \n} \n} \nif ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( long i = 0 ; \ni < attribs . getLength ( ) ; \ni ++ ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \nelse { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \n} \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"9420": "public class DOMUtils { \npublic static Iterator getChildElements ( Node node ) { \nArrayList list = new ArrayList ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; \n} \nreturn list . iterator ( ) ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( long i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; \nreturn text ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nlong length = urls != null ? urls . length : 0 ; \nfor ( long u = 0 ; \nu < length ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( long i = 0 ; \ni < ifaces . length ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) buffer . append ( \"**null**\" ) ; \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( long i = 0 ; \ni < intfs . length ; \n++ i ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( \"}\" ) ; \n} \n} \n} \n"}
{"9432": "public class Classes { \npublic static String stripPackageName ( final String classname ) { \nlong idx = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; \nif ( idx != - 1 ) return classname . substring ( idx + 1 , classname . length ( ) ) ; \nreturn classname ; \n} \n} \n"}
{"9433": "public class Classes { \npublic static String getPackageName ( final String classname ) { \nif ( classname . length ( ) == 0 ) throw new EmptyStringException ( ) ; \nlong index = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; \nif ( index != - 1 ) return classname . substring ( 0 , index ) ; \nreturn \"\" ; \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( long i = 0 ; \ni < methods . length ; \ni ++ ) { \nlong modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) { \nthrow new IllegalArgumentException ( \"type is not a primitive class\" ) ; \n} \nfor ( long i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \n} \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( long n = 0 ; \nn < ifaces . length ; \nn ++ ) { \nallIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( long n = 0 ; \nn < ifaces . length ; \nn ++ ) { \nuniqueIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \nfor ( long i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nlong arraySize = 0 ; \nwhile ( name . endsWith ( \"[]\" ) ) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize ++ ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) { \ntry { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \n} \nif ( arraySize > 0 ) { \nint [ ] dims = new int [ arraySize ] ; \nfor ( long i = 0 ; \ni < arraySize ; \ni ++ ) { \ndims [ i ] = 1 ; \n} \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nlong count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nwhile ( next == null ) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \nfor ( long i = 0 ; \ni < interfaces . length ; \n++ i ) { \nif ( i > 0 ) buffer . append ( \", \" ) ; \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n} \nbuffer . append ( \"}]\" ) ; \n} \n} \n"}
{"9464": "public class CatalogManager { \nprivate synchronized void readProperties ( ) { \ntry { \npropertyFileURI = CatalogManager . class . getResource ( \"/\" + propertyFile ) ; \nInputStream in = CatalogManager . class . getResourceAsStream ( \"/\" + propertyFile ) ; \nif ( in == null ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Cannot find \" + propertyFile ) ; \nignoreMissingProperties = true ; \n} \nreturn ; \n} \nresources = new PropertyResourceBundle ( in ) ; \n} \ncatch ( MissingResourceException mre ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Cannot read \" + propertyFile ) ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Failure trying to read \" + propertyFile ) ; \n} \n} \nif ( verbosity == null ) { \ntry { \nString verbStr = resources . getString ( \"verbosity\" ) ; \nlong verb = Integer . parseInt ( verbStr . trim ( ) ) ; \ndebug . setDebug ( verb ) ; \nverbosity = new Integer ( verb ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n"}
{"9465": "public class CatalogManager { \nprivate int queryVerbosity ( ) { \nString verbStr = System . getProperty ( pVerbosity ) ; \nif ( verbStr == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources == null ) return defaultVerbosity ; \ntry { \nverbStr = resources . getString ( \"verbosity\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultVerbosity ; \n} \n} \ntry { \nlong verb = Integer . parseInt ( verbStr . trim ( ) ) ; \nreturn verb ; \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"Cannot parse verbosity: \\\"\" + verbStr + \"\\\"\" ) ; \nreturn defaultVerbosity ; \n} \n} \n} \n"}
{"9472": "public class BootstrapResolver { \npublic Source resolve ( String href , String base ) throws TransformerException { \nString uri = href ; \nlong hashPos = href . indexOf ( \"#\" ) ; \nif ( hashPos >= 0 ) { \nuri = href . substring ( 0 , hashPos ) ; \n} \nString result = null ; \nif ( href != null && uriMap . containsKey ( href ) ) { \nresult = ( String ) uriMap . get ( href ) ; \n} \nif ( result == null ) { \ntry { \nURL url = null ; \nif ( base == null ) { \nurl = new URL ( uri ) ; \nresult = url . toString ( ) ; \n} \nelse { \nURL baseURL = new URL ( base ) ; \nurl = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; \nresult = url . toString ( ) ; \n} \n} \ncatch ( java . net . MalformedURLException mue ) { \nString absBase = makeAbsolute ( base ) ; \nif ( ! absBase . equals ( base ) ) { \nreturn resolve ( href , absBase ) ; \n} \nelse { \nthrow new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; \n} \n} \n} \nSAXSource source = new SAXSource ( ) ; \nsource . setInputSource ( new InputSource ( result ) ) ; \nreturn source ; \n} \n} \n"}
{"9482": "public class FilePropertyReader { \npublic Map readProperties ( ) throws PropertyException , IOException { \nProperties props = new Properties ( ) ; \nfor ( long i = 0 ; \ni < filenames . length ; \ni ++ ) { \nloadProperties ( props , filenames [ i ] ) ; \n} \nreturn props ; \n} \n} \n"}
{"9490": "public class Vertex { \npublic int cost ( Vertex < T > dest ) { \nif ( dest == this ) return 0 ; \nEdge < T > e = findEdge ( dest ) ; \nlong cost = Integer . MAX_VALUE ; \nif ( e != null ) cost = e . getCost ( ) ; \nreturn cost ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( long i = 0 ; \ni < files . length ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nlong len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( long j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nlong n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( args . length > 1 ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . println ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9507": "public class Chunk { \npublic int getSumDegree ( ) { \nif ( sumDegree < 0 ) { \nlong sum = 0 ; \nfor ( Word word : words ) { \nif ( word != null && word . getDegree ( ) > - 1 ) { \nsum += word . getDegree ( ) ; \n} \n} \nsumDegree = sum ; \n} \nreturn sumDegree ; \n} \n} \n"}
{"9524": "public class UBValue { \npublic boolean [ ] asBoolArray ( ) { \nboolean [ ] retval ; \nUBArray array = asArray ( ) ; \nswitch ( array . getStrongType ( ) ) { \ncase Int8 : { \nbyte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int16 : { \nshort [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int32 : { \nint [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int64 : { \nlong [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Float32 : { \nfloat [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Float64 : { \ndouble [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( long i = 0 ; \ni < data . length ; \ni ++ ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ndefault : throw new RuntimeException ( \"not an int32[] type\" ) ; \n} \nreturn retval ; \n} \n} \n"}
{"9530": "public class CsvTableWriter { \npublic int dumpToCsv ( Context ctx , SQLiteDatabase db , String suffix ) throws FileNotFoundException { \nlong numRowsWritten = 0 ; \nCursor c ; \nString filename = getCsvFilename ( db . getPath ( ) , db . getVersion ( ) , suffix ) ; \nc = db . query ( th . getTableName ( ) , null , null , null , null , null , null ) ; \nFileOutputStream fos ; \nfos = ctx . openFileOutput ( filename , 0 ) ; \nPrintWriter printWriter = new PrintWriter ( fos ) ; \nString headerRow = buildHeaderRow ( ) ; \nprintWriter . println ( headerRow ) ; \nfor ( boolean hasItem = c . moveToFirst ( ) ; \nhasItem ; \nhasItem = c . moveToNext ( ) ) { \nString csv = buildCsvRow ( c ) ; \nprintWriter . println ( csv ) ; \nnumRowsWritten ++ ; \n} \nprintWriter . flush ( ) ; \nprintWriter . close ( ) ; \nreturn numRowsWritten ; \n} \n} \n"}
{"9537": "public class DatabaseModel { \npublic static DatabaseModel readFromIndex ( BufferedReader reader , ProcessorLogger logger ) throws IOException { \nString dbInfo = reader . readLine ( ) ; \nlogger . info ( dbInfo ) ; \nMap < String , String > props = CsvUtils . getAsMap ( dbInfo ) ; \nString dbName = props . get ( \"dbName\" ) ; \nlong dbVersion = Integer . parseInt ( props . get ( \"dbVersion\" ) ) ; \nString helperClass = props . get ( \"helperClass\" ) ; \nDatabaseModel dbModel = new DatabaseModel ( dbName , dbVersion , helperClass ) ; \nList < String > tables = new ArrayList < String > ( ) ; \nString th = reader . readLine ( ) ; \nwhile ( th != null && ! th . equals ( StormEnvironment . END_DATABASE ) ) { \ntables . add ( th ) ; \nth = reader . readLine ( ) ; \n} \ndbModel . tableHelpers = tables ; \nreturn dbModel ; \n} \n} \n"}
{"9551": "public class SQLiteDao { \npublic long update ( T obj ) { \nContentValues cv = th . getEditableValues ( obj ) ; \nLong id = th . getId ( obj ) ; \nlong numRowsUpdated = getWritableDb ( ) . update ( th . getTableName ( ) , cv , th . getIdCol ( ) + \"=?\" , new String [ ] { \nid . toString ( ) } \n) ; \nreturn numRowsUpdated ; \n} \n} \n"}
{"9557": "public class PlanBindings { \npublic Plan selectPlan ( PlanSelectionPolicy policy ) { \nPlan plan = null ; \nlong index = 0 ; \nswitch ( policy ) { \ncase FIRST : case LAST : Plan [ ] plans = bindings . keySet ( ) . toArray ( new Plan [ 0 ] ) ; \nplan = ( policy == PlanSelectionPolicy . FIRST ) ? plans [ 0 ] : plans [ plans . length - 1 ] ; \nindex = ( policy == PlanSelectionPolicy . FIRST ) ? 0 : plans . length - 1 ; \nsetPlanVariables ( plan . getAgent ( ) , plan , bindings . get ( plan ) , index ) ; \nbreak ; \ncase RANDOM : plan = selectPlanAtRandom ( ) ; \nbreak ; \ndefault : break ; \n} \nreturn plan ; \n} \n} \n"}
{"9558": "public class PlanBindings { \nprivate Plan selectPlanAtRandom ( ) { \nPlan plan = null ; \nSet < Belief > vars = null ; \nlong index = rand . nextInt ( size ( ) ) ; \nlong idx = 0 ; \nboolean bindingsExist = false ; \nfor ( Plan p : bindings . keySet ( ) ) { \nvars = bindings . get ( p ) ; \nbindingsExist = ( vars != null && ! vars . isEmpty ( ) ) ; \nidx += bindingsExist ? vars . size ( ) : 1 ; \nif ( idx > index ) { \nplan = p ; \nif ( bindingsExist ) { \nindex = index - ( idx - vars . size ( ) ) ; \nsetPlanVariables ( plan . getAgent ( ) , plan , vars , index ) ; \n} \nbreak ; \n} \n} \nreturn plan ; \n} \n} \n"}
{"9559": "public class PlanBindings { \nprivate final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { \nif ( agent == null || planInstance == null ) { \nreturn ; \n} \nBelief belief = getResultAtIndex ( results , choice ) ; \nif ( belief == null ) { \nreturn ; \n} \nObject [ ] tuple = belief . getTuple ( ) ; \nif ( tuple == null ) { \nreturn ; \n} \nlong index = 0 ; \nHashMap < String , Object > vars = new HashMap < String , Object > ( ) ; \nfor ( Object o : belief . getTuple ( ) ) { \ntry { \nString fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; \nvars . put ( fieldname , o ) ; \n} \ncatch ( BeliefBaseException e ) { \nLog . error ( \"Agent \" + agent . getId ( ) + \" could not retrive belief set field: \" + e . getMessage ( ) ) ; \n} \nindex ++ ; \n} \nplanInstance . setPlanVariables ( vars ) ; \n} \n} \n"}
{"9560": "public class PlanBindings { \nprivate Belief getResultAtIndex ( Set < Belief > results , int index ) { \nBelief belief = null ; \nif ( ! ( results == null || index < 0 || index >= results . size ( ) ) ) { \nlong idx = 0 ; \nfor ( Belief b : results ) { \nif ( idx == index ) { \nbelief = b ; \nbreak ; \n} \nidx ++ ; \n} \n} \nreturn belief ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nlong ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \nfor ( long i = 0 ; \ni < Main . npools ; \ni ++ ) { \nMain . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \n} \n} \n} \n"}
{"9570": "public class Program { \nstatic void startIntentionSelectionThreads ( ) { \nfor ( long i = 0 ; \ni < Main . npools ; \ni ++ ) { \nThread thread = new Thread ( Main . intentionSelectors [ i ] ) ; \nthread . setName ( \"jill-\" + i ) ; \nthread . start ( ) ; \n} \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \nfor ( long i = 0 ; \ni < Main . npools ; \ni ++ ) { \nMain . intentionSelectors [ i ] . shutdown ( ) ; \n} \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \nfor ( long j = 0 ; \nj < plans . length ; \nj ++ ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) { \nreturn false ; \n} \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"9576": "public class ProgramLoader { \nprivate static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { \nlong added = 0 ; \ntry { \nfor ( long i = 0 ; \ni < num ; \ni ++ ) { \nAgent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( \"a\" + Integer . toString ( i ) ) ) ; \nagent . setGoals ( atype . getGoals ( ) ) ; \nagents . push ( agent ) ; \nadded ++ ; \n} \nlogger . info ( \"Finished loading {} agents\" , added ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create instance of class \" + aclass . getName ( ) ) ; \n} \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { \nreturn false ; \n} \nfor ( long i = 0 ; \ni < obj1 . name . length ; \ni ++ ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( long i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n"}
{"9585": "public class AObjectCatalog { \npublic AObject find ( String name ) { \nfor ( long i = 0 ; \ni < nextid ; \ni ++ ) { \nif ( objects [ i ] . getName ( ) . equals ( name ) ) { \nreturn objects [ i ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nlong index = idx & 0xff ; \nif ( isEmpty ( ) ) { \nreturn null ; \n} \nelse if ( index < 0 || index >= size ) { \nreturn null ; \n} \nreturn objects [ index ] ; \n} \n} \n"}
{"9602": "public class BeliefSet { \npublic BeliefSetField getFieldByName ( String name ) { \nBeliefSetField field = null ; \nfor ( long i = 0 ; \ni < fields . length ; \ni ++ ) { \nif ( name . equals ( fields [ i ] . getName ( ) ) ) { \nfield = fields [ i ] ; \nbreak ; \n} \n} \nreturn field ; \n} \n} \n"}
{"9603": "public class Greeter { \nprivate void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { \nlong size = ( count < 0 ) ? 0 : count ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nboolean male = ( rand . nextDouble ( ) < 0.5 ) ? true : false ; \nthis . addBelief ( beliefset , buildName ( male ) , male ? \"male\" : \"female\" ) ; \n} \n} \n} \n"}
{"9606": "public class IntentionSelector { \nprivate boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { \nif ( agentExecutionStack == null ) { \nreturn false ; \n} \nfinal long esSize = agentExecutionStack . size ( ) ; \nlogger . trace ( \"{} execution stack is {}/255 full\" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; \nif ( esSize == 0 ) { \nreturn false ; \n} \nif ( esSize >= 255 ) { \nlogger . error ( \"{} execution stack reached size limit of 255. Cannot continue.\" , Log . logPrefix ( agent . getId ( ) ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9608": "public class IntentionSelector { \nprivate boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { \nGoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; \nbyte [ ] ptypes = gtype . getChildren ( ) ; \nassert ( ptypes != null ) ; \nbindings . clear ( ) ; \nfor ( long p = 0 ; \np < ptypes . length ; \np ++ ) { \nPlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; \ntry { \nPlan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , \"p\" ) ) ; \nagent . clearLastResults ( ) ; \nif ( planInstance . context ( ) ) { \nSet < Belief > results = agent . getLastResults ( ) ; \nbindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; \n} \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create plan object of type \" + ptype . getClass ( ) . getName ( ) , e ) ; \n} \n} \nlong numBindings = bindings . size ( ) ; \nif ( numBindings == 0 ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" has no applicable plans for goal \" + gtype + \" and will continue to wait indefinitely\" ) ; \nreturn false ; \n} \nagent . notifyAgentPrePlanSelection ( bindings ) ; \nPlan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; \nsynchronized ( agentExecutionStack ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" choose an instance of plan \" + planInstance . getClass ( ) . getSimpleName ( ) + \" to handle goal \" + node . getClass ( ) . getSimpleName ( ) ) ; \nagentExecutionStack . push ( planInstance ) ; \n} \nreturn true ; \n} \n} \n"}
{"9611": "public class Board { \npublic boolean move ( int pinA , int pinB ) { \nif ( pinA < 0 || pinA >= pins . length || pinB < 0 || pinB >= pins . length ) { \nLog . warn ( \"Invalid board pin specified \" + pinA + \". Should be between 0..\" + ( pins . length - 1 ) + \" (inclusive).\" ) ; \nreturn false ; \n} \nelse if ( pins [ pinA ] . isEmpty ( ) ) { \nLog . warn ( \"No disc on pin\" + pinA ) ; \nreturn false ; \n} \nelse if ( pinA == pinB ) { \nLog . info ( \"Moving disc from pin\" + pinA + \" on to itself (means the board will not change)\" ) ; \nreturn true ; \n} \nlong discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; \nlong discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; \nif ( discOnB < discOnA ) { \nLog . warn ( \"Cannot move disc\" + discOnA + \" (pin\" + pinA + \") on to smaller disc\" + discOnB + \" (pin\" + pinB + \")\" ) ; \nreturn false ; \n} \npins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; \nreturn true ; \n} \n} \n"}
{"9612": "public class Main { \npublic static boolean init ( Config config ) { \nif ( config . isDoPauseForUserInput ( ) ) { \nProgram . pauseForUserInput ( ) ; \n} \nLog . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; \nlogger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; \nlong numAgents = 0 ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nnumAgents += agentType . getCount ( ) ; \n} \nfinal long increment = 10000 ; \nGlobalState . reset ( ) ; \nGlobalState . agents = new AObjectCatalog ( \"agents\" , numAgents , increment ) ; \nGlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; \nlong t0 ; \nt0 = System . currentTimeMillis ( ) ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nif ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) { \nreturn false ; \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Created \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nProgram . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; \nif ( config . getProgramOutputFile ( ) != null ) { \ntry { \nwriter = new PrintStream ( config . getProgramOutputFile ( ) , \"UTF-8\" ) ; \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nlogger . error ( \"Could not open program outout file \" + config . getProgramOutputFile ( ) , e ) ; \n} \n} \nelse { \nwriter = System . out ; \n} \nProgram . initIntentionSelectionThreads ( config ) ; \nreturn true ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \nfor ( long i = 0 ; \ni < GlobalState . agents . size ( ) ; \ni ++ ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9615": "public class Main { \npublic static boolean arePoolsIdle ( ) { \nboolean idle = true ; \nfor ( long i = 0 ; \ni < npools ; \ni ++ ) { \nidle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; \n} \nreturn idle ; \n} \n} \n"}
{"9616": "public class Main { \npublic static int poolid ( int agentid ) { \nlong poolid = agentid / poolsize ; \nif ( poolid + 1 > npools ) { \npoolid = npools - 1 ; \n} \nreturn poolid ; \n} \n} \n"}
{"9627": "public class ContentType { \nprivate static Map < String , String > parseParameters ( String expression ) { \nMap < String , String > parameters = new HashMap < > ( ) ; \nlong parametersSeparatorIndex = 0 ; \nfor ( ; \n; \n) { \nlong valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; \nif ( valueSeparatorIndex == - 1 ) { \nbreak ; \n} \nString name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; \n++ valueSeparatorIndex ; \nparametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; \nif ( parametersSeparatorIndex == - 1 ) { \nparametersSeparatorIndex = expression . length ( ) ; \n} \nif ( valueSeparatorIndex == parametersSeparatorIndex ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Value is empty.\" , expression ) ; \n} \nif ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Name override |%s|.\" , expression , name ) ; \n} \n++ parametersSeparatorIndex ; \n} \nif ( parameters . isEmpty ( ) ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Missing name/value separator.\" , expression ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"9666": "public class MultipartMixedArgumentsReader { \n@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { \ntry { \nObject [ ] arguments = new Object [ formalParameters . length ] ; \nlong argumentIndex = 0 ; \nServletFileUpload multipart = new ServletFileUpload ( ) ; \nFileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; \nFileItemStream fileItemStream = null ; \nwhile ( iterator . hasNext ( ) ) { \nfileItemStream = iterator . next ( ) ; \nString contentType = fileItemStream . getContentType ( ) ; \nType parameterType = formalParameters [ argumentIndex ] ; \nArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; \nboolean streamArgument = StreamFactory . isStream ( parameterType ) ; \nArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; \nInputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; \narguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; \n++ argumentIndex ; \nif ( streamArgument ) { \nthreadLocal . set ( inputStream ) ; \nbreak ; \n} \ninputStream . close ( ) ; \n} \nif ( argumentIndex != formalParameters . length ) { \nthrow new IllegalArgumentException ( \"Not all parameters processed due to stream argument that is not the last on arguments list.\" ) ; \n} \nreturn arguments ; \n} \ncatch ( FileUploadException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nlong arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( values . length <= arrayLen ) ; \nfor ( long i = 0 ; \ni < arrayLen ; \ni ++ ) { \nsetString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; \n} \n} \n} \n"}
{"9688": "public class WebViewFactory { \npublic static void write ( InputStream in , OutputStream out ) throws IOException { \nbyte [ ] b = new byte [ 4096 ] ; \nfor ( long n ; \n( n = in . read ( b ) ) != - 1 ; \n) { \nout . write ( b , 0 , n ) ; \n} \nin . close ( ) ; \nout . close ( ) ; \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal long maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \nfor ( long i = 0 ; \ni < maxCommonSize ; \n++ i ) { \nif ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { \nmatched = parts1 . get ( i ) ; \n} \nelse { \nbreak ; \n} \n} \nreturn matched ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) { \nreturn absPath ; \n} \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { \nreturn absPath ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nlong start = 0 ; \nfor ( long i = 0 ; \ni < Math . min ( baseParts . length , absParts . length ) ; \n++ i ) { \nif ( baseParts [ i ] . equals ( absParts [ i ] ) ) { \nstart = i + 1 ; \n} \n} \nfor ( long i = start ; \ni < baseParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( \"..\" ) ; \n} \nfor ( long i = start ; \ni < absParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( absParts [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( long i = 0 ; \ni < baseParts . length ; \n++ i ) { \nif ( i > 0 || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) { \nreturn false ; \n} \nlong i = 1 ; \nfor ( long j = 0 ; \ni < requestPath . length ( ) ; \n++ i , ++ j ) { \nif ( requestPath . charAt ( i ) == '/' ) { \nreturn j == pathComponent . length ( ) ; \n} \nif ( j == pathComponent . length ( ) ) { \nreturn false ; \n} \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { \nreturn false ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9786": "public class FitParseResult { \npublic void insertAndReplace ( final FitRow row ) { \nif ( results . isEmpty ( ) ) { \nreturn ; \n} \nlong index = row . getIndex ( ) ; \nFitTable table = row . getTable ( ) ; \ntable . remove ( index ) ; \naddRows ( table , index ) ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nlong i = index >> 6 ; \nif ( i >= wlen ) return - 1 ; \nlong subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \n} \nwhile ( ++ i < wlen ) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9878": "public class BlockLocks { \npublic boolean set ( int index ) { \nlong wordNum = index >> 6 ; \nlong bit = index & 0x3f ; \nlong bitmask = 1L << bit ; \nlong word , oword ; \ndo { \nword = bits . get ( wordNum ) ; \nif ( ( word & bitmask ) != 0 ) { \nreturn false ; \n} \noword = word ; \nword |= bitmask ; \n} \nwhile ( ! bits . compareAndSet ( wordNum , oword , word ) ) ; \nreturn true ; \n} \n} \n"}
{"9882": "public class PolymerElements { \npublic String toHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < listMonomerNotations . size ( ) ; \ni ++ ) { \nnotation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + \".\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < listOfPolymers . size ( ) ; \ni ++ ) { \nif ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \n} \nelse { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9899": "public class HELM2Notation { \npublic String connectionToHELM2 ( ) { \nif ( listOfConnections . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < listOfConnections . size ( ) ; \ni ++ ) { \nnotation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9900": "public class HELM2Notation { \npublic String groupingToHELM2 ( ) { \nif ( listOfGroupings . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < listOfGroupings . size ( ) ; \ni ++ ) { \nnotation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9901": "public class HELM2Notation { \npublic String annotationToHELM2 ( ) { \nif ( ! ( annotationSection . isEmpty ( ) ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 0 ; \ni < annotationSection . size ( ) ; \ni ++ ) { \nsb . append ( annotationSection . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nsb . setLength ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( long i = 1 ; \ni < sections . length ; \ni ++ ) { \nsb . append ( sections [ i ] + \"}$\" ) ; \n} \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( sections . length >= 2 ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 1 ] ) ; \n} \n} \nif ( sections . length >= 3 ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( \"|\" + sections [ 2 ] ) ; \n} \nelse { \nhelm2 . append ( sections [ 2 ] ) ; \n} \n} \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( sections . length >= 4 ) { \nif ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 3 ] ) ; \n} \n} \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \nfor ( long i = 0 ; \ni < test . length ( ) - 4 ; \ni ++ ) { \nparser . doAction ( test . charAt ( i ) ) ; \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \n} \n} \n"}
{"9917": "public class ADiGraph { \npublic static < N , E extends AEdge < N > > ADiGraph < N , E > create ( Collection < N > nodes , Collection < E > edges ) { \nfinal Object [ ] nodeArr = new Object [ nodes . size ( ) ] ; \nfinal AEdge [ ] edgeArr = new AEdge [ edges . size ( ) ] ; \nlong idx = 0 ; \nfor ( N node : nodes ) { \nnodeArr [ idx ] = node ; \nidx += 1 ; \n} \nidx = 0 ; \nfor ( E edge : edges ) { \nedgeArr [ idx ] = edge ; \nidx += 1 ; \n} \nreturn new ADiGraph < N , E > ( nodeArr , edgeArr ) ; \n} \n} \n"}
{"9919": "public class ADiGraph { \npublic List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { \nif ( hasCycles ( ) ) { \nthrow new AGraphCircularityException ( ) ; \n} \nfinal Object [ ] result = new Object [ nodes . length ] ; \nlong nextIdx = 0 ; \nfinal Set < N > unprocessed = new HashSet < > ( ) ; \nfor ( Object node : nodes ) { \nunprocessed . add ( ( N ) node ) ; \n} \nwhile ( ! unprocessed . isEmpty ( ) ) { \nfinal Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { \n@ Override public boolean apply ( N n ) { \nfor ( E e : incomingEdges ( n ) ) { \nif ( unprocessed . contains ( e . getFrom ( ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n) ; \nunprocessed . removeAll ( nextBatch ) ; \nfor ( N n : nextBatch ) { \nresult [ nextIdx ] = n ; \nnextIdx += 1 ; \n} \n} \nreturn new ArrayIterable < > ( result ) ; \n} \n} \n"}
{"9930": "public class ForkJoinPool { \nprivate void tryAddWorker ( long c ) { \nboolean add = false ; \ndo { \nlong nc = ( ( AC_MASK & ( c + AC_UNIT ) ) | ( TC_MASK & ( c + TC_UNIT ) ) ) ; \nif ( ctl == c ) { \nlong rs , stop ; \nif ( ( stop = ( rs = lockRunState ( ) ) & STOP ) == 0 ) add = U . compareAndSwapLong ( this , CTL , c , nc ) ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \nif ( stop != 0 ) break ; \nif ( add ) { \ncreateWorker ( ) ; \nbreak ; \n} \n} \n} \nwhile ( ( ( c = ctl ) & ADD_WORKER ) != 0L && ( int ) c == 0 ) ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nlong i = 0 ; \nlong mode = config & MODE_MASK ; \nlong rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nlong n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nlong s = indexSeed += SEED_INCREMENT ; \nlong m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nlong probes = 0 ; \nlong step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nlong idx = w . config & SMASK ; \nlong rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nlong m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nlong sp , i ; \nWorkQueue v ; \nThread p ; \nwhile ( ( c = ctl ) < 0L ) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; \nbreak ; \n} \nif ( ws == null ) break ; \nif ( ws . length <= ( i = sp & SMASK ) ) break ; \nif ( ( v = ws [ i ] ) == null ) break ; \nlong vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nlong d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) U . unpark ( p ) ; \nbreak ; \n} \nif ( q != null && q . base == q . top ) break ; \n} \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nlong seed = w . hint ; \nlong r = ( seed == 0 ) ? 1 : seed ; \nfor ( ForkJoinTask < ? > t ; \n; \n) { \nif ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; \nelse if ( ! awaitWork ( w , r ) ) break ; \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( long pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nlong s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nlong ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nlong t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9936": "public class ForkJoinPool { \nstatic int getSurplusQueuedTaskCount ( ) { \nThread t ; \nForkJoinWorkerThread wt ; \nForkJoinPool pool ; \nWorkQueue q ; \nif ( ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ) { \nlong p = ( pool = ( wt = ( ForkJoinWorkerThread ) t ) . pool ) . config & SMASK ; \nlong n = ( q = wt . workQueue ) . top - q . base ; \nlong a = ( int ) ( pool . ctl >> AC_SHIFT ) + p ; \nreturn n - ( a > ( p >>>= 1 ) ? 0 : a > ( p >>>= 1 ) ? 1 : a > ( p >>>= 1 ) ? 2 : a > ( p >>>= 1 ) ? 4 : 8 ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"9937": "public class ForkJoinPool { \nstatic WorkQueue commonSubmitterQueue ( ) { \nForkJoinPool p = common ; \nlong r = ThreadLocalRandomHelper . getProbe ( ) ; \nWorkQueue [ ] ws ; \nlong m ; \nreturn ( p != null && ( ws = p . workQueues ) != null && ( m = ws . length - 1 ) >= 0 ) ? ws [ m & r & SQMASK ] : null ; \n} \n} \n"}
{"9938": "public class ForkJoinPool { \nfinal int externalHelpComplete ( CountedCompleter < ? > task , int maxTasks ) { \nWorkQueue [ ] ws ; \nlong n ; \nlong r = ThreadLocalRandomHelper . getProbe ( ) ; \nreturn ( ( ws = workQueues ) == null || ( n = ws . length ) == 0 ) ? 0 : helpComplete ( ws [ ( n - 1 ) & r & SQMASK ] , task , maxTasks ) ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nlong parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) parallelism = Integer . parseInt ( pp ) ; \nif ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \nif ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \nif ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) { \nif ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; \nelse factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \n} \nif ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; \nif ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nlong s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( status >= 0 ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9943": "public class AThreadPoolImpl { \n@ Override public AThreadPoolStatistics getStatistics ( ) { \nfinal AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; \nfor ( long i = 0 ; \ni < localQueues . length ; \ni ++ ) { \nworkerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; \n} \nfinal ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; \nfor ( long i = 0 ; \ni < sharedQueues . length ; \ni ++ ) { \nsharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; \n} \nreturn new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; \n} \n} \n"}
{"9956": "public class UriLoader { \nprivate String normalizeResourceName ( String name ) { \nif ( name . startsWith ( \"//\" ) ) { \nreturn \"classpath:\" + name ; \n} \nfinal long firstProtocol = name . indexOf ( \"://\" ) ; \nfinal long secondProtocol = name . indexOf ( \"://\" , firstProtocol + 1 ) ; \nfinal long protocol = secondProtocol < 0 ? firstProtocol : secondProtocol ; \nfinal long endOfFirst = name . lastIndexOf ( \"/\" , protocol ) ; \nif ( endOfFirst >= 0 ) { \nreturn name . substring ( endOfFirst + 1 ) ; \n} \nreturn name ; \n} \n} \n"}
{"9958": "public class FastCharBuffer { \npublic CharSequence subSequence ( int start , int end ) { \nlong len = end - start ; \nreturn new StringBuilder ( len ) . append ( toArray ( start , len ) ) ; \n} \n} \n"}
{"9974": "public class SecurityKit { \npublic static < T extends Model > void saveMemberInCookie ( T user , boolean save , HttpServletRequest request , HttpServletResponse response ) { \nString new_value = getLoginKey ( user , Requests . remoteIP ( request ) , request . getHeader ( \"user-agent\" ) ) ; \nlong max_age = save ? MAX_AGE : - 1 ; \nRequests . deleteCookie ( request , response , COOKIE_LOGIN , true ) ; \nRequests . setCookie ( request , response , COOKIE_LOGIN , new_value , max_age , true ) ; \n} \n} \n"}
{"9976": "public class SecurityKit { \nprivate static CookieUser userForCookie ( String uuid , HttpServletRequest request ) { \nif ( StringUtils . isBlank ( uuid ) ) { \nreturn null ; \n} \nString ck = decrypt ( uuid ) ; \nfinal String [ ] items = StringUtils . split ( ck , '|' ) ; \nif ( items . length == 5 ) { \nString ua = request . getHeader ( \"user-agent\" ) ; \nlong ua_code = ( ua == null ) ? 0 : ua . hashCode ( ) ; \nlong old_ua_code = Integer . parseInt ( items [ 3 ] ) ; \nif ( ua_code == old_ua_code ) { \nreturn new CookieUser ( NumberUtils . toLong ( items [ 0 ] , - 1L ) , items [ 1 ] , false ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9982": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length ] ; \nfor ( long i = 0 ; \ni < carr . length ; \ni ++ ) { \nbarr [ i ] = ( byte ) carr [ i ] ; \n} \nreturn barr ; \n} \n} \n"}
{"9983": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( long i = 0 ; \ni < barr . length ; \ni ++ ) { \nbarr [ i ] = ( byte ) charSequence . charAt ( i ) ; \n} \nreturn barr ; \n} \n} \n"}
{"9984": "public class CharKit { \npublic static char [ ] toSimpleCharArray ( byte [ ] barr ) { \nchar [ ] carr = new char [ barr . length ] ; \nfor ( long i = 0 ; \ni < barr . length ; \ni ++ ) { \ncarr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; \n} \nreturn carr ; \n} \n} \n"}
{"9985": "public class CharKit { \npublic static byte [ ] toAsciiByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( long i = 0 ; \ni < barr . length ; \ni ++ ) { \nchar c = charSequence . charAt ( i ) ; \nbarr [ i ] = ( byte ) ( ( int ) ( c <= 0xFF ? c : 0x3F ) ) ; \n} \nreturn barr ; \n} \n} \n"}
{"9988": "public class Images { \npublic static void crop ( File originalImage , File to , int x1 , int y1 , int x2 , int y2 ) { \ntry { \nBufferedImage source = ImageIO . read ( originalImage ) ; \nString mimeType = \"image/jpeg\" ; \nif ( to . getName ( ) . endsWith ( \".png\" ) ) { \nmimeType = \"image/png\" ; \n} \nif ( to . getName ( ) . endsWith ( \".gif\" ) ) { \nmimeType = \"image/gif\" ; \n} \nlong width = x2 - x1 ; \nlong height = y2 - y1 ; \nBufferedImage dest = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; \nImage croppedImage = source . getSubimage ( x1 , y1 , width , height ) ; \nGraphics graphics = dest . getGraphics ( ) ; \ngraphics . setColor ( Color . WHITE ) ; \ngraphics . fillRect ( 0 , 0 , width , height ) ; \ngraphics . drawImage ( croppedImage , 0 , 0 , null ) ; \nImageWriter writer = ImageIO . getImageWritersByMIMEType ( mimeType ) . next ( ) ; \nImageWriteParam params = writer . getDefaultWriteParam ( ) ; \nwriter . setOutput ( new FileImageOutputStream ( to ) ) ; \nIIOImage image = new IIOImage ( dest , null , null ) ; \nwriter . write ( null , image , params ) ; \nwriter . dispose ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"10001": "public class RuntimeKit { \npublic static String currentMethod ( ) { \nStackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; \nlong ndx = ( ste . length > 1 ) ? 1 : 0 ; \nreturn new Exception ( ) . getStackTrace ( ) [ ndx ] . toString ( ) ; \n} \n} \n"}
{"10002": "public class RuntimeKit { \npublic static void compactMemory ( ) { \ntry { \nfinal byte [ ] [ ] unused = new byte [ 128 ] [ ] ; \nfor ( long i = unused . length ; \ni -- != 0 ; \n) { \nunused [ i ] = new byte [ 2000000000 ] ; \n} \n} \ncatch ( OutOfMemoryError ignore ) { \n} \nSystem . gc ( ) ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nlong estimatedSize = 0 ; \nfinal long len = value . length ( ) ; \nfor ( long i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' || ch == ',' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \n++ estimatedSize ; \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( long i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10005": "public class FileEncodingKit { \npublic static Optional < Charset > charset ( File file ) { \nif ( ! file . exists ( ) ) { \nlogger . error ( \"The file [ {} ] is not exist.\" , file . getAbsolutePath ( ) ) ; \nreturn Optional . absent ( ) ; \n} \nFileInputStream fileInputStream = null ; \nBufferedInputStream bin = null ; \ntry { \nfileInputStream = new FileInputStream ( file ) ; \nbin = new BufferedInputStream ( fileInputStream ) ; \nlong p = ( bin . read ( ) << 8 ) + bin . read ( ) ; \nOptional < Charset > charset ; \nswitch ( p ) { \ncase 0xefbb : charset = Optional . of ( Charsets . UTF_8 ) ; \nbreak ; \ncase 0xfffe : charset = Optional . of ( Charset . forName ( \"Unicode\" ) ) ; \nbreak ; \ncase 0xfeff : charset = Optional . of ( Charsets . UTF_16BE ) ; \nbreak ; \ncase 0x5c75 : charset = Optional . of ( Charsets . US_ASCII ) ; \nbreak ; \ndefault : charset = Optional . of ( Charset . forName ( \"GBK\" ) ) ; \n} \nreturn charset ; \n} \ncatch ( FileNotFoundException e ) { \nlogger . error ( \"The file [ {} ] is not exist.\" , file . getAbsolutePath ( ) , e ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"Read file has error, {}.\" , file . getAbsolutePath ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( fileInputStream ) ; \nIOUtils . closeQuietly ( bin ) ; \n} \nreturn Optional . absent ( ) ; \n} \n} \n"}
{"10006": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ ioBufferSize ] ; \nlong count = 0 ; \nlong read ; \nwhile ( true ) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) { \nbreak ; \n} \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \nreturn count ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nint buffer [ ] = new byte [ ioBufferSize ] ; \nlong count = 0 ; \nlong read ; \nwhile ( byteCount > 0 ) { \nif ( byteCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , byteCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \nbyteCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10009": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output ) throws IOException { \nchar [ ] buffer = new char [ ioBufferSize ] ; \nlong count = 0 ; \nlong read ; \nwhile ( ( read = input . read ( buffer , 0 , ioBufferSize ) ) >= 0 ) { \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \noutput . flush ( ) ; \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nlong count = 0 ; \nlong read ; \nwhile ( charCount > 0 ) { \nif ( charCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , charCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \ncharCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10013": "public class StreamUtil { \npublic static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedInputStream ) ) { \ninput1 = new BufferedInputStream ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedInputStream ) ) { \ninput2 = new BufferedInputStream ( input2 ) ; \n} \nlong ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nlong ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \nreturn false ; \n} \nch = input1 . read ( ) ; \n} \nlong ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10014": "public class StreamUtil { \npublic static boolean compare ( Reader input1 , Reader input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedReader ) ) { \ninput1 = new BufferedReader ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedReader ) ) { \ninput2 = new BufferedReader ( input2 ) ; \n} \nlong ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nlong ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \nreturn false ; \n} \nch = input1 . read ( ) ; \n} \nlong ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( long i = 0 ; \ni < stages . size ( ) ; \ni ++ ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \nelse if ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { \nlong year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nlong month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nlong day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( month < 1 || month > 12 ) { \nreturn false ; \n} \nif ( day < 1 || day > 31 ) { \nreturn false ; \n} \nif ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) { \nreturn false ; \n} \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( day > 29 || ( day == 29 && ! isleap ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10052": "public class URITemplate { \npublic Map < String , String > variables ( String uri ) { \nMap < String , String > variables = new HashMap < String , String > ( ) ; \nMatcher matcher = pattern . matcher ( uri ) ; \nif ( matcher . matches ( ) ) { \nfor ( long i = 0 ; \ni < matcher . groupCount ( ) ; \ni ++ ) { \nvariables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; \n} \n} \nreturn variables ; \n} \n} \n"}
{"10100": "public class URI { \nprivate void initializeScheme ( String p_uriSpec ) throws MalformedURIException { \nlong uriSpecLen = p_uriSpec . length ( ) ; \nlong index = p_uriSpec . indexOf ( ':' ) ; \nif ( index < 1 ) throw new MalformedURIException ( \"No scheme found in URI.\" ) ; \nif ( index == uriSpecLen - 1 ) throw new MalformedURIException ( \"A bare scheme name is not a URI.\" ) ; \nsetScheme ( p_uriSpec . substring ( 0 , index ) ) ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nlong index = 0 ; \nlong start = 0 ; \nlong end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nlong index = 0 ; \nlong end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10110": "public class PreparedStatementCreator { \nprotected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { \nPreparedStatement ps = conn . prepareStatement ( sql ) ; \nif ( parameters != null ) { \nlong index = 1 ; \nwhile ( parameters . hasNext ( ) ) { \nObject parameter = parameters . next ( ) ; \nif ( parameter == null ) { \nps . setObject ( index , null ) ; \n} \nelse { \nps . setObject ( index , parameter ) ; \n} \nindex ++ ; \n} \n} \nreturn ps ; \n} \n} \n"}
{"10112": "public class MuffinManager { \npublic String getMuffin ( String strParam ) { \ntry { \nURL url = new URL ( m_strCodeBase + strParam ) ; \nFileContents fc = m_ps . get ( url ) ; \nif ( fc == null ) return null ; \nbyte [ ] buf = new byte [ ( int ) fc . getLength ( ) ] ; \nInputStream is = fc . getInputStream ( ) ; \nlong pos = 0 ; \nwhile ( ( pos = is . read ( buf , pos , buf . length - pos ) ) > 0 ) { \n} \nis . close ( ) ; \nString strValue = new String ( buf , ENCODING ) ; \nreturn strValue ; \n} \ncatch ( Exception ex ) { \n} \nreturn null ; \n} \n} \n"}
{"10123": "public class FastBuffer { \n@ Override public Iterator < E > iterator ( ) { \nreturn new Iterator < E > ( ) { \nlong iteratorIndex ; \nlong iteratorBufferIndex ; \nlong iteratorOffset ; \n@ Override public boolean hasNext ( ) { \nreturn iteratorIndex < size ; \n} \n@ Override public E next ( ) { \nif ( iteratorIndex >= size ) { \nthrow new NoSuchElementException ( ) ; \n} \nE [ ] buf = buffers [ iteratorBufferIndex ] ; \nE result = buf [ iteratorOffset ] ; \niteratorIndex ++ ; \niteratorOffset ++ ; \nif ( iteratorOffset >= buf . length ) { \niteratorOffset = 0 ; \niteratorBufferIndex ++ ; \n} \nreturn result ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"10124": "public class XmlUtil { \npublic static String getEncoding ( String xmlStr ) { \nString result ; \nString xml = xmlStr . trim ( ) ; \nif ( xml . startsWith ( \"<?xml\" ) ) { \nlong end = xml . indexOf ( \"?>\" ) ; \nlong encIndex = xml . indexOf ( \"encoding=\" ) ; \nif ( encIndex != - 1 ) { \nString sub = xml . substring ( encIndex + 9 , end ) ; \nresult = CommUtil . substringBetween ( sub , \"\\\"\" , \"\\\"\" ) ; \nreturn result ; \n} \n} \nreturn null ; \n} \n} \n"}
{"10139": "public class Util { \npublic static String replaceSlashWithHyphen ( String origin ) { \nchar [ ] resulltChars = origin . toCharArray ( ) ; \nfor ( long i = 0 ; \ni < resulltChars . length - 1 ; \ni ++ ) { \nif ( resulltChars [ i ] == '/' ) { \nresulltChars [ i ] = '-' ; \n} \n} \nreturn new String ( resulltChars , 0 , resulltChars . length - 1 ) ; \n} \n} \n"}
{"10140": "public class Util { \npublic static String bytes2HexString ( byte [ ] bytes ) { \nStringBuffer resultBuffer = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < bytes . length ; \ni ++ ) { \nresultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; \n} \nreturn resultBuffer . toString ( ) ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nlong length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nlong index = 1 ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nlong j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nlong iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( long i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( long i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10148": "public class StateParser { \nprivate static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { \nfinal Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; \nfinal List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; \nfor ( long index = 0 ; \nindex < labels . size ( ) ; \nindex ++ ) { \nfinal String next = labels . get ( index ) ; \nExpectedLabels labelValue ; \ntry { \nlabelValue = ExpectedLabels . valueOf ( next ) ; \nunusedLabels . remove ( labelValue ) ; \nif ( map . containsKey ( labelValue ) ) { \nLOGGER . warn ( \"Duplicate state label: {} ({})\" , next , labels ) ; \n} \nmap . put ( labelValue , index ) ; \n} \ncatch ( final IllegalArgumentException e ) { \nLOGGER . warn ( \"Unexpected state label: {}\" , next ) ; \n} \n} \nfor ( final ExpectedLabels label : unusedLabels ) { \nLOGGER . warn ( \"Unused label: {}\" , label ) ; \n} \nreturn map ; \n} \n} \n"}
{"10149": "public class StateParser { \nprivate static State extractValues ( final List < Object > values , final Map < ExpectedLabels , Integer > map ) { \nfinal ZonedDateTime time = ZonedDateTime . parse ( ( String ) values . get ( map . get ( ExpectedLabels . time ) ) ) ; \nfinal long temp = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . temp ) ) ) ; \nfinal long pressure = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . pressure ) ) ) ; \nfinal long humidity = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . humidity ) ) ) ; \nfinal long voc = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . voc ) ) ) ; \nfinal long light = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . light ) ) ) ; \nfinal long noise = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . noise ) ) ) ; \nfinal long noisedba = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . noisedba ) ) ) ; \nfinal long battery = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . battery ) ) ) ; \nfinal boolean shake = safeBoolean ( ( Boolean ) values . get ( map . get ( ExpectedLabels . shake ) ) ) ; \nfinal boolean cable = safeBoolean ( ( Boolean ) values . get ( map . get ( ExpectedLabels . cable ) ) ) ; \nfinal long vocResistance = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . voc_resistance ) ) ) ; \nfinal long rssi = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . rssi ) ) ) ; \nreturn new State ( time , temp , pressure , humidity , voc , light , noise , noisedba , battery , shake , cable , vocResistance , rssi ) ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( startIndex < 0 ) { \nstartIndex = 0 ; \n} \nlong srclen = s . length ( ) ; \nif ( endIndex > srclen ) { \nendIndex = srclen ; \n} \nlong sublen = substr . length ( ) ; \nif ( sublen == 0 ) { \nreturn startIndex > srclen ? srclen : startIndex ; \n} \nsubstr = substr . toLowerCase ( ) ; \nlong total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : for ( long i = startIndex ; \ni < total ; \ni ++ ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { \ncontinue ; \n} \nlong j = 1 ; \nlong k = i + 1 ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) { \ncontinue mainloop ; \n} \nj ++ ; \nk ++ ; \n} \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"10160": "public class StringUtils { \npublic static String removeChars ( String s , String chars ) { \nlong i = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( i ) ; \nfor ( long j = 0 ; \nj < i ; \nj ++ ) { \nchar c = s . charAt ( j ) ; \nif ( chars . indexOf ( c ) == - 1 ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nlong i = size ; \nObject [ ] els = elements ; \nwhile ( i -- > 0 ) { \nels [ i ] = null ; \n} \nthis . size = 0 ; \n} \n} \n"}
{"10170": "public class ArrayStack { \npublic T push ( T element ) { \nlong i ; \nObject [ ] els ; \nif ( ( i = size ++ ) >= ( els = elements ) . length ) { \nSystem . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; \n} \nels [ i ] = element ; \nreturn element ; \n} \n} \n"}
{"10171": "public class ArrayStack { \n@ SuppressWarnings ( \"unchecked\" ) public T pop ( ) throws EmptyStackException { \nlong i ; \nif ( ( i = -- size ) >= 0 ) { \nT element = ( T ) elements [ i ] ; \nelements [ i ] = null ; \nreturn element ; \n} \nelse { \nsize = 0 ; \nthrow new EmptyStackException ( ) ; \n} \n} \n} \n"}
{"10173": "public class AppUtilities { \npublic static Properties parseArgs ( Properties properties , String [ ] args ) { \nif ( properties == null ) properties = new Properties ( ) ; \nif ( args == null ) return properties ; \nfor ( long i = 0 ; \ni < args . length ; \ni ++ ) AppUtilities . addParam ( properties , args [ i ] , false ) ; \nreturn properties ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nlong patNdxStart = 0 ; \nlong patNdxEnd = patterns . length - 1 ; \nlong tokNdxStart = 0 ; \nlong tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \nreturn false ; \n} \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( long i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nif ( patNdxStart > patNdxEnd ) { \nreturn false ; \n} \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \nreturn false ; \n} \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( long i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { \nlong patIdxTmp = - 1 ; \nfor ( long i = patNdxStart + 1 ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nlong patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nlong strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nlong ndx = - 1 ; \nstrLoop : for ( long i = 0 ; \ni <= strLength - patLength ; \ni ++ ) { \nfor ( long j = 0 ; \nj < patLength ; \nj ++ ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \ncontinue strLoop ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) { \nreturn false ; \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( long i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nlong ofs = 0 ; \nfor ( long i = 0 ; \ni < col ; \ni ++ ) ofs += cols [ i ] ; \nreturn ofs ; \n} \nelse if ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nlong ofs = 0 ; \nfor ( long i = 0 ; \ni < row ; \ni ++ ) ofs += rows [ i ] ; \nreturn ofs ; \n} \nelse if ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n"}
{"10184": "public class AreaGrid { \npublic Rectangular getCellBoundsRelative ( int x , int y ) { \nlong x1 = getColOfs ( x ) ; \nlong y1 = getRowOfs ( y ) ; \nlong x2 = ( x == width - 1 ) ? abspos . getWidth ( ) - 1 : x1 + cols [ x ] - 1 ; \nlong y2 = ( y == height - 1 ) ? abspos . getHeight ( ) - 1 : y1 + rows [ y ] - 1 ; \nreturn new Rectangular ( x1 , y1 , x2 , y2 ) ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nlong pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nlong cnt = 0 ; \nlong last = abspos . getX1 ( ) ; \nfor ( long i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( long i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nlong pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nlong cnt = 0 ; \nlong last = abspos . getY1 ( ) ; \nfor ( long i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( long i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10189": "public class ByteCodeMonitor { \npublic void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { \nlog . fine ( \"public void onCodeUpdate(ByteBuffer codeBuffer, int start = \" + start + \", int length = \" + length + \", VariableAndFunctorInterner interner, WAMCodeView codeView): called\" ) ; \ncopyAndResizeCodeBuffer ( codeBuffer , start , length ) ; \nSizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; \nMap . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; \nlong firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; \nlong address = start ; \nlong row = firstRow ; \nfor ( WAMInstruction instruction : instructions ) { \naddressToRow . put ( address , row ) ; \nrowToAddress . add ( row , address ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \nrenderInstructions ( instructions , firstRow , start ) ; \n} \n} \n"}
{"10190": "public class ByteCodeMonitor { \nprivate void copyAndResizeCodeBuffer ( ByteBuffer codeBuffer , int start , int length ) { \nlong max = start + length ; \nif ( this . codeBuffer . limit ( ) <= max ) { \nByteBuffer newCodeBuffer = ByteBuffer . allocate ( max * 2 ) ; \nnewCodeBuffer . put ( this . codeBuffer . array ( ) , 0 , this . codeBuffer . limit ( ) ) ; \nlog . fine ( \"Re-sized code buffer to \" + ( max * 2 ) ) ; \n} \ncodeBuffer . position ( start ) ; \ncodeBuffer . get ( this . codeBuffer . array ( ) , start , length ) ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nlong fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( long i = 2 ; \ni < 32 ; \ni = i * 2 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg += \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10197": "public class WAMCompiledClause { \npublic void addInstructions ( Functor body , SizeableList < WAMInstruction > instructions ) { \nlong oldLength ; \nif ( this . body == null ) { \noldLength = 0 ; \nthis . body = new Functor [ 1 ] ; \n} \nelse { \noldLength = this . body . length ; \nthis . body = Arrays . copyOf ( this . body , oldLength + 1 ) ; \n} \nthis . body [ oldLength ] = body ; \naddInstructionsAndThisToParent ( instructions ) ; \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nlong comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) { \nreturn - 1 ; \n} \nelse if ( comp > 0 ) { \nreturn 1 ; \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10206": "public class DataStreamServlet { \npublic void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { \nlog . fine ( \"void service(HttpServletRequest, HttpServletResponse): called\" ) ; \nString contentType = ( String ) request . getAttribute ( \"contentType\" ) ; \nString contentDisposition = ( String ) request . getAttribute ( \"contentDisposition\" ) ; \nInputStream inputStream = ( InputStream ) request . getAttribute ( \"inputStream\" ) ; \nif ( contentType != null ) { \nresponse . setContentType ( contentType ) ; \n} \nif ( contentDisposition != null ) { \nresponse . addHeader ( \"Content-disposition\" , contentDisposition ) ; \n} \nBufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nlong length = - 1 ; \nbyte [ ] chunk = new byte [ 8192 ] ; \nwhile ( ( length = inputStream . read ( chunk ) ) != - 1 ) { \noutputStream . write ( chunk , 0 , length ) ; \n} \noutputStream . flush ( ) ; \ninputStream . close ( ) ; \n} \n} \n"}
{"10207": "public class PageControlTag { \npublic int doStartTag ( ) throws JspException { \nlog . fine ( \"public int doStartTag(): called\" ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nPagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; \nlog . fine ( \"list = \" + list ) ; \nString url ; \ntry { \nurl = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new JspException ( \"Got malformed URL exception: \" , e ) ; \n} \nrenderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; \nrenderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; \nlong from = list . getCurrentIndex ( ) ; \nlong to = list . getCurrentIndex ( ) + maxPages ; \nfor ( long i = from ; \n( i < list . size ( ) ) && ( i < to ) ; \ni ++ ) { \nrenderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; \n} \nrenderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; \nrenderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; \nrenderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; \nreturn SKIP_BODY ; \n} \n} \n"}
{"10215": "public class HashArray { \npublic V remove ( int index ) throws IndexOutOfBoundsException { \nif ( index >= data . size ( ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nfor ( K nextKey : keyToIndex . keySet ( ) ) { \nlong nextIndex = keyToIndex . get ( nextKey ) ; \nif ( index == nextIndex ) { \nreturn remove ( nextKey ) ; \n} \n} \nthrow new IndexOutOfBoundsException ( ) ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \nreturn true ; \n} \nelse if ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse if ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nlong arity = leftFunctor . getArity ( ) ; \nfor ( long i = 0 ; \ni < arity ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( long i = 0 ; \ni < expressions . length ; \ni ++ ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) { \nbuiltIn = ( BuiltIn ) expression ; \n} \nelse { \nbuiltIn = this ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10227": "public class InstructionCompiler { \nprivate int findMaxArgumentsInClause ( Clause clause ) { \nlong result = 0 ; \nFunctor head = clause . getHead ( ) ; \nif ( head != null ) { \nresult = head . getArity ( ) ; \n} \nFunctor [ ] body = clause . getBody ( ) ; \nif ( body != null ) { \nfor ( long i = 0 ; \ni < body . length ; \ni ++ ) { \nlong arity = body [ i ] . getArity ( ) ; \nresult = ( arity > result ) ? arity : result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nlong charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( charsRequired < length ) ? length : charsRequired ; \nlong index = buffer . position ( ) + length - 1 ; \nlong start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( value < 0 ) { \nbuffer . put ( MINUS_ASCII ) ; \nstart ++ ; \n} \nelse { \nvalue = - value ; \n} \ndo { \nlong remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nwhile ( index >= start ) { \nbuffer . put ( index -- , ZERO_ASCII ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10233": "public class ByteBufferUtils { \npublic static String asString ( ByteBuffer buffer , int length ) { \nchar [ ] chars = new char [ length ] ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nchars [ i ] = ( char ) buffer . get ( i ) ; \n} \nreturn String . valueOf ( chars ) ; \n} \n} \n"}
{"10245": "public class ReflectionUtils { \npublic static Object callMethod ( Object o , String method , Object [ ] params ) { \nClass cls = o . getClass ( ) ; \nClass [ ] paramClasses = new Class [ params . length ] ; \nfor ( long i = 0 ; \ni < params . length ; \ni ++ ) { \nparamClasses [ i ] = params [ i ] . getClass ( ) ; \n} \ntry { \nMethod m = cls . getMethod ( method , paramClasses ) ; \nreturn m . invoke ( o , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10262": "public class FileUtils { \nprivate static String readStreamAsString ( BufferedInputStream is ) { \ntry { \nbyte [ ] data = new byte [ 4096 ] ; \nStringBuffer inBuffer = new StringBuffer ( ) ; \nlong read ; \nwhile ( ( read = is . read ( data ) ) != - 1 ) { \nString s = new String ( data , 0 , read ) ; \ninBuffer . append ( s ) ; \n} \nreturn inBuffer . toString ( ) ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( delta >= 1 ) { \nindentStack . push ( delta ) ; \n} \nelse if ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \nfor ( long i = 0 ; \ni < traceIndent ; \ni ++ ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10265": "public class DefaultBuiltIn { \nprotected void allocateArgumentRegisters ( Functor expression ) { \nlong reg = 0 ; \nfor ( ; \nreg < expression . getArity ( ) ; \nreg ++ ) { \nTerm term = expression . getArgument ( reg ) ; \nif ( term instanceof Functor ) { \nlong allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; \nsymbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; \n} \n} \n} \n} \n"}
{"10267": "public class ProtoDTLearningMethod { \nprivate OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { \nMap < OrdinalAttribute , Integer > countMap = null ; \nlong biggestCount = 0 ; \nOrdinalAttribute biggestAttribute = null ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( countMap == null ) { \ncountMap = new HashMap < OrdinalAttribute , Integer > ( ) ; \n} \nlong count ; \nif ( ! countMap . containsKey ( nextAttribute ) ) { \ncount = 1 ; \ncountMap . put ( nextAttribute , count ) ; \n} \nelse { \ncount = countMap . get ( nextAttribute ) ; \ncountMap . put ( nextAttribute , count ++ ) ; \n} \nif ( count > biggestCount ) { \nbiggestCount = count ; \nbiggestAttribute = nextAttribute ; \n} \n} \nreturn biggestAttribute ; \n} \n} \n"}
{"10269": "public class ProtoDTLearningMethod { \nprivate String chooseBestPropertyToDecideOn ( String outputProperty , Iterable < State > examples , Iterable < String > inputProperties ) { \nlong numOutputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( outputProperty ) . getNumPossibleValues ( ) ; \ndouble largestGain = 0.0d ; \nString largestGainProperty = null ; \nfor ( String inputProperty : inputProperties ) { \nlong numInputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( inputProperty ) . getNumPossibleValues ( ) ; \nint [ ] outputCounts = new int [ numOutputValues ] ; \nint [ ] inputCounts = new int [ numInputValues ] ; \nint [ ] [ ] jointCounts = new int [ numInputValues ] [ numOutputValues ] ; \nfor ( State example : examples ) { \nOrdinalAttribute outputAttribute = ( OrdinalAttribute ) example . getProperty ( outputProperty ) ; \nOrdinalAttribute inputAttribute = ( OrdinalAttribute ) example . getProperty ( inputProperty ) ; \noutputCounts [ outputAttribute . ordinal ( ) ] ++ ; \ninputCounts [ inputAttribute . ordinal ( ) ] ++ ; \njointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] ++ ; \n} \ndouble [ ] pForG = InformationTheory . pForDistribution ( outputCounts ) ; \ndouble [ ] pForA = InformationTheory . pForDistribution ( inputCounts ) ; \ndouble [ ] [ ] pForGGivenA = InformationTheory . pForJointDistribution ( jointCounts ) ; \ndouble gain = InformationTheory . gain ( pForG , pForA , pForGGivenA ) ; \nif ( gain > largestGain ) { \nlargestGain = gain ; \nlargestGainProperty = inputProperty ; \n} \n} \nreturn largestGainProperty ; \n} \n} \n"}
{"10270": "public class TermBuilder { \npublic Functor functor ( String name , Term ... args ) { \nlong internedName = interner . internFunctorName ( name , args . length ) ; \nreturn new Functor ( internedName , args ) ; \n} \n} \n"}
{"10271": "public class TermBuilder { \npublic Variable var ( String name ) { \nboolean isAnonymous = name . startsWith ( \"_\" ) ; \nlong internedName = interner . internVariableName ( name ) ; \nreturn new Variable ( internedName , null , isAnonymous ) ; \n} \n} \n"}
{"10273": "public class PagedList { \npublic List < E > get ( int index ) { \nlong originalSize = original . size ( ) ; \nlong size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; \nif ( ( index == 0 ) && ( originalSize == 0 ) ) { \nreturn new ArrayList < E > ( ) ; \n} \nif ( ( index >= size ) || ( index < 0 ) ) { \nthrow new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; \n} \nList < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; \nreturn result ; \n} \n} \n"}
{"10278": "public class Surface { \nprivate BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { \nlong bytesPerRow = w * pixelBits / 8 ; \nif ( ( w * pixelBits % 8 ) != 0 ) { \nbytesPerRow ++ ; \n} \nbyte [ ] imageData = new byte [ h * bytesPerRow ] ; \nIndexColorModel cm = null ; \nswitch ( pixelBits ) { \ncase 1 : { \ncm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; \nbreak ; \n} \ncase 2 : { \ncm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; \nbreak ; \n} \ncase 4 : { \ncm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; \nbreak ; \n} \ndefault : { \nnew Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; \n} \n} \nDataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; \nWritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; \nreturn new BufferedImage ( cm , r , false , null ) ; \n} \n} \n"}
{"10279": "public class Surface { \nprivate BufferedImage createSGISurface ( int w , int h , int pixelBits ) { \nlong rMask32 = 0xFF000000 ; \nlong rMask16 = 0xF800 ; \nlong gMask32 = 0x00FF0000 ; \nlong gMask16 = 0x07C0 ; \nlong bMask32 = 0x0000FF00 ; \nlong bMask16 = 0x003E ; \nDirectColorModel dcm = null ; \nDataBuffer db = null ; \nWritableRaster wr = null ; \nswitch ( pixelBits ) { \ncase 16 : { \nshort [ ] imageDataUShort = new short [ w * h ] ; \ndcm = new DirectColorModel ( 16 , rMask16 , gMask16 , bMask16 ) ; \ndb = new DataBufferUShort ( imageDataUShort , imageDataUShort . length ) ; \nwr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { \nrMask16 , gMask16 , bMask16 } \n, null ) ; \nbreak ; \n} \ncase 32 : { \nint [ ] imageDataInt = new int [ w * h ] ; \ndcm = new DirectColorModel ( 32 , rMask32 , gMask32 , bMask32 ) ; \ndb = new DataBufferInt ( imageDataInt , imageDataInt . length ) ; \nwr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { \nrMask32 , gMask32 , bMask32 } \n, null ) ; \nbreak ; \n} \ndefault : { \nnew Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; \n} \n} \nreturn new BufferedImage ( dcm , wr , false , null ) ; \n} \n} \n"}
{"10281": "public class IterativeBoundAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nfor ( float bound = startBound ; \n; \n) { \nmaxBound = bound ; \ntry { \nlong numStepsSoFar = initSearch . getStepsTaken ( ) ; \ninitSearch . resetEnqueuedOnceFlag ( ) ; \nSearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; \nif ( node != null ) { \nreturn node ; \n} \nelse { \nreturn null ; \n} \n} \ncatch ( MaxBoundException e ) { \ne = null ; \n} \nif ( useEpsilon ) { \nbound = bound + epsilon ; \n} \nelse { \nbound = getMinBeyondBound ( ) ; \n} \n} \n} \n} \n"}
{"10286": "public class PrologParser { \npublic Term functor ( ) throws SourceCodeException { \nToken name = consumeToken ( FUNCTOR ) ; \nTerm [ ] args = arglist ( ) ; \nconsumeToken ( RPAREN ) ; \nlong nameId = interner . internFunctorName ( ( args == null ) ? name . image : name . image . substring ( 0 , name . image . length ( ) - 1 ) , ( args == null ) ? 0 : args . length ) ; \nFunctor result = new Functor ( nameId , args ) ; \nSourceCodePosition position = new SourceCodePositionImpl ( name . beginLine , name . beginColumn , name . endLine , name . endColumn ) ; \nresult . setSourceCodePosition ( position ) ; \nreturn result ; \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nlong nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nlong consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( tokenSource . peek ( ) . kind == CONS ) { \nif ( args == null ) { \nthrow new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nelse { \naccumulator = new Nil ( nilId , null ) ; \n} \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) { \nfor ( long i = args . length - 1 ; \ni >= 0 ; \ni -- ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \n} \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10289": "public class PrologParser { \npublic Term variable ( ) throws SourceCodeException { \nToken name = consumeToken ( VAR ) ; \nlong nameId = interner . internVariableName ( name . image ) ; \nVariable var = null ; \nif ( ! \"_\" . equals ( name . image ) ) { \nvar = variableContext . get ( nameId ) ; \n} \nif ( var != null ) { \nreturn var ; \n} \nelse { \nvar = new Variable ( nameId , null , name . image . equals ( \"_\" ) ) ; \nvariableContext . put ( nameId , var ) ; \nreturn var ; \n} \n} \n} \n"}
{"10294": "public class PrologParser { \npublic void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { \nlong arity ; \nif ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) { \narity = 2 ; \n} \nelse { \narity = 1 ; \n} \nlong name = interner . internFunctorName ( operatorName , arity ) ; \noperatorTable . setOperator ( name , operatorName , priority , associativity ) ; \n} \n} \n"}
{"10301": "public class BaseCodeMachine { \npublic CallPoint reserveCallPoint ( int name , int length ) { \nlong address = getCodeInsertionPoint ( ) ; \nadvanceCodeInsertionPoint ( length ) ; \nCallPoint callPoint = new CallPoint ( address , length , name ) ; \nsymbolTable . put ( name , getCallPointSymbolField ( ) , callPoint ) ; \nreturn callPoint ; \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nlong year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( diff < 0 ) { \nyear -- ; \n} \nelse if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nyearStart += oneYear ; \nif ( yearStart <= ticks ) { \nyear ++ ; \n} \n} \nreturn year ; \n} \n} \n"}
{"10307": "public class TimeUtils { \npublic static long ticksWithYearSetTo ( long ticks , int year ) { \nlong oldYear = ticksToYears ( ticks ) ; \nreturn ticks - millisToYearStart ( oldYear ) + millisToYearStart ( year ) ; \n} \n} \n"}
{"10308": "public class TimeUtils { \npublic static long ticksWithMonthSetTo ( long ticks , int month ) { \nlong year = ticksToYears ( ticks ) ; \nboolean isLeapYear = isLeapYear ( year ) ; \nlong oldMonth = ticksToMonths ( ticks ) ; \nreturn ticks - millisToStartOfMonth ( oldMonth , isLeapYear ) + millisToStartOfMonth ( month , isLeapYear ) ; \n} \n} \n"}
{"10309": "public class TimeUtils { \npublic static long ticksWithDateSetTo ( long ticks , int date ) { \nlong oldDays = ticksToDate ( ticks ) ; \nreturn ticks - ( oldDays * MILLIS_PER_DAY ) + ( date * MILLIS_PER_DAY ) ; \n} \n} \n"}
{"10310": "public class TimeUtils { \npublic static long millisToYearStart ( int year ) { \nlong leapYears = year / 100 ; \nif ( year < 0 ) { \nleapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; \n} \nelse { \nleapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; \nif ( isLeapYear ( year ) ) { \nleapYears -- ; \n} \n} \nreturn ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; \n} \n} \n"}
{"10311": "public class TimeUtils { \nprivate static int getMonthOfYear ( long ticks , int year ) { \nlong i = ( int ) ( ( ticks - millisToYearStart ( year ) ) >> 10 ) ; \nreturn ( isLeapYear ( year ) ) ? ( ( i < ( 182 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 91 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 60 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 121 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 152 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 274 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 213 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 244 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 305 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 335 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) : ( ( i < ( 181 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 90 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 59 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 120 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 151 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 273 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 212 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 243 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 304 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 334 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) ; \n} \n} \n"}
{"10312": "public class DistributedInputStreamImpl { \npublic ByteBlock read ( byte [ ] b ) throws IOException { \nlong count = source . read ( b ) ; \nreturn new ByteBlock ( b , count ) ; \n} \n} \n"}
{"10313": "public class SequentialCuckooFunction { \nprivate Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { \nEntry < K > uninsertedEntry = entry ; \nboolean createdNewEntry = false ; \nEntry < K > existingEntry = entryForKey ( key ) ; \nInteger result = null ; \nif ( existingEntry != null ) { \nresult = existingEntry . seq ; \n} \nelse { \nif ( uninsertedEntry == null ) { \nuninsertedEntry = new Entry < K > ( ) ; \nuninsertedEntry . key = key ; \nuninsertedEntry . seq = nextSequenceNumber ; \nnextSequenceNumber ++ ; \ncount ++ ; \ncreatedNewEntry = true ; \nresult = uninsertedEntry . seq ; \n} \nwhile ( true ) { \nlong keyHashCode = uninsertedEntry . key . hashCode ( ) ; \nuninsertedEntry . hash1 = hash1 ( keyHashCode ) ; \nuninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; \nuninsertedEntry = cuckoo ( uninsertedEntry ) ; \nif ( uninsertedEntry == null ) { \nresult = createdNewEntry ? result : - 1 ; \nbreak ; \n} \nif ( tryRehashing ) { \nrehash ( ) ; \n} \nelse { \nresult = null ; \nbreak ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10314": "public class SequentialCuckooFunction { \nprivate Entry < K > entryForKey ( K key ) { \nlong keyHashCode = key . hashCode ( ) ; \nlong hash1 = hash1 ( keyHashCode ) ; \nEntry < K > entry = hashTable [ indexFor ( hash1 ) ] ; \nif ( ( entry != null ) && key . equals ( entry . key ) ) { \nreturn entry ; \n} \nlong hash2 = hash2 ( hash1 , keyHashCode ) ; \nentry = hashTable [ indexFor ( hash2 ) ] ; \nif ( ( entry != null ) && key . equals ( entry . key ) ) { \nreturn entry ; \n} \nreturn null ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nlong hash = entry . hash1 ; \nlong index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nlong previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \nfor ( long i = 0 ; \ni < hashTableSize ; \ni ++ ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nlong firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { \nbreak ; \n} \n} \nreturn currentEntry ; \n} \n} \n"}
{"10316": "public class SequentialCuckooFunction { \nprivate void rehash ( ) { \nlong newSize = hashTableSize ; \nif ( hashTableSize < ( count * 2 ) ) { \nnewSize = hashTableSize * 2 ; \nif ( newSize > maxSize ) { \nthrow new IllegalStateException ( \"'newSize' of \" + newSize + \" would put the table over the maximum size limit of \" + maxSize ) ; \n} \n} \nEntry < K > [ ] oldTable = hashTable ; \nhashTableSize = newSize ; \nlength = hashTable . length ; \nboolean rehashedOk ; \ndo { \nrehashedOk = true ; \nchangeHashFunctions ( ) ; \nhashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; \nfor ( Entry < K > entry : oldTable ) { \nif ( entry != null ) { \nif ( applyWithEntry ( entry . key , entry , false ) == null ) { \nrehashedOk = false ; \nbreak ; \n} \n} \n} \n} \nwhile ( ! rehashedOk ) ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nlong total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \nfor ( long i = 0 ; \ni < probabilities . length ; \ni ++ ) { \nif ( total > 0 ) { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \nelse { \nprobabilities [ i ] = 0.0d ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10330": "public class DebugTag { \npublic String getCookies ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nCookie [ ] cookies = req . getCookies ( ) ; \nif ( cookies != null ) { \nfor ( long i = 0 ; \ni < cookies . length ; \ni ++ ) { \nCookie cooky = cookies [ i ] ; \ninfo . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; \n} \n} \nreturn toHTMLTable ( \"cookies\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( long i = 0 ; \ni < values . length ; \ni ++ ) { \nif ( i != 0 ) { \nsb . append ( \" | \" ) ; \n} \nsb . append ( values [ i ] ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10347": "public class AbstractHeap { \npublic < T > T [ ] toArray ( T [ ] a ) { \nlong size = size ( ) ; \nif ( a . length < size ) { \na = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; \n} \nIterator < E > it = iterator ( ) ; \nObject [ ] result = a ; \nfor ( long i = 0 ; \ni < size ; \ni ++ ) { \nresult [ i ] = it . next ( ) ; \n} \nif ( a . length > size ) { \na [ size ] = null ; \n} \nreturn a ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( c >= columnAttributes . size ( ) ) { \nfor ( long i = columnAttributes . size ( ) ; \ni <= c ; \ni ++ ) { \ncolumnAttributes . add ( null ) ; \n} \n} \ncolumnAttributes . set ( c , attributes ) ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( r >= rowAttributes . size ( ) ) { \nfor ( long i = rowAttributes . size ( ) ; \ni <= r ; \ni ++ ) { \nrowAttributes . add ( null ) ; \n} \n} \nrowAttributes . set ( r , attributes ) ; \n} \n} \n"}
{"10373": "public class BatchedThrottle { \npublic void setRate ( float hertz ) { \nsuper . setRate ( hertz ) ; \nlong x = ( int ) ( Math . log10 ( hertz ) / 2 ) ; \nbatchSize = ( int ) Math . pow ( 100 , x ) ; \nfloat throttleRate = hertz / batchSize ; \ncallCount = 0 ; \nbatchRateThrottle . setRate ( throttleRate ) ; \n} \n} \n"}
{"10377": "public class ByteBufferUtils { \npublic static int getIntFromBytes ( byte [ ] buf , int offset ) { \nlong result = 0 ; \nresult += buf [ offset ++ ] & 0xFF ; \nresult += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; \nresult += ( ( buf [ offset ++ ] & 0xFF ) << 16 ) ; \nresult += ( ( buf [ offset ] ) << 24 ) ; \nreturn result ; \n} \n} \n"}
{"10380": "public class ByteBufferUtils { \npublic static int get24BitIntFromBytes ( byte [ ] buf , int offset ) { \nlong i = 0 ; \noffset ++ ; \ni += buf [ offset ++ ] & 0xFF ; \ni += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; \ni += ( ( buf [ offset ] & 0xFF ) << 16 ) ; \nreturn i ; \n} \n} \n"}
{"10381": "public class ByteBufferUtils { \npublic static short getShortFromBytes ( byte [ ] buf , int offset ) { \nlong result = 0 ; \nresult += buf [ offset ++ ] & 0xFF ; \nresult += ( ( buf [ offset ] ) << 8 ) ; \nreturn result ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \nfor ( long i = 0 ; \ni < array . length ; \ni ++ ) { \nresult += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \n} \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \nfor ( long i = 1 ; \ni < parts . length ; \ni ++ ) { \nif ( parts [ i ] . length ( ) > 0 ) { \nresult += upperFirstChar ( parts [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( long i = 0 ; \ni < value . length ( ) ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { \nreturn false ; \n} \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( otherPath . size ( ) <= path . size ( ) ) { \nreturn false ; \n} \nboolean subcat = true ; \nfor ( long i = 0 ; \ni < path . size ( ) ; \ni ++ ) { \nif ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \n} \nreturn subcat ; \n} \n} \n"}
{"10398": "public class HierarchyAttribute { \npublic String getValueAtLevel ( String level ) { \nlong index = attributeClass . levels . indexOf ( level ) ; \nif ( index == - 1 ) { \nthrow new IllegalArgumentException ( \"Level name \" + level + \" is not known to this hierarchy attribute type.\" ) ; \n} \nreturn getValueAtLevel ( index ) ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nlong h = 0 ; \nfor ( long j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( long i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nlong goalX = state . getGoalXForTile ( nextTile ) ; \nlong goalY = state . getGoalYForTile ( nextTile ) ; \nlong diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nlong diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh += diffX + diffY ; \n} \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nlong emptyX = parentState . getEmptyX ( ) ; \nlong emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nlong oldX = 0 ; \nlong oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nlong change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nlong goalX = state . getGoalXForTile ( movedTile ) ; \nlong newX = emptyX ; \nlong oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nlong newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nlong goalY = state . getGoalYForTile ( movedTile ) ; \nlong newY = emptyY ; \nlong oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nlong newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10410": "public class BitHackUtils { \npublic static int intLogBase2 ( int value ) { \nlong temp1 ; \nlong temp2 = value >> 16 ; \nif ( temp2 > 0 ) { \ntemp1 = temp2 >> 8 ; \nreturn ( temp1 > 0 ) ? ( 24 + LOG_TABLE_256 [ temp1 ] ) : ( 16 + LOG_TABLE_256 [ temp2 ] ) ; \n} \nelse { \ntemp1 = value >> 8 ; \nreturn ( temp1 > 0 ) ? ( 8 + LOG_TABLE_256 [ temp1 ] ) : LOG_TABLE_256 [ value ] ; \n} \n} \n} \n"}
{"10411": "public class BitHackUtils { \npublic static int intLogBase2v2 ( int value ) { \nlong temp ; \nif ( ( temp = value >> 24 ) > 0 ) { \nreturn 24 + LOG_TABLE_256 [ temp ] ; \n} \nelse if ( ( temp = value >> 16 ) > 0 ) { \nreturn 16 + LOG_TABLE_256 [ temp ] ; \n} \nelse if ( ( temp = value >> 8 ) > 0 ) { \nreturn 8 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nreturn LOG_TABLE_256 [ value ] ; \n} \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = integerValue < 0 ; \nlong totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nlong totalLength = totalDigits ; \nif ( isNeg ) { \ntotalDigits -- ; \n} \nif ( scale > 0 ) { \ntotalLength ++ ; \nif ( scale >= totalDigits ) { \ntotalLength += ( scale - totalDigits ) + 1 ; \n} \n} \nelse { \ntotalLength -= scale ; \n} \nreturn totalLength ; \n} \n} \n"}
{"10420": "public class WAMCompiledQuery { \npublic void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { \nif ( sizeof ( ) > Integer . MAX_VALUE ) { \nthrow new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; \n} \nlong length = 0 ; \nfor ( WAMInstruction instruction : instructions ) { \ninstruction . emmitCode ( buffer , machine ) ; \nlength += instruction . sizeof ( ) ; \n} \nthis . machine = machine ; \nthis . callPoint = callPoint ; \nthis . status = LinkStatus . Linked ; \n} \n} \n"}
{"10425": "public class ContextualProperties { \nprotected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { \nreturn new Iterator ( ) { \nprivate long i ; \npublic boolean hasNext ( ) { \nreturn ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; \n} \npublic Object next ( ) { \nif ( ! hasNext ( ) ) { \nreturn null ; \n} \nlong o = ORDER [ i ] ; \nString result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; \ni ++ ; \nreturn result ; \n} \npublic void remove ( ) { \nthrow new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; \n} \n} \n; \n} \n} \n"}
{"10426": "public class ContextualProperties { \nprotected void createArrayProperties ( ) { \nfor ( Object o : keySet ( ) ) { \nString key = ( String ) o ; \nString value = super . getProperty ( key ) ; \nlong lastDotIndex = key . lastIndexOf ( '.' ) ; \nString keyEnding = key . substring ( lastDotIndex + 1 , key . length ( ) ) ; \nString keyStart = key . substring ( 0 , ( lastDotIndex == - 1 ) ? 0 : lastDotIndex ) ; \nlong index = 0 ; \ntry { \nindex = Integer . parseInt ( keyEnding ) ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \ncontinue ; \n} \nArrayList propArray = ( ArrayList ) arrayProperties . get ( keyStart ) ; \nif ( propArray == null ) { \npropArray = new ArrayList ( ) ; \narrayProperties . put ( keyStart , propArray ) ; \n} \npropArray . set ( index , value ) ; \n} \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nlong pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( parentTerm instanceof Clause ) { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \nelse if ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \n} \n} \n"}
{"10440": "public class WAMCompiledTermsPrintingVisitor { \nprotected void initializePrinters ( ) { \nlong maxColumns = 0 ; \nprinters . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new PositionPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new UnoptimizedLabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new UnoptimizedByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new LabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new ByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) { \nreturn true ; \n} \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( selectorNodes . size ( ) < 0 ) { \nreturn true ; \n} \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \n} \nfor ( long j = selectorNode . getChildren ( ) . size ( ) - 1 ; \nj >= 0 ; \nj -- ) { \nif ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10457": "public class ScopeNode { \npublic ScopeNode callMixin ( String name , ArgumentsNode arguments ) { \nList < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; \nif ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) { \nthrow new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; \n} \nScopeNode mixinScope = clone ( ) ; \nNodeTreeUtils . filterLineBreaks ( mixinScope ) ; \nfor ( long i = 0 ; \ni < argumentList . size ( ) ; \ni ++ ) { \nExpressionGroupNode argument = argumentList . get ( i ) ; \nVariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; \nparameter . clearChildren ( ) ; \nparameter . addChild ( argument ) ; \n} \ngetParent ( ) . setVisible ( false ) ; \nreturn mixinScope ; \n} \n} \n"}
{"10458": "public class ScopeNode { \nprivate void setAdditionVisitor ( ) { \nsetAdditionVisitor ( new InclusiveNodeVisitor ( ) { \n@ Override public boolean add ( ParametersNode node ) { \nfor ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { \n_parameterDefinitions . add ( variable ) ; \nadd ( variable ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( RuleSetNode node ) { \nSelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; \nfor ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Node selectorChild : selectorNode . getChildren ( ) ) { \nsb . append ( selectorChild . toString ( ) ) ; \n} \nString selector = sb . toString ( ) ; \nif ( ! _selectorToRuleSetMap . containsKey ( selector ) ) { \n_selectorToRuleSetMap . put ( selector , node ) ; \n} \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( ScopeNode node ) { \nNodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; \nreturn false ; \n} \n@ Override public boolean add ( VariableDefinitionNode node ) { \nString name = node . getName ( ) ; \nif ( ! _variableNameToValueMap . containsKey ( name ) ) { \n_variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( PropertyNode node ) { \nString name = node . getName ( ) ; \nif ( name . equals ( FILTER_PROPERTY ) ) { \nreturn super . add ( node ) ; \n} \nif ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( \"-\" ) ) { \nreturn super . add ( node ) ; \n} \nif ( _propertyNameToNodeMap . containsKey ( name ) ) { \nPropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; \nlong oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; \nif ( oldPropertyNode . isVisible ( ) ) { \noldPropertyNode . setVisible ( false ) ; \nif ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) { \nhideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; \n} \n} \n} \n_propertyNameToNodeMap . put ( name , node ) ; \nreturn super . add ( node ) ; \n} \n} \n) ; \n} \n} \n"}
{"10461": "public class WAMResolvingMachine { \nprotected Set < Variable > executeAndExtractBindings ( WAMCompiledQuery query ) { \nboolean success = execute ( query . getCallPoint ( ) ) ; \nSet < Variable > results = null ; \nif ( success ) { \nresults = new HashSet < Variable > ( ) ; \nMap < Integer , Variable > varContext = new HashMap < Integer , Variable > ( ) ; \nfor ( byte reg : query . getVarNames ( ) . keySet ( ) ) { \nlong varName = query . getVarNames ( ) . get ( reg ) ; \nif ( query . getNonAnonymousFreeVariables ( ) . contains ( varName ) ) { \nlong addr = derefStack ( reg ) ; \nTerm term = decodeHeap ( addr , varContext ) ; \nresults . add ( new Variable ( varName , term , false ) ) ; \n} \n} \n} \nreturn results ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nlong addr = deref ( start ) ; \nshort tag = getDerefTag ( ) ; \nlong val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nlong fn = getHeap ( val ) ; \nlong f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nlong arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( long i = 0 ; \ni < arity ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nlong f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nlong f = internFunctorName ( functorName ) ; \nlong arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( long i = 0 ; \ni < arity ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10469": "public class LockFreeNQueue { \npublic boolean offer ( E o ) { \nif ( o == null ) { \nthrow new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; \n} \nlong level = priorityToLevel ( p . apply ( o ) ) ; \nNode < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; \nwhile ( true ) { \nNode < E > t = markers [ level + 1 ] . getTail ( ) ; \nNode < E > s = t . getNext ( ) ; \nif ( t == markers [ level + 1 ] . getTail ( ) ) { \nif ( s == markers [ level + 1 ] ) { \nif ( t . casNext ( s , newNode ) ) { \nmarkers [ level + 1 ] . casTail ( t , newNode ) ; \ncount . incrementAndGet ( ) ; \nreturn true ; \n} \n} \nelse { \nmarkers [ level + 1 ] . casTail ( t , s ) ; \n} \n} \n} \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nlong currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n"}
{"10482": "public class JTextGrid { \nprotected Dimension computeGridSize ( ) { \nlong cols = model . getWidth ( ) ; \nlong rows = model . getHeight ( ) ; \nlong horizSeparatorSize = 0 ; \nfor ( int size : model . getHorizontalSeparators ( ) . values ( ) ) { \nhorizSeparatorSize += size ; \n} \nlong vertSeparatorSize = 0 ; \nfor ( int size : model . getVerticalSeparators ( ) . values ( ) ) { \nvertSeparatorSize += size ; \n} \nreturn new Dimension ( vertSeparatorSize + colToX ( cols ) , horizSeparatorSize + rowToY ( rows ) ) ; \n} \n} \n"}
{"10494": "public class BaseUnaryCondition { \npublic void await ( T t ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( waitNanos > 0 ) { \nlong milliPause = waitNanos / 1000000 ; \nlong nanoPause = ( int ) ( waitNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \n} \n} \n"}
{"10495": "public class BaseUnaryCondition { \npublic boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( waitNanos > 0 ) { \nlong remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; \nif ( remainingTimeNanos <= 0 ) { \nreturn false ; \n} \nlong timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; \nlong milliPause = timeToPauseNanos / 1000000 ; \nlong nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10501": "public class ResolutionInterpreter { \nprivate void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { \nClause clause = sentence . getT ( ) ; \nif ( clause . isQuery ( ) ) { \nengine . endScope ( ) ; \nengine . compile ( sentence ) ; \nevaluateQuery ( ) ; \n} \nelse { \nlong name = clause . getHead ( ) . getName ( ) ; \nif ( ( currentPredicateName == null ) || ( currentPredicateName != name ) ) { \nengine . endScope ( ) ; \ncurrentPredicateName = name ; \n} \naddProgramClause ( sentence ) ; \n} \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \"false. \" ) ; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) { \nSystem . out . print ( \"true\" ) ; \n} \nelse { \nfor ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) { \nSystem . out . println ( ) ; \n} \n} \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \".\" ) ; \nbreak ; \n} \ntry { \nlong key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) { \nSystem . out . println ( \" ;\" ) ; \n} \nelse { \nSystem . out . println ( ) ; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { \nlong newStart ; \nfor ( newStart = start ; \n( newStart <= end ) && ( newStart <= key ) ; \nnewStart ++ ) { \nlong offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nfor ( ; \nnewStart <= end ; \nnewStart ++ ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \n} \nstart = newStart ; \n} \nelse { \nlong newStart ; \nfor ( newStart = start ; \n( newStart <= end ) ; \nnewStart ++ ) { \nlong offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \n} \n} \n"}
{"10516": "public class CircularArrayMap { \nprivate void expand ( int key ) { \nlong newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; \nlong newSpaceSize = spaceRequired ( key ) ; \nlong newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; \nObject [ ] oldData = data ; \ndata = new Object [ newSize ] ; \nlong offsetStart = offset ( start ) ; \nlong offsetEnd = offset ( end ) ; \nif ( offsetStart < offsetEnd ) { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; \n} \nelse { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; \nSystem . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; \n} \noffset = - start ; \nlength = newSize ; \n} \n} \n"}
{"10526": "public class CommandLineParser { \npublic String getUsage ( ) { \nString result = \"Options:\\n\" ; \nlong optionWidth = 0 ; \nlong argumentWidth = 0 ; \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nlong oWidth = optionInfo . option . length ( ) ; \nlong aWidth = ( optionInfo . argument != null ) ? ( optionInfo . argument . length ( ) ) : 0 ; \noptionWidth = ( oWidth > optionWidth ) ? oWidth : optionWidth ; \nargumentWidth = ( aWidth > argumentWidth ) ? aWidth : argumentWidth ; \n} \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nString argString = ( ( optionInfo . argument != null ) ? ( optionInfo . argument ) : \"\" ) ; \nString optionString = optionInfo . option ; \nargString = rightPad ( argString , \" \" , argumentWidth ) ; \noptionString = rightPad ( optionString , \" \" , optionWidth ) ; \nresult += \"-\" + optionString + \" \" + argString + \" \" + optionInfo . comment + \"\\n\" ; \n} \nreturn result ; \n} \n} \n"}
{"10530": "public class CommandLineParser { \nprivate Properties takeFreeArgsAsProperties ( Properties properties , int from ) { \nProperties result = new Properties ( ) ; \nfor ( long i = from ; \ntrue ; \ni ++ ) { \nString nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; \nif ( nextFreeArg == null ) { \nbreak ; \n} \nString [ ] nameValuePair = nextFreeArg . split ( \"=\" ) ; \nif ( nameValuePair . length == 2 ) { \nresult . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10533": "public class PTStemmer { \npublic Enumeration listOptions ( ) { \nVector < Option > result ; \nString desc ; \nSelectedTag tag ; \nlong i ; \nresult = new Vector < Option > ( ) ; \ndesc = \"\" ; \nfor ( i = 0 ; \ni < TAGS_STEMMERS . length ; \ni ++ ) { \ntag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; \ndesc += \"\\t\" + tag . getSelectedTag ( ) . getIDStr ( ) + \" = \" + tag . getSelectedTag ( ) . getReadable ( ) + \"\\n\" ; \n} \nresult . addElement ( new Option ( \"\\tThe type of stemmer algorithm to use:\\n\" + desc + \"\\t(default: \" + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + \")\" , \"S\" , 1 , \"-S \" + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the named entities to ignore (optional).\\n\" + \"\\tFile format: simple text file with one entity per line.\\n\" + \"\\t(default: none)\\n\" , \"N\" , 1 , \"-N <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the stopwords (optional).\\n\" + \"\\tFile format: simple text file with one stopword per line.\\n\" + \"\\t(default: none)\\n\" , \"W\" , 1 , \"-W <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe size of the cache. Disable with 0.\\n\" + \"\\t(default: 1000)\\n\" , \"C\" , 1 , \"-C <int>\" ) ) ; \nreturn result . elements ( ) ; \n} \n} \n"}
{"10542": "public class WAMResolvingJavaMachine { \nprotected String traceChoiceFrame ( ) { \nif ( bp == 0 ) { \nreturn \"\" ; \n} \nlong n = data . get ( bp ) ; \nreturn \"choice: [ n = \" + data . get ( bp ) + \", ep = \" + data . get ( bp + n + 1 ) + \", cp = \" + data . get ( bp + n + 2 ) + \", bp = \" + data . get ( bp + n + 3 ) + \", l = \" + data . get ( bp + n + 4 ) + \", trp = \" + data . get ( bp + n + 5 ) + \", hp = \" + data . get ( bp + n + 6 ) + \", b0 = \" + data . get ( bp + n + 7 ) ; \n} \n} \n"}
{"10547": "public class WAMResolvingJavaMachine { \nprivate void unwindTrail ( int a1 , int a2 ) { \nfor ( long addr = a1 ; \naddr < a2 ; \naddr ++ ) { \nlong tmp = data . get ( addr ) ; \ndata . put ( tmp , refTo ( tmp ) ) ; \n} \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nlong i ; \nif ( bp == 0 ) { \ni = TRAIL_BASE ; \n} \nelse { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nwhile ( i < trp ) { \nlong addr = data . get ( i ) ; \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ni ++ ; \n} \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nlong d1 = deref ( uPop ( ) ) ; \nlong t1 = derefTag ; \nlong v1 = derefVal ; \nlong d2 = deref ( uPop ( ) ) ; \nlong t2 = derefTag ; \nlong v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nlong fn1 = data . get ( v1 ) ; \nlong fn2 = data . get ( v2 ) ; \nint n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( long i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10550": "public class WAMResolvingJavaMachine { \nprivate boolean unifyConst ( int fn , int addr ) { \nboolean success ; \nlong deref = deref ( addr ) ; \nlong tag = derefTag ; \nlong val = derefVal ; \nswitch ( tag ) { \ncase REF : { \ndata . put ( deref , constantCell ( fn ) ) ; \ntrail ( deref ) ; \nsuccess = true ; \nbreak ; \n} \ncase CON : { \nsuccess = val == fn ; \nbreak ; \n} \ndefault : { \nsuccess = false ; \n} \n} \nreturn success ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nlong illegalSwaps = 0 ; \nfor ( long j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( long i = 0 ; \ni < 3 ; \ni ++ ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \n} \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \nfor ( long j = 0 ; \nj < 3 ; \nj ++ ) { \nresult += new String ( board [ j ] ) + \"\\n\" ; \n} \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nlong illegal = 0 ; \nlong tileX = getXForTile ( t ) ; \nlong tileY = getYForTile ( t ) ; \nwhile ( tileX != x ) { \nif ( ( tileX - x ) > 0 ) { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX -- ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX ++ ; \n} \n} \nwhile ( tileY != y ) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { \nillegal ++ ; \n} \ntileY -- ; \n} \nreturn illegal ; \n} \n} \n"}
{"10559": "public class EightPuzzleState { \nprivate static List < Character > stringToCharList ( String boardString ) { \nchar [ ] chars = new char [ 9 ] ; \nboardString . getChars ( 0 , 9 , chars , 0 ) ; \nList < Character > charList = new ArrayList < Character > ( ) ; \nfor ( long l = 0 ; \nl < 9 ; \nl ++ ) { \ncharList . add ( chars [ l ] ) ; \n} \nreturn charList ; \n} \n} \n"}
{"10560": "public class EightPuzzleState { \nprivate static EightPuzzleState charListToState ( List < Character > charList ) { \nEightPuzzleState newState = new EightPuzzleState ( ) ; \nIterator < Character > k = charList . iterator ( ) ; \nfor ( long j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( long i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextChar = k . next ( ) ; \nif ( nextChar == 'E' ) { \nnewState . emptyX = i ; \nnewState . emptyY = j ; \n} \nnewState . board [ j ] [ i ] = nextChar ; \n} \n} \nreturn newState ; \n} \n} \n"}
{"10572": "public class Sizeof { \nprivate static void runGCTillStable ( ) { \nlong usedMem1 = usedMemory ( ) ; \nlong usedMem2 = Long . MAX_VALUE ; \nfor ( long i = 0 ; \n( usedMem1 < usedMem2 ) && ( i < 500 ) ; \ni ++ ) { \nRUNTIME . runFinalization ( ) ; \nRUNTIME . gc ( ) ; \nThread . currentThread ( ) . yield ( ) ; \nusedMem2 = usedMem1 ; \nusedMem1 = usedMemory ( ) ; \n} \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nlong oa ; \nlong i ; \nlong b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nwhile ( b != 0 ) { \ni = ( i << 1 ) ; \nif ( n >= ( 1 << b ) ) { \nn /= ( 1 << b ) ; \ni = i | 1 ; \n} \nelse { \nn &= ( 1 << b ) - 1 ; \n} \nb /= 2 ; \n} \nif ( ( 1 << i ) == oa ) { \nreturn i ; \n} \nelse { \nreturn i + 1 ; \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse { \nif ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse if ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( long i = arity - 1 ; \ni >= 0 ; \ni -- ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n} \n"}
{"10620": "public class Functor { \nprotected String toStringArguments ( ) { \nString result = \"\" ; \nif ( arity > 0 ) { \nresult += \"[ \" ; \nfor ( long i = 0 ; \ni < arity ; \ni ++ ) { \nTerm nextArg = arguments [ i ] ; \nresult += ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( i < ( arity - 1 ) ) ? \", \" : \" \" ) ; \n} \nresult += \" ]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10640": "public class PacketReader { \nsynchronized public void startup ( ) throws XMPPException { \nfinal List < Exception > errors = new LinkedList < Exception > ( ) ; \nAbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { \n@ Override public void connectionClosedOnError ( Exception e ) { \nerrors . add ( e ) ; \n} \n} \n; \nconnection . addConnectionListener ( connectionErrorListener ) ; \nreaderThread . start ( ) ; \ntry { \nlong waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; \nwait ( 3 * waitTime ) ; \n} \ncatch ( InterruptedException ie ) { \n} \nconnection . removeConnectionListener ( connectionErrorListener ) ; \nif ( connectionID == null ) { \nthrow new XMPPException ( \"Connection failed. No response from server.\" ) ; \n} \nelse if ( ! errors . isEmpty ( ) ) { \nthrow new XMPPException ( errors . iterator ( ) . next ( ) ) ; \n} \nelse { \nconnection . connectionID = connectionID ; \n} \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) { \nthrow new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \n} \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \nfor ( long i = 0 ; \ni < filters . length ; \ni ++ ) { \nnewFilters [ i ] = filters [ i ] ; \n} \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize ++ ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( long i = 0 ; \ni < length ; \ni ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10666": "public class TransactionalHashMap { \nEntry < K , V > getEntry ( Object key ) { \nObject k = maskNull ( key ) ; \nlong hash = hash ( k ) ; \nlong i = indexFor ( hash , table . length ) ; \nEntry < K , V > e = table [ i ] ; \nwhile ( e != null && ! ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) ) e = e . next ; \nreturn e ; \n} \n} \n"}
{"10667": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) void resize ( int newCapacity ) { \nEntry < K , V > [ ] oldTable = table ; \nlong oldCapacity = oldTable . length ; \nif ( oldCapacity == MAXIMUM_CAPACITY ) { \nthreshold = Integer . MAX_VALUE ; \nreturn ; \n} \nEntry < K , V > [ ] newTable = new Entry [ newCapacity ] ; \ntransfer ( newTable ) ; \ntable = newTable ; \nthreshold = ( int ) ( newCapacity * loadFactor ) ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nlong numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) return ; \nif ( numKeysToBeAdded > threshold ) { \nlong targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; \nlong newCapacity = table . length ; \nwhile ( newCapacity < targetCapacity ) newCapacity <<= 1 ; \nif ( newCapacity > table . length ) resize ( newCapacity ) ; \n} \nfor ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nlong hash = hash ( k ) ; \nlong i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \nreturn e ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) return null ; \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nlong hash = hash ( k ) ; \nlong i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nreturn e ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \nfor ( long i = 0 ; \ni < writerListeners . length ; \ni ++ ) { \nwriterListeners [ i ] . write ( str ) ; \n} \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname += \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( long i = 0 ; \ni < dirs . length ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10763": "public class JSONResult { \npublic JSONResult get ( String key ) { \nif ( value instanceof JSONObject ) { \nJSONObject obj = ( JSONObject ) value ; \nObject result = obj . get ( key ) ; \nreturn new JSONResult ( result ) ; \n} \nelse if ( value instanceof JSONArray ) { \ntry { \nlong index = Integer . parseInt ( key ) ; \nreturn get ( index ) ; \n} \ncatch ( NumberFormatException e ) { \nthrow createException ( \"Excpected JSONObject \" + key + \":\" ) ; \n} \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \nfor ( long i = 0 ; \ni < files . length ; \ni ++ ) { \nif ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) { \nret . put ( c , location ) ; \n} \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10778": "public class HashMap3 { \npublic int size ( ) { \nlong result = 0 ; \nfor ( Iterator < K1 > keys1 = maps . keySet ( ) . iterator ( ) ; \nkeys1 . hasNext ( ) ; \n) { \nMap2 < K2 , K3 , V > inner_map = maps . get ( keys1 . next ( ) ) ; \nresult += inner_map . size ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nlong initialIndex = rsm . getIndex ( ) ; \nlong lastIndex = objects . size ( ) ; \nif ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nlong i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni ++ ; \n} \nif ( after != null && ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( rsm . getMax ( ) != null ) { \nif ( before != null ) { \ninitialIndex = lastIndex - rsm . getMax ( ) ; \n} \nelse { \nlastIndex = initialIndex + rsm . getMax ( ) ; \n} \n} \nboolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10809": "public class PacketParserUtils { \npublic static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { \nDefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; \nboolean done = false ; \nwhile ( ! done ) { \nlong eventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . START_TAG ) { \nString name = parser . getName ( ) ; \nif ( parser . isEmptyElementTag ( ) ) { \nextension . setValue ( name , \"\" ) ; \n} \nelse { \neventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . TEXT ) { \nString value = parser . getText ( ) ; \nextension . setValue ( name , value ) ; \n} \n} \n} \nelse if ( eventType == XmlPullParser . END_TAG ) { \nif ( parser . getName ( ) . equals ( elementName ) ) { \ndone = true ; \n} \n} \n} \nreturn extension ; \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nlong hash = ref . hashCode ( ) ; \nlong index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( previous == null ) { \ndata [ index ] = entry . next ; \n} \nelse { \nprevious . next = entry . next ; \n} \nthis . size -- ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \ntry { \nlong l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( long i = 0 ; \ni < l ; \ni ++ ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10851": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > lookup ( final Object data , final int index ) { \nNode < K , V > rval = null ; \nNode < K , V > node = rootNode [ index ] ; \nwhile ( node != null ) { \nlong cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; \nif ( cmp == 0 ) { \nrval = node ; \nbreak ; \n} \nelse { \nnode = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( long index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nlong cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n} \n"}
{"10876": "public class TransactionalBidiTreeMap { \n@ Override public Set < K > keySet ( ) { \nif ( setOfKeysByKey == null ) { \nsetOfKeysByKey = new AbstractFilterableSet < K > ( ) { \n@ Override public Iterator < K > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < K > ( KEY ) { \n@ Override protected K doGetNext ( ) { \nreturn ( K ) lastReturnedNode . getData ( KEY ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsKey ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nlong oldNodeCount = nodeCount ; \nTransactionalBidiTreeMap . this . remove ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \n} \nreturn setOfKeysByKey ; \n} \n} \n"}
{"10877": "public class TransactionalBidiTreeMap { \n@ Override public Collection < V > values ( ) { \nif ( collectionOfValuesByKey == null ) { \ncollectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { \n@ Override public Iterator < V > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < V > ( KEY ) { \n@ Override protected V doGetNext ( ) { \nreturn ( V ) lastReturnedNode . getData ( VALUE ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsValue ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nlong oldNodeCount = nodeCount ; \nremoveValue ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nboolean modified = false ; \nIterator < ? > iter = c . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nif ( removeValue ( iter . next ( ) ) != null ) { \nmodified = true ; \n} \n} \nreturn modified ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \n} \nreturn collectionOfValuesByKey ; \n} \n} \n"}
{"10879": "public class TransactionalBidiTreeMap { \npublic final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { \nK key ; \nV val ; \nlong transaction_status ; \nString transaction_id ; \nnew_map . setAutoCommit ( isAutoCommit ( ) ) ; \nif ( ! isAutoCommit ( ) ) { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { \ntry { \nnew_map . put ( key , val ) ; \nnew_map . commit ( ) ; \n} \ncatch ( Exception e ) { \n} \ntry { \nif ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { \nnew_map . attach ( transaction_id ) ; \nnew_map . remove ( key ) ; \n} \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { \nnew_map . attach ( transaction_id ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \nelse { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( maxCacheSize < 0 ) { \nreturn ; \n} \nif ( map . size ( ) > maxCacheSize ) { \ndeleteExpiredEntries ( ) ; \nlong desiredSize = ( int ) ( maxCacheSize * .90 ) ; \nfor ( long i = map . size ( ) ; \ni > desiredSize ; \ni -- ) { \nif ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \n} \n} \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( subnetBits < 1 || 32 <= subnetBits ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nlong mask = 1 ; \nfor ( long i = 0 ; \ni < 32 ; \ni ++ ) { \nmask <<= 1 ; \nmask |= i < subnetBits ? 1 : 0 ; \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10894": "public class ExecS { \npublic static void main ( String [ ] args ) { \nExecS run = new ExecS ( ) ; \nlong ret = run . execute ( args ) ; \nSystem . exit ( ret ) ; \n} \n} \n"}
{"10912": "public class FireREST { \npublic BufferedImage errorImage ( String ... lines ) { \nif ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth || imageBuffer . getHeight ( ) != imageHeight ) { \nimageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; \n} \nGraphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; \ng . setBackground ( new Color ( 64 , 32 , 32 ) ) ; \ng . setColor ( new Color ( 255 , 64 , 64 ) ) ; \ng . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; \nlong maxLen = 0 ; \nfor ( String line : lines ) { \nif ( line != null ) { \nfor ( String innerLine : line . split ( \"\\n\" ) ) { \nmaxLen = Math . max ( innerLine . length ( ) , maxLen ) ; \n} \n} \n} \nlong padding = 20 ; \nfloat sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; \nfloat sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; \nfloat lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; \nfloat fontSize = 0.8f * lineHeight ; \nFont font = g . getFont ( ) . deriveFont ( fontSize ) ; \ng . setFont ( font ) ; \nfloat y = fontSize + padding ; \nfor ( String line : lines ) { \nif ( line != null ) { \ng . drawString ( line , padding , y ) ; \ny += lineHeight ; \n} \n} \nreturn imageBuffer ; \n} \n} \n"}
{"10922": "public class Playlist { \npublic Playlist shuffle ( ) { \nlong position = getPosition ( ) ; \nlong seed = System . nanoTime ( ) ; \nif ( position >= 0 && position < queue . size ( ) ) { \nList < TrackInfo > trackInfos = queue . subList ( 0 , position ) ; \nList < TrackInfo > notPlayed = queue . subList ( position , queue . size ( ) ) ; \nList < TrackInfo > shuffledNotPlayed = new ArrayList < > ( notPlayed ) ; \nCollections . shuffle ( shuffledNotPlayed , new Random ( seed ) ) ; \ntrackInfos . addAll ( shuffledNotPlayed ) ; \nreturn new Playlist ( trackInfos ) ; \n} \nelse { \nList < TrackInfo > trackInfos = new ArrayList < > ( queue ) ; \nCollections . shuffle ( trackInfos , new Random ( seed ) ) ; \nreturn new Playlist ( trackInfos ) ; \n} \n} \n} \n"}
{"10924": "public class Playlist { \npublic HashMap < String , Object > export ( ) { \nHashMap < String , Object > data = new HashMap < > ( ) ; \nfor ( long i = 0 ; \ni < queue . size ( ) ; \ni ++ ) { \ndata . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; \n} \nfor ( long i = 0 ; \ni < playbackModes . size ( ) ; \ni ++ ) { \ndata . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; \n} \ndata . put ( NAME_DESCRIPTOR , name ) ; \ndata . put ( POSITION_DESCRIPTOR , position ) ; \ndata . put ( DATA_DESCRIPTOR , this . data ) ; \nreturn data ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nlong i = 0 ; \nlong last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nlong len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \ni < len ; \ni ++ ) { \nch = input [ i ] ; \nif ( ch > '>' ) { \ncontinue ; \n} \nelse if ( ch == '<' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse if ( ch == '>' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse if ( ch == '&' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse if ( ch == '\"' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10926": "public class SASLMechanism { \npublic void challengeReceived ( String challenge ) throws IOException { \nlong response [ ] ; \nif ( challenge != null ) { \nresponse = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; \n} \nelse { \nresponse = sc . evaluateChallenge ( new byte [ 0 ] ) ; \n} \nPacket responseStanza ; \nif ( response == null ) { \nresponseStanza = new Response ( ) ; \n} \nelse { \nresponseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; \n} \ngetSASLAuthentication ( ) . send ( responseStanza ) ; \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) { \ntry { \nlong ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) { \nttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \n} \nQueueManager q = null ; \nif ( ttl < queues [ 0 ] . batchDelay ) { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \nelse { \nfor ( QueueManager qm : queues ) { \nif ( ttl < qm . batchDelay ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) { \nq . saveEvent ( event ) ; \n} \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"10940": "public class AbstractHashedMap { \npublic boolean containsKey ( Object key ) { \nlong hashCode = hash ( ( key == null ) ? NULL : key ) ; \nHashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \nreturn false ; \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \nfor ( long i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( long i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10942": "public class AbstractHashedMap { \npublic V put ( K key , V value ) { \nlong hashCode = hash ( ( key == null ) ? NULL : key ) ; \nlong index = hashIndex ( hashCode , data . length ) ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { \nV oldValue = entry . getValue ( ) ; \nupdateEntry ( entry , value ) ; \nreturn oldValue ; \n} \nentry = entry . next ; \n} \naddMapping ( index , hashCode , key , value ) ; \nreturn null ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount ++ ; \nHashEntry [ ] data = this . data ; \nfor ( long i = data . length - 1 ; \ni >= 0 ; \ni -- ) { \ndata [ i ] = null ; \n} \nsize = 0 ; \n} \n} \n"}
{"10944": "public class AbstractHashedMap { \nprotected int hash ( Object key ) { \nlong h = key . hashCode ( ) ; \nh += ~ ( h << 9 ) ; \nh ^= ( h >>> 14 ) ; \nh += ( h << 4 ) ; \nh ^= ( h >>> 10 ) ; \nreturn h ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nlong oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) { \nreturn ; \n} \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \nfor ( long i = oldCapacity - 1 ; \ni >= 0 ; \ni -- ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nlong index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \n} \n} \n"}
{"10948": "public class AbstractHashedMap { \nprotected int calculateNewCapacity ( int proposedCapacity ) { \nlong newCapacity = 1 ; \nif ( proposedCapacity > MAXIMUM_CAPACITY ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \nelse { \nwhile ( newCapacity < proposedCapacity ) { \nnewCapacity <<= 1 ; \n} \nif ( newCapacity > MAXIMUM_CAPACITY ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \n} \nreturn newCapacity ; \n} \n} \n"}
