{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nfor ( ; \n! deque . isEmpty ( ) ; \n) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( int i = exceptions . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \n} \n} \nelse { \nlist . add ( e ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nfor ( ; \na != null ; \n) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nfor ( ; \na != null ; \n) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"62": "public class PerfAsyncConsumer { \npublic PerfAsyncConsumer await ( int count ) { \nif ( count <= 1000 ) { \nfor ( ; \ngetCount ( ) != 0 ; \n) { \n} \n} \nelse { \ntry { \nawait ( ) ; \n} \ncatch ( InterruptedException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"87": "public class SpringSecurityLdapTemplate { \npublic static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { \nfinal DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; \nfinal DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; \nfinal NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\" ) ; \n} \nSet < DirContextOperations > results = new HashSet < > ( ) ; \ntry { \nfor ( ; \nresultsEnum . hasMore ( ) ; \n) { \nSearchResult searchResult = resultsEnum . next ( ) ; \nDirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; \nAssert . notNull ( dca , \"No object returned by search, DirContext is not correctly configured\" ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Found DN: \" + dca . getDn ( ) ) ; \n} \nresults . add ( dca ) ; \n} \n} \ncatch ( PartialResultException e ) { \nLdapUtils . closeEnumeration ( resultsEnum ) ; \nlogger . info ( \"Ignoring PartialResultException\" ) ; \n} \nif ( results . size ( ) == 0 ) { \nthrow new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; \n} \nif ( results . size ( ) > 1 ) { \nthrow new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; \n} \nreturn results . iterator ( ) . next ( ) ; \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < cookieTokens . length ; \ni ++ ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( i < cookieTokens . length - 1 ) { \nsb . append ( DELIMITER ) ; \n} \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nfor ( ; \nsb . charAt ( sb . length ( ) - 1 ) == '=' ; \n) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"213": "public class JaasAuthenticationProvider { \nprivate void configureJaasUsingLoop ( ) throws IOException { \nString loginConfigUrl = convertLoginConfigToUrl ( ) ; \nboolean alreadySet = false ; \nint n = 1 ; \nfinal String prefix = \"login.config.url.\" ; \nString existing ; \nfor ( ; \n( existing = Security . getProperty ( prefix + n ) ) != null ; \n) { \nalreadySet = existing . equals ( loginConfigUrl ) ; \nif ( alreadySet ) { \nbreak ; \n} \nn ++ ; \n} \nif ( ! alreadySet ) { \nString key = prefix + n ; \nlog . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; \nSecurity . setProperty ( key , loginConfigUrl ) ; \n} \n} \n} \n"}
{"365": "public class FilterChainInvocation { \nprivate Filter findNextFilter ( HttpServletRequest request ) { \nfor ( ; \n++ index < filterDefinitions . length ; \n) { \nFilter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; \nif ( filter != null ) { \nreturn filter ; \n} \n} \nreturn null ; \n} \n} \n"}
{"405": "public class DefaultConnectionManager { \n@ Override public Map < String , List < Connection > > getAll ( ) { \nMap < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nif ( null != pool ) { \nallConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; \n} \n} \nreturn allConnections ; \n} \n} \n"}
{"406": "public class DefaultConnectionManager { \n@ Override public void scan ( ) { \nif ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { \nIterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nString poolKey = iter . next ( ) ; \nConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; \nif ( null != pool ) { \npool . scan ( ) ; \nif ( pool . isEmpty ( ) ) { \nif ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { \niter . remove ( ) ; \nlogger . warn ( \"Remove expired pool task of poolKey {} which is empty.\" , poolKey ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"413": "public class Connection { \npublic void onClose ( ) { \nIterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nEntry < Integer , InvokeFuture > entry = iter . next ( ) ; \niter . remove ( ) ; \nInvokeFuture future = entry . getValue ( ) ; \nif ( future != null ) { \nfuture . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; \nfuture . cancelTimeout ( ) ; \nfuture . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \n} \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nBitSet bs = new BitSet ( ) ; \nint index = 0 ; \nfor ( ; \nvalue != 0 ; \n) { \nif ( value % 2 != 0 ) { \nbs . set ( index ) ; \n} \n++ index ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools && ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nelse { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) { \noffConn . close ( ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns || conns . isEmpty ( ) ) { \nreturn null ; \n} \nint size = conns . size ( ) ; \nint tries = 0 ; \nConnection result = null ; \nfor ( ; \n( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ; \n) { \nresult = conns . get ( this . random . nextInt ( size ) ) ; \n} \nif ( result != null && ! result . isFine ( ) ) { \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"506": "public class WebSocketServer { \nprivate void doAdditionalRead ( ) throws InterruptedException , IOException { \nWebSocketImpl conn ; \nfor ( ; \n! iqueue . isEmpty ( ) ; \n) { \nconn = iqueue . remove ( 0 ) ; \nWrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; \nByteBuffer buf = takeBuffer ( ) ; \ntry { \nif ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n} \n} \n} \n"}
{"651": "public class MemberUtils { \nprivate static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { \nif ( destClass . isPrimitive ( ) ) { \nreturn getPrimitivePromotionCost ( srcClass , destClass ) ; \n} \nfloat cost = 0.0f ; \nfor ( ; \nsrcClass != null && ! destClass . equals ( srcClass ) ; \n) { \nif ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { \ncost += 0.25f ; \nbreak ; \n} \ncost ++ ; \nsrcClass = srcClass . getSuperclass ( ) ; \n} \nif ( srcClass == null ) { \ncost += 1.5f ; \n} \nreturn cost ; \n} \n} \n"}
{"672": "public class TinyBitSet { \npublic int cardinality ( ) { \nint w = value ; \nint c = 0 ; \nfor ( ; \nw != 0 ; \n) { \nc += T [ w & 255 ] ; \nw >>= 8 ; \n} \nreturn c ; \n} \n} \n"}
{"700": "public class Handler { \nstatic int getExceptionTableLength ( final Handler firstHandler ) { \nint length = 0 ; \nHandler handler = firstHandler ; \nfor ( ; \nhandler != null ; \n) { \nlength ++ ; \nhandler = handler . nextHandler ; \n} \nreturn length ; \n} \n} \n"}
{"719": "public class RequestScope { \nprotected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; \nfor ( ; \nattributeNames . hasMoreElements ( ) ; \n) { \nfinal String attrName = attributeNames . nextElement ( ) ; \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( attrName ) ; \nif ( name != null ) { \nfinal Object attrValue = servletRequest . getAttribute ( attrName ) ; \ntarget . writeValue ( name , attrValue , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nfor ( ; \nparamNames . hasMoreElements ( ) ; \n) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nfor ( ; \nparamNames . hasMoreElements ( ) ; \n) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"743": "public class ClassScanner { \nprotected void scanJarFile ( final File file ) { \nfinal ZipFile zipFile ; \ntry { \nzipFile = new ZipFile ( file ) ; \n} \ncatch ( IOException ioex ) { \nif ( ! ignoreException ) { \nthrow new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; \n} \nreturn ; \n} \nfinal Enumeration entries = zipFile . entries ( ) ; \nfor ( ; \nentries . hasMoreElements ( ) ; \n) { \nfinal ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; \nfinal String zipEntryName = zipEntry . getName ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { \nfinal String entryName = prepareEntryName ( zipEntryName , true ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \nelse if ( includeResources ) { \nfinal String entryName = prepareEntryName ( zipEntryName , false ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nZipUtil . close ( zipFile ) ; \nthrow rex ; \n} \n} \n} \nZipUtil . close ( zipFile ) ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) { \nrootPath += File . separatorChar ; \n} \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nfor ( ; \n( file = ff . nextFile ( ) ) != null ; \n) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { \nscanClassFile ( filePath , rootPath , file , true ) ; \n} \nelse if ( includeResources ) { \nscanClassFile ( filePath , rootPath , file , false ) ; \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nthrow rex ; \n} \n} \n} \n} \n} \n"}
{"754": "public class CsrfShield { \nprotected static void assureSize ( final Set < Token > tokenSet ) { \nif ( tokenSet . size ( ) < maxTokensPerSession ) { \nreturn ; \n} \nlong validUntilMin = Long . MAX_VALUE ; \nToken tokenToRemove = null ; \nIterator < Token > iterator = tokenSet . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nToken token = iterator . next ( ) ; \nif ( token . isExpired ( ) ) { \niterator . remove ( ) ; \ncontinue ; \n} \nif ( token . validUntil < validUntilMin ) { \nvalidUntilMin = token . validUntil ; \ntokenToRemove = token ; \n} \n} \nif ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { \ntokenSet . remove ( tokenToRemove ) ; \n} \n} \n} \n"}
{"755": "public class CsrfShield { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { \nSet < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; \nif ( ( tokenSet == null ) && ( tokenValue == null ) ) { \nreturn true ; \n} \nif ( ( tokenSet == null ) || ( tokenValue == null ) ) { \nreturn false ; \n} \nboolean found = false ; \nIterator < Token > it = tokenSet . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nToken t = it . next ( ) ; \nif ( t . isExpired ( ) ) { \nit . remove ( ) ; \ncontinue ; \n} \nif ( t . getValue ( ) . equals ( tokenValue ) ) { \nit . remove ( ) ; \nfound = true ; \n} \n} \nreturn found ; \n} \n} \n"}
{"803": "public class ServletUtil { \npublic static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nEnumeration paramNames = servletRequest . getParameterNames ( ) ; \nfor ( ; \nparamNames . hasMoreElements ( ) ; \n) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues == null ) { \ncontinue ; \n} \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nMultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nparamNames = multipartRequest . getFileParameterNames ( ) ; \nfor ( ; \nparamNames . hasMoreElements ( ) ; \n) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \nFileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ignoreMissingMacros ) { \nstringTemplateParser . setReplaceMissingKey ( false ) ; \n} \nelse { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nint leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nint loopCount = 0 ; \nfor ( ; \nloopCount ++ < MAX_INNER_MACROS ; \n) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) { \nbreak ; \n} \nif ( skipEmptyProps ) { \nif ( newValue . length ( ) == 0 ) { \nreturn null ; \n} \n} \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"818": "public class PropsData { \npublic Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { \nif ( target == null ) { \ntarget = new HashMap ( ) ; \n} \nif ( prefix != null ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { \nprefix += StringPool . DOT ; \n} \n} \nif ( profiles != null ) { \nfor ( String profile : profiles ) { \nfor ( ; \ntrue ; \n) { \nfinal Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; \nif ( map != null ) { \nextractMap ( target , map , profiles , wildcardPatterns , prefix ) ; \n} \nfinal int ndx = profile . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nprofile = profile . substring ( 0 , ndx ) ; \n} \n} \n} \nextractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; \nreturn target ; \n} \n} \n"}
{"822": "public class MultipartRequestInputStream { \npublic int copyAll ( final OutputStream out ) throws IOException { \nint count = 0 ; \nfor ( ; \ntrue ; \n) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount ++ ; \n} \nreturn count ; \n} \n} \n"}
{"823": "public class MultipartRequestInputStream { \npublic int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { \nint count = 0 ; \nfor ( ; \ntrue ; \n) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount ++ ; \nif ( count == maxBytes ) { \nreturn count ; \n} \n} \nreturn count ; \n} \n} \n"}
{"829": "public class ActionMethodParser { \nprotected String [ ] readPackageActionPath ( final Class actionClass ) { \nPackage actionPackage = actionClass . getPackage ( ) ; \nfinal String actionPackageName = actionPackage . getName ( ) ; \nString packageActionPathFromAnnotation ; \nmainloop : for ( ; \ntrue ; \n) { \nMadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; \npackageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; \nif ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { \npackageActionPathFromAnnotation = null ; \n} \nif ( packageActionPathFromAnnotation == null ) { \nString newPackage = actionPackage . getName ( ) ; \nactionPackage = null ; \nfor ( ; \nactionPackage == null ; \n) { \nfinal int ndx = newPackage . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak mainloop ; \n} \nnewPackage = newPackage . substring ( 0 , ndx ) ; \nactionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; \n} \n} \nelse { \nrootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; \nbreak ; \n} \n} \nString packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; \nif ( packagePath == null ) { \nreturn ArraysUtil . array ( null , null ) ; \n} \nreturn ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( bootstrapMethodCount > 0 ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \nfor ( int i = 0 ; \ni < bootstrapMethodCount ; \ni ++ ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nfor ( ; \nnumBootstrapArguments -- > 0 ; \n) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \n} \n} \n"}
{"851": "public class SymbolTable { \nprivate Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { \nint hashCode = hash ( tag , owner , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; \n} \n} \n"}
{"853": "public class SymbolTable { \nprivate Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( tag ) . putInt ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"855": "public class SymbolTable { \nprivate Symbol addConstantLongOrDouble ( final int tag , final long value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nint index = constantPoolCount ; \nconstantPool . putByte ( tag ) . putLong ( value ) ; \nconstantPoolCount += 2 ; \nreturn put ( new Entry ( index , tag , value , hashCode ) ) ; \n} \n} \n"}
{"857": "public class SymbolTable { \nint addConstantNameAndType ( final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nint hashCode = hash ( tag , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; \n} \n} \n"}
{"859": "public class SymbolTable { \nint addConstantUtf8 ( final String value ) { \nint hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nif ( referenceKind <= Opcodes . H_PUTSTATIC ) { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"865": "public class SymbolTable { \nprivate Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nint hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"867": "public class SymbolTable { \nprivate Symbol addConstantUtf8Reference ( final int tag , final String value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"870": "public class SymbolTable { \nint addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { \nlong data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; \nint hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; \nEntry entry = get ( hashCode ) ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { \nreturn entry . info ; \n} \nentry = entry . next ; \n} \nString type1 = typeTable [ typeTableIndex1 ] . value ; \nString type2 = typeTable [ typeTableIndex2 ] . value ; \nint commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; \nput ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; \nreturn commonSuperTypeIndex ; \n} \n} \n"}
{"873": "public class HttpMultiMap { \npublic List < V > getAll ( final String name ) { \nLinkedList < V > values = new LinkedList < > ( ) ; \nint h = hash ( name ) ; \nint i = index ( h ) ; \nMapEntry < V > e = entries [ i ] ; \nfor ( ; \ne != null ; \n) { \nif ( e . hash == h && eq ( name , e . key ) ) { \nvalues . addFirst ( e . getValue ( ) ) ; \n} \ne = e . next ; \n} \nreturn values ; \n} \n} \n"}
{"875": "public class HttpMultiMap { \npublic List < Map . Entry < String , V > > entries ( ) { \nList < Map . Entry < String , V > > all = new LinkedList < > ( ) ; \nMapEntry < V > e = head . after ; \nfor ( ; \ne != head ; \n) { \nall . add ( e ) ; \ne = e . after ; \n} \nreturn all ; \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nfor ( ; \noffset < bytes . length ; \n) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nfor ( ; \nremaining > 0 ; \n) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"906": "public class DbQueryParser { \nDbQueryNamedParameter lookupNamedParameter ( final String name ) { \nDbQueryNamedParameter p = rootNP ; \nfor ( ; \np != null ; \n) { \nif ( p . equalsName ( name ) ) { \nreturn p ; \n} \np = p . next ; \n} \nreturn null ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nfor ( ; \ni < len ; \n) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse { \nresult . append ( value . substring ( i ) ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) { \nresult . append ( alias ) ; \n} \nelse { \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nfor ( ; \ni < len ; \n) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni ++ ; \n} \nif ( i > 1 ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nint i = 0 ; \nfor ( ; \ni < value . length ( ) ; \n) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni ++ ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) { \nvalue = value . substring ( 1 ) ; \n} \nelse { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( value . length ( ) > 0 ) { \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath += value ; \n} \nelse { \npath += '.' + value ; \n} \n} \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"941": "public class MadvocUtil { \npublic static String stripLastCamelWord ( String name ) { \nint ndx = name . length ( ) - 1 ; \nfor ( ; \nndx >= 0 ; \n) { \nif ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { \nbreak ; \n} \nndx -- ; \n} \nif ( ndx >= 0 ) { \nname = name . substring ( 0 , ndx ) ; \n} \nreturn name ; \n} \n} \n"}
{"956": "public class ZipUtil { \npublic static List < String > listZip ( final File zipFile ) throws IOException { \nList < String > entries = new ArrayList < > ( ) ; \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nfor ( ; \nzipEntries . hasMoreElements ( ) ; \n) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nentries . add ( entryName ) ; \n} \nreturn Collections . unmodifiableList ( entries ) ; \n} \n} \n"}
{"958": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . toString ( ) ) ; \n} \nif ( path == null ) { \npath = file . getName ( ) ; \n} \nfor ( ; \npath . length ( ) != 0 && path . charAt ( 0 ) == '/' ; \n) { \npath = path . substring ( 1 ) ; \n} \nboolean isDir = file . isDirectory ( ) ; \nif ( isDir ) { \nif ( ! StringUtil . endsWithChar ( path , '/' ) ) { \npath += '/' ; \n} \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( file . lastModified ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nif ( isDir ) { \nzipEntry . setSize ( 0 ) ; \nzipEntry . setCrc ( 0 ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nif ( ! isDir ) { \nInputStream is = new FileInputStream ( file ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \n} \nzos . closeEntry ( ) ; \nif ( recursive && file . isDirectory ( ) ) { \nboolean noRelativePath = StringUtil . isEmpty ( path ) ; \nfinal File [ ] children = file . listFiles ( ) ; \nif ( children != null && children . length != 0 ) { \nfor ( File child : children ) { \nString childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; \naddToZip ( zos , child , childRelativePath , comment , recursive ) ; \n} \n} \n} \n} \n} \n"}
{"959": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { \nfor ( ; \npath . length ( ) != 0 && path . charAt ( 0 ) == '/' ; \n) { \npath = path . substring ( 1 ) ; \n} \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath = path . substring ( 0 , path . length ( ) - 1 ) ; \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( System . currentTimeMillis ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nInputStream is = new ByteArrayInputStream ( content ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \nzos . closeEntry ( ) ; \n} \n} \n"}
{"968": "public class ClassReader { \nprivate static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { \nif ( inputStream == null ) { \nthrow new IOException ( \"Class not found\" ) ; \n} \ntry { \nByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; \nbyte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; \nint bytesRead ; \nfor ( ; \n( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ; \n) { \noutputStream . write ( data , 0 , bytesRead ) ; \n} \noutputStream . flush ( ) ; \nreturn outputStream . toByteArray ( ) ; \n} \nfinally { \nif ( close ) { \ninputStream . close ( ) ; \n} \n} \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( named ) { \nfor ( ; \nnumElementValuePairs -- > 0 ; \n) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nelse { \nfor ( ; \nnumElementValuePairs -- > 0 ; \n) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"986": "public class FindFile { \npublic List < File > findAll ( ) { \nList < File > allFiles = new ArrayList < > ( ) ; \nFile file ; \nfor ( ; \n( file = nextFile ( ) ) != null ; \n) { \nallFiles . add ( file ) ; \n} \nreturn allFiles ; \n} \n} \n"}
{"987": "public class FindFile { \nprotected void init ( ) { \nrules . detectMode ( ) ; \ntodoFiles = new LinkedList < > ( ) ; \ntodoFolders = new LinkedList < > ( ) ; \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \nreturn ; \n} \nif ( pathListOriginal == null ) { \npathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; \n} \nString [ ] files = new String [ pathList . size ( ) ] ; \nint index = 0 ; \nIterator < File > iterator = pathList . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nFile file = iterator . next ( ) ; \nif ( file . isFile ( ) ) { \nfiles [ index ++ ] = file . getAbsolutePath ( ) ; \niterator . remove ( ) ; \n} \n} \nif ( index != 0 ) { \nFilesIterator filesIterator = new FilesIterator ( files ) ; \ntodoFiles . add ( filesIterator ) ; \n} \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nint argumentsSize = 1 ; \nint currentOffset = 1 ; \nint currentChar = methodDescriptor . charAt ( currentOffset ) ; \nfor ( ; \ncurrentChar != ')' ; \n) { \nif ( currentChar == 'J' || currentChar == 'D' ) { \ncurrentOffset ++ ; \nargumentsSize += 2 ; \n} \nelse { \nfor ( ; \nmethodDescriptor . charAt ( currentOffset ) == '[' ; \n) { \ncurrentOffset ++ ; \n} \nif ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { \ncurrentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \n} \nargumentsSize += 1 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( currentChar == 'V' ) { \nreturn argumentsSize << 2 ; \n} \nelse { \nint returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \n} \n} \n"}
{"1002": "public class JtxTransaction { \nprotected void rollbackAllResources ( final boolean wasForced ) { \nstatus = STATUS_ROLLING_BACK ; \nException lastException = null ; \nIterator < JtxResource > it = resources . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nJtxResource resource = it . next ( ) ; \ntry { \nresource . rollbackTransaction ( ) ; \n} \ncatch ( Exception ex ) { \nlastException = ex ; \n} \nfinally { \nit . remove ( ) ; \n} \n} \ntxManager . removeTransaction ( this ) ; \nstatus = STATUS_ROLLEDBACK ; \nif ( lastException != null ) { \nstatus = STATUS_UNKNOWN ; \nthrow new JtxException ( \"Rollback failed: one or more TX resources couldn't rollback a TX\" , lastException ) ; \n} \nif ( wasForced ) { \nthrow new JtxException ( \"TX rolled back because it has been marked as rollback-only\" , rollbackCause ) ; \n} \n} \n} \n"}
{"1018": "public class BinarySearchBase { \npublic int findLast ( int low , int high ) { \nint ndx = - 1 ; \nfor ( ; \nlow <= high ; \n) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( mid ) ; \nif ( delta > 0 ) { \nhigh = mid - 1 ; \n} \nelse { \nif ( delta == 0 ) { \nndx = mid ; \n} \nlow = mid + 1 ; \n} \n} \nif ( ndx == - 1 ) { \nreturn - ( low + 1 ) ; \n} \nreturn ndx ; \n} \n} \n"}
{"1021": "public class ClassWriter { \nprivate Attribute [ ] getAttributePrototypes ( ) { \nAttribute . Set attributePrototypes = new Attribute . Set ( ) ; \nattributePrototypes . addAttributes ( firstAttribute ) ; \nFieldWriter fieldWriter = firstField ; \nfor ( ; \nfieldWriter != null ; \n) { \nfieldWriter . collectAttributePrototypes ( attributePrototypes ) ; \nfieldWriter = ( FieldWriter ) fieldWriter . fv ; \n} \nMethodWriter methodWriter = firstMethod ; \nfor ( ; \nmethodWriter != null ; \n) { \nmethodWriter . collectAttributePrototypes ( attributePrototypes ) ; \nmethodWriter = ( MethodWriter ) methodWriter . mv ; \n} \nreturn attributePrototypes . toArray ( ) ; \n} \n} \n"}
{"1036": "public class Format { \npublic static String alignLeftAndPad ( final String text , final int size ) { \nint textLength = text . length ( ) ; \nif ( textLength > size ) { \nreturn text . substring ( 0 , size ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( size ) ; \nsb . append ( text ) ; \nfor ( ; \ntextLength ++ < size ; \n) { \nsb . append ( ' ' ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nint total = src . length ( ) ; \nint from = 0 ; \nfor ( ; \nfrom < total ; \n) { \nint to = from + len ; \nif ( to >= total ) { \nto = total ; \n} \nelse if ( breakOnWhitespace ) { \nint ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) { \nto = ndx + 1 ; \n} \n} \nint cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nint cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1040": "public class Format { \npublic static String convertTabsToSpaces ( final String line , final int tabWidth ) { \nint tab_index , tab_size ; \nint last_tab_index = 0 ; \nint added_chars = 0 ; \nif ( tabWidth == 0 ) { \nreturn StringUtil . remove ( line , '\\t' ) ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nfor ( ; \n( tab_index = line . indexOf ( '\\t' , last_tab_index ) ) != - 1 ; \n) { \ntab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; \nif ( tab_size == 0 ) { \ntab_size = tabWidth ; \n} \nadded_chars += tab_size - 1 ; \nresult . append ( line , last_tab_index , tab_index ) ; \nresult . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; \nlast_tab_index = tab_index + 1 ; \n} \nif ( last_tab_index == 0 ) { \nreturn line ; \n} \nresult . append ( line . substring ( last_tab_index ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1048": "public class PetiteContainer { \npublic void setBeanProperty ( final String name , final Object value ) { \nObject bean = null ; \nint ndx = name . length ( ) ; \nfor ( ; \ntrue ; \n) { \nndx = name . lastIndexOf ( '.' , ndx ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString beanName = name . substring ( 0 , ndx ) ; \nbean = getBean ( beanName ) ; \nif ( bean != null ) { \nbreak ; \n} \nndx -- ; \n} \nif ( bean == null ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name ) ; \n} \ntry { \nBeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1054": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void end ( ) { \nif ( parentNode != rootNode ) { \nNode thisNode = parentNode ; \nfor ( ; \nthisNode != rootNode ; \n) { \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nif ( implRules . implicitlyCloseTagOnEOF ( thisNode . getNodeName ( ) ) ) { \nthisNode = thisNode . getParentNode ( ) ; \ncontinue ; \n} \n} \nerror ( \"Unclosed tag closed: <\" + thisNode . getNodeName ( ) + \">\" ) ; \nthisNode = thisNode . getParentNode ( ) ; \n} \n} \nif ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , true ) ; \n} \nif ( domBuilder . config . isUseFosterRules ( ) ) { \nHtmlFosterRules fosterRules = new HtmlFosterRules ( ) ; \nfosterRules . fixFosterElements ( rootNode ) ; \n} \nrootNode . end ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"LagartoDom tree created in \" + rootNode . getElapsedTime ( ) + \" ms\" ) ; \n} \n} \n} \n"}
{"1056": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void tag ( final Tag tag ) { \nif ( ! enabled ) { \nreturn ; \n} \nTagType tagType = tag . getType ( ) ; \nElement node ; \nswitch ( tagType ) { \ncase START : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , false ) ; \n} \nnode = createElementNode ( tag ) ; \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nfor ( ; \ntrue ; \n) { \nString parentNodeName = parentNode . getNodeName ( ) ; \nif ( ! implRules . implicitlyCloseParentTagOnNewTag ( parentNodeName , node . getNodeName ( ) ) ) { \nbreak ; \n} \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Implicitly closed tag <\" + node . getNodeName ( ) + \"> \" ) ; \n} \n} \n} \nparentNode . addChild ( node ) ; \nif ( ! node . isVoidElement ( ) ) { \nparentNode = node ; \n} \nbreak ; \ncase END : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , true ) ; \n} \nString tagName = tag . getName ( ) . toString ( ) ; \nNode matchingParent = findMatchingParentOpenTag ( tagName ) ; \nif ( matchingParent == parentNode ) { \nparentNode = parentNode . getParentNode ( ) ; \nbreak ; \n} \nif ( matchingParent == null ) { \nerror ( \"Orphan closed tag ignored: </\" + tagName + \"> \" + tag . getTagPosition ( ) ) ; \nbreak ; \n} \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nboolean fixed = false ; \nfor ( ; \nimplRules . implicitlyCloseParentTagOnTagEnd ( parentNode . getNodeName ( ) , tagName ) ; \n) { \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Implicitly closed tag <\" + tagName + \">\" ) ; \n} \nif ( parentNode == matchingParent ) { \nparentNode = matchingParent . parentNode ; \nfixed = true ; \nbreak ; \n} \n} \nif ( fixed ) { \nbreak ; \n} \n} \nfixUnclosedTagsUpToMatchingParent ( tag , matchingParent ) ; \nbreak ; \ncase SELF_CLOSING : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , false ) ; \n} \nnode = createElementNode ( tag ) ; \nparentNode . addChild ( node ) ; \nbreak ; \n} \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nfor ( ; \ntok . hasMoreTokens ( ) ; \n) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( parameterValues . size ( ) > 1 + qMarkCount ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nelse { \nif ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nint i = 0 ; \nint to = calculateTo ( from , count , collection . size ( ) ) ; \nfor ( ; \ni < to ; \n) { \nObject item = iter . next ( ) ; \nif ( i >= from ) { \nif ( status != null ) { \niteratorStatus . next ( ! iter . hasNext ( ) ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni ++ ; \n} \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nint sublen = sub . length ( ) ; \nif ( startIndex + sublen > src . length ( ) ) { \nreturn false ; \n} \nint j = 0 ; \nint i = startIndex ; \nfor ( ; \nj < sublen ; \n) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) { \nreturn false ; \n} \nj ++ ; \ni ++ ; \n} \nreturn true ; \n} \n} \n"}
{"1080": "public class StringUtil { \npublic static int countIgnoreCase ( final String source , final String sub ) { \nint count = 0 ; \nint j = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \nreturn 0 ; \n} \nfor ( ; \ntrue ; \n) { \nint i = indexOfIgnoreCase ( source , sub , j ) ; \nif ( i == - 1 ) { \nbreak ; \n} \ncount ++ ; \nj = i + sublen ; \n} \nreturn count ; \n} \n} \n"}
{"1089": "public class StringUtil { \npublic static String trimLeft ( final String src ) { \nint len = src . length ( ) ; \nint st = 0 ; \nfor ( ; \n( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ; \n) { \nst ++ ; \n} \nreturn st > 0 ? src . substring ( st ) : src ; \n} \n} \n"}
{"1090": "public class StringUtil { \npublic static String trimRight ( final String src ) { \nint len = src . length ( ) ; \nint count = len ; \nfor ( ; \n( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ; \n) { \nlen -- ; \n} \nreturn ( len < count ) ? src . substring ( 0 , len ) : src ; \n} \n} \n"}
{"1105": "public class StringUtil { \npublic static String repeat ( final String source , int count ) { \nStringBand result = new StringBand ( count ) ; \nfor ( ; \ncount > 0 ; \n) { \nresult . append ( source ) ; \ncount -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : for ( ; \ntrue ; \n) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nfor ( ; \n! nodes . isEmpty ( ) ; \n) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = childCount - 1 ; \ni >= 0 ; \ni -- ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nfor ( ; \ntrue ; \n) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1147": "public class CSSellyLexer { \nprivate static char [ ] zzUnpackCMap ( final String packed ) { \nchar [ ] map = new char [ 0x110000 ] ; \nint i = 0 ; \nint j = 0 ; \nfor ( ; \ni < 128 ; \n) { \nint count = packed . charAt ( i ++ ) ; \nchar value = packed . charAt ( i ++ ) ; \ndo map [ j ++ ] = value ; \nwhile ( -- count > 0 ) ; \n} \nreturn map ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nint from = 0 ; \nint fromCount = 1 ; \nint selectCount = 0 ; \nint lastNdx = 0 ; \nfor ( ; \ntrue ; \n) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( fromCount >= selectCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount ++ ; \n} \nreturn sql ; \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nint ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) { \nreturn html ; \n} \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nint lastIndex = 0 ; \nint len = html . length ( ) ; \nmainloop : for ( ; \nndx != - 1 ; \n) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nfor ( ; \nhtml . charAt ( lastIndex ) != ';' ; \n) { \nlastIndex ++ ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( html . charAt ( ndx + 1 ) == '#' ) { \nchar c = html . charAt ( ndx + 2 ) ; \nint radix ; \nif ( ( c == 'x' ) || ( c == 'X' ) ) { \nradix = 16 ; \nndx += 3 ; \n} \nelse { \nradix = 10 ; \nndx += 2 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nint i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex ++ ; \n} \nelse { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( replacement == null ) { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \nelse { \nresult . append ( replacement ) ; \nlastIndex ++ ; \n} \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nint firstIndex = 0 ; \nint lastIndex = ENTITY_NAMES . length - 1 ; \nint len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( ptr . offset >= name . length ) { \nreturn - 1 ; \n} \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nfor ( ; \ntrue ; \n) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( firstIndex < 0 ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) { \nlastName = ENTITY_NAMES [ firstIndex ] ; \n} \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \nfor ( int i = ptr . offset ; \ni < element . length ; \ni ++ ) { \nif ( element [ i ] != input [ ndx ] ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nndx ++ ; \n} \nreturn new String ( element ) ; \n} \nptr . offset ++ ; \nndx ++ ; \nif ( ndx == len ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n} \n"}
{"1171": "public class LoopingTagSupport { \nprotected void loopBody ( ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nif ( body == null ) { \nreturn ; \n} \nLoopIterator loopIterator = new LoopIterator ( start , end , step , modulus ) ; \nif ( status != null ) { \ngetJspContext ( ) . setAttribute ( status , loopIterator ) ; \n} \nfor ( ; \nloopIterator . next ( ) ; \n) { \nTagUtil . invokeBody ( body ) ; \n} \nif ( status != null ) { \ngetJspContext ( ) . removeAttribute ( status ) ; \n} \n} \n} \n"}
{"1186": "public class HttpTunnel { \npublic void start ( ) throws IOException { \nserverSocket = new ServerSocket ( listenPort , socketBacklog ) ; \nserverSocket . setReuseAddress ( true ) ; \nexecutorService = Executors . newFixedThreadPool ( threadPoolSize ) ; \nrunning = true ; \nfor ( ; \nrunning ; \n) { \nSocket socket = serverSocket . accept ( ) ; \nsocket . setKeepAlive ( false ) ; \nexecutorService . execute ( onSocketConnection ( socket ) ) ; \n} \nexecutorService . shutdown ( ) ; \n} \n} \n"}
{"1198": "public class SortedArrayList { \n@ Override public boolean addAll ( final Collection < ? extends E > c ) { \nIterator < ? extends E > i = c . iterator ( ) ; \nboolean changed = false ; \nfor ( ; \ni . hasNext ( ) ; \n) { \nboolean ret = add ( i . next ( ) ) ; \nif ( ! changed ) { \nchanged = ret ; \n} \n} \nreturn changed ; \n} \n} \n"}
{"1199": "public class SortedArrayList { \nprotected int findInsertionPoint ( final E o , int low , int high ) { \nfor ( ; \nlow <= high ; \n) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( get ( mid ) , o ) ; \nif ( delta > 0 ) { \nhigh = mid - 1 ; \n} \nelse { \nlow = mid + 1 ; \n} \n} \nreturn low ; \n} \n} \n"}
{"1206": "public class HtmlFosterRules { \nprotected Element findLastTable ( final Node node ) { \nNode tableNode = node ; \nfor ( ; \ntableNode != null ; \n) { \nif ( tableNode . getNodeType ( ) == Node . NodeType . ELEMENT ) { \nString tableNodeName = tableNode . getNodeName ( ) . toLowerCase ( ) ; \nif ( tableNodeName . equals ( \"table\" ) ) { \nbreak ; \n} \n} \ntableNode = tableNode . getParentNode ( ) ; \n} \nreturn ( Element ) tableNode ; \n} \n} \n"}
{"1214": "public class PropsParser { \nprotected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { \nString fullKey = key ; \nint ndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \njustAdd ( fullKey , value , null , operator ) ; \nreturn ; \n} \nArrayList < String > keyProfiles = new ArrayList < > ( ) ; \nfor ( ; \ntrue ; \n) { \nndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nfinal int len = fullKey . length ( ) ; \nint ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; \nif ( ndx2 == - 1 ) { \nndx2 = len ; \n} \nfinal String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; \nkeyProfiles . add ( profile ) ; \nndx2 ++ ; \nfinal String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; \nfullKey = fullKey . substring ( 0 , ndx ) + right ; \n} \nif ( fullKey . startsWith ( StringPool . DOT ) ) { \nfullKey = fullKey . substring ( 1 ) ; \n} \njustAdd ( fullKey , value , keyProfiles , operator ) ; \n} \n} \n"}
{"1218": "public class AsmUtil { \npublic static String typedescToSignature ( final String desc , final MutableInteger from ) { \nint fromIndex = from . get ( ) ; \nfrom . value ++ ; \nswitch ( desc . charAt ( fromIndex ) ) { \ncase 'B' : return \"byte\" ; \ncase 'C' : return \"char\" ; \ncase 'D' : return \"double\" ; \ncase 'F' : return \"float\" ; \ncase 'I' : return \"int\" ; \ncase 'J' : return \"long\" ; \ncase 'S' : return \"short\" ; \ncase 'Z' : return \"boolean\" ; \ncase 'V' : return \"void\" ; \ncase 'L' : int index = desc . indexOf ( ';' , fromIndex ) ; \nif ( index < 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nfrom . set ( index + 1 ) ; \nString str = desc . substring ( fromIndex + 1 , index ) ; \nreturn str . replace ( '/' , '.' ) ; \ncase 'T' : return desc . substring ( from . value ) ; \ncase '[' : StringBuilder brackets = new StringBuilder ( ) ; \nint n = fromIndex ; \nfor ( ; \ndesc . charAt ( n ) == '[' ; \n) { \nbrackets . append ( \"[]\" ) ; \nn ++ ; \n} \nfrom . value = n ; \nString type = typedescToSignature ( desc , from ) ; \nreturn type + brackets ; \ndefault : if ( from . value == 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nreturn desc . substring ( from . value ) ; \n} \n} \n} \n"}
{"1231": "public class Label { \nfinal void markSubroutine ( final short subroutineId ) { \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nfor ( ; \nlistOfBlocksToProcess != EMPTY_LIST ; \n) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nbasicBlock . nextListElement = null ; \nif ( basicBlock . subroutineId == 0 ) { \nbasicBlock . subroutineId = subroutineId ; \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \n} \n} \n} \n"}
{"1232": "public class Label { \nfinal void addSubroutineRetSuccessors ( final Label subroutineCaller ) { \nLabel listOfProcessedBlocks = EMPTY_LIST ; \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nfor ( ; \nlistOfBlocksToProcess != EMPTY_LIST ; \n) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = basicBlock . nextListElement ; \nbasicBlock . nextListElement = listOfProcessedBlocks ; \nlistOfProcessedBlocks = basicBlock ; \nif ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 && basicBlock . subroutineId != subroutineCaller . subroutineId ) { \nbasicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; \n} \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \nfor ( ; \nlistOfProcessedBlocks != EMPTY_LIST ; \n) { \nLabel newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; \nlistOfProcessedBlocks . nextListElement = null ; \nlistOfProcessedBlocks = newListOfProcessedBlocks ; \n} \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nint zeroCount1 = 0 ; \nfor ( ; \ncharAt ( str1 , ndx1 ) == '0' ; \n) { \nzeroCount1 ++ ; \nndx1 ++ ; \n} \nint len1 = 0 ; \nfor ( ; \ntrue ; \n) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) { \nbreak ; \n} \nlen1 ++ ; \nndx1 ++ ; \n} \nint zeroCount2 = 0 ; \nfor ( ; \ncharAt ( str2 , ndx2 ) == '0' ; \n) { \nzeroCount2 ++ ; \nndx2 ++ ; \n} \nint len2 = 0 ; \nint ndx1_new = ndx1 - len1 ; \nint equalNumbers = 0 ; \nfor ( ; \ntrue ; \n) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) { \nbreak ; \n} \nif ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) { \nequalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; \n} \nlen2 ++ ; \nndx2 ++ ; \n} \nif ( len1 != len2 ) { \nreturn new int [ ] { \nlen1 - len2 } \n; \n} \nif ( equalNumbers != 0 ) { \nreturn new int [ ] { \nequalNumbers } \n; \n} \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1266": "public class StringKeyedMapAdapter { \n@ Override public void clear ( ) { \nentries = null ; \nIterator < String > keys = getAttributeNames ( ) ; \nfor ( ; \nkeys . hasNext ( ) ; \n) { \nremoveAttribute ( keys . next ( ) ) ; \n} \n} \n} \n"}
{"1267": "public class StringKeyedMapAdapter { \n@ Override public Set < Entry < String , Object > > entrySet ( ) { \nif ( entries == null ) { \nentries = new HashSet < > ( ) ; \nIterator < String > iterator = getAttributeNames ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nfinal String key = iterator . next ( ) ; \nfinal Object value = getAttribute ( key ) ; \nentries . add ( new Entry < String , Object > ( ) { \n@ Override public boolean equals ( final Object obj ) { \nif ( obj == null ) { \nreturn false ; \n} \nif ( this . getClass ( ) != obj . getClass ( ) ) { \nreturn false ; \n} \nEntry entry = ( Entry ) obj ; \nreturn ( ( key == null ) ? ( entry . getKey ( ) == null ) : key . equals ( entry . getKey ( ) ) ) && ( ( value == null ) ? ( entry . getValue ( ) == null ) : value . equals ( entry . getValue ( ) ) ) ; \n} \n@ Override public int hashCode ( ) { \nreturn ( ( key == null ) ? 0 : key . hashCode ( ) ) ^ ( ( value == null ) ? 0 : value . hashCode ( ) ) ; \n} \n@ Override public String getKey ( ) { \nreturn key ; \n} \n@ Override public Object getValue ( ) { \nreturn value ; \n} \n@ Override public Object setValue ( final Object obj ) { \nsetAttribute ( key , obj ) ; \nreturn value ; \n} \n} \n) ; \n} \n} \nreturn entries ; \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nfor ( ; \nt != null ; \n) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \nfor ( int i = 0 ; \ni < allStacks . length ; \ni ++ ) { \nallStacks [ i ] = result . get ( i ) ; \n} \nreturn allStacks ; \n} \n} \n"}
{"1273": "public class ExceptionUtil { \npublic static Throwable [ ] getExceptionChain ( Throwable throwable ) { \nArrayList < Throwable > list = new ArrayList < > ( ) ; \nlist . add ( throwable ) ; \nfor ( ; \n( throwable = throwable . getCause ( ) ) != null ; \n) { \nlist . add ( throwable ) ; \n} \nThrowable [ ] result = new Throwable [ list . size ( ) ] ; \nreturn list . toArray ( result ) ; \n} \n} \n"}
{"1275": "public class ExceptionUtil { \npublic static String exceptionChainToString ( Throwable t ) { \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter pw = new PrintWriter ( sw , true ) ; \nfor ( ; \nt != null ; \n) { \nt . printStackTrace ( pw ) ; \nt = t . getCause ( ) ; \n} \nStreamUtil . close ( pw ) ; \nStreamUtil . close ( sw ) ; \nreturn sw . toString ( ) ; \n} \n} \n"}
{"1277": "public class ExceptionUtil { \npublic static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { \nThrowable unwrapped = wrappedThrowable ; \nfor ( ; \ntrue ; \n) { \nif ( unwrapped instanceof InvocationTargetException ) { \nunwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; \n} \nelse if ( unwrapped instanceof UndeclaredThrowableException ) { \nunwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; \n} \nelse { \nreturn unwrapped ; \n} \n} \n} \n} \n"}
{"1287": "public class MultipartRequest { \npublic void parseRequest ( ) throws IOException { \nif ( ServletUtil . isMultipartRequest ( request ) ) { \nparseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; \n} \nelse { \nEnumeration names = request . getParameterNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString paramName = ( String ) names . nextElement ( ) ; \nString [ ] values = request . getParameterValues ( paramName ) ; \nputParameters ( paramName , values ) ; \n} \n} \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount - 1 ; \ni ++ ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nfor ( ; \nndx >= 0 ; \n) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1328": "public class HttpBrowser { \npublic HttpResponse sendRequest ( HttpRequest httpRequest ) { \nelapsedTime = System . currentTimeMillis ( ) ; \nhttpRequest . followRedirects ( false ) ; \nfor ( ; \ntrue ; \n) { \nthis . httpRequest = httpRequest ; \nHttpResponse previousResponse = this . httpResponse ; \nthis . httpResponse = null ; \naddDefaultHeaders ( httpRequest ) ; \naddCookies ( httpRequest ) ; \nif ( catchTransportExceptions ) { \ntry { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \ncatch ( HttpException httpException ) { \nhttpResponse = new HttpResponse ( ) ; \nhttpResponse . assignHttpRequest ( httpRequest ) ; \nhttpResponse . statusCode ( 503 ) ; \nhttpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; \n} \n} \nelse { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \nreadCookies ( httpResponse ) ; \nint statusCode = httpResponse . statusCode ( ) ; \nif ( statusCode == 301 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 302 || statusCode == 303 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 307 || statusCode == 308 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nbreak ; \n} \nelapsedTime = System . currentTimeMillis ( ) - elapsedTime ; \nreturn this . httpResponse ; \n} \n} \n"}
{"1354": "public class CollectionUtil { \npublic static < T > Collection < T > collectionOf ( final Iterator < ? extends T > iterator ) { \nfinal List < T > list = new ArrayList < > ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nlist . add ( iterator . next ( ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"1360": "public class SimpleLogger { \nprotected String shortenClassName ( final String className ) { \nint lastDotIndex = className . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 ) { \nreturn className ; \n} \nStringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; \nint start = 0 ; \nfor ( ; \ntrue ; \n) { \nshortClassName . append ( className . charAt ( start ) ) ; \nint next = className . indexOf ( '.' , start ) ; \nif ( next == lastDotIndex ) { \nbreak ; \n} \nstart = next + 1 ; \nshortClassName . append ( '.' ) ; \n} \nshortClassName . append ( className . substring ( lastDotIndex ) ) ; \nreturn shortClassName . toString ( ) ; \n} \n} \n"}
{"1418": "public class ClassPathURLs { \npublic static URL [ ] of ( ClassLoader classLoader , Class clazz ) { \nif ( clazz == null ) { \nclazz = ClassPathURLs . class ; \n} \nif ( classLoader == null ) { \nclassLoader = clazz . getClassLoader ( ) ; \n} \nfinal Set < URL > urls = new LinkedHashSet < > ( ) ; \nfor ( ; \nclassLoader != null ; \n) { \nif ( classLoader instanceof URLClassLoader ) { \nURLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; \nURL [ ] allURLS = urlClassLoader . getURLs ( ) ; \nCollections . addAll ( urls , allURLS ) ; \nbreak ; \n} \nURL classUrl = classModuleUrl ( classLoader , clazz ) ; \nif ( classUrl != null ) { \nurls . add ( classUrl ) ; \n} \nclassUrl = classModuleUrl ( classLoader , ClassPathURLs . class ) ; \nif ( classUrl != null ) { \nurls . add ( classUrl ) ; \n} \nModuleDescriptor moduleDescriptor = clazz . getModule ( ) . getDescriptor ( ) ; \nif ( moduleDescriptor != null ) { \nmoduleDescriptor . requires ( ) . forEach ( req -> { \nModuleLayer . boot ( ) . findModule ( req . name ( ) ) . ifPresent ( mod -> { \nClassLoader moduleClassLoader = mod . getClassLoader ( ) ; \nif ( moduleClassLoader != null ) { \nURL url = moduleClassLoader . getResource ( MANIFEST ) ; \nif ( url != null ) { \nurl = fixManifestUrl ( url ) ; \nurls . add ( url ) ; \n} \n} \n} \n) ; \n} \n) ; \n} \nclassLoader = classLoader . getParent ( ) ; \n} \nreturn urls . toArray ( new URL [ 0 ] ) ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nfor ( ; \ntrue ; \n) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) { \nif ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nfor ( ; \ntrue ; \n) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nfor ( ; \nend < length ; \n) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1430": "public class TemplateParser { \nprotected int countEscapes ( final String template , int macroIndex ) { \nmacroIndex -- ; \nint escapeCount = 0 ; \nfor ( ; \nmacroIndex >= 0 ; \n) { \nif ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { \nbreak ; \n} \nescapeCount ++ ; \nmacroIndex -- ; \n} \nreturn escapeCount ; \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) { \nreturn queryMap ; \n} \nint lastNdx = 0 ; \nfor ( ; \nlastNdx < query . length ( ) ; \n) { \nint ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) { \nndx = query . length ( ) ; \n} \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ndx == - 1 ) { \nqueryMap . add ( paramAndValue , null ) ; \n} \nelse { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) { \nname = URLDecoder . decodeQuery ( name ) ; \n} \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) { \nvalue = URLDecoder . decodeQuery ( value ) ; \n} \nqueryMap . add ( name , value ) ; \n} \nlastNdx += paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nfor ( ; \nndx < total ; \n) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount ++ ; \n} \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1446": "public class JsonParser { \nprotected String parseStringContent ( final char quote ) { \nfinal int startNdx = ndx ; \nfor ( ; \ntrue ; \n) { \nfinal char c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nreturn new String ( input , startNdx , ndx - 1 - startNdx ) ; \n} \nif ( c == '\\\\' ) { \nbreak ; \n} \nndx ++ ; \n} \ntextLen = ndx - startNdx ; \ngrowEmpty ( ) ; \nSystem . arraycopy ( input , startNdx , text , 0 , textLen ) ; \nfor ( ; \ntrue ; \n) { \nchar c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nfinal String str = new String ( text , 0 , textLen ) ; \ntextLen = 0 ; \nreturn str ; \n} \nif ( c == '\\\\' ) { \nndx ++ ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase '\\\"' : c = '\\\"' ; \nbreak ; \ncase '\\\\' : c = '\\\\' ; \nbreak ; \ncase '/' : c = '/' ; \nbreak ; \ncase 'b' : c = '\\b' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'u' : ndx ++ ; \nc = parseUnicode ( ) ; \nbreak ; \ndefault : if ( looseMode ) { \nif ( c != '\\'' ) { \nc = '\\\\' ; \nndx -- ; \n} \n} \nelse { \nsyntaxError ( \"Invalid escape char: \" + c ) ; \n} \n} \n} \ntext [ textLen ] = c ; \ntextLen ++ ; \ngrowAndCopy ( ) ; \nndx ++ ; \n} \n} \n} \n"}
{"1448": "public class JsonParser { \nprotected String parseUnquotedStringContent ( ) { \nfinal int startNdx = ndx ; \nfor ( ; \ntrue ; \n) { \nfinal char c = input [ ndx ] ; \nif ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { \nfinal int currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nfor ( ; \ntrue ; \n) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1450": "public class JsonParser { \nprotected Object parseArrayContent ( Class targetType , Class componentType ) { \nif ( targetType == Object . class ) { \ntargetType = List . class ; \n} \ntargetType = replaceWithMappedTypeForPath ( targetType ) ; \nif ( componentType == null && targetType != null && targetType . isArray ( ) ) { \ncomponentType = targetType . getComponentType ( ) ; \n} \npath . push ( VALUES ) ; \ncomponentType = replaceWithMappedTypeForPath ( componentType ) ; \nCollection < Object > target = newArrayInstance ( targetType ) ; \nboolean koma = false ; \nmainloop : for ( ; \ntrue ; \n) { \nskipWhiteSpaces ( ) ; \nchar c = input [ ndx ] ; \nif ( c == ']' ) { \nif ( koma ) { \nsyntaxError ( \"Trailing comma\" ) ; \n} \nndx ++ ; \npath . pop ( ) ; \nreturn target ; \n} \nObject value = parseValue ( componentType , null , null ) ; \ntarget . add ( value ) ; \nskipWhiteSpaces ( ) ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase ']' : ndx ++ ; \nbreak mainloop ; \ncase ',' : ndx ++ ; \nkoma = true ; \nbreak ; \ndefault : syntaxError ( \"Invalid char: expected ] or ,\" ) ; \n} \n} \npath . pop ( ) ; \nif ( targetType != null ) { \nreturn convertType ( target , targetType ) ; \n} \nreturn target ; \n} \n} \n"}
{"1470": "public class ClassUtil { \npublic static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { \nif ( instance == null || instance == Object . class ) { \nreturn null ; \n} \nif ( parentClass != null ) { \nif ( parentClass . isInterface ( ) ) { \nreturn null ; \n} \n} \nClass < ? > childClass = instance . getClass ( ) ; \nfor ( ; \ntrue ; \n) { \nClass < ? > parent = childClass . getSuperclass ( ) ; \nif ( parent == parentClass ) { \nreturn childClass ; \n} \nif ( parent == null ) { \nreturn null ; \n} \nchildClass = parent ; \n} \n} \n} \n"}
{"1491": "public class DbListIterator { \nprivate boolean moveToNext ( ) { \nif ( last ) { \nif ( closeOnEnd ) { \nquery . close ( ) ; \n} \nelse { \nquery . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; \n} \nreturn false ; \n} \nfor ( ; \ntrue ; \n) { \nif ( ! resultSetMapper . next ( ) ) { \nlast = true ; \nreturn entityAwareMode ; \n} \nObject [ ] objects = resultSetMapper . parseObjects ( types ) ; \nObject row = query . resolveRowResults ( objects ) ; \nnewElement = ( T ) row ; \nif ( entityAwareMode ) { \nif ( count == 0 && previousElement == null ) { \npreviousElement = newElement ; \ncontinue ; \n} \nif ( previousElement != null && newElement != null ) { \nboolean equals ; \nif ( newElement . getClass ( ) . isArray ( ) ) { \nequals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; \n} \nelse { \nequals = previousElement . equals ( newElement ) ; \n} \nif ( equals ) { \ncontinue ; \n} \n} \n} \nbreak ; \n} \nreturn true ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nfor ( ; \nhandler != null ; \n) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nfor ( ; \nhandlerRangeBlock != handlerRangeEnd ; \n) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nfor ( ; \nbasicBlock != null ; \n) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nfor ( ; \nbasicBlock != null ; \n) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nfor ( ; \nlistOfBlocksToProcess != Label . EMPTY_LIST ; \n) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nfor ( ; \noutgoingEdge != null ; \n) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1521": "public class HtmlStaplerBundlesManager { \npublic synchronized void reset ( ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . clear ( ) ; \nmirrors . clear ( ) ; \n} \nfinal FindFile ff = new FindFile ( ) ; \nff . includeDirs ( false ) ; \nff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; \nFile f ; \nint count = 0 ; \nfor ( ; \n( f = ff . nextFile ( ) ) != null ; \n) { \nf . delete ( ) ; \ncount ++ ; \n} \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; \n} \n} \n} \n"}
{"1522": "public class HtmlStaplerBundlesManager { \nprotected String fixCssRelativeUrls ( final String content , final String src ) { \nfinal String path = FileNameUtil . getPath ( src ) ; \nfinal Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; \nfinal StringBuilder sb = new StringBuilder ( content . length ( ) ) ; \nint start = 0 ; \nfor ( ; \nmatcher . find ( ) ; \n) { \nsb . append ( content , start , matcher . start ( ) ) ; \nfinal String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , \"'\\\"\" ) ; \nfinal String url ; \nif ( matchedUrl . startsWith ( \"https://\" ) || matchedUrl . startsWith ( \"http://\" ) || matchedUrl . startsWith ( \"data:\" ) ) { \nurl = \"url('\" + matchedUrl + \"')\" ; \n} \nelse { \nurl = fixRelativeUrl ( matchedUrl , path ) ; \n} \nsb . append ( url ) ; \nstart = matcher . end ( ) ; \n} \nsb . append ( content . substring ( start ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1573": "public class Node { \npublic String getCssPath ( ) { \nStringBuilder path = new StringBuilder ( ) ; \nNode node = this ; \nfor ( ; \nnode != null ; \n) { \nString nodeName = node . getNodeName ( ) ; \nif ( nodeName != null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( ' ' ) . append ( nodeName ) ; \nString id = node . getAttribute ( \"id\" ) ; \nif ( id != null ) { \nsb . append ( '#' ) . append ( id ) ; \n} \npath . insert ( 0 , sb ) ; \n} \nnode = node . getParentNode ( ) ; \n} \nif ( path . charAt ( 0 ) == ' ' ) { \nreturn path . substring ( 1 ) ; \n} \nreturn path . toString ( ) ; \n} \n} \n"}
{"1595": "public class AbstractTemplateViewActionResult { \nprotected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { \nString resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; \nResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; \nString actionPath = resultPath . path ( ) ; \nString path = actionPath ; \nString value = resultPath . value ( ) ; \nif ( StringUtil . isEmpty ( value ) ) { \nvalue = null ; \n} \nString target ; \nfor ( ; \ntrue ; \n) { \nif ( value != null ) { \nif ( path == null ) { \nint lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; \nif ( lastSlashNdx != - 1 ) { \ntarget = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; \n} \nelse { \ntarget = '/' + value ; \n} \n} \nelse { \ntarget = path + '.' + value ; \n} \ntarget = locateTarget ( actionRequest , target ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path != null ) { \ntarget = locateTarget ( actionRequest , path ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path == null ) { \nreturn null ; \n} \nint dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; \nif ( dotNdx == - 1 ) { \npath = null ; \n} \nelse { \npath = path . substring ( 0 , dotNdx ) ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1600": "public class PropertyResolver { \npublic PropertyInjectionPoint [ ] resolve ( Class type , final boolean autowire ) { \nfinal List < PropertyInjectionPoint > list = new ArrayList < > ( ) ; \nfinal Set < String > usedPropertyNames = new HashSet < > ( ) ; \nfor ( ; \ntype != Object . class ; \n) { \nfinal ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nfinal PropertyDescriptor [ ] allPropertyDescriptors = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allPropertyDescriptors ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) { \ncontinue ; \n} \nif ( usedPropertyNames . contains ( propertyDescriptor . getName ( ) ) ) { \ncontinue ; \n} \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { \ncontinue ; \n} \nBeanReferences reference = referencesResolver . readReferenceFromAnnotation ( propertyDescriptor ) ; \nif ( reference == null ) { \nif ( ! autowire ) { \ncontinue ; \n} \nelse { \nreference = referencesResolver . buildDefaultReference ( propertyDescriptor ) ; \n} \n} \nlist . add ( new PropertyInjectionPoint ( propertyDescriptor , reference ) ) ; \nusedPropertyNames . add ( propertyDescriptor . getName ( ) ) ; \n} \ntype = type . getSuperclass ( ) ; \n} \nfinal PropertyInjectionPoint [ ] fields ; \nif ( list . isEmpty ( ) ) { \nfields = PropertyInjectionPoint . EMPTY ; \n} \nelse { \nfields = list . toArray ( new PropertyInjectionPoint [ 0 ] ) ; \n} \nreturn fields ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal int proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nint index = 0 ; \nbuf [ index ++ ] = 4 ; \nbuf [ index ++ ] = 1 ; \nbuf [ index ++ ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index ++ ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index ++ ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex += user . length ( ) ; \n} \nbuf [ index ++ ] = 0 ; \nout . write ( buf , 0 , index ) ; \nint len = 6 ; \nint s = 0 ; \nfor ( ; \ns < len ; \n) { \nint i = in . read ( buf , s , len - s ) ; \nif ( i <= 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \n} \ns += i ; \n} \nif ( buf [ 0 ] != 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \n} \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1602": "public class Attribute { \nfinal int getAttributeCount ( ) { \nint count = 0 ; \nAttribute attribute = this ; \nfor ( ; \nattribute != null ; \n) { \ncount += 1 ; \nattribute = attribute . nextAttribute ; \n} \nreturn count ; \n} \n} \n"}
{"1613": "public class Frame { \nprivate static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { \nString internalName ; \nswitch ( buffer . charAt ( offset ) ) { \ncase 'V' : return 0 ; \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; \ncase 'F' : return FLOAT ; \ncase 'J' : return LONG ; \ncase 'D' : return DOUBLE ; \ncase 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; \nreturn REFERENCE_KIND | symbolTable . addType ( internalName ) ; \ncase '[' : int elementDescriptorOffset = offset + 1 ; \nfor ( ; \nbuffer . charAt ( elementDescriptorOffset ) == '[' ; \n) { \n++ elementDescriptorOffset ; \n} \nint typeValue ; \nswitch ( buffer . charAt ( elementDescriptorOffset ) ) { \ncase 'Z' : typeValue = BOOLEAN ; \nbreak ; \ncase 'C' : typeValue = CHAR ; \nbreak ; \ncase 'B' : typeValue = BYTE ; \nbreak ; \ncase 'S' : typeValue = SHORT ; \nbreak ; \ncase 'I' : typeValue = INTEGER ; \nbreak ; \ncase 'F' : typeValue = FLOAT ; \nbreak ; \ncase 'J' : typeValue = LONG ; \nbreak ; \ncase 'D' : typeValue = DOUBLE ; \nbreak ; \ncase 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; \ntypeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \ni < numLocal ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n} \nfor ( ; \ninputLocalIndex < inputLocals . length ; \n) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nint numStackTop = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nfor ( ; \narrayDimensions -- > 0 ; \n) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \nelse { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \n} \n} \n"}
{"1624": "public class TimedCache { \n@ Override protected int pruneCache ( ) { \nint count = 0 ; \nIterator < CacheObject < K , V > > values = cacheMap . values ( ) . iterator ( ) ; \nfor ( ; \nvalues . hasNext ( ) ; \n) { \nCacheObject co = values . next ( ) ; \nif ( co . isExpired ( ) ) { \nvalues . remove ( ) ; \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1676": "public class RestActionNamingStrategy { \nprotected String resolveHttpMethodFromMethodName ( final String methodName ) { \nint i = 0 ; \nfor ( ; \ni < methodName . length ( ) ; \n) { \nif ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { \nbreak ; \n} \ni ++ ; \n} \nfinal String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; \nfor ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { \nif ( httpMethod . equalsName ( name ) ) { \nreturn httpMethod . name ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nfor ( ; \ntrue ; \n) { \nif ( ( sNdx >= sLen ) ) { \nfor ( ; \n( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ; \n) { \npNdx ++ ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni -- ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1686": "public class ClassPathURLs { \npublic static URL [ ] of ( ClassLoader classLoader , Class clazz ) { \nif ( clazz == null ) { \nclazz = ClassPathURLs . class ; \n} \nif ( classLoader == null ) { \nclassLoader = clazz . getClassLoader ( ) ; \n} \nfinal Set < URL > urls = new LinkedHashSet < > ( ) ; \nfor ( ; \nclassLoader != null ; \n) { \nif ( classLoader instanceof URLClassLoader ) { \nfinal URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; \nreturn urlClassLoader . getURLs ( ) ; \n} \nfinal URL url = classModuleUrl ( classLoader , clazz ) ; \nif ( url != null ) { \nurls . add ( url ) ; \n} \nclassLoader = classLoader . getParent ( ) ; \n} \nreturn urls . toArray ( new URL [ 0 ] ) ; \n} \n} \n"}
{"1700": "public class RandomString { \npublic String random ( int count , final char [ ] chars ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nfor ( ; \ncount -- > 0 ; \n) { \nresult [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1701": "public class RandomString { \npublic String random ( int count , final char start , final char end ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nfinal int len = end - start + 1 ; \nfor ( ; \ncount -- > 0 ; \n) { \nresult [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nfor ( ; \ni < ranges . length ; \n) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nfor ( ; \ncount -- > 0 ; \n) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \ni < ranges . length ; \ni += 2 ) { \nif ( r < lens [ i ] ) { \nr += ranges [ i ] ; \nif ( i != 0 ) { \nr -= lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1769": "public class Base32 { \npublic static String encode ( final byte [ ] bytes ) { \nStringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; \nint currByte , digit , i = 0 ; \nfor ( ; \ni < bytes . length ; \n) { \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ currByte >> 3 ] ) ; \ndigit = ( currByte & 7 ) << 2 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; \ndigit = ( currByte & 1 ) << 4 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; \ndigit = ( currByte & 15 ) << 1 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; \ndigit = ( currByte & 3 ) << 3 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; \nbase32 . append ( CHARS [ currByte & 31 ] ) ; \n} \nreturn base32 . toString ( ) ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nint offset = startOffset ; \nchar currentChar = signature . charAt ( offset ++ ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : int start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nfor ( ; \ntrue ; \n) { \ncurrentChar = signature . charAt ( offset ++ ) ; \nif ( currentChar == '.' || currentChar == ';' ) { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \nelse if ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \nvisited = true ; \nfor ( ; \n( currentChar = signature . charAt ( offset ) ) != '>' ; \n) { \nswitch ( currentChar ) { \ncase '*' : ++ offset ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1800": "public class TargetClassInfoReader { \n@ Override public void visitEnd ( ) { \nif ( classAnnotations != null ) { \nannotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; \nclassAnnotations = null ; \n} \nList < String > superList = new ArrayList < > ( ) ; \nSet < String > allInterfaces = new HashSet < > ( ) ; \nif ( nextInterfaces != null ) { \nallInterfaces . addAll ( nextInterfaces ) ; \n} \nfor ( ; \nnextSupername != null ; \n) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super class: \" + nextSupername , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperList . add ( nextSupername ) ; \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nCollections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; \n} \n} \nsuperClasses = superList . toArray ( new String [ 0 ] ) ; \nSet < String > todoInterfaces = new HashSet < > ( allInterfaces ) ; \nSet < String > newCollectedInterfaces = new HashSet < > ( ) ; \nfor ( ; \ntrue ; \n) { \nfor ( String next : todoInterfaces ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super interface: \" + next , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nfor ( String newInterface : cr . getInterfaces ( ) ) { \nif ( ! allInterfaces . contains ( newInterface ) && ! todoInterfaces . contains ( newInterface ) ) { \nnewCollectedInterfaces . add ( newInterface ) ; \n} \n} \n} \n} \nallInterfaces . addAll ( todoInterfaces ) ; \nif ( newCollectedInterfaces . isEmpty ( ) ) { \nbreak ; \n} \ntodoInterfaces . clear ( ) ; \ntodoInterfaces . addAll ( newCollectedInterfaces ) ; \nnewCollectedInterfaces . clear ( ) ; \n} \n} \n} \n"}
{"1918": "public class CommonContext { \npublic static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { \nif ( null == cncByteBuffer ) { \nreturn false ; \n} \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long startTimeMs = System . currentTimeMillis ( ) ; \nint cncVersion ; \nfor ( ; \n0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ; \n) { \nif ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) { \nthrow new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; \n} \nsleep ( 1 ) ; \n} \nif ( CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; \nfinal long now = System . currentTimeMillis ( ) ; \nfinal long timestampAge = now - timestamp ; \nlogger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; \nreturn timestampAge <= driverTimeoutMs ; \n} \n} \n"}
{"1931": "public class RecordingLog { \npublic void reload ( ) { \nentries . clear ( ) ; \nindexByLeadershipTermIdMap . clear ( ) ; \nindexByLeadershipTermIdMap . compact ( ) ; \nnextEntryIndex = 0 ; \nbyteBuffer . clear ( ) ; \ntry { \nfor ( ; \ntrue ; \n) { \nfinal int bytes = fileChannel . read ( byteBuffer ) ; \nif ( byteBuffer . remaining ( ) == 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nif ( - 1 == bytes ) { \nif ( byteBuffer . position ( ) > 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nbreak ; \n} \n} \n} \ncatch ( final IOException ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nfor ( ; \nbytesCopied < length ; \n) { \nlong bytesLeft = length - bytesCopied ; \nint bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( bytesRead < 0 ) { \nthrow new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \n} \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied += bytesRead ; \n} \n} \n} \n"}
{"2017": "public class DeltaBinaryPackingValuesReader { \n@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { \nthis . in = stream ; \nlong startPos = in . position ( ) ; \nthis . config = DeltaBinaryPackingConfig . readConfig ( in ) ; \nthis . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; \nallocateValuesBuffer ( ) ; \nbitWidths = new int [ config . miniBlockNumInABlock ] ; \nvaluesBuffer [ valuesBuffered ++ ] = BytesUtils . readZigZagVarLong ( in ) ; \nfor ( ; \nvaluesBuffered < totalValueCount ; \n) { \nloadNewBlockToBuffer ( ) ; \n} \nupdateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nfor ( ; \nrecordsRead < recordCount && ! recordFilter . isMatch ( ) ; \n) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) { \ncolumnReader . skip ( ) ; \n} \ncolumnReader . consume ( ) ; \nint nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \n++ recordsRead ; \n} \n} \n} \n"}
{"2140": "public class ApplicationPackage { \nstatic void removeLogicalDuplicates ( SortedSet < String > packages ) { \nIterator < String > iterator = packages . iterator ( ) ; \nif ( ! iterator . hasNext ( ) ) { \nreturn ; \n} \nString last = iterator . next ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nString current = iterator . next ( ) ; \nif ( current . startsWith ( last ) ) { \niterator . remove ( ) ; \n} \nelse { \nlast = current ; \n} \n} \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nfor ( ; \nidx > - 1 ; \n) { \nfor ( int i = pos ; \ni < idx ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \ni < chunkLines . size ( ) ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2148": "public class Producer { \npublic Object put ( OffsetAndResult < Map . Entry > batch ) { \nif ( consumerError != null ) { \nthrow new RuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , consumerError ) , consumerError ) ; \n} \nif ( producerError != null ) { \nthrow new RuntimeException ( Utils . format ( \"Producer encountered error: {}\" , producerError ) , producerError ) ; \n} \ntry { \nObject expectedOffset = \"EMPTY_BATCH\" ; \nif ( ! batch . getResult ( ) . isEmpty ( ) ) { \nexpectedOffset = batch . getResult ( ) . get ( batch . getResult ( ) . size ( ) - 1 ) . getKey ( ) ; \n} \nfor ( ; \n! dataChannel . offer ( batch , 10 , TimeUnit . MILLISECONDS ) ; \n) { \nfor ( ControlChannel . Message controlMessage : controlChannel . getProducerMessages ( ) ) { \nswitch ( controlMessage . getType ( ) ) { \ncase CONSUMER_ERROR : Throwable throwable = ( Throwable ) controlMessage . getPayload ( ) ; \nconsumerError = throwable ; \nthrow new ConsumerRuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , throwable ) , throwable ) ; \ndefault : String msg = Utils . format ( \"Illegal control message type: '{}'\" , controlMessage . getType ( ) ) ; \nthrow new IllegalStateException ( msg ) ; \n} \n} \n} \nreturn expectedOffset ; \n} \ncatch ( Throwable throwable ) { \ncontrolChannel . producerComplete ( ) ; \nif ( ! ( throwable instanceof ConsumerRuntimeException ) ) { \nString msg = \"Error caught in producer: \" + throwable ; \nLOG . error ( msg , throwable ) ; \ncontrolChannel . producerError ( throwable ) ; \nif ( producerError == null ) { \nproducerError = throwable ; \n} \n} \nthrow Throwables . propagate ( throwable ) ; \n} \n} \n} \n"}
{"2150": "public class GrokDictionary { \nprivate String digestExpressionAux ( String originalExpression ) { \nfinal String PATTERN_START = \"%{\" ; \nfinal String PATTERN_STOP = \"}\" ; \nfinal char PATTERN_DELIMITER = ':' ; \nfor ( ; \ntrue ; \n) { \nint PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; \nint PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; \nif ( PATTERN_START_INDEX < 0 || PATTERN_STOP_INDEX < 0 ) { \nbreak ; \n} \nString grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; \nint PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; \nString regexName = grokPattern ; \nString groupName = null ; \nif ( PATTERN_DELIMITER_INDEX >= 0 ) { \nregexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; \ngroupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; \n} \nfinal String dictionaryValue = regexDictionary . get ( regexName ) ; \nif ( dictionaryValue == null ) { \nthrow new GrokCompilationException ( \"Missing value for regex name : \" + regexName ) ; \n} \nif ( dictionaryValue . contains ( PATTERN_START ) ) { \nbreak ; \n} \nString replacement = dictionaryValue ; \nif ( null != groupName ) { \nreplacement = \"(?<\" + groupName + \">\" + dictionaryValue + \")\" ; \n} \noriginalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; \n} \nreturn originalExpression ; \n} \n} \n"}
{"2193": "public class Consumer { \npublic OffsetAndResult < Map . Entry > take ( ) { \nif ( producerError != null ) { \nthrow new RuntimeException ( Utils . format ( \"Producer encountered error: {}\" , producerError ) , producerError ) ; \n} \nif ( consumerError != null ) { \nthrow new RuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , consumerError ) , consumerError ) ; \n} \ntry { \nUtils . checkState ( batchCommitted , \"Cannot take messages when last batch is uncommitted\" ) ; \nfor ( ; \nrunning ; \n) { \nfor ( ControlChannel . Message controlMessage : controlChannel . getConsumerMessages ( ) ) { \nswitch ( controlMessage . getType ( ) ) { \ncase PRODUCER_COMPLETE : running = false ; \nbreak ; \ncase PRODUCER_ERROR : running = false ; \nThrowable throwable = ( Throwable ) controlMessage . getPayload ( ) ; \nproducerError = throwable ; \nthrow new ProducerRuntimeException ( Utils . format ( \"Producer encountered error: {}\" , throwable ) , throwable ) ; \ndefault : String msg = Utils . format ( \"Illegal control message type: '{}'\" , controlMessage . getType ( ) ) ; \nthrow new IllegalStateException ( msg ) ; \n} \n} \nOffsetAndResult < Map . Entry > batch = dataChannel . take ( 10 , TimeUnit . MILLISECONDS ) ; \nLOG . trace ( \"Received batch: {}\" , batch ) ; \nif ( batch != null ) { \nbatchCommitted = false ; \nreturn batch ; \n} \n} \nLOG . trace ( \"Returning null\" ) ; \nreturn null ; \n} \ncatch ( Throwable throwable ) { \nif ( ! ( throwable instanceof ProducerRuntimeException ) ) { \nString msg = \"Error caught in consumer: \" + throwable ; \nLOG . error ( msg , throwable ) ; \nerror ( throwable ) ; \n} \nthrow Throwables . propagate ( throwable ) ; \n} \n} \n} \n"}
{"2216": "public class JdbcMultiRowRecordWriter { \nprivate void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { \nif ( queue . isEmpty ( ) ) { \nreturn ; \n} \nint rowCount = 0 ; \nfinal Record first = queue . getFirst ( ) ; \nSortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; \nif ( columnsToParameters . isEmpty ( ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"No parameters found for record with ID {}; skipping\" , first . getHeader ( ) . getSourceId ( ) ) ; \n} \nreturn ; \n} \nString query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; \nLinkedList < Record > removed = new LinkedList < > ( ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nfor ( ; \n! queue . isEmpty ( ) ; \n) { \nRecord r = queue . removeFirst ( ) ; \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \nremoved . add ( r ) ; \n++ rowCount ; \nif ( rowCount == maxRowsPerBatch ) { \nprocessBatch ( removed , errorRecords , statement , connection ) ; \nrowCount = 0 ; \nparamIdx = 1 ; \nremoved . clear ( ) ; \n} \n} \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \nif ( ! removed . isEmpty ( ) ) { \nquery = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nfor ( Record r : removed ) { \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \n} \nprocessBatch ( removed , errorRecords , statement , connection ) ; \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \n} \n} \n} \n"}
{"2228": "public class JdbcUtil { \npublic < T > void write ( Iterator < Record > recordIterator , T key , LoadingCache < T , JdbcRecordWriter > recordWriters , ErrorRecordHandler errorRecordHandler , boolean perRecord ) throws StageException { \nfinal JdbcRecordWriter jdbcRecordWriter ; \ntry { \njdbcRecordWriter = recordWriters . getUnchecked ( key ) ; \n} \ncatch ( UncheckedExecutionException ex ) { \nfinal Throwable throwable = ex . getCause ( ) ; \nfinal ErrorCode errorCode ; \nfinal Object [ ] messageParams ; \nif ( throwable instanceof StageException ) { \nStageException stageEx = ( StageException ) ex . getCause ( ) ; \nerrorCode = stageEx . getErrorCode ( ) ; \nmessageParams = stageEx . getParams ( ) ; \n} \nelse { \nerrorCode = JdbcErrors . JDBC_301 ; \nmessageParams = new Object [ ] { \nex . getMessage ( ) , ex . getCause ( ) } \n; \n} \nfor ( ; \nrecordIterator . hasNext ( ) ; \n) { \nRecord record = recordIterator . next ( ) ; \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , errorCode , messageParams ) ) ; \n} \nreturn ; \n} \nList < OnRecordErrorException > errors = perRecord ? jdbcRecordWriter . writePerRecord ( recordIterator ) : jdbcRecordWriter . writeBatch ( recordIterator ) ; \nfor ( OnRecordErrorException error : errors ) { \nerrorRecordHandler . onError ( error ) ; \n} \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nfor ( ; \n! stop ; \n) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \nelse { \nif ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \n} \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( timeout >= 1000 , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( queryJob == null ) { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nelse if ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \nfor ( ; \n! queryJob . isDone ( ) ; \n) { \nif ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2292": "public class AerospikeBeanConfig { \npublic void init ( Target . Context context , List < Target . ConfigIssue > issues ) { \nList < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , context ) ; \nClientPolicy cp = new ClientPolicy ( ) ; \ntry { \nclient = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; \nint retries = 0 ; \nfor ( ; \n! client . isConnected ( ) && retries <= maxRetries ; \n) { \nif ( retries > maxRetries ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \nreturn ; \n} \nretries ++ ; \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException ignored ) { \n} \n} \n} \ncatch ( AerospikeException ex ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \n} \n} \n} \n"}
{"2310": "public class AmazonS3Util { \nstatic List < S3ObjectSummary > listObjectsLexicographically ( AmazonS3 s3Client , S3ConfigBean s3ConfigBean , AntPathMatcher pathMatcher , S3Offset s3Offset , int fetchSize ) { \nList < S3ObjectSummary > list = new ArrayList < > ( fetchSize ) ; \nListObjectsRequest listObjectsRequest = new ListObjectsRequest ( ) ; \nlistObjectsRequest . setBucketName ( s3ConfigBean . s3Config . bucket ) ; \nlistObjectsRequest . setPrefix ( s3ConfigBean . s3Config . commonPrefix ) ; \nlistObjectsRequest . setMaxKeys ( BATCH_SIZE ) ; \nif ( s3Offset . getKey ( ) != null ) { \nlistObjectsRequest . setMarker ( s3Offset . getKey ( ) ) ; \n} \nObjectListing objectListing = s3Client . listObjects ( listObjectsRequest ) ; \nfor ( ; \ntrue ; \n) { \nfor ( S3ObjectSummary s : objectListing . getObjectSummaries ( ) ) { \nString fullPrefix = s . getKey ( ) ; \nString remainingPrefix = fullPrefix . substring ( s3ConfigBean . s3Config . commonPrefix . length ( ) , fullPrefix . length ( ) ) ; \nif ( ! remainingPrefix . isEmpty ( ) ) { \nif ( pathMatcher . match ( s3ConfigBean . s3FileConfig . prefixPattern , remainingPrefix ) ) { \nlist . add ( s ) ; \n} \nif ( list . size ( ) == fetchSize ) { \nreturn list ; \n} \n} \n} \nif ( ! objectListing . isTruncated ( ) ) { \nbreak ; \n} \nobjectListing = s3Client . listNextBatchOfObjects ( objectListing ) ; \n} \nreturn list ; \n} \n} \n"}
{"2312": "public class ProductionPipelineRunner { \npublic int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { \nLOG . debug ( \"Checking if any active runner is idle\" ) ; \nint counter = 0 ; \ntry { \ndestroyLock . lock ( ) ; \nfor ( ; \nrunning && counter < pipes . size ( ) ; \n) { \ncounter ++ ; \nPipeRunner runner = null ; \ntry { \nrunner = runnerPool . getIdleRunner ( idleTime ) ; \nif ( runner == null ) { \nreturn counter ; \n} \nLOG . debug ( \"Generating empty batch for runner: {}\" , runner . getRunnerId ( ) ) ; \npipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; \nFullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; \npipeBatch . setIdleBatch ( true ) ; \npipeBatch . skipStage ( originPipe ) ; \nexecuteRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \nif ( runner != null ) { \nrunnerPool . returnRunner ( runner ) ; \n} \n} \n} \n} \nfinally { \ndestroyLock . unlock ( ) ; \n} \nreturn counter ; \n} \n} \n"}
{"2318": "public class LogCharDataParser { \nint readLine ( StringBuilder sb ) throws IOException { \nint c = reader . read ( ) ; \nint count = ( c == - 1 ) ? - 1 : 0 ; \nfor ( ; \nc > - 1 && ! isOverMaxObjectLen ( count ) && ! checkEolAndAdjust ( c ) ; \n) { \ncount ++ ; \nsb . append ( ( char ) c ) ; \nc = reader . read ( ) ; \n} \nif ( isOverMaxObjectLen ( count ) ) { \nsb . setLength ( sb . length ( ) - 1 ) ; \nfor ( ; \nc > - 1 && c != '\\n' && c != '\\r' ; \n) { \ncount ++ ; \nc = reader . read ( ) ; \n} \ncheckEolAndAdjust ( c ) ; \n} \nreturn count ; \n} \n} \n"}
{"2336": "public class Pattern { \nstatic private boolean isSlashEscapedChar ( String s , int pos ) { \nint numSlashes = 0 ; \nfor ( ; \npos > 0 && ( s . charAt ( pos - 1 ) == '\\\\' ) ; \n) { \npos -- ; \nnumSlashes ++ ; \n} \nreturn numSlashes % 2 != 0 ; \n} \n} \n"}
{"2337": "public class Pattern { \nstatic private boolean isInsideCharClass ( String s , int pos ) { \nboolean openBracketFound = false ; \nboolean closeBracketFound = false ; \nString s2 = s . substring ( 0 , pos ) ; \nint posOpen = pos ; \nfor ( ; \n( posOpen = s2 . lastIndexOf ( '[' , posOpen - 1 ) ) != - 1 ; \n) { \nif ( ! isEscapedChar ( s2 , posOpen ) ) { \nopenBracketFound = true ; \nbreak ; \n} \n} \nif ( openBracketFound ) { \nString s3 = s . substring ( posOpen , pos ) ; \nint posClose = - 1 ; \nfor ( ; \n( posClose = s3 . indexOf ( ']' , posClose + 1 ) ) != - 1 ; \n) { \nif ( ! isEscapedChar ( s3 , posClose ) ) { \ncloseBracketFound = true ; \nbreak ; \n} \n} \n} \nreturn openBracketFound && ! closeBracketFound ; \n} \n} \n"}
{"2338": "public class Pattern { \nstatic private int countOpenParens ( String s , int pos ) { \njava . util . regex . Pattern p = java . util . regex . Pattern . compile ( \"\\\\(\" ) ; \njava . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; \nint numParens = 0 ; \nfor ( ; \nm . find ( ) ; \n) { \nif ( isInsideCharClass ( s , m . start ( ) ) ) { \ncontinue ; \n} \nif ( isEscapedChar ( s , m . start ( ) ) ) continue ; \nif ( ! isNoncapturingParen ( s , m . start ( ) ) ) { \nnumParens ++ ; \n} \n} \nreturn numParens ; \n} \n} \n"}
{"2339": "public class Pattern { \nstatic public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { \nMap < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; \njava . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; \nfor ( ; \nmatcher . find ( ) ; \n) { \nint pos = matcher . start ( ) ; \nif ( isEscapedChar ( namedPattern , pos ) ) continue ; \nString name = matcher . group ( INDEX_GROUP_NAME ) ; \nint groupIndex = countOpenParens ( namedPattern , pos ) ; \nList < GroupInfo > list ; \nif ( groupInfo . containsKey ( name ) ) { \nlist = groupInfo . get ( name ) ; \n} \nelse { \nlist = new ArrayList < GroupInfo > ( ) ; \n} \nlist . add ( new GroupInfo ( groupIndex , pos ) ) ; \ngroupInfo . put ( name , list ) ; \n} \nreturn groupInfo ; \n} \n} \n"}
{"2340": "public class Pattern { \nstatic private StringBuilder replace ( StringBuilder input , java . util . regex . Pattern pattern , String replacement ) { \njava . util . regex . Matcher m = pattern . matcher ( input ) ; \nfor ( ; \nm . find ( ) ; \n) { \nif ( isEscapedChar ( input . toString ( ) , m . start ( ) ) ) { \ncontinue ; \n} \ninput . replace ( m . start ( ) , m . end ( ) , replacement ) ; \nm . reset ( input ) ; \n} \nreturn input ; \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nint offset = startOffset ; \nint numValues = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nfor ( ; \nnumValues -- > 0 ; \n) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset += 1 ; \n} \nfor ( int i = 0 ; \ni < types . size ( ) ; \ni ++ ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2368": "public class MetricEnabledWrapperStream { \nstatic String convertBytesToDisplayFormat ( double bytes ) { \nint unitIdx = 0 ; \ndouble unitChangedBytes = bytes ; \nfor ( ; \nunitIdx < UNITS . length - 1 && Math . floor ( unitChangedBytes / 1024 ) > 0 ; \n) { \nunitChangedBytes = unitChangedBytes / 1024 ; \nunitIdx ++ ; \n} \nreturn df . format ( unitChangedBytes ) + \" \" + UNITS [ unitIdx ] ; \n} \n} \n"}
{"2381": "public class EmbeddedSDCPool { \n@ SuppressWarnings ( \"unchecked\" ) protected EmbeddedSDC create ( ) throws Exception { \nUtils . checkState ( open , \"Not open\" ) ; \nfinal EmbeddedSDC embeddedSDC = new EmbeddedSDC ( ) ; \nObject source ; \nObject pipelineStartResult = BootstrapCluster . startPipeline ( ( ) -> LOG . debug ( \"Batch completed\" ) ) ; \nsource = pipelineStartResult . getClass ( ) . getDeclaredField ( \"source\" ) . get ( pipelineStartResult ) ; \nif ( source instanceof DSource ) { \nlong startTime = System . currentTimeMillis ( ) ; \nlong endTime = startTime ; \nlong diff = 0 ; \nSource actualSource = ( ( DSource ) source ) . getSource ( ) ; \nfor ( ; \nactualSource == null && diff < 60000 ; \n) { \nThread . sleep ( 100 ) ; \nactualSource = ( ( DSource ) source ) . getSource ( ) ; \nendTime = System . currentTimeMillis ( ) ; \ndiff = endTime - startTime ; \n} \nif ( actualSource == null ) { \nthrow new IllegalStateException ( \"Actual source is null, pipeline may not have been initialized\" ) ; \n} \nsource = actualSource ; \n} \nif ( ! ( source instanceof ClusterSource ) ) { \nthrow new IllegalArgumentException ( \"Source is not of type ClusterSource: \" + source . getClass ( ) . getName ( ) ) ; \n} \nembeddedSDC . setSource ( ( ClusterSource ) source ) ; \nembeddedSDC . setSparkProcessors ( ( List < Object > ) pipelineStartResult . getClass ( ) . getDeclaredField ( \"sparkProcessors\" ) . get ( pipelineStartResult ) ) ; \nreturn embeddedSDC ; \n} \n} \n"}
{"2392": "public class WholeFileTransformerProcessor { \nprivate void writeParquet ( String sourceFileName , DataFileStream < GenericRecord > fileReader , Path tempParquetFile ) throws StageException { \nlong recordCount = 0 ; \nGenericRecord avroRecord ; \nSchema schema = fileReader . getSchema ( ) ; \nLOG . debug ( \"Start reading input file : {}\" , sourceFileName ) ; \ntry { \nConfiguration jobConfiguration = new Configuration ( ) ; \nString compressionCodecName = compressionElEval . eval ( variables , jobConfig . avroParquetConfig . compressionCodec , String . class ) ; \njobConfiguration . set ( AvroParquetConstants . COMPRESSION_CODEC_NAME , compressionCodecName ) ; \njobConfiguration . setInt ( AvroParquetConstants . ROW_GROUP_SIZE , jobConfig . avroParquetConfig . rowGroupSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . PAGE_SIZE , jobConfig . avroParquetConfig . pageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . DICTIONARY_PAGE_SIZE , jobConfig . avroParquetConfig . dictionaryPageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . MAX_PADDING_SIZE , jobConfig . avroParquetConfig . maxPaddingSize ) ; \nParquetWriter . Builder builder = AvroToParquetConverterUtil . initializeWriter ( new org . apache . hadoop . fs . Path ( tempParquetFile . toString ( ) ) , schema , jobConfiguration ) ; \nparquetWriter = builder . build ( ) ; \nfor ( ; \nfileReader . hasNext ( ) ; \n) { \navroRecord = fileReader . next ( ) ; \nparquetWriter . write ( avroRecord ) ; \nrecordCount ++ ; \n} \nparquetWriter . close ( ) ; \n} \ncatch ( IOException ex ) { \nthrow new TransformerStageCheckedException ( Errors . CONVERT_08 , sourceFileName , recordCount , ex ) ; \n} \nLOG . debug ( \"Finished writing {} records to {}\" , recordCount , tempParquetFile . getFileName ( ) ) ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nfor ( ; \nsplitbyte + 1 < rlen ; \n) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \nsplitbyte ++ ; \n} \nreturn 0 ; \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nfor ( ; \npending > 0 || sendEverything ; \n) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nint read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( read <= 0 ) { \nbreak ; \n} \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) { \nthis . data . close ( ) ; \n} \n} \nif ( ! sendEverything ) { \npending -= read ; \n} \n} \n} \n} \n"}
{"2467": "public class JCAOrderedLastSynchronizationList { \n@ Override public void beforeCompletion ( ) { \nint lastIndexProcessed = 0 ; \nfor ( ; \n( lastIndexProcessed < preJcaSyncs . size ( ) ) ; \n) { \nSynchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; \n} \npreJcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nlastIndexProcessed = 0 ; \nfor ( ; \n( lastIndexProcessed < jcaSyncs . size ( ) ) ; \n) { \nSynchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; \n} \njcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nfor ( ; \nreader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ; \n) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \n} \n} \n"}
{"2486": "public class TransactionSubsystem10Parser { \nstatic void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { \nif ( reader . getAttributeCount ( ) > 0 ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \nboolean encountered = false ; \nfor ( ; \nreader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ; \n) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nswitch ( element ) { \ncase UUID : if ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nif ( reader . getAttributeCount ( ) > 0 ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \ncoreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; \nrequireNoContent ( reader ) ; \nbreak ; \ncase SOCKET : { \nif ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nparseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! encountered ) { \nthrow missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; \n} \n} \n} \n"}
{"2500": "public class WildFlyProviderResolver { \nprivate List < ValidationProvider < ? > > loadProviders ( ClassLoader classLoader ) { \n@ SuppressWarnings ( \"rawtypes\" ) Iterator < ValidationProvider > providerIterator = ServiceLoader . load ( ValidationProvider . class , classLoader ) . iterator ( ) ; \nLinkedList < ValidationProvider < ? > > providers = new LinkedList < ValidationProvider < ? > > ( ) ; \nfor ( ; \nproviderIterator . hasNext ( ) ; \n) { \ntry { \nValidationProvider < ? > provider = providerIterator . next ( ) ; \nif ( provider . getClass ( ) . getName ( ) . equals ( \"org.hibernate.validator.HibernateValidator\" ) ) { \nproviders . addFirst ( provider ) ; \n} \nelse { \nproviders . add ( provider ) ; \n} \n} \ncatch ( ServiceConfigurationError e ) { \n} \n} \nreturn providers ; \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nfor ( ; \n! clz . equals ( Object . class ) ; \n) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nfor ( ; \n! clz . equals ( Object . class ) ; \n) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nfor ( ; \nen . hasMoreElements ( ) ; \n) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) { \nsb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nfor ( ; \nenparam . hasMoreElements ( ) ; \n) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nint len = paramValues != null ? paramValues . length : 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nsb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \n} \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nfor ( ; \nenu . hasMoreElements ( ) ; \n) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2556": "public class ShutDownInterceptorFactory { \npublic void shutdown ( ) { \nint value ; \nint oldValue ; \ndo { \noldValue = invocationCount ; \nvalue = SHUTDOWN_FLAG | oldValue ; \nif ( oldValue == value ) { \nreturn ; \n} \n} \nwhile ( ! updater . compareAndSet ( this , oldValue , value ) ) ; \nsynchronized ( lock ) { \nvalue = invocationCount ; \nfor ( ; \nvalue != SHUTDOWN_FLAG ; \n) { \ntry { \nlock . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \nvalue = invocationCount ; \nif ( ( value & SHUTDOWN_FLAG ) == 0 ) { \nreturn ; \n} \n} \n} \n} \n} \n"}
{"2598": "public class CorbaUtils { \npublic static ORB getOrb ( String server , int port , Hashtable env ) { \nProperties orbProp ; \nif ( env != null ) { \norbProp = new Properties ( ) ; \nfinal Enumeration envProp = env . keys ( ) ; \nfor ( ; \nenvProp . hasMoreElements ( ) ; \n) { \nString key = ( String ) envProp . nextElement ( ) ; \nObject val = env . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \nfinal Enumeration mainProps = orbProperties . keys ( ) ; \nfor ( ; \nmainProps . hasMoreElements ( ) ; \n) { \nString key = ( String ) mainProps . nextElement ( ) ; \nObject val = orbProperties . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \n} \nelse { \norbProp = orbProperties ; \n} \nif ( server != null ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialHost\" , server ) ; \n} \nif ( port >= 0 ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialPort\" , \"\" + port ) ; \n} \nif ( env != null ) { \nObject applet = env . get ( Context . APPLET ) ; \nif ( applet != null ) { \nreturn initAppletORB ( applet , orbProp ) ; \n} \n} \nreturn ORB . init ( new String [ 0 ] , orbProp ) ; \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nfor ( ; \ntrue ; \n) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse if ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nfor ( ; \ntrue ; \n) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse if ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nint sequence = 0 ; \nfor ( ; \ncomponentClass . isArray ( ) ; \n) { \ncomponentClass = componentClass . getComponentType ( ) ; \n++ sequence ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nint idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; \nif ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; \nif ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; \nif ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; \nif ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; \nif ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; \nif ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; \nif ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) { \nif ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2650": "public class QueryName { \nprivate static void subst ( final StringBuilder stringBuilder , final String from , final String to ) { \nint begin = 0 , end = 0 ; \nfor ( ; \n( end = stringBuilder . indexOf ( from , end ) ) != - 1 ; \n) { \nstringBuilder . delete ( end , end + from . length ( ) ) ; \nstringBuilder . insert ( end , to ) ; \nbegin = end + to . length ( ) ; \nend = begin ; \n} \n} \n} \n"}
{"2678": "public class WeldModuleResourceLoader { \n@ Override public Collection < URL > getResources ( String name ) { \ntry { \nfinal HashSet < URL > resources = new HashSet < URL > ( ) ; \nEnumeration < URL > urls = module . getClassLoader ( ) . getResources ( name ) ; \nfor ( ; \nurls . hasMoreElements ( ) ; \n) { \nresources . add ( urls . nextElement ( ) ) ; \n} \nreturn resources ; \n} \ncatch ( Exception e ) { \nthrow new ResourceLoadingException ( e ) ; \n} \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nfor ( ; \ni < len ; \n) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2731": "public class PersistenceProviderResolverImpl { \nprivate ClassLoader findParentModuleCl ( ClassLoader classLoader ) { \nClassLoader c = classLoader ; \nfor ( ; \nc != null && ! ( c instanceof ModuleClassLoader ) ; \n) { \nc = c . getParent ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"2745": "public class ContainerAnalysis { \npublic String getIDLModuleName ( ) { \nif ( idlModuleName == null ) { \nString pkgName = cls . getPackage ( ) . getName ( ) ; \nStringBuffer b = new StringBuffer ( ) ; \nfor ( ; \n! \"\" . equals ( pkgName ) ; \n) { \nint idx = pkgName . indexOf ( '.' ) ; \nString n = ( idx == - 1 ) ? pkgName : pkgName . substring ( 0 , idx ) ; \nb . append ( \"::\" ) . append ( Util . javaToIDLName ( n ) ) ; \npkgName = ( idx == - 1 ) ? \"\" : pkgName . substring ( idx + 1 ) ; \n} \nidlModuleName = b . toString ( ) ; \n} \nreturn idlModuleName ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nfor ( ; \n! \"\" . equals ( s ) ; \n) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nfor ( ; \nreader . hasNext ( ) ; \n) { \nswitch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) { \nreturn new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \n} \nelse { \nif ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { \nthrow new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \n} \n} \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null && password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) password = resolvedPassword ; \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2801": "public class JndiPermission { \npublic String getActions ( ) { \nfinal String actionString = this . actionString ; \nif ( actionString != null ) { \nreturn actionString ; \n} \nint actionBits = this . actionBits ; \nif ( actionBits == ACTION_ALL ) { \nreturn this . actionString = \"*\" ; \n} \nint m = Integer . lowestOneBit ( actionBits ) ; \nif ( m != 0 ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \nfor ( ; \nactionBits != 0 ; \n) { \nm = Integer . lowestOneBit ( actionBits ) ; \nb . append ( ',' ) . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \n} \nreturn this . actionString = b . toString ( ) ; \n} \nelse { \nreturn this . actionString = \"\" ; \n} \n} \n} \n"}
{"2877": "public class Utils { \npublic static void skip ( InputStream is , long amount ) throws IOException { \nlong leftToSkip = amount ; \nlong amountSkipped = 0 ; \nfor ( ; \nleftToSkip > 0 && amountSkipped >= 0 ; \n) { \namountSkipped = is . skip ( leftToSkip ) ; \nleftToSkip -= amountSkipped ; \n} \n} \n} \n"}
{"2919": "public class OSelectExecutionPlanner { \nprivate Map < String , Set < String > > getMinimalSetOfNodesForShardedQuery ( String localNode , Map < String , Set < String > > clusterMap , Set < String > queryClusters ) { \nMap < String , Set < String > > result = new LinkedHashMap < > ( ) ; \nSet < String > uncovered = new HashSet < > ( ) ; \nuncovered . addAll ( queryClusters ) ; \nuncovered = uncovered . stream ( ) . filter ( x -> x != null ) . map ( x -> x . toLowerCase ( Locale . ENGLISH ) ) . collect ( Collectors . toSet ( ) ) ; \nSet < String > nextNodeClusters = new HashSet < > ( ) ; \nSet < String > clustersForNode = clusterMap . get ( localNode ) ; \nif ( clustersForNode != null ) { \nnextNodeClusters . addAll ( clustersForNode ) ; \n} \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( nextNodeClusters . size ( ) > 0 ) { \nresult . put ( localNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nfor ( ; \nuncovered . size ( ) > 0 ; \n) { \nString nextNode = findItemThatCoversMore ( uncovered , clusterMap ) ; \nnextNodeClusters = new HashSet < > ( ) ; \nnextNodeClusters . addAll ( clusterMap . get ( nextNode ) ) ; \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( nextNodeClusters . size ( ) == 0 ) { \nthrow new OCommandExecutionException ( \"Cannot execute a sharded query: clusters [\" + uncovered . stream ( ) . collect ( Collectors . joining ( \", \" ) ) + \"] are not present on any node\" + \"\\n [\" + clusterMap . entrySet ( ) . stream ( ) . map ( x -> \"\" + x . getKey ( ) + \":(\" + x . getValue ( ) . stream ( ) . collect ( Collectors . joining ( \",\" ) ) + \")\" ) . collect ( Collectors . joining ( \", \" ) ) + \"]\" ) ; \n} \nresult . put ( nextNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nreturn result ; \n} \n} \n"}
{"2925": "public class OSelectExecutionPlanner { \nprivate boolean isDiamondHierarchy ( OClass clazz ) { \nSet < OClass > traversed = new HashSet < > ( ) ; \nList < OClass > stack = new ArrayList < > ( ) ; \nstack . add ( clazz ) ; \nfor ( ; \n! stack . isEmpty ( ) ; \n) { \nOClass current = stack . remove ( 0 ) ; \ntraversed . add ( current ) ; \nfor ( OClass sub : current . getSubclasses ( ) ) { \nif ( traversed . contains ( sub ) ) { \nreturn true ; \n} \nstack . add ( sub ) ; \ntraversed . add ( sub ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2929": "public class OSelectExecutionPlanner { \nprivate IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { \nList < String > indexFields = index . getDefinition ( ) . getFields ( ) ; \nOBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; \nOIdentifier key = new OIdentifier ( \"key\" ) ; \nkeyCondition . setLeft ( new OExpression ( key ) ) ; \nboolean found = false ; \nOAndBlock blockCopy = block . copy ( ) ; \nIterator < OBooleanExpression > blockIterator ; \nOAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; \nIndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; \nresult . idx = index ; \nresult . keyCondition = indexKeyValue ; \nfor ( String indexField : indexFields ) { \nblockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; \nboolean breakHere = false ; \nboolean indexFieldFound = false ; \nfor ( ; \nblockIterator . hasNext ( ) ; \n) { \nOBooleanExpression singleExp = blockIterator . next ( ) ; \nif ( singleExp instanceof OContainsTextCondition ) { \nOExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; \nif ( left . isBaseIdentifier ( ) ) { \nString fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; \nif ( indexField . equals ( fieldName ) ) { \nfound = true ; \nindexFieldFound = true ; \nOContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; \ncondition . setLeft ( left ) ; \ncondition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; \nindexKeyValue . getSubBlocks ( ) . add ( condition ) ; \nblockIterator . remove ( ) ; \nbreak ; \n} \n} \n} \n} \nif ( breakHere || ! indexFieldFound ) { \nbreak ; \n} \n} \nif ( result . keyCondition . getSubBlocks ( ) . size ( ) < index . getDefinition ( ) . getFields ( ) . size ( ) && ! index . supportsOrderedIterations ( ) ) { \nreturn null ; \n} \nif ( found ) { \nresult . remainingCondition = blockCopy ; \nreturn result ; \n} \nreturn null ; \n} \n} \n"}
{"2939": "public class OHazelcastPlugin { \nprivate void assignLockManagerFromCluster ( ) { \nString lockManagerServer = null ; \nfor ( ; \nlockManagerServer == null ; \n) { \nif ( activeNodes . size ( ) == 1 ) { \nlockManagerServer = nodeName ; \nif ( configurationMap . putIfAbsent ( CONFIG_LOCKMANAGER , lockManagerServer ) == null ) break ; \n} \nelse { \nlockManagerServer = ( String ) configurationMap . get ( CONFIG_LOCKMANAGER ) ; \nif ( lockManagerServer != null && lockManagerServer . equals ( nodeName ) ) { \nOLogManager . instance ( ) . info ( this , \"Found lock as current node, even if it was offline. Forcing a new election...\" ) ; \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nlockManagerServer = electNewLockManager ( ) ; \nbreak ; \n} \nif ( lockManagerServer != null ) break ; \n} \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException e ) { \nbreak ; \n} \n} \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nOLogManager . instance ( ) . info ( this , \"Distributed Lock Manager server is '%s'\" , lockManagerServer ) ; \n} \n} \n"}
{"2946": "public class Pattern { \npublic List < Pattern > getDisjointPatterns ( ) { \nMap < PatternNode , String > reverseMap = new IdentityHashMap < > ( ) ; \nreverseMap . putAll ( this . aliasToNode . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( x -> x . getValue ( ) , x -> x . getKey ( ) ) ) ) ; \nList < Pattern > result = new ArrayList < > ( ) ; \nfor ( ; \n! reverseMap . isEmpty ( ) ; \n) { \nPattern pattern = new Pattern ( ) ; \nresult . add ( pattern ) ; \nMap . Entry < PatternNode , String > nextNode = reverseMap . entrySet ( ) . iterator ( ) . next ( ) ; \nSet < PatternNode > toVisit = new HashSet < > ( ) ; \ntoVisit . add ( nextNode . getKey ( ) ) ; \nfor ( ; \ntoVisit . size ( ) > 0 ; \n) { \nPatternNode currentNode = toVisit . iterator ( ) . next ( ) ; \ntoVisit . remove ( currentNode ) ; \nif ( reverseMap . containsKey ( currentNode ) ) { \npattern . aliasToNode . put ( reverseMap . get ( currentNode ) , currentNode ) ; \nreverseMap . remove ( currentNode ) ; \nfor ( PatternEdge x : currentNode . out ) { \ntoVisit . add ( x . in ) ; \n} \nfor ( PatternEdge x : currentNode . in ) { \ntoVisit . add ( x . out ) ; \n} \n} \n} \npattern . recalculateNumOfEdges ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"2970": "public class OEmbeddedRidBag { \npublic boolean swap ( int index , OIdentifiable newValue ) { \nEntriesIterator iter = ( EntriesIterator ) rawIterator ( ) ; \nint currIndex = 0 ; \nfor ( ; \niter . hasNext ( ) ; \n) { \niter . next ( ) ; \nif ( index == currIndex ) { \niter . swapValueOnCurrent ( newValue ) ; \nreturn true ; \n} \ncurrIndex ++ ; \n} \nreturn false ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( steps . size ( ) > 0 ) { \nlastStep = steps . get ( steps . size ( ) - 1 ) ; \n} \nfor ( int i = 0 ; \ni < steps . size ( ) - 1 ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nfor ( ; \nlastResult . hasNext ( ) ; \n) { \nfor ( ; \nlastResult . hasNext ( ) ; \n) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \nfor ( int i = 0 ; \ni < steps . size ( ) ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nreturn returnStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nfor ( ; \nlastResult . hasNext ( ) ; \n) { \nfor ( ; \nlastResult . hasNext ( ) ; \n) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3002": "public class OIndexAbstract { \npublic OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { \nacquireExclusiveLock ( ) ; \ntry { \nconfiguration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; \nthis . indexDefinition = indexDefinition ; \nif ( clustersToIndex != null ) this . clustersToIndex = new HashSet < > ( clustersToIndex ) ; \nelse this . clustersToIndex = new HashSet < > ( ) ; \ntry { \nif ( apiVersion == 0 ) { \nremoveValuesContainer ( ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during deletion of index '%s'\" , e , name ) ; \n} \nindexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; \napiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; \nassert indexId >= 0 ; \nassert apiVersion >= 0 ; \nonIndexEngineChange ( indexId ) ; \nif ( rebuild ) fillIndex ( progressListener , false ) ; \nupdateConfiguration ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' creation\" , e , name ) ; \nfor ( ; \ntrue ; \n) try { \nif ( indexId >= 0 ) storage . deleteIndexEngine ( indexId ) ; \nbreak ; \n} \ncatch ( OInvalidIndexEngineIdException ignore ) { \ndoReloadIndexEngine ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' deletion\" , ex , name ) ; \n} \nif ( e instanceof OIndexException ) throw ( OIndexException ) e ; \nthrow OException . wrapException ( new OIndexException ( \"Cannot create the index '\" + name + \"'\" ) , e ) ; \n} \nfinally { \nreleaseExclusiveLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"3032": "public class ORidBag { \npublic boolean tryMerge ( final ORidBag otherValue , boolean iMergeSingleItemsOfMultiValueFields ) { \nif ( ! isEmbedded ( ) && ! otherValue . isEmbedded ( ) ) { \nfinal OSBTreeRidBag thisTree = ( OSBTreeRidBag ) delegate ; \nfinal OSBTreeRidBag otherTree = ( OSBTreeRidBag ) otherValue . delegate ; \nif ( thisTree . getCollectionPointer ( ) . equals ( otherTree . getCollectionPointer ( ) ) ) { \nthisTree . mergeChanges ( otherTree ) ; \nuuid = otherValue . uuid ; \nreturn true ; \n} \n} \nelse if ( iMergeSingleItemsOfMultiValueFields ) { \nfinal Iterator < OIdentifiable > iter = otherValue . rawIterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nfinal OIdentifiable value = iter . next ( ) ; \nif ( value != null ) { \nfinal Iterator < OIdentifiable > localIter = rawIterator ( ) ; \nboolean found = false ; \nfor ( ; \nlocalIter . hasNext ( ) ; \n) { \nfinal OIdentifiable v = localIter . next ( ) ; \nif ( value . equals ( v ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) add ( value ) ; \n} \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3038": "public class OSQLEngine { \npublic static Set < String > getFunctionNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OSQLFunctionFactory > ite = getFunctionFactories ( ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \ntypes . addAll ( ite . next ( ) . getFunctionNames ( ) ) ; \n} \nreturn types ; \n} \n} \n"}
{"3039": "public class OSQLEngine { \npublic static Set < String > getCollateNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OCollateFactory > ite = getCollateFactories ( ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \ntypes . addAll ( ite . next ( ) . getNames ( ) ) ; \n} \nreturn types ; \n} \n} \n"}
{"3040": "public class OSQLEngine { \npublic static Set < String > getCommandNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OCommandExecutorSQLFactory > ite = getCommandFactories ( ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \ntypes . addAll ( ite . next ( ) . getCommandNames ( ) ) ; \n} \nreturn types ; \n} \n} \n"}
{"3064": "public class ONodeManager { \nprotected void initReceiveMessages ( ) throws IOException { \nmessageThread = new Thread ( ( ) -> { \nfor ( ; \n! Thread . interrupted ( ) ; \n) { \nreceiveMessages ( ) ; \n} \n} \n) ; \nmessageThread . setName ( \"OrientDB_DistributedDiscoveryThread\" ) ; \nmessageThread . setDaemon ( true ) ; \nmessageThread . start ( ) ; \n} \n} \n"}
{"3144": "public class OIndexes { \nprivate static Set < String > getIndexTypes ( ) { \nfinal Set < String > types = new HashSet < > ( ) ; \nfinal Iterator < OIndexFactory > ite = getAllFactories ( ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \ntypes . addAll ( ite . next ( ) . getTypes ( ) ) ; \n} \nreturn types ; \n} \n} \n"}
{"3145": "public class OIndexes { \npublic static Set < String > getIndexEngines ( ) { \nfinal Set < String > engines = new HashSet < > ( ) ; \nfinal Iterator < OIndexFactory > ite = getAllFactories ( ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \nengines . addAll ( ite . next ( ) . getAlgorithms ( ) ) ; \n} \nreturn engines ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nfor ( ; \ntrue ; \n) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) { \nif ( ++ i > iTo ) break ; \n} \nelse { \nif ( -- i < iFrom ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3170": "public class OEntityManager { \npublic synchronized void setClassHandler ( final OEntityManagerClassHandler iClassHandler ) { \nIterator < Entry < String , Class < ? > > > iterator = classHandler . getClassesEntrySet ( ) . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nEntry < String , Class < ? > > entry = iterator . next ( ) ; \nboolean forceSchemaReload = ! iterator . hasNext ( ) ; \niClassHandler . registerEntityClass ( entry . getValue ( ) , forceSchemaReload ) ; \n} \nthis . classHandler = iClassHandler ; \n} \n} \n"}
{"3208": "public class OrientVertex { \n@ Override public void remove ( ) { \ncheckClass ( ) ; \nfinal OrientBaseGraph graph = checkIfAttached ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nfinal ODocument doc = getRecord ( ) ; \nif ( doc == null ) throw ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; \nMap < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; \nif ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) { \nfor ( String fieldName : doc . fieldNames ( ) ) { \nfinal OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; \nif ( connection == null ) continue ; \nObject fv = doc . field ( fieldName ) ; \nif ( fv instanceof ORidBag && ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { \nList < ODocument > docs = new ArrayList < ODocument > ( ) ; \nfor ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; \ntreeRidbagEdgesToRemove . put ( fieldName , docs ) ; \n} \n} \n} \nsuper . removeRecord ( ) ; \nfinal Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; \nif ( it . hasNext ( ) ) { \nfinal Set < Edge > allEdges = new HashSet < Edge > ( ) ; \nfor ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nfinal Index < ? extends Element > index = it . next ( ) ; \nif ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; \nidx . removeElement ( this ) ; \n} \nif ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; \nfor ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { \ndoc . removeField ( entry . getKey ( ) ) ; \nIterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nODocument docEdge = iter . next ( ) ; \nOrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; \n} \n} \ngraph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; \n} \n} \n"}
{"3213": "public class ODatabaseImport { \nprivate void processBrokenRids ( Set < ORID > brokenRids ) throws IOException , ParseException { \nif ( exporterVersion >= 12 ) { \nlistener . onMessage ( \"Reading of set of RIDs of records which were detected as broken during database export\\n\" ) ; \njsonReader . readNext ( OJSONReader . BEGIN_COLLECTION ) ; \nfor ( ; \ntrue ; \n) { \njsonReader . readNext ( OJSONReader . NEXT_IN_ARRAY ) ; \nfinal ORecordId recordId = new ORecordId ( jsonReader . getValue ( ) ) ; \nbrokenRids . add ( recordId ) ; \nif ( jsonReader . lastChar ( ) == ']' ) break ; \n} \n} \nif ( migrateLinks ) { \nif ( exporterVersion >= 12 ) listener . onMessage ( brokenRids . size ( ) + \" were detected as broken during database export, links on those records will be removed from\" + \" result database\" ) ; \nmigrateLinksInImportedDocuments ( brokenRids ) ; \n} \n} \n} \n"}
{"3214": "public class OConsoleApplication { \nprotected Map < Method , Object > getConsoleMethods ( ) { \nif ( methods != null ) return methods ; \nfinal Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; \nfinal Collection < Object > candidates = new ArrayList < Object > ( ) ; \ncandidates . add ( this ) ; \nfor ( ; \nite . hasNext ( ) ; \n) { \ntry { \nfinal OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; \ncc . setContext ( this ) ; \ncandidates . add ( cc ) ; \n} \ncatch ( InstantiationException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \n} \nmethods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { \npublic int compare ( Method o1 , Method o2 ) { \nfinal ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; \nfinal ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; \nif ( ann1 != null && ann2 != null ) { \nif ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; \n} \nint res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; \nif ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; \nreturn res ; \n} \n} \n) ; \nfor ( final Object candidate : candidates ) { \nfinal Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; \nfor ( Method m : classMethods ) { \nif ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) { \ncontinue ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \ncontinue ; \n} \nmethods . put ( m , candidate ) ; \n} \n} \nreturn methods ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( bufpos >= tokenBegin ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nfor ( ; \ni < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ; \n) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nfor ( ; \ni ++ < len ; \n) { \nif ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; \nelse bufline [ j ] = newLine ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3241": "public class OAtomicOperationsManager { \npublic OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { \nfinal OAtomicOperation operation = currentOperation . get ( ) ; \nif ( operation == null ) { \nOLogManager . instance ( ) . error ( this , \"There is no atomic operation active\" , null ) ; \nthrow new ODatabaseException ( \"There is no atomic operation active\" ) ; \n} \nint counter = operation . getCounter ( ) ; \noperation . decrementCounter ( ) ; \nassert counter > 0 ; \nfinal OLogSequenceNumber lsn ; \ntry { \nif ( rollback ) { \noperation . rollback ( ) ; \n} \nif ( counter == 1 ) { \ntry { \nfinal boolean useWal = useWal ( ) ; \nif ( ! operation . isRollback ( ) ) { \nlsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; \n} \nelse { \nlsn = null ; \n} \nif ( trackAtomicOperations ) { \nactiveAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; \n} \n} \nfinally { \nfinal Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; \nfor ( ; \nlockedObjectIterator . hasNext ( ) ; \n) { \nfinal String lockedObject = lockedObjectIterator . next ( ) ; \nlockedObjectIterator . remove ( ) ; \nlockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \n} \ncurrentOperation . set ( null ) ; \n} \n} \nelse { \nlsn = null ; \n} \n} \ncatch ( Error e ) { \nfinal OAbstractPaginatedStorage st = storage ; \nif ( st != null ) { \nst . handleJVMError ( e ) ; \n} \ncounter = 1 ; \nthrow e ; \n} \nfinally { \nif ( counter == 1 ) { \natomicOperationsCount . decrement ( ) ; \n} \n} \nreturn lsn ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \ni < READ_BUFFER_SIZE ; \ni ++ ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nfor ( ; \nlruList . poll ( ) != null ; \n) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nfor ( ; \ntrue ; \n) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse if ( holds < 0 ) { \nreturn true ; \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nfor ( ; \nwNode . locked ; \n) { \ndistributedCounter . decrement ( ) ; \nfor ( ; \nwNode . locked && wNode == tail . get ( ) ; \n) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \nreturn false ; \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \ni < parallel - 1 ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nfor ( ; \nrunningThreads . get ( ) > 0 ; \n) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { \nreturn false ; \n} \nparserSkipWhiteSpaces ( ) ; \nint start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nint end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nint position = parserGetCurrentPosition ( ) ; \nfor ( ; \n! parserIsEnded ( ) ; \n) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { \nbreak ; \n} \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( end < 0 ) { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \n} \nelse { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \n} \nrequest . setFetchPlan ( fetchPlan ) ; \nreturn true ; \n} \n} \n"}
{"3321": "public class OAbstractPaginatedStorage { \n@ Override public final Object command ( final OCommandRequestText iCommand ) { \ntry { \nfor ( ; \ntrue ; \n) { \ntry { \nfinal OCommandExecutor executor = OCommandManager . instance ( ) . getExecutor ( iCommand ) ; \nexecutor . setContext ( iCommand . getContext ( ) ) ; \nexecutor . setProgressListener ( iCommand . getProgressListener ( ) ) ; \nexecutor . parse ( iCommand ) ; \nreturn executeCommand ( iCommand , executor ) ; \n} \ncatch ( final ORetryQueryException ignore ) { \nif ( iCommand instanceof OQueryAbstract ) { \nfinal OQueryAbstract query = ( OQueryAbstract ) iCommand ; \nquery . reset ( ) ; \n} \n} \n} \n} \ncatch ( final RuntimeException ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Error ee ) { \nthrow logAndPrepareForRethrow ( ee , false ) ; \n} \ncatch ( final Throwable t ) { \nthrow logAndPrepareForRethrow ( t ) ; \n} \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nint currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nfor ( ; \npos >= ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) ; \n) currentChunkIndex ++ ; \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize -= currentChunk . length ; \nint relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nint len ; \nfor ( ; \ntoSkip > 0 ; \n) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( len > 0 ) toSkip -= len ; \nelse break ; \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nfor ( ; \ntoSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ; \n) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \nelse toSkip -= result ; \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3376": "public class SegmentedByteArray { \npublic int copy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nfor ( ; \nlength > 0 ; \n) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \nSystem . arraycopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nint segmentLength = 1 << log2OfSegmentSize ; \nint currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nint segmentStartPos = ( int ) ( destPos & bitmask ) ; \nint remainingBytesInSegment = segmentLength - segmentStartPos ; \nfor ( ; \nlength > 0 ; \n) { \nint bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nint copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos += copiedBytes ; \nlength -= copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment ++ ; \n} \n} \n} \n"}
{"3379": "public class SegmentedByteArray { \npublic int orderedCopy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nfor ( ; \nlength > 0 ; \n) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \norderedCopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nfor ( ; \nlength > 0 ; \n) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nfor ( ; \nbytesCopied < bytesToCopy ; \n) { \nbytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \n} \n} \n"}
{"3381": "public class SegmentedByteArray { \npublic void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nlong remainingBytesInCopy = len ; \nfor ( ; \nremainingBytesInCopy > 0 ; \n) { \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; \nos . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; \nstartPosition += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nremainingBytesInCopy -= bytesToCopyFromSegment ; \n} \n} \n} \n"}
{"3382": "public class SegmentedByteArray { \nprivate void ensureCapacity ( int segmentIndex ) { \nfor ( ; \nsegmentIndex >= segments . length ; \n) { \nsegments = Arrays . copyOf ( segments , segments . length * 3 / 2 ) ; \n} \nif ( segments [ segmentIndex ] == null ) { \nsegments [ segmentIndex ] = memoryRecycler . getByteArray ( ) ; \n} \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( int i = 0 ; \ni < elementArray . numLists ( ) ; \ni ++ ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; \nfor ( int j = 0 ; \nj < predictedBuckets ; \nj ++ ) selectArray [ j ] = - 1 ; \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nfor ( ; \nselectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ; \n) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nfor ( ; \ntrue ; \n) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) maxSize = setSize ; \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3394": "public class HollowPrefixIndex { \nprivate void initialize ( ) { \nString lastRefType = this . fieldPath . getLastRefTypeInPath ( ) ; \ntotalWords = readStateEngine . getTypeState ( lastRefType ) . getPopulatedOrdinals ( ) . cardinality ( ) ; \naverageWordLen = 0 ; \ndouble avg = 0 ; \nHollowObjectTypeReadState objectTypeReadState = ( HollowObjectTypeReadState ) readStateEngine . getTypeState ( lastRefType ) ; \nBitSet keyBitSet = objectTypeReadState . getPopulatedOrdinals ( ) ; \nint ordinal = keyBitSet . nextSetBit ( 0 ) ; \nfor ( ; \nordinal != - 1 ; \n) { \navg += ( ( double ) objectTypeReadState . readString ( ordinal , 0 ) . length ( ) ) / ( ( double ) objectTypeReadState . maxOrdinal ( ) ) ; \nordinal = keyBitSet . nextSetBit ( ordinal + 1 ) ; \n} \naverageWordLen = ( int ) Math . ceil ( avg ) ; \nHollowObjectTypeReadState valueState = ( HollowObjectTypeReadState ) readStateEngine . getTypeDataAccess ( type ) ; \nmaxOrdinalOfType = valueState . maxOrdinal ( ) ; \nbuild ( ) ; \n} \n} \n"}
{"3398": "public class HollowSchemaSorter { \npublic static List < HollowSchema > dependencyOrderedSchemaList ( Collection < HollowSchema > schemas ) { \nDependencyIndex idx = new DependencyIndex ( ) ; \nMap < String , HollowSchema > schemaMap = new HashMap < String , HollowSchema > ( ) ; \nfor ( HollowSchema schema : schemas ) { \nschemaMap . put ( schema . getName ( ) , schema ) ; \nidx . indexSchema ( schema , schemas ) ; \n} \nList < HollowSchema > orderedSchemas = new ArrayList < HollowSchema > ( ) ; \nfor ( ; \nidx . hasMoreTypes ( ) ; \n) orderedSchemas . add ( schemaMap . get ( idx . getNextType ( ) ) ) ; \nreturn orderedSchemas ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nint hashCode = 0 ; \nfor ( int i = 0 ; \ni < query . length ; \ni ++ ) { \nif ( query [ i ] == null ) throw new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nfor ( ; \n! bucketIsEmpty ; \n) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nint selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3444": "public class VarInt { \npublic static int readVInt ( InputStream in ) throws IOException { \nbyte b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) throw new RuntimeException ( \"Attempting to read null value as int\" ) ; \nint value = b & 0x7F ; \nfor ( ; \n( b & 0x80 ) != 0 ; \n) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3445": "public class VarInt { \npublic static long readVLong ( InputStream in ) throws IOException { \nbyte b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) throw new RuntimeException ( \"Attempting to read null value as long\" ) ; \nlong value = b & 0x7F ; \nfor ( ; \n( b & 0x80 ) != 0 ; \n) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3507": "public class IoUtil { \npublic static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { \nlog . progressStart ( ) ; \ntry { \nOkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; \nRequest request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; \nResponse response = client . newCall ( request ) . execute ( ) ; \ntry ( OutputStream out = new FileOutputStream ( target ) ; \nInputStream im = response . body ( ) . byteStream ( ) ) { \nlong length = response . body ( ) . contentLength ( ) ; \nInputStream in = response . body ( ) . byteStream ( ) ; \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong readBytes = 0 ; \nfor ( ; \ntrue ; \n) { \nint len = in . read ( buffer ) ; \nreadBytes += len ; \nlog . progressUpdate ( target . getName ( ) , \"Downloading\" , getProgressBar ( readBytes , length ) ) ; \nif ( len <= 0 ) { \nout . flush ( ) ; \nbreak ; \n} \nout . write ( buffer , 0 , len ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Failed to download URL \" + downloadUrl + \" to  \" + target + \": \" + e , e ) ; \n} \nfinally { \nlog . progressFinished ( ) ; \n} \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) { \nreturn null ; \n} \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) { \nreturn null ; \n} \nint unitPos = 1 ; \nfor ( ; \nunitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ; \n) { \nunitPos ++ ; \n} \nif ( unitPos >= duration . length ( ) ) { \nthrow new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \n} \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \nfor ( int i = 0 ; \ni < TIME_UNITS . length ; \ni ++ ) { \nif ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \n} \nif ( multiplier == null ) { \nthrow new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \n} \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) { \nvalue = value . add ( remainingValue ) ; \n} \nreturn value ; \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! isOnline ( ) ) { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \nelse { \ntry { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) { \nns = getNamespace ( ) ; \n} \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nboolean notFound = false ; \nboolean connectError = false ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nfor ( ; \n! stack . isEmpty ( ) ; \n) { \nThrowable t = stack . pop ( ) ; \nif ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse if ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"3591": "public class OpenKoreanTextProcessorJava { \npublic static List < String > tokensToJavaStringList ( Seq < KoreanToken > tokens , boolean keepSpace ) { \nIterator < KoreanToken > tokenized = tokens . iterator ( ) ; \nList < String > output = new LinkedList < > ( ) ; \nfor ( ; \ntokenized . hasNext ( ) ; \n) { \nfinal KoreanToken token = tokenized . next ( ) ; \nif ( keepSpace || token . pos ( ) != KoreanPos . Space ( ) ) { \noutput . add ( token . text ( ) ) ; \n} \n} \nreturn output ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nfor ( ; \nsumFix < precNum ; \n) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nfor ( ; \nbuf . hasRemaining ( ) ; \n) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3605": "public class QTTimeUtil { \npublic static long frameToTimevalue ( TrakBox trak , int frameNumber ) { \nTimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) ; \nTimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; \nlong pts = 0 ; \nint sttsInd = 0 , sttsSubInd = frameNumber ; \nfor ( ; \nsttsSubInd >= timeToSamples [ sttsInd ] . getSampleCount ( ) ; \n) { \nsttsSubInd -= timeToSamples [ sttsInd ] . getSampleCount ( ) ; \npts += timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; \nsttsInd ++ ; \n} \nreturn pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( range < 0x8000 ) { \nfor ( ; \nrange < 0x8000 ; \n) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nfor ( ; \nrange < 0x8000 ; \n) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) return 1 ; \nint length = 8 ; \nfor ( ; \nlength > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ; \n) length -- ; \nreturn length ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni ++ ) { \nfor ( ; \nreadBuf . hasRemaining ( ) ; \n) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \nreturn false ; \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) return null ; \nint from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nint val = 0xffffffff ; \nfor ( ; \nbuf . hasRemaining ( ) ; \n) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( val >= mmin && val <= mmax ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \n-- n ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nfor ( ; \ninb . remaining ( ) >= bytesPerFrame ; \n) { \nfor ( int j = 0 ; \nj < outs . length ; \nj ++ ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \nouts [ j ] . put ( inb . get ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal int slot = mNextAvailableReferenceSlot ++ ; \nif ( slot < mMaxValidReference ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \nreturn true ; \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nfor ( ; \n! mSpinLock . compareAndSet ( false , true ) ; \n) ; \n} \ntry { \nint slot = mNextAvailableReferenceSlot ++ ; \nif ( slot >= mMaxValidReference ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot ++ ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3665": "public class JNIMemoryManager { \nvoid gcInternal ( ) { \nJNIReference ref = null ; \nfor ( ; \n( ref = ( JNIReference ) mRefQueue . poll ( ) ) != null ; \n) { \nref . delete ( ) ; \n} \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nfor ( ; \nc . hasMoreElements ( ) ; \n) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nfor ( ; \n( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ; \n) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( ; \ndemuxer . read ( packet ) >= 0 ; \n) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3677": "public class DecodeAndPlayVideo { \nprivate static BufferedImage displayVideoAtCorrectTime ( long streamStartTime , final MediaPicture picture , final MediaPictureConverter converter , BufferedImage image , final ImageFrame window , long systemStartTime , final Rational systemTimeBase , final Rational streamTimebase ) throws InterruptedException { \nlong streamTimestamp = picture . getTimeStamp ( ) ; \nstreamTimestamp = systemTimeBase . rescale ( streamTimestamp - streamStartTime , streamTimebase ) ; \nlong systemTimestamp = System . nanoTime ( ) ; \nfor ( ; \nstreamTimestamp > ( systemTimestamp - systemStartTime + 1000000 ) ; \n) { \nThread . sleep ( 1 ) ; \nsystemTimestamp = System . nanoTime ( ) ; \n} \nimage = converter . toImage ( image , picture ) ; \nwindow . setImage ( image ) ; \nreturn image ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( ; \ndemuxer . read ( packet ) >= 0 ; \n) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( int i = 0 ; \ni < input . length ( ) ; \n++ i ) { \nchar c = input . charAt ( i ) ; \nint digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n} \nint zeros = 0 ; \nfor ( ; \nzeros < input58 . length && input58 [ zeros ] == 0 ; \n) { \n++ zeros ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \nfor ( int inputStart = zeros ; \ninputStart < input58 . length ; \n) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \n++ inputStart ; \n} \n} \nfor ( ; \noutputStart < decoded . length && decoded [ outputStart ] == 0 ; \n) { \n++ outputStart ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3741": "public class FSTConfiguration { \npublic void clearCaches ( ) { \ntry { \nFSTInputStream . cachedBuffer . set ( null ) ; \nfor ( ; \n! cacheLock . compareAndSet ( false , true ) ; \n) { \n} \ncachedObjects . clear ( ) ; \n} \nfinally { \ncacheLock . set ( false ) ; \n} \n} \n} \n"}
{"3765": "public class BinaryQueue { \npublic byte [ ] readByteArray ( int len ) { \nif ( available ( ) < len ) { \nthrow new RuntimeException ( \"not enough data available, check available() > len before calling\" ) ; \n} \nbyte b [ ] = new byte [ len ] ; \nint count = 0 ; \nfor ( ; \npollIndex != addIndex && count < len ; \n) { \nb [ count ++ ] = storage . get ( pollIndex ++ ) ; \nif ( pollIndex >= storage . length ( ) ) { \npollIndex = 0 ; \n} \n} \nreturn b ; \n} \n} \n"}
{"3789": "public class MathUtils { \npublic static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { \nint count = 0 ; \nList < List < Double > > ret = new ArrayList < List < Double > > ( ) ; \nfor ( ; \ncount < arr . size ( ) ; \n) { \nList < Double > sublist = arr . subList ( count , count + chunk ) ; \ncount += chunk ; \nret . add ( sublist ) ; \n} \nfor ( List < Double > lists : ret ) { \nif ( lists . size ( ) < chunk ) ret . remove ( lists ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \nfor ( int i = 0 ; \ni < numSamples ; \ni ++ ) { \nint picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) for ( ; \nadded . contains ( picked ) ; \n) picked = rng . nextInt ( numExamples ( ) ) ; \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3821": "public class StringUtils { \npublic static String [ ] split ( String str , char escapeChar , char separator ) { \nif ( str == null ) { \nreturn null ; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nStringBuilder split = new StringBuilder ( ) ; \nint index = 0 ; \nfor ( ; \n( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ; \n) { \n++ index ; \nstrList . add ( split . toString ( ) ) ; \nsplit . setLength ( 0 ) ; \n} \nstrList . add ( split . toString ( ) ) ; \nint last = strList . size ( ) ; \nfor ( ; \n-- last >= 0 && \"\" . equals ( strList . get ( last ) ) ; \n) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3822": "public class StringUtils { \npublic static String [ ] split ( String str , char separator ) { \nif ( str . isEmpty ( ) ) { \nreturn new String [ ] { \n\"\" } \n; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nint startIndex = 0 ; \nint nextIndex = 0 ; \nfor ( ; \n( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ; \n) { \nstrList . add ( str . substring ( startIndex , nextIndex ) ) ; \nstartIndex = nextIndex + 1 ; \n} \nstrList . add ( str . substring ( startIndex ) ) ; \nint last = strList . size ( ) ; \nfor ( ; \n-- last >= 0 && \"\" . equals ( strList . get ( last ) ) ; \n) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3825": "public class StringUtils { \npublic static String join ( CharSequence separator , Iterable < ? > strings ) { \nIterator < ? > i = strings . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nreturn \"\" ; \n} \nStringBuilder sb = new StringBuilder ( i . next ( ) . toString ( ) ) ; \nfor ( ; \ni . hasNext ( ) ; \n) { \nsb . append ( separator ) ; \nsb . append ( i . next ( ) . toString ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3827": "public class StringUtils { \npublic static String replaceTokens ( String template , Pattern pattern , Map < String , String > replacements ) { \nStringBuffer sb = new StringBuffer ( ) ; \nMatcher matcher = pattern . matcher ( template ) ; \nfor ( ; \nmatcher . find ( ) ; \n) { \nString replacement = replacements . get ( matcher . group ( 1 ) ) ; \nif ( replacement == null ) { \nreplacement = \"\" ; \n} \nmatcher . appendReplacement ( sb , Matcher . quoteReplacement ( replacement ) ) ; \n} \nmatcher . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3830": "public class Factorial { \npublic BigInteger at ( int n ) { \nfor ( ; \na . size ( ) <= n ; \n) { \nfinal int lastn = a . size ( ) - 1 ; \nfinal BigInteger nextn = BigInteger . valueOf ( lastn + 1 ) ; \na . add ( a . get ( lastn ) . multiply ( nextn ) ) ; \n} \nreturn a . get ( n ) ; \n} \n} \n"}
{"3858": "public class Paths { \npublic static boolean nameExistsInPath ( String name ) { \nString path = System . getenv ( PATH_ENV_VARIABLE ) ; \nString [ ] dirs = path . split ( File . pathSeparator ) ; \nfor ( String dir : dirs ) { \nFile dirFile = new File ( dir ) ; \nif ( ! dirFile . exists ( ) ) continue ; \nif ( dirFile . isFile ( ) && dirFile . getName ( ) . equals ( name ) ) return true ; \nelse { \nIterator < File > files = FileUtils . iterateFiles ( dirFile , null , false ) ; \nfor ( ; \nfiles . hasNext ( ) ; \n) { \nFile curr = files . next ( ) ; \nif ( curr . getName ( ) . equals ( name ) ) return true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nfor ( ; \nexSc > 0 ; \n) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nfor ( ; \nexsub -- > 0 ; \n) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3954": "public class AtomicState { \npublic void requestTick ( long time , TimeUnit timeUnit ) { \nlong timeframeMs = TimeUnit . MILLISECONDS . convert ( time , timeUnit ) ; \nlong currentTime = System . currentTimeMillis ( ) ; \nboolean isWaiting = false ; \ntry { \nfor ( ; \nisToeScheduled . get ( ) || isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ; \n) { \nif ( ! isWaiting ) { \nisWaiting = true ; \nwaitingTicks . incrementAndGet ( ) ; \n} \nThread . sleep ( 50 ) ; \n} \ncurrentState . set ( AccessState . TICK . ordinal ( ) ) ; \nwaitingTicks . decrementAndGet ( ) ; \ntickRequests . incrementAndGet ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nint addPrecision = this . precision ; \nfor ( ; \naddPrecision > 0 ; \n) { \nthis . scientificFormat += \"#\" ; \naddPrecision -= 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . scientificFormat . length ( ) + 2 > this . padding ) this . padding = this . scientificFormat . length ( ) + 2 ; \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize && arr . length ( ) > 1000 ) return format ( arr , 0 , true ) ; \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"4013": "public class HybridQueryResults { \nprivate Iterator < ResultWithCursor < T > > load ( final Iterator < ResultWithCursor < Key < T > > > keys ) { \nfinal List < Entry < ResultWithCursor < Key < T > > , Result < T > > > results = Lists . newArrayList ( ) ; \nfor ( ; \nkeys . hasNext ( ) ; \n) { \nfinal ResultWithCursor < Key < T > > next = keys . next ( ) ; \nresults . add ( Maps . immutableEntry ( next , loadEngine . load ( next . getResult ( ) ) ) ) ; \n} \nloadEngine . execute ( ) ; \nreturn Iterators . transform ( results . iterator ( ) , entry -> new ResultWithCursor < > ( entry . getValue ( ) . now ( ) , entry . getKey ( ) . getCursorAfter ( ) ) ) ; \n} \n} \n"}
{"4014": "public class LogUtils { \npublic static String msg ( Path path , String msg ) { \nStringBuilder bld = new StringBuilder ( ) ; \nbld . append ( \"\\t.\" ) ; \nbld . append ( path . toPathString ( ) ) ; \nif ( bld . length ( ) < PATH_PADDING ) for ( ; \nbld . length ( ) < PATH_PADDING ; \n) bld . append ( ' ' ) ; \nelse bld . append ( '\\t' ) ; \nbld . append ( msg ) ; \nreturn bld . toString ( ) ; \n} \n} \n"}
{"4038": "public class ForwardPath { \npublic Path getFinalPath ( ) { \nForwardPath here = this ; \nfor ( ; \nhere . next != null ; \n) here = here . next ; \nreturn here . getPath ( ) ; \n} \n} \n"}
{"4040": "public class Path { \npublic int depth ( ) { \nint depth = 0 ; \nPath here = this ; \nfor ( ; \nhere != ROOT ; \n) { \ndepth ++ ; \nhere = here . previous ; \n} \nreturn depth ; \n} \n} \n"}
{"4080": "public class LoadContext { \npublic void done ( ) { \nengine . execute ( ) ; \nfor ( ; \ndeferred != null ; \n) { \nfinal List < Runnable > runme = deferred ; \ndeferred = null ; \nfor ( final Runnable run : runme ) { \nlog . trace ( \"Executing {}\" , run ) ; \nrun . run ( ) ; \n} \n} \n} \n} \n"}
{"4081": "public class LoadContext { \npublic Object getContainer ( Type containerType , Path path ) { \nClass < ? > containerClass = GenericTypeReflector . erase ( containerType ) ; \nIterator < Object > containersIt = containers . descendingIterator ( ) ; \ncontainersIt . next ( ) ; \nfor ( ; \ncontainersIt . hasNext ( ) ; \n) { \nObject potentialContainer = containersIt . next ( ) ; \nif ( containerClass . isAssignableFrom ( potentialContainer . getClass ( ) ) ) return potentialContainer ; \n} \nthrow new IllegalStateException ( \"No container matching \" + containerType + \" in \" + containers + \" at path \" + path ) ; \n} \n} \n"}
{"4095": "public class SnippetProcessor { \npublic String process ( SnippetProcessorContext ctx , String snippet ) { \ncheckNotNull ( ctx ) ; \nStringBuilder sb = ctx . builder ( ) ; \nsb . setLength ( 0 ) ; \nString currSnippet = snippet ; \nboolean processedMacros = false ; \nint snippetPos = 0 ; \nint macroPos = currSnippet . indexOf ( \"${\" ) ; \nfor ( ; \nmacroPos != - 1 ; \n) { \nsb . append ( currSnippet . substring ( snippetPos , macroPos ) ) ; \nint macroEnd = processMacroAt ( ctx , currSnippet , macroPos ) ; \nif ( macroEnd == - 1 ) { \nsb . append ( \"${\" ) ; \nsnippetPos = macroPos + 2 ; \n} \nelse { \nsnippetPos = macroEnd ; \nprocessedMacros = true ; \n} \nmacroPos = currSnippet . indexOf ( \"${\" , snippetPos ) ; \n} \nif ( processedMacros ) { \nsb . append ( currSnippet , snippetPos , currSnippet . length ( ) ) ; \ncurrSnippet = sb . toString ( ) ; \n} \nsb . setLength ( 0 ) ; \nString ret = urlEncode ( ctx , currSnippet ) ; \nsb . setLength ( 0 ) ; \nreturn ret ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \n++ i ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nfor ( ; \nunfiltered . hasNext ( ) ; \n) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4101": "public class AbstractOpenRtbJsonReader { \nprotected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { \n@ SuppressWarnings ( \"unchecked\" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; \nif ( extReaders . isEmpty ( ) ) { \npar . skipChildren ( ) ; \nreturn ; \n} \nstartObject ( par ) ; \nJsonToken tokLast = par . getCurrentToken ( ) ; \nJsonLocation locLast = par . getCurrentLocation ( ) ; \nfor ( ; \ntrue ; \n) { \nboolean extRead = false ; \nfor ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { \nif ( extReader . filter ( par ) ) { \nextReader . read ( msg , par ) ; \nJsonToken tokNew = par . getCurrentToken ( ) ; \nJsonLocation locNew = par . getCurrentLocation ( ) ; \nboolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; \nextRead |= advanced ; \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nelse if ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) { \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \nelse { \ntokLast = tokNew ; \nlocLast = locNew ; \n} \n} \n} \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nif ( ! extRead ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Extension field not consumed by any reader, skipping: {} @{}:{}\" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; \n} \npar . nextToken ( ) ; \npar . skipChildren ( ) ; \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \n} \n} \n} \n"}
{"4126": "public class WARCRecordFormat { \npublic static byte [ ] generateWARCInfo ( Map < String , String > fields ) { \nStringBuffer buffer = new StringBuffer ( ) ; \nbuffer . append ( WARC_VERSION ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( \"WARC-Type: warcinfo\" ) . append ( CRLF ) ; \nString mainID = UUID . randomUUID ( ) . toString ( ) ; \nString date = fields . get ( \"WARC-Date\" ) ; \nbuffer . append ( \"WARC-Date: \" ) . append ( date ) . append ( CRLF ) ; \nString filename = fields . get ( \"WARC-Filename\" ) ; \nbuffer . append ( \"WARC-Filename: \" ) . append ( filename ) . append ( CRLF ) ; \nbuffer . append ( \"WARC-Record-ID\" ) . append ( \": \" ) . append ( \"<urn:uuid:\" ) . append ( mainID ) . append ( \">\" ) . append ( CRLF ) ; \nbuffer . append ( \"Content-Type\" ) . append ( \": \" ) . append ( \"application/warc-fields\" ) . append ( CRLF ) ; \nStringBuilder fieldsBuffer = new StringBuilder ( ) ; \nIterator < Entry < String , String > > iter = fields . entrySet ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nEntry < String , String > entry = iter . next ( ) ; \nString key = entry . getKey ( ) ; \nif ( key . startsWith ( \"WARC-\" ) ) continue ; \nfieldsBuffer . append ( key ) . append ( \": \" ) . append ( entry . getValue ( ) ) . append ( CRLF ) ; \n} \nbuffer . append ( \"Content-Length\" ) . append ( \": \" ) . append ( fieldsBuffer . toString ( ) . getBytes ( StandardCharsets . UTF_8 ) . length ) . append ( CRLF ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( fieldsBuffer . toString ( ) ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( CRLF ) ; \nreturn buffer . toString ( ) . getBytes ( StandardCharsets . UTF_8 ) ; \n} \n} \n"}
{"4145": "public class RegexURLNormalizer { \n@ Override public String filter ( URL sourceUrl , Metadata sourceMetadata , String urlString ) { \nIterator < Rule > i = rules . iterator ( ) ; \nfor ( ; \ni . hasNext ( ) ; \n) { \nRule r = i . next ( ) ; \nMatcher matcher = r . pattern . matcher ( urlString ) ; \nurlString = matcher . replaceAll ( r . substitution ) ; \n} \nif ( urlString . equals ( \"\" ) ) { \nurlString = null ; \n} \nreturn urlString ; \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) { \nquery = params ; \n} \nelse { \nquery += \"&\" + params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nfor ( ; \npairsIterator . hasNext ( ) ; \n) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) { \npairsIterator . remove ( ) ; \n} \nelse if ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4175": "public class ArrayChar { \n@ Override public ByteBuffer getDataAsByteBuffer ( ) { \nByteBuffer bb = ByteBuffer . allocate ( ( int ) getSize ( ) ) ; \nresetLocalIterator ( ) ; \nfor ( ; \nhasNext ( ) ; \n) bb . put ( nextByte ( ) ) ; \nreturn bb ; \n} \n} \n"}
{"4177": "public class ArrayChar { \npublic ArrayObject make1DStringArray ( ) { \nint nelems = ( getRank ( ) == 0 ) ? 1 : ( int ) getSize ( ) / indexCalc . getShape ( getRank ( ) - 1 ) ; \nArray sarr = Array . factory ( DataType . STRING , new int [ ] { \nnelems } \n) ; \nIndexIterator newsiter = sarr . getIndexIterator ( ) ; \nArrayChar . StringIterator siter = getStringIterator ( ) ; \nfor ( ; \nsiter . hasNext ( ) ; \n) { \nnewsiter . setObjectNext ( siter . next ( ) ) ; \n} \nreturn ( ArrayObject ) sarr ; \n} \n} \n"}
{"4179": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values ) { \nIndexIterator ii = values . getIndexIterator ( ) ; \nint strlen = 0 ; \nfor ( ; \nii . hasNext ( ) ; \n) { \nString s = ( String ) ii . next ( ) ; \nstrlen = Math . max ( s . length ( ) , strlen ) ; \n} \nreturn makeFromStringArray ( values , strlen ) ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nfor ( ; \nii . hasNext ( ) ; \n) { \nString s = ( String ) ii . next ( ) ; \nfor ( int k = 0 ; \nk < s . length ( ) && k < strlen ; \nk ++ ) cdata [ start + k ] = s . charAt ( k ) ; \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4185": "public class Grib1RecordScanner { \npublic static void main ( String [ ] args ) throws IOException { \nint count = 0 ; \nString file = ( args . length > 0 ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1\" ; \nRandomAccessFile raf = new RandomAccessFile ( file , \"r\" ) ; \nSystem . out . printf ( \"Read %s%n\" , raf . getLocation ( ) ) ; \nGrib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; \nfor ( ; \nscan . hasNext ( ) ; \n) { \nscan . next ( ) ; \ncount ++ ; \n} \nraf . close ( ) ; \nSystem . out . printf ( \"count=%d%n\" , count ) ; \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nfor ( ; \nsb . length ( ) > 0 ; \n) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \nfor ( int pos = 1 ; \npos < sb . length ( ) ; \n++ pos ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n} \nfor ( ; \nsb . length ( ) > 0 ; \n) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nfor ( ; \n( maxLines < 0 ) || ( count < maxLines ) ; \n) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4325": "public class SigmetIOServiceProvider { \npublic Array readIntData ( LayoutRegular index , Variable v2 ) throws IOException { \nint [ ] var = ( int [ ] ) ( v2 . read ( ) . get1DJavaArray ( v2 . getDataType ( ) ) ) ; \nint [ ] data = new int [ ( int ) index . getTotalNelems ( ) ] ; \nfor ( ; \nindex . hasNext ( ) ; \n) { \nLayout . Chunk chunk = index . next ( ) ; \nSystem . arraycopy ( var , ( int ) chunk . getSrcPos ( ) / 4 , data , ( int ) chunk . getDestElem ( ) , chunk . getNelems ( ) ) ; \n} \nreturn Array . factory ( v2 . getDataType ( ) , new int [ ] { \n( int ) index . getTotalNelems ( ) } \n, data ) ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \nSystem . out . println ( \"COUNT=\" + count ) ; \nif ( buffer . hasRemaining ( ) ) { \nbuffer . compact ( ) ; \n} \nelse { \nbuffer . clear ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4359": "public class DodsURLExtractor { \nprivate InputStream filterTag ( InputStream in ) throws IOException { \nBufferedReader buffIn = new BufferedReader ( new InputStreamReader ( in , CDM . UTF8 ) ) ; \nByteArrayOutputStream bos = new ByteArrayOutputStream ( 10000 ) ; \nString line = buffIn . readLine ( ) ; \nfor ( ; \nline != null ; \n) { \nString lline = line . toLowerCase ( ) ; \nif ( lline . contains ( \"<meta \" ) ) continue ; \nbos . write ( line . getBytes ( CDM . utf8Charset ) ) ; \nline = buffIn . readLine ( ) ; \n} \nbuffIn . close ( ) ; \nreturn new ByteArrayInputStream ( bos . toByteArray ( ) ) ; \n} \n} \n"}
{"4395": "public class AWIPSConvention { \nprivate List < Dimension > breakupLevels ( NetcdfDataset ds , Variable levelVar ) throws IOException { \nif ( debugBreakup ) parseInfo . format ( \"breakupLevels = %s%n\" , levelVar . getShortName ( ) ) ; \nList < Dimension > dimList = new ArrayList < > ( ) ; \nArrayChar levelVarData ; \ntry { \nlevelVarData = ( ArrayChar ) levelVar . read ( ) ; \n} \ncatch ( IOException ioe ) { \nreturn dimList ; \n} \nList < String > values = null ; \nString currentUnits = null ; \nArrayChar . StringIterator iter = levelVarData . getStringIterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nString s = iter . next ( ) ; \nif ( debugBreakup ) parseInfo . format ( \"   %s%n\" , s ) ; \nStringTokenizer stoke = new StringTokenizer ( s ) ; \nif ( ! stoke . hasMoreTokens ( ) ) continue ; \nString units = stoke . nextToken ( ) . trim ( ) ; \nif ( ! units . equals ( currentUnits ) ) { \nif ( values != null ) dimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \nvalues = new ArrayList < > ( ) ; \ncurrentUnits = units ; \n} \nif ( stoke . hasMoreTokens ( ) ) values . add ( stoke . nextToken ( ) ) ; \nelse values . add ( \"0\" ) ; \n} \nif ( values != null ) dimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \nif ( debugBreakup ) parseInfo . format ( \"  done breakup%n\" ) ; \nreturn dimList ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( len > 1 ) name = name + Integer . toString ( len ) ; \nelse name = name + values . get ( 0 ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nint count = 1 ; \nfor ( ; \nds . getRootGroup ( ) . findDimension ( name ) != null ; \n) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4398": "public class AWIPSConvention { \nprivate CoordinateAxis makeTimeCoordAxisFromReference ( NetcdfDataset ds , Variable timeVar , Array vals ) { \nVariable refVar = ds . findVariable ( \"reftime\" ) ; \nif ( refVar == null ) return null ; \ndouble refValue ; \ntry { \nArray refArray = refVar . read ( ) ; \nrefValue = refArray . getDouble ( refArray . getIndex ( ) ) ; \n} \ncatch ( IOException ioe ) { \nreturn null ; \n} \nif ( refValue == N3iosp . NC_FILL_DOUBLE ) return null ; \nArray dvals = Array . factory ( DataType . DOUBLE , vals . getShape ( ) ) ; \nIndexIterator diter = dvals . getIndexIterator ( ) ; \nIndexIterator iiter = vals . getIndexIterator ( ) ; \nfor ( ; \niiter . hasNext ( ) ; \n) diter . setDoubleNext ( iiter . getDoubleNext ( ) + refValue ) ; \nString units = ds . findAttValueIgnoreCase ( refVar , CDM . UNITS , \"seconds since 1970-1-1 00:00:00\" ) ; \nunits = normalize ( units ) ; \nString desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\" ; \nCoordinateAxis1D timeCoord = new CoordinateAxis1D ( ds , null , \"timeCoord\" , DataType . DOUBLE , \"record\" , units , desc ) ; \ntimeCoord . setCachedData ( dvals , true ) ; \nparseInfo . format ( \"Created Time Coordinate Axis From Reference = \" ) ; \ntimeCoord . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn timeCoord ; \n} \n} \n"}
{"4418": "public class ThreddsMetadata { \npublic void removeDocumentation ( String type ) { \nIterator iter = docs . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nInvDocumentation doc = ( InvDocumentation ) iter . next ( ) ; \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) iter . remove ( ) ; \n} \n} \n} \n"}
{"4419": "public class LayoutSegmented { \nprivate int getMaxBytes ( long start ) { \nint segno = 0 ; \nfor ( ; \nstart >= segMax [ segno ] ; \n) segno ++ ; \nreturn ( int ) ( segMax [ segno ] - start ) ; \n} \n} \n"}
{"4422": "public class CoordSysBuilder { \nstatic public List < String > breakupConventionNames ( String convAttValue ) { \nList < String > names = new ArrayList < > ( ) ; \nif ( ( convAttValue . indexOf ( ',' ) > 0 ) || ( convAttValue . indexOf ( ';' ) > 0 ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \",;\" ) ; \nfor ( ; \nstoke . hasMoreTokens ( ) ; \n) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse if ( ( convAttValue . indexOf ( '/' ) > 0 ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \"/\" ) ; \nfor ( ; \nstoke . hasMoreTokens ( ) ; \n) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \" \" ) ; \nfor ( ; \nstoke . hasMoreTokens ( ) ; \n) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nreturn names ; \n} \n} \n"}
{"4426": "public class CoordSysBuilder { \nprotected void findCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordSys != null ) { \nStringTokenizer stoker = new StringTokenizer ( vp . coordSys ) ; \nfor ( ; \nstoker . hasMoreTokens ( ) ; \n) { \nString vname = stoker . nextToken ( ) ; \nVarProcess ap = findVarProcess ( vname , vp ) ; \nif ( ap != null ) { \nif ( ! ap . isCoordinateSystem ) parseInfo . format ( \" CoordinateSystem = %s added; referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nap . isCoordinateSystem = true ; \n} \nelse { \nparseInfo . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nuserAdvice . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return ; \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( nested . getMark ( ) ) { \niter . remove ( ) ; \nif ( debugFilter ) System . out . println ( \" remove \" + nested . getName ( ) ) ; \n} \nelse delete ( nested ) ; \n} \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) System . out . println ( \"HEY KMPMatch\" ) ; \nfor ( int i = start ; \ni < start + max ; \ni ++ ) { \nfor ( ; \nj > 0 && match [ j ] != data [ i ] ; \n) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4475": "public class PictureCache { \npublic static synchronized void reportCache ( ) { \nTools . log ( \"   PictureCache.reportCache: cache contains: \" + Integer . toString ( pictureCache . size ( ) ) + \" max: \" + Integer . toString ( maxCache ) ) ; \nEnumeration e = pictureCache . keys ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nTools . log ( \"   Cache contains: \" + ( ( String ) e . nextElement ( ) ) ) ; \n} \nTools . log ( \"  End of cache contents\" ) ; \n} \n} \n"}
{"4476": "public class PictureCache { \npublic static void stopBackgroundLoading ( ) { \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \n( ( SourcePicture ) e . nextElement ( ) ) . stopLoading ( ) ; \n} \n} \n} \n"}
{"4477": "public class PictureCache { \npublic static boolean stopBackgroundLoadingExcept ( URL exemptionURL ) { \nSourcePicture sp ; \nString exemptionURLString = exemptionURL . toString ( ) ; \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nboolean inProgress = false ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nsp = ( ( SourcePicture ) e . nextElement ( ) ) ; \nif ( ! sp . getUrlString ( ) . equals ( exemptionURLString ) ) sp . stopLoading ( ) ; \nelse { \nTools . log ( \"PictureCache.stopBackgroundLoading: picture was already loading\" ) ; \ninProgress = true ; \n} \n} \nreturn inProgress ; \n} \n} \n"}
{"4486": "public class TypedDatasetImpl { \nprotected void removeDataVariable ( String varName ) { \nIterator iter = dataVariables . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nVariableSimpleIF v = ( VariableSimpleIF ) iter . next ( ) ; \nif ( v . getShortName ( ) . equals ( varName ) ) iter . remove ( ) ; \n} \n} \n} \n"}
{"4498": "public class CatGenConfigMetadataFactory { \npublic void addMetadataContent ( org . jdom2 . Element mdataJdomElement , Object contentObject ) { \nArrayList catGenConfigList = ( ArrayList ) contentObject ; \nIterator iter = catGenConfigList . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nCatalogGenConfig cgc = ( CatalogGenConfig ) iter . next ( ) ; \nmdataJdomElement . addContent ( createCatGenConfigElement ( cgc ) ) ; \n} \n} \n} \n"}
{"4499": "public class CatGenConfigMetadataFactory { \npublic boolean validateMetadataContent ( Object contentObject , StringBuilder out ) { \nboolean ok = true ; \nArrayList catGenConfigList = ( ArrayList ) contentObject ; \nIterator iter = catGenConfigList . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nCatalogGenConfig catGenConf = ( CatalogGenConfig ) iter . next ( ) ; \nok &= catGenConf . validate ( out ) ; \n} \nreturn ok ; \n} \n} \n"}
{"4517": "public class GempakParameterTable { \nprivate byte [ ] readBytes ( InputStream is ) throws IOException { \nint totalRead = 0 ; \nbyte [ ] content = new byte [ 1000000 ] ; \nfor ( ; \ntrue ; \n) { \nint howMany = is . read ( content , totalRead , content . length - totalRead ) ; \nif ( howMany < 0 ) { \nbreak ; \n} \nif ( howMany == 0 ) { \ncontinue ; \n} \ntotalRead += howMany ; \nif ( totalRead >= content . length ) { \nbyte [ ] tmp = content ; \nint newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; \ncontent = new byte [ newLength ] ; \nSystem . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; \n} \n} \nis . close ( ) ; \nbyte [ ] results = new byte [ totalRead ] ; \nSystem . arraycopy ( content , 0 , results , 0 , totalRead ) ; \nreturn results ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) group = rootGroup ; \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nfor ( ; \nenumerate . hasMoreElements ( ) ; \n) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) name = StringUtil2 . unescape ( name ) ; \nDimension myd ; \nif ( name == null ) { \nmyd = new Dimension ( null , dad . getSize ( ) , false ) ; \n} \nelse { \nif ( RC . getUseGroups ( ) ) { \nif ( name . indexOf ( '/' ) >= 0 ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \n} \nmyd = group . findDimension ( name ) ; \nif ( myd == null ) { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \nelse if ( myd . getLength ( ) != dad . getSize ( ) ) { \nmyd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4542": "public class IospHelper { \nstatic public ucar . ma2 . Array readSection ( ParsedSectionSpec cer ) throws IOException , InvalidRangeException { \nVariable inner = null ; \nList < Range > totalRanges = new ArrayList < > ( ) ; \nParsedSectionSpec current = cer ; \nfor ( ; \ncurrent != null ; \n) { \ntotalRanges . addAll ( current . section . getRanges ( ) ) ; \ninner = current . v ; \ncurrent = current . child ; \n} \nassert inner != null ; \nSection total = new Section ( totalRanges ) ; \nArray result = Array . factory ( inner . getDataType ( ) , total . getShape ( ) ) ; \nStructure outer = ( Structure ) cer . v ; \nStructure outerSubset = outer . select ( cer . child . v . getShortName ( ) ) ; \nArrayStructure outerData = ( ArrayStructure ) outerSubset . read ( cer . section ) ; \nextractSection ( cer . child , outerData , result . getIndexIterator ( ) ) ; \nreturn result ; \n} \n} \n"}
{"4543": "public class IospHelper { \nstatic private ArrayStructure sectionArrayStructure ( ParsedSectionSpec child , ArrayStructure innerData , StructureMembers . Member m ) throws IOException , InvalidRangeException { \nStructureMembers membersw = new StructureMembers ( m . getStructureMembers ( ) ) ; \nArrayStructureW result = new ArrayStructureW ( membersw , child . section . getShape ( ) ) ; \nint count = 0 ; \nSection . Iterator iter = child . section . getIterator ( child . v . getShape ( ) ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nint recno = iter . next ( null ) ; \nStructureData sd = innerData . getStructureData ( recno ) ; \nresult . setStructureData ( sd , count ++ ) ; \n} \nreturn result ; \n} \n} \n"}
{"4550": "public class CrawlableDatasetFactory { \npublic static String normalizePath ( String path ) { \nString newPath = path . replaceAll ( \"\\\\\\\\\" , \"/\" ) ; \nfor ( ; \nnewPath . endsWith ( \"/\" ) && ! newPath . equals ( \"/\" ) ; \n) newPath = newPath . substring ( 0 , newPath . length ( ) - 1 ) ; \nreturn newPath ; \n} \n} \n"}
{"4563": "public class SortingStationPointFeatureCache { \npublic void addAll ( FeatureDatasetPoint fdPoint ) throws IOException { \ntry ( PointFeatureIterator pointFeatIter = new FlattenedDatasetPointCollection ( fdPoint ) . getPointFeatureIterator ( ) ) { \nfor ( ; \npointFeatIter . hasNext ( ) ; \n) { \nStationPointFeature pointFeat = ( StationPointFeature ) pointFeatIter . next ( ) ; \nadd ( pointFeat ) ; \n} \n} \n} \n} \n"}
{"4565": "public class CEEvaluator { \npublic boolean evalClauses ( Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nboolean result = true ; \nEnumeration ec = getClauses ( ) ; \nfor ( ; \nec . hasMoreElements ( ) && result == true ; \n) { \nObject o = ec . nextElement ( ) ; \nif ( _Debug ) { \nSystem . out . println ( \"Evaluating clause: \" + ec . nextElement ( ) ) ; \n} \nresult = ( ( TopLevelClause ) o ) . evaluate ( ) ; \n} \nreturn ( result ) ; \n} \n} \n"}
{"4566": "public class CEEvaluator { \npublic void printConstraint ( PrintWriter pw ) { \nEnumeration ec = getClauses ( ) ; \nboolean first = true ; \nfor ( ; \nec . hasMoreElements ( ) ; \n) { \nClause cl = ( Clause ) ec . nextElement ( ) ; \nif ( ! first ) pw . print ( \" & \" ) ; \ncl . printConstraint ( pw ) ; \nfirst = false ; \n} \npw . flush ( ) ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n} \n"}
{"4571": "public class Documentation { \npublic String readXlinkContent ( ) throws java . io . IOException { \nif ( uri == null ) return \"\" ; \nURL url = uri . toURL ( ) ; \nInputStream is = url . openStream ( ) ; \nByteArrayOutputStream os = new ByteArrayOutputStream ( is . available ( ) ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nfor ( ; \ntrue ; \n) { \nint bytesRead = is . read ( buffer ) ; \nif ( bytesRead == - 1 ) break ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \nis . close ( ) ; \nreturn new String ( os . toByteArray ( ) , CDM . utf8Charset ) ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nfor ( ; \n! layoutPass ( target ) ; \n) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nfor ( ; \niterOne . hasNext ( ) ; \n) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \nelse if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nfor ( ; \n( c = input . read ( ) ) >= 0 ; \n) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse if ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse assert false : \"Internal error\" ; \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse if ( dmr . endsWith ( \"\\n\" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse dmr = dmr + \"\\r\\n\" ; \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; \nelse if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; \nelse state = State . DATA ; \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nfor ( ; \ncount > 0 ; \n) { \nif ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nfor ( ; \ntableNames . hasMoreElements ( ) ; \n) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) System . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4669": "public class BufrDataProcess { \npublic int scanBufrFile ( String filename , Counter total ) throws Exception { \nint count = 0 ; \ntry ( RandomAccessFile raf = new RandomAccessFile ( filename , \"r\" ) ) { \nMessageScanner scan = new MessageScanner ( raf ) ; \nfor ( ; \nscan . hasNext ( ) ; \n) { \nMessage m = scan . next ( ) ; \nif ( m == null ) continue ; \ntry { \nif ( showMess ) out . format ( \"%sMessage %d header=%s%n\" , indent , count , m . getHeader ( ) ) ; \ncount ++ ; \nCounter counter = new Counter ( ) ; \nprocessBufrMessageAsDataset ( scan , m , counter ) ; \nif ( showMess ) out . format ( \"%scount=%d miss=%d%n\" , indent , counter . nvals , counter . nmiss ) ; \ntotal . add ( counter ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"  BARF:%s on %s%n\" , e . getMessage ( ) , m . getHeader ( ) ) ; \nindent . setIndentLevel ( 0 ) ; \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"4681": "public class ListenerManager { \npublic synchronized void sendEvent ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) return ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nObject client = iter . next ( ) ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException e ) { \nlogger . error ( \"ListenerManager IllegalAccessException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlogger . error ( \"ListenerManager IllegalArgumentException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new RuntimeException ( e . getCause ( ) ) ; \n} \n} \n} \n} \n"}
{"4682": "public class ListenerManager { \npublic synchronized void sendEventExcludeSource ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) return ; \nObject source = event . getSource ( ) ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nObject client = iter . next ( ) ; \nif ( client == source ) continue ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException | InvocationTargetException | IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \nif ( e . getCause ( ) != null ) e . getCause ( ) . printStackTrace ( ) ; \nlogger . error ( \"ListenerManager calling \" + method + \" threw exception \" , e ) ; \n} \n} \n} \n} \n"}
{"4684": "public class NCdumpW { \npublic static boolean print ( NetcdfFile nc , String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nWantValues showValues = WantValues . none ; \nboolean ncml = false ; \nboolean strict = false ; \nString varNames = null ; \nString trueDataset = null ; \nString fakeDataset = null ; \nif ( command != null ) { \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nfor ( ; \nstoke . hasMoreTokens ( ) ; \n) { \nString toke = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-help\" ) ) { \nout . write ( usage ) ; \nout . write ( '\\n' ) ; \nreturn true ; \n} \nif ( toke . equalsIgnoreCase ( \"-vall\" ) ) showValues = WantValues . all ; \nif ( toke . equalsIgnoreCase ( \"-c\" ) && ( showValues == WantValues . none ) ) showValues = WantValues . coordsOnly ; \nif ( toke . equalsIgnoreCase ( \"-ncml\" ) ) ncml = true ; \nif ( toke . equalsIgnoreCase ( \"-cdl\" ) || toke . equalsIgnoreCase ( \"-strict\" ) ) strict = true ; \nif ( toke . equalsIgnoreCase ( \"-v\" ) && stoke . hasMoreTokens ( ) ) varNames = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-datasetname\" ) && stoke . hasMoreTokens ( ) ) { \nfakeDataset = stoke . nextToken ( ) ; \nif ( fakeDataset . length ( ) == 0 ) fakeDataset = null ; \nif ( fakeDataset != null ) { \ntrueDataset = nc . getLocation ( ) ; \nnc . setLocation ( fakeDataset ) ; \n} \n} \n} \n} \nboolean ok = print ( nc , out , showValues , ncml , strict , varNames , ct ) ; \nif ( trueDataset != null && fakeDataset != null ) nc . setLocation ( trueDataset ) ; \nreturn ok ; \n} \n} \n"}
{"4688": "public class NCdumpW { \nstatic public void printArrayPlain ( Array ma , PrintWriter out ) { \nma . resetLocalIterator ( ) ; \nfor ( ; \nma . hasNext ( ) ; \n) { \nout . print ( ma . next ( ) ) ; \nout . print ( ' ' ) ; \n} \n} \n} \n"}
{"4699": "public class BitReader { \npublic long bits2UInt ( int nb ) throws IOException { \nassert nb <= 64 ; \nassert nb >= 0 ; \nlong result = 0 ; \nint bitsLeft = nb ; \nfor ( ; \nbitsLeft > 0 ; \n) { \nif ( bitPos == 0 ) { \nbitBuf = nextByte ( ) ; \nbitPos = BIT_LENGTH ; \n} \nint size = Math . min ( bitsLeft , bitPos ) ; \nint myBits = bitBuf >> ( bitPos - size ) ; \nmyBits &= BYTE_BITMASK ; \nmyBits &= ~ ( BYTE_BITMASK << size ) ; \nint shift = bitsLeft - size ; \nassert shift >= 0 ; \nresult |= myBits << shift ; \nbitsLeft -= size ; \nbitPos -= size ; \n} \nreturn result ; \n} \n} \n"}
{"4716": "public class Escape { \npublic static String backslashDecode ( String s ) { \nStringBuilder buf = new StringBuilder ( s ) ; \nint i = 0 ; \nfor ( ; \ni < buf . length ( ) ; \n) { \nif ( buf . charAt ( i ) == '\\\\' ) { \nbuf . deleteCharAt ( i ) ; \n} \ni ++ ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4772": "public class DapNode { \npublic DapGroup getGroup ( ) { \nif ( this . sort == DapSort . DATASET ) return null ; \nDapNode group = parent ; \nfor ( ; \ngroup != null ; \n) { \nswitch ( group . getSort ( ) ) { \ncase DATASET : case GROUP : return ( DapGroup ) group ; \ndefault : group = group . getParent ( ) ; \nbreak ; \n} \n} \nreturn ( DapGroup ) group ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nfor ( ; \niter . hasNext ( ) ; \n) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4851": "public class Grib2RecordScanner { \n@ Nullable public static Grib2Record findRecordByDrspos ( RandomAccessFile raf , long drsPos ) throws IOException { \nlong pos = Math . max ( 0 , drsPos - ( 20 * 1000 ) ) ; \nGrib2RecordScanner scan = new Grib2RecordScanner ( raf , pos ) ; \nfor ( ; \nscan . hasNext ( ) ; \n) { \nucar . nc2 . grib . grib2 . Grib2Record gr = scan . next ( ) ; \nGrib2SectionDataRepresentation drs = gr . getDataRepresentationSection ( ) ; \nif ( drsPos == drs . getStartingPosition ( ) ) return gr ; \nif ( raf . getFilePointer ( ) > drsPos ) break ; \n} \nreturn null ; \n} \n} \n"}
{"4853": "public class NcSDStructure { \npublic void serialize ( String dataset , DataOutputStream sink , CEEvaluator ce , Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nif ( org == null ) { \nsuper . serialize ( dataset , sink , ce , specialO ) ; \nreturn ; \n} \njava . util . Enumeration vars = org . getVariables ( ) ; \nStructureMembers sm = sdata . getStructureMembers ( ) ; \nint count = 0 ; \nfor ( ; \nvars . hasMoreElements ( ) ; \n) { \nHasNetcdfVariable sm_org = ( HasNetcdfVariable ) vars . nextElement ( ) ; \nboolean isProjected = ( ( ServerMethods ) sm_org ) . isProject ( ) ; \nif ( isProjected ) { \nStructureMembers . Member m = sm . getMember ( count ) ; \nsm_org . serialize ( sink , sdata , m ) ; \n} \ncount ++ ; \n} \n} \n} \n"}
{"4962": "public class MFileCollectionManager { \nprivate boolean scanFirstTime ( ) throws IOException { \nMap < String , MFile > newMap = new HashMap < > ( ) ; \nif ( ! hasScans ( ) ) { \nmap = newMap ; \nreturn false ; \n} \nreallyScan ( newMap ) ; \nif ( olderThanInMsecs > 0 ) { \nlong olderThan = System . currentTimeMillis ( ) - olderThanInMsecs ; \nIterator < MFile > iter = newMap . values ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nMFile newFile = iter . next ( ) ; \nString path = newFile . getPath ( ) ; \nif ( newFile . getLastModified ( ) > olderThan ) { \niter . remove ( ) ; \nlogger . debug ( \"{}: scan found new Dataset but its too recently modified = {}\" , collectionName , path ) ; \n} \n} \n} \nmap = newMap ; \nthis . lastScanned = System . currentTimeMillis ( ) ; \nthis . lastChanged . set ( this . lastScanned ) ; \nlogger . debug ( \"{} : initial scan found n datasets = {} \" , collectionName , map . keySet ( ) . size ( ) ) ; \nreturn map . keySet ( ) . size ( ) > 0 ; \n} \n} \n"}
{"4974": "public class StructureDS { \nprivate VariableEnhanced findVariableFromOrgName ( String orgName ) { \nfor ( Variable vTop : getVariables ( ) ) { \nVariable v = vTop ; \nfor ( ; \nv instanceof VariableEnhanced ; \n) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( ( ve . getOriginalName ( ) != null ) && ( ve . getOriginalName ( ) . equals ( orgName ) ) ) return ( VariableEnhanced ) vTop ; \nv = ve . getOriginalVariable ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4975": "public class StructureDS { \nprivate boolean varHasData ( Variable v , StructureMembers sm ) { \nif ( sm . findMember ( v . getShortName ( ) ) != null ) return true ; \nfor ( ; \nv instanceof VariableEnhanced ; \n) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( sm . findMember ( ve . getOriginalName ( ) ) != null ) return true ; \nv = ve . getOriginalVariable ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nfor ( ; \ndimB < rankB ; \n) if ( shapeB [ dimB ] == 1 ) dimB ++ ; \nelse break ; \nif ( aShapeA != shapeB [ dimB ] ) return false ; \ndimB ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5019": "public class MAMath { \npublic static void copyBoolean ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nfor ( ; \niterA . hasNext ( ) ; \n) iterR . setBooleanNext ( iterA . getBooleanNext ( ) ) ; \n} \n} \n"}
{"5020": "public class MAMath { \npublic static void copyObject ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nfor ( ; \niterA . hasNext ( ) ; \n) { \niterR . setObjectNext ( iterA . getObjectNext ( ) ) ; \n} \n} \n} \n"}
{"5021": "public class MAMath { \npublic static MAMath . MinMax getMinMax ( Array a ) { \nIndexIterator iter = a . getIndexIterator ( ) ; \ndouble max = - Double . MAX_VALUE ; \ndouble min = Double . MAX_VALUE ; \nfor ( ; \niter . hasNext ( ) ; \n) { \ndouble val = iter . getDoubleNext ( ) ; \nif ( Double . isNaN ( val ) ) continue ; \nif ( val > max ) max = val ; \nif ( val < min ) min = val ; \n} \nreturn new MinMax ( min , max ) ; \n} \n} \n"}
{"5022": "public class MAMath { \npublic static void setDouble ( Array result , double val ) { \nIndexIterator iter = result . getIndexIterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \niter . setDoubleNext ( val ) ; \n} \n} \n} \n"}
{"5030": "public class EscapeStrings { \npublic static List < String > tokenizeEscapedName ( String escapedName ) { \nList < String > result = new ArrayList < > ( ) ; \nint pos = 0 ; \nint start = 0 ; \nfor ( ; \ntrue ; \n) { \npos = escapedName . indexOf ( sep , pos + 1 ) ; \nif ( pos <= 0 ) break ; \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nresult . add ( escapedName . substring ( start , pos ) ) ; \nstart = pos + 1 ; \n} \n} \nresult . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5031": "public class EscapeStrings { \npublic static int indexOf ( String escapedName , char c ) { \nint pos = 0 ; \nfor ( ; \ntrue ; \n) { \npos = escapedName . indexOf ( c , pos + 1 ) ; \nif ( pos <= 0 ) return pos ; \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) return pos ; \n} \n} \n} \n"}
{"5036": "public class SwingUtils { \npublic static < T extends JComponent > Class getJClass ( T component ) { \nClass < ? > clazz = component . getClass ( ) ; \nfor ( ; \n! clazz . getName ( ) . matches ( \"javax.swing.J[^.]*$\" ) ; \n) { \nclazz = clazz . getSuperclass ( ) ; \n} \nreturn clazz ; \n} \n} \n"}
{"5038": "public class D4DataCompiler { \nprotected D4Cursor compileStructureArray ( DapVariable var , D4Cursor container ) throws DapException { \nDapStructure dapstruct = ( DapStructure ) var . getBaseType ( ) ; \nD4Cursor structarray = new D4Cursor ( Scheme . STRUCTARRAY , this . dsp , var , container ) . setOffset ( getPos ( this . databuffer ) ) ; \nList < DapDimension > dimset = var . getDimensions ( ) ; \nlong dimproduct = DapUtil . dimProduct ( dimset ) ; \nD4Cursor [ ] instances = new D4Cursor [ ( int ) dimproduct ] ; \nOdometer odom = Odometer . factory ( DapUtil . dimsetToSlices ( dimset ) , dimset ) ; \nfor ( ; \nodom . hasNext ( ) ; \n) { \nIndex index = odom . next ( ) ; \nD4Cursor instance = compileStructure ( var , dapstruct , structarray ) ; \ninstance . setIndex ( index ) ; \ninstances [ ( int ) index . index ( ) ] = instance ; \n} \nstructarray . setElements ( instances ) ; \nreturn structarray ; \n} \n} \n"}
{"5040": "public class D4DataCompiler { \nprotected D4Cursor compileSequenceArray ( DapVariable var , D4Cursor container ) throws DapException { \nDapSequence dapseq = ( DapSequence ) var . getBaseType ( ) ; \nD4Cursor seqarray = new D4Cursor ( Scheme . SEQARRAY , this . dsp , var , container ) . setOffset ( getPos ( this . databuffer ) ) ; \nList < DapDimension > dimset = var . getDimensions ( ) ; \nlong dimproduct = DapUtil . dimProduct ( dimset ) ; \nD4Cursor [ ] instances = new D4Cursor [ ( int ) dimproduct ] ; \nOdometer odom = Odometer . factory ( DapUtil . dimsetToSlices ( dimset ) , dimset ) ; \nfor ( ; \nodom . hasNext ( ) ; \n) { \nIndex index = odom . next ( ) ; \nD4Cursor instance = compileSequence ( var , dapseq , seqarray ) ; \ninstance . setIndex ( index ) ; \ninstances [ ( int ) index . index ( ) ] = instance ; \n} \nseqarray . setElements ( instances ) ; \nreturn seqarray ; \n} \n} \n"}
{"5083": "public class GisFeatureRenderer { \npublic void draw ( java . awt . Graphics2D g , AffineTransform pixelAT ) { \ng . setColor ( color ) ; \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ng . setStroke ( new java . awt . BasicStroke ( 0.0f ) ) ; \nRectangle2D clipRect = ( Rectangle2D ) g . getClip ( ) ; \nIterator siter = getShapes ( g , pixelAT ) ; \nfor ( ; \nsiter . hasNext ( ) ; \n) { \nShape s = ( Shape ) siter . next ( ) ; \nRectangle2D shapeBounds = s . getBounds2D ( ) ; \nif ( shapeBounds . intersects ( clipRect ) ) g . draw ( s ) ; \n} \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) System . out . println ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) shape = feature . getShape ( ) ; \nelse if ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse if ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5085": "public class BufrSplitter { \npublic void processStream ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nfor ( ; \ntrue ; \n) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = processBuffer ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nfor ( ; \ndone < want ; \n) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) return false ; \ndone += got ; \n} \nif ( showRead ) System . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nfor ( ; \nvp . isMemberOfStructure ( ) ; \n) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nfor ( ; \ngp . getParentGroup ( ) != null ; \n) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( int i = 1 ; \ni < gchain . size ( ) ; \ni ++ ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \nfor ( int i = 1 ; \ni < vchain . size ( ) ; \ni ++ ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5134": "public class Nidsheader { \nbyte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { \nbyte [ ] header = new byte [ offset ] ; \nbuf . position ( 0 ) ; \nbuf . get ( header ) ; \nbyte [ ] out = new byte [ offset + uncomplen ] ; \nSystem . arraycopy ( header , 0 , out , 0 , offset ) ; \nCBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; \nint numCompBytes = buf . remaining ( ) ; \nbyte [ ] bufc = new byte [ numCompBytes ] ; \nbuf . get ( bufc , 0 , numCompBytes ) ; \nByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; \ncbzip2 . setStream ( bis ) ; \nint total = 0 ; \nint nread ; \nbyte [ ] ubuff = new byte [ 40000 ] ; \nbyte [ ] obuff = new byte [ 40000 ] ; \ntry { \nfor ( ; \n( nread = cbzip2 . read ( ubuff ) ) != - 1 ; \n) { \nif ( total + nread > obuff . length ) { \nbyte [ ] temp = obuff ; \nobuff = new byte [ temp . length * 2 ] ; \nSystem . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; \n} \nSystem . arraycopy ( ubuff , 0 , obuff , total , nread ) ; \ntotal += nread ; \n} \nif ( obuff . length >= 0 ) System . arraycopy ( obuff , 0 , out , offset , total ) ; \n} \ncatch ( BZip2ReadException ioe ) { \nlog . warn ( \"Nexrad2IOSP.uncompress \" + raf . getLocation ( ) , ioe ) ; \n} \nreturn out ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nint comp ; \nif ( constrained ) { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nif ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; \n} \n} \nelse { \ncomp = 1 + mapVars . size ( ) ; \n} \nreturn comp ; \n} \n} \n"}
{"5189": "public class CatalogTreeView { \nTreePath makeTreePath ( TreeNode node ) { \nArrayList < TreeNode > path = new ArrayList < > ( ) ; \npath . add ( node ) ; \nTreeNode parent = node . getParent ( ) ; \nfor ( ; \nparent != null ; \n) { \npath . add ( 0 , parent ) ; \nparent = parent . getParent ( ) ; \n} \nObject [ ] paths = path . toArray ( ) ; \nreturn new TreePath ( paths ) ; \n} \n} \n"}
{"5194": "public class VlenIO { \npublic int writeVInt ( int i ) throws IOException { \nint count = 0 ; \nfor ( ; \n( i & ~ 0x7F ) != 0 ; \n) { \nwriteByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; \ni >>>= 7 ; \ncount ++ ; \n} \nwriteByte ( ( byte ) i ) ; \nreturn count + 1 ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \ni < u . length ( ) ; \n) { \nchar c = u . charAt ( i ) ; \nif ( c == '\\\\' ) { \nif ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \nbuf . append ( \"%5c\" ) ; \ni ++ ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \nelse buf . append ( c ) ; \ni ++ ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nint len = dsr . length ( ) ; \nfor ( ; \nlen > 0 ; \n) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) break ; \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) { \nfor ( ; \nindex . hasNext ( ) ; \n) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) { \nfor ( ; \nindex . hasNext ( ) ; \n) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) { \nfor ( ; \nindex . hasNext ( ) ; \n) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) { \nfor ( ; \nindex . hasNext ( ) ; \n) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5295": "public class InvDatasetImpl { \npublic boolean finish ( ) { \nboolean ok = true ; \njava . util . Iterator iter ; \nlogger . debug ( \"Now finish \" + getName ( ) + \" id= \" + getID ( ) ) ; \nauthorityName = null ; \ndataType = null ; \ndataFormatType = null ; \ndefaultService = null ; \ngc = null ; \ntc = null ; \ndocs = new ArrayList < > ( ) ; \nmetadata = new ArrayList < > ( ) ; \nproperties = new ArrayList < > ( ) ; \ncreators = new ArrayList < > ( ) ; \ncontributors = new ArrayList < > ( ) ; \ndates = new ArrayList < > ( ) ; \nkeywords = new ArrayList < > ( ) ; \nprojects = new ArrayList < > ( ) ; \npublishers = new ArrayList < > ( ) ; \nvariables = new ArrayList < > ( ) ; \ncanonicalize ( ) ; \ntransfer2PublicMetadata ( tm , true ) ; \ntransfer2PublicMetadata ( tmi , true ) ; \ntransferInheritable2PublicMetadata ( ( InvDatasetImpl ) getParent ( ) ) ; \naccess = new ArrayList < > ( ) ; \nif ( ( urlPath != null ) && ( getServiceDefault ( ) != null ) ) { \nInvAccessImpl a = new InvAccessImpl ( this , urlPath , getServiceDefault ( ) ) ; \na . setSize ( size ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \niter = accessLocal . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nInvAccessImpl a = ( InvAccessImpl ) iter . next ( ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \nif ( ! ( this instanceof InvCatalogRef ) ) { \nfor ( InvDataset invDataset : this . getDatasets ( ) ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invDataset ; \nok &= curDs . finish ( ) ; \n} \n} \nreturn ok ; \n} \n} \n"}
{"5312": "public class WFSController { \nprivate WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { \nList < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; \nGeometryType geoT = sgcs . getGeometryType ( ftName ) ; \nif ( geoT == null ) { \nreturn new WFSExceptionWriter ( \"Feature Type of \" + fullFtName + \" not found.\" , \"GetFeature\" , \"OperationProcessingFailed\" ) ; \n} \ntry { \nswitch ( geoT ) { \ncase POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; \nint j = 0 ; \nfor ( ; \npt != null ; \n) { \ngeometryList . add ( pt ) ; \nj ++ ; \npt = sgcs . getPoint ( ftName , j ) ; \n} \nbreak ; \ncase LINE : Line line = sgcs . getLine ( ftName , 0 ) ; \nint k = 0 ; \nfor ( ; \nline != null ; \n) { \ngeometryList . add ( line ) ; \nk ++ ; \nline = sgcs . getLine ( ftName , k ) ; \n} \nbreak ; \ncase POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; \nint i = 0 ; \nfor ( ; \npoly != null ; \n) { \ngeometryList . add ( poly ) ; \ni ++ ; \npoly = sgcs . getPolygon ( ftName , i ) ; \n} \nbreak ; \n} \n} \ncatch ( ArrayIndexOutOfBoundsException aout ) { \n} \nWFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; \ngfdw . startXML ( ) ; \ngfdw . writeMembers ( ) ; \ngfdw . finishXML ( ) ; \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nfor ( ; \nparamNamesE . hasMoreElements ( ) ; \n) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; \nelse return ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5325": "public class ServletUtil { \npublic static String getParameterIgnoreCase ( HttpServletRequest req , String paramName ) { \nEnumeration e = req . getParameterNames ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nString s = ( String ) e . nextElement ( ) ; \nif ( s . equalsIgnoreCase ( paramName ) ) return req . getParameter ( s ) ; \n} \nreturn null ; \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nfor ( ; \ntrue ; \n) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5349": "public class IO { \nstatic public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { \nint bufferSize = buffer . length ; \nlong want = length ; \nraf . seek ( offset ) ; \nfor ( ; \nwant > 0 ; \n) { \nint len = ( int ) Math . min ( want , bufferSize ) ; \nint bytesRead = raf . read ( buffer , 0 , len ) ; \nif ( bytesRead <= 0 ) break ; \nout . write ( buffer , 0 , bytesRead ) ; \nwant -= bytesRead ; \n} \nout . flush ( ) ; \nreturn length - want ; \n} \n} \n"}
{"5372": "public class StringUtil2 { \nstatic public int match ( String s1 , String s2 ) { \nint i = 0 ; \nfor ( ; \n( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ; \n) { \nif ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { \nbreak ; \n} \ni ++ ; \n} \nreturn i ; \n} \n} \n"}
{"5373": "public class StringUtil2 { \npublic static String padLeft ( String s , int desiredLength , String padString ) { \nfor ( ; \ns . length ( ) < desiredLength ; \n) { \ns = padString + s ; \n} \nreturn s ; \n} \n} \n"}
{"5374": "public class StringUtil2 { \npublic static String padRight ( String s , int desiredLength , String padString ) { \nStringBuilder ret = new StringBuilder ( s ) ; \nfor ( ; \nret . length ( ) < desiredLength ; \n) { \nret . append ( padString ) ; \n} \nreturn ret . toString ( ) ; \n} \n} \n"}
{"5375": "public class StringUtil2 { \nstatic public String remove ( String s , String sub ) { \nint len = sub . length ( ) ; \nint pos ; \nfor ( ; \n0 <= ( pos = s . indexOf ( sub ) ) ; \n) { \ns = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; \n} \nreturn s ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) { \nreturn s ; \n} \nStringBuilder buff = new StringBuilder ( s ) ; \nint i = 0 ; \nfor ( ; \ni < buff . length ( ) ; \n) { \nif ( buff . charAt ( i ) == c ) { \nbuff . deleteCharAt ( i ) ; \n} \nelse { \ni ++ ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5377": "public class StringUtil2 { \nstatic public String removeFromEnd ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) return s ; \nint len = s . length ( ) ; \nfor ( ; \n( s . charAt ( len - 1 ) == c ) && ( len > 0 ) ; \n) len -- ; \nif ( len == s . length ( ) ) return s ; \nreturn s . substring ( 0 , len ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( ' ' ) ; \nfor ( ; \n( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ; \n) { \ni ++ ; \n} \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5381": "public class StringUtil2 { \npublic static String replace ( String string , String pattern , String value ) { \nif ( pattern . length ( ) == 0 ) return string ; \nif ( ! string . contains ( pattern ) ) return string ; \nStringBuilder returnValue = new StringBuilder ( ) ; \nint patternLength = pattern . length ( ) ; \nfor ( ; \ntrue ; \n) { \nint idx = string . indexOf ( pattern ) ; \nif ( idx < 0 ) break ; \nreturnValue . append ( string . substring ( 0 , idx ) ) ; \nif ( value != null ) returnValue . append ( value ) ; \nstring = string . substring ( idx + patternLength ) ; \n} \nreturnValue . append ( string ) ; \nreturn returnValue . toString ( ) ; \n} \n} \n"}
{"5382": "public class StringUtil2 { \nstatic public String substitute ( String original , String match , String subst ) { \nString s = original ; \nint pos ; \nfor ( ; \n0 <= ( pos = s . indexOf ( match ) ) ; \n) { \nStringBuilder sb = new StringBuilder ( s ) ; \ns = sb . replace ( pos , pos + match . length ( ) , subst ) . toString ( ) ; \n} \nreturn s ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nfor ( ; \ni < sb . length ( ) ; \n) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) i ++ ; \n} \n} \n} \n"}
{"5385": "public class StringUtil2 { \nstatic public void unreplace ( StringBuilder sb , String out , char in ) { \nint pos ; \nfor ( ; \n0 <= ( pos = sb . indexOf ( out ) ) ; \n) { \nsb . setCharAt ( pos , in ) ; \nsb . delete ( pos + 1 , pos + out . length ( ) ) ; \n} \n} \n} \n"}
{"5387": "public class StringUtil2 { \nstatic public void substitute ( StringBuilder sbuff , String match , String subst ) { \nint pos , fromIndex = 0 ; \nint substLen = subst . length ( ) ; \nint matchLen = match . length ( ) ; \nfor ( ; \n0 <= ( pos = sbuff . indexOf ( match , fromIndex ) ) ; \n) { \nsbuff . replace ( pos , pos + matchLen , subst ) ; \nfromIndex = pos + substLen ; \n} \n} \n} \n"}
{"5388": "public class StringUtil2 { \nstatic public String trim ( String s , int bad ) { \nint len = s . length ( ) ; \nint st = 0 ; \nfor ( ; \n( st < len ) && ( s . charAt ( st ) == bad ) ; \n) { \nst ++ ; \n} \nfor ( ; \n( st < len ) && ( s . charAt ( len - 1 ) == bad ) ; \n) { \nlen -- ; \n} \nreturn ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; \n} \n} \n"}
{"5396": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( ArrayStructure as , ByteOrder bo , boolean canonical ) throws IOException { \nif ( ! canonical && as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { \nArrayStructureBB abb = ( ArrayStructureBB ) as ; \nByteBuffer bb = abb . getByteBuffer ( ) ; \nif ( bo == null || bo . equals ( bb . order ( ) ) ) return abb ; \n} \nStructureMembers smo = as . getStructureMembers ( ) ; \nStructureMembers sm = new StructureMembers ( smo ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , as . getShape ( ) ) ; \nArrayStructureBB . setOffsets ( sm ) ; \nif ( bo != null ) { \nByteBuffer bb = abb . getByteBuffer ( ) ; \nbb . order ( bo ) ; \n} \ntry ( StructureDataIterator iter = as . getStructureDataIterator ( ) ) { \nfor ( ; \niter . hasNext ( ) ; \n) copyToArrayBB ( iter . next ( ) , abb ) ; \n} \nreturn abb ; \n} \n} \n"}
{"5397": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( Structure s , ArrayStructure as , ByteOrder bo ) throws IOException { \nStructureMembers sm = s . makeStructureMembers ( ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , as . getShape ( ) ) ; \nArrayStructureBB . setOffsets ( sm ) ; \nif ( bo != null ) { \nByteBuffer bb = abb . getByteBuffer ( ) ; \nbb . order ( bo ) ; \n} \ntry ( StructureDataIterator iter = as . getStructureDataIterator ( ) ) { \nfor ( ; \niter . hasNext ( ) ; \n) copyToArrayBB ( iter . next ( ) , abb ) ; \n} \nreturn abb ; \n} \n} \n"}
{"5412": "public class Group { \npublic Group commonParent ( Group other ) { \nif ( isParent ( other ) ) return this ; \nif ( other . isParent ( this ) ) return other ; \nfor ( ; \n! other . isParent ( this ) ; \n) other = other . getParentGroup ( ) ; \nreturn other ; \n} \n} \n"}
{"5413": "public class Group { \npublic boolean isParent ( Group other ) { \nfor ( ; \n( other != this ) && ( other . getParentGroup ( ) != null ) ; \n) other = other . getParentGroup ( ) ; \nreturn ( other == this ) ; \n} \n} \n"}
{"5422": "public class DDS { \nprivate String convertDDSAliasFieldsToDASAliasFields ( String attribute ) throws MalformedAliasException { \nString prefix = \"\" ; \nVector aNames = tokenizeAliasField ( attribute ) ; \nString topName = ( String ) aNames . get ( 1 ) ; \nboolean foundIt = false ; \nEnumeration e = getVariables ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nBaseType bt = ( BaseType ) e . nextElement ( ) ; \nString normName = normalize ( bt . getEncodedName ( ) ) ; \nif ( topName . equals ( normName ) ) foundIt = true ; \n} \nif ( ! foundIt ) { \nprefix = \".\" + getLooseEndsTableName ( ) ; \n} \nreturn ( prefix + attribute ) ; \n} \n} \n"}
{"5426": "public class GeotiffWriter { \nprivate ArrayFloat replaceMissingValues ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \nfloat minValue = ( float ) ( dataMinMax . min - 1.0 ) ; \nArrayFloat floatArray = ( ArrayFloat ) Array . factory ( DataType . FLOAT , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator floatIter = floatArray . getIndexIterator ( ) ; \nfor ( ; \ndataIter . hasNext ( ) ; \n) { \nfloat v = dataIter . getFloatNext ( ) ; \nif ( grid . isMissing ( ( double ) v ) ) { \nv = minValue ; \n} \nfloatIter . setFloatNext ( v ) ; \n} \nreturn floatArray ; \n} \n} \n"}
{"5427": "public class GeotiffWriter { \nprivate ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \ndouble scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; \nArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator resultIter = byteArray . getIndexIterator ( ) ; \nbyte bv ; \nfor ( ; \ndataIter . hasNext ( ) ; \n) { \ndouble v = dataIter . getDoubleNext ( ) ; \nif ( grid . isMissing ( v ) ) { \nbv = 0 ; \n} \nelse { \nint iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; \nbv = ( byte ) ( iv & 0xff ) ; \n} \nresultIter . setByteNext ( bv ) ; \n} \nreturn byteArray ; \n} \n} \n"}
{"5428": "public class GeotiffWriter { \nprivate double geoShiftGetXstart ( Array lon , double inc ) { \nIndex ilon = lon . getIndex ( ) ; \nint [ ] lonShape = lon . getShape ( ) ; \nIndexIterator lonIter = lon . getIndexIterator ( ) ; \ndouble xlon = 0.0 ; \nLatLonPoint p0 = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( 0 ) ) ) ; \nLatLonPoint pN = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( lonShape [ 0 ] - 1 ) ) ) ; \nxlon = p0 . getLongitude ( ) ; \nfor ( ; \nlonIter . hasNext ( ) ; \n) { \nfloat l = lonIter . getFloatNext ( ) ; \nLatLonPoint pn = new LatLonPointImpl ( 0 , l ) ; \nif ( pn . getLongitude ( ) < xlon ) { \nxlon = pn . getLongitude ( ) ; \n} \n} \nif ( p0 . getLongitude ( ) == pN . getLongitude ( ) ) { \nxlon = xlon - inc ; \n} \nreturn xlon ; \n} \n} \n"}
{"5447": "public class GisFeatureRendererMulti { \npublic void setProjection ( ProjectionImpl project ) { \ndisplayProject = project ; \nif ( featSetList == null ) return ; \nIterator iter = featSetList . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nFeatureSet fs = ( FeatureSet ) iter . next ( ) ; \nfs . newProjection = true ; \n} \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \nSystem . out . println ( \"GisFeature/MapDraw: makeShapes with \" + displayProject ) ; \n} \nfor ( ; \nfeatList . hasNext ( ) ; \n) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse if ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5456": "public class ArrayStructure { \nprotected void copyStructures ( int recnum , StructureMembers . Member m , IndexIterator result ) { \nArray data = getArray ( recnum , m ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nfor ( ; \ndataIter . hasNext ( ) ; \n) result . setObjectNext ( dataIter . getObjectNext ( ) ) ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nfor ( ; \ndkIter . hasNext ( ) ; \n) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) throw new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \nint len = val . length ( ) ; \nfor ( ; \n( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ; \n) len -- ; \nif ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nint totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nfor ( ; \narr . hasNext ( ) ; \n) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen += bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nint pos = 0 ; \narr . resetLocalIterator ( ) ; \nfor ( ; \narr . hasNext ( ) ; \n) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos += bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \nif ( arr . getRank ( ) > 1 ) arr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \n} \n} \n"}
{"5591": "public class RandomAccessFile { \npublic boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { \nlong start = getFilePointer ( ) ; \nlong last = ( maxBytes < 0 ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; \nlong needToScan = last - start ; \nint bytesAvailable = ( int ) ( dataEnd - filePosition ) ; \nif ( bytesAvailable < 1 ) { \nseek ( filePosition ) ; \nbytesAvailable = ( int ) ( dataEnd - filePosition ) ; \n} \nint bufStart = ( int ) ( filePosition - bufferStart ) ; \nint scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; \nint pos = match . indexOf ( buffer , bufStart , scanBytes ) ; \nif ( pos >= 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nint matchLen = match . getMatchLength ( ) ; \nneedToScan -= scanBytes - matchLen ; \nfor ( ; \nneedToScan > matchLen ; \n) { \nreadBuffer ( dataEnd - matchLen ) ; \nscanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; \npos = match . indexOf ( buffer , 0 , scanBytes ) ; \nif ( pos > 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nneedToScan -= scanBytes - matchLen ; \n} \nseek ( last ) ; \nreturn false ; \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nint countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) && count ++ < 100 ; \n) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) countDir ++ ; \nelse countFile ++ ; \n} \n} \npartitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5606": "public class FileCacheARC { \npublic synchronized void clearCache ( boolean force ) { \nList < CacheElement . CacheFile > deleteList = new ArrayList < > ( 2 * cache . size ( ) ) ; \nif ( force ) { \ncache . clear ( ) ; \ndeleteList . addAll ( files . values ( ) ) ; \nfiles . clear ( ) ; \n} \nelse { \nIterator < CacheElement . CacheFile > iter = files . values ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nCacheElement . CacheFile file = iter . next ( ) ; \nif ( file . isLocked . compareAndSet ( false , true ) ) { \nfile . remove ( ) ; \ndeleteList . add ( file ) ; \niter . remove ( ) ; \n} \n} \nfor ( CacheElement elem : cache . values ( ) ) { \nif ( elem . list . size ( ) == 0 ) cache . remove ( elem . hashKey ) ; \n} \n} \nfor ( CacheElement . CacheFile file : deleteList ) { \nif ( force && file . isLocked . get ( ) ) cacheLog . warn ( \"FileCacheARC \" + name + \" force close locked file= \" + file ) ; \nif ( file . ncfile == null ) continue ; \ntry { \nfile . ncfile . setFileCache ( null ) ; \nfile . ncfile . close ( ) ; \nfile . ncfile = null ; \n} \ncatch ( IOException e ) { \nlog . error ( \"FileCacheARC \" + name + \" close failed on \" + file ) ; \n} \n} \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList . size ( ) + \" left=\" + files . size ( ) ) ; \n} \n} \n"}
{"5646": "public class ConvertD2N { \npublic Array convertNestedVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV , boolean flatten ) throws IOException , DAP2Exception { \nArray data = convertTopVariable ( v , section , dataV ) ; \nif ( flatten ) { \nArrayStructure as = ( ArrayStructure ) data ; \nList < String > names = new ArrayList < > ( ) ; \nVariable nested = v ; \nfor ( ; \nnested . isMemberOfStructure ( ) ; \n) { \nnames . add ( 0 , nested . getShortName ( ) ) ; \nnested = nested . getParentStructure ( ) ; \n} \nStructureMembers . Member m = findNested ( as , names , v . getShortName ( ) ) ; \nArray mdata = m . getDataArray ( ) ; \nif ( mdata instanceof ArraySequenceNested ) { \nArraySequenceNested arraySeq = ( ArraySequenceNested ) mdata ; \nreturn arraySeq . flatten ( ) ; \n} \nreturn mdata ; \n} \nreturn data ; \n} \n} \n"}
{"5661": "public class EcmwfLocalConcepts { \nprivate void addLocalConcept ( InputStream is , String conceptName ) throws IOException { \ntry ( BufferedReader br = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ) { \nString line = br . readLine ( ) ; \nfor ( ; \n! line . startsWith ( \"#\" ) ; \n) line = br . readLine ( ) ; \nfor ( ; \ntrue ; \n) { \nHashMap < String , String > items = new HashMap < > ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nif ( ( line . length ( ) == 0 ) || line . startsWith ( \"#\" ) ) continue ; \nline = cleanLine ( line ) ; \nif ( line . contains ( \"{\" ) ) { \nString paramName = line . split ( \"=\" ) [ 0 ] . trim ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \nfor ( ; \nline . contains ( \"=\" ) ; \n) { \nString [ ] kvp = line . split ( \"=\" ) ; \nitems . put ( kvp [ 0 ] . trim ( ) , kvp [ 1 ] . trim ( ) ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \n} \nString tableVersion = items . get ( TABLE_VERSION_ID ) ; \nString parameterNumber = items . get ( PARAM_NUM_ID ) ; \nstoreConcept ( tableVersion , parameterNumber , conceptName , paramName ) ; \n} \n} \n} \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nfor ( ; \ndsIter . hasNext ( ) ; \n) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni ++ ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5677": "public class ScalablePicture { \npublic void sourceLoadProgressNotification ( int statusCode , int percentage ) { \nEnumeration e = scalablePictureStatusListeners . elements ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \n( ( ScalablePictureListener ) e . nextElement ( ) ) . sourceLoadProgressNotification ( statusCode , percentage ) ; \n} \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nfor ( ; \n! done ; \n) { \nfor ( int group = 0 ; \ngroup < belowGroups . length ; \ngroup ++ ) { \nif ( above ) { \npartToCheck = aboveGroups [ group ] ; \n} \nelse { \npartToCheck = belowGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \n} \nif ( ! above ) { \nabove = true ; \n} \nelse { \ndone = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nint lo = lo0 ; \nint hi = hi0 ; \nString mid ; \nif ( hi0 > lo0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nfor ( ; \nlo <= hi ; \n) { \nfor ( ; \n( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ; \n) ++ lo ; \nfor ( ; \n( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ; \n) -- hi ; \nif ( lo <= hi ) { \nswap ( a , lo , hi ) ; \n++ lo ; \n-- hi ; \n} \n} \nif ( lo0 < hi ) quickSort ( a , lo0 , hi ) ; \nif ( lo < hi0 ) quickSort ( a , lo , hi0 ) ; \n} \n} \n} \n"}
{"5712": "public class DapSerializer { \nprotected void writeStructure ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nfor ( ; \nodom . hasNext ( ) ; \n) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteStructure1 ( instance [ 0 ] , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) for ( ; \nodom . hasNext ( ) ; \n) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"5812": "public class MessageBroker { \npublic void process ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nfor ( ; \ntrue ; \n) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = process ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nfor ( ; \nstart < b . have ; \n) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5815": "public class Ceparse { \nvoid markStackedVariables ( Stack s ) { \nStack bts = new Stack ( ) ; \nfor ( ; \n! s . empty ( ) ; \n) { \nbts . push ( s . pop ( ) ) ; \n} \nfor ( ; \nbts . size ( ) > 1 ; \n) { \nServerMethods ct = ( ServerMethods ) bts . pop ( ) ; \nct . setProject ( true , false ) ; \n} \nServerMethods bt = ( ServerMethods ) bts . pop ( ) ; \nbt . setProject ( true , true ) ; \n} \n} \n"}
{"5857": "public class FluentLoggerFactory { \nprotected synchronized void purgeLogger ( FluentLogger logger ) { \nIterator < Entry < FluentLogger , String > > it = loggers . entrySet ( ) . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nif ( it . next ( ) . getKey ( ) == logger ) { \nit . remove ( ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"5864": "public class ListTransformation { \nprivate void initListEvents ( ) { \nthis . listChangeListener = new ListChangeListener < SourceType > ( ) { \n@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { \nList < TargetType > deleteStaging = new ArrayList < > ( ) ; \nfor ( ; \nlistEvent . next ( ) ; \n) { \nif ( listEvent . wasUpdated ( ) ) { \nprocessUpdateEvent ( listEvent ) ; \n} \nelse if ( listEvent . wasReplaced ( ) ) { \nprocessReplaceEvent ( listEvent , deleteStaging ) ; \n} \nelse if ( listEvent . wasAdded ( ) ) { \nprocessAddEvent ( listEvent ) ; \n} \nelse if ( listEvent . wasRemoved ( ) ) { \nprocessRemoveEvent ( listEvent , deleteStaging ) ; \n} \n} \nprocessStagingLists ( deleteStaging ) ; \n} \n} \n; \nmodelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; \n} \n} \n"}
{"5883": "public class CoverageDataPng { \npublic int [ ] getPixelValues ( byte [ ] imageBytes ) { \nPngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; \nvalidateImageType ( reader ) ; \nint [ ] pixels = new int [ reader . imgInfo . cols * reader . imgInfo . rows ] ; \nint rowNumber = 0 ; \nfor ( ; \nreader . hasMoreRows ( ) ; \n) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] rowValues = row . getScanline ( ) ; \nSystem . arraycopy ( rowValues , 0 , pixels , rowNumber * reader . imgInfo . cols , rowValues . length ) ; \nrowNumber ++ ; \n} \nreader . close ( ) ; \nreturn pixels ; \n} \n} \n"}
{"5925": "public class ManualFeatureQuery { \npublic ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { \nList < Long > featureIds = new ArrayList < > ( ) ; \nlong offset = 0 ; \nboolean hasResults = true ; \nminX -= tolerance ; \nmaxX += tolerance ; \nminY -= tolerance ; \nmaxY += tolerance ; \nfor ( ; \nhasResults ; \n) { \nhasResults = false ; \nFeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; \ntry { \nfor ( ; \nfeatureCursor . moveToNext ( ) ; \n) { \nhasResults = true ; \nFeatureRow featureRow = featureCursor . getRow ( ) ; \nGeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; \nif ( envelope != null ) { \ndouble minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; \ndouble maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; \ndouble minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; \ndouble maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; \nif ( minXMax <= maxXMin && minYMax <= maxYMin ) { \nfeatureIds . add ( featureRow . getId ( ) ) ; \n} \n} \n} \n} \nfinally { \nfeatureCursor . close ( ) ; \n} \noffset += chunkLimit ; \n} \nManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; \nreturn results ; \n} \n} \n"}
{"5953": "public class StyleMappingDao { \npublic List < StyleMappingRow > queryByBaseFeatureId ( long id ) { \nList < StyleMappingRow > rows = new ArrayList < > ( ) ; \nUserCustomCursor cursor = queryByBaseId ( id ) ; \ntry { \nfor ( ; \ncursor . moveToNext ( ) ; \n) { \nrows . add ( getRow ( cursor ) ) ; \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn rows ; \n} \n} \n"}
{"5990": "public class TileCreator { \nprivate Bitmap drawTile ( TileMatrix tileMatrix , TileCursor tileResults , BoundingBox requestProjectedBoundingBox , int tileWidth , int tileHeight ) { \nBitmap tileBitmap = null ; \nCanvas canvas = null ; \nPaint paint = null ; \nfor ( ; \ntileResults . moveToNext ( ) ; \n) { \nTileRow tileRow = tileResults . getRow ( ) ; \nBitmap tileDataBitmap = tileRow . getTileDataBitmap ( ) ; \nBoundingBox tileBoundingBox = TileBoundingBoxUtils . getBoundingBox ( tileSetBoundingBox , tileMatrix , tileRow . getTileColumn ( ) , tileRow . getTileRow ( ) ) ; \nBoundingBox overlap = requestProjectedBoundingBox . overlap ( tileBoundingBox ) ; \nif ( overlap != null ) { \nRect src = TileBoundingBoxAndroidUtils . getRectangle ( tileMatrix . getTileWidth ( ) , tileMatrix . getTileHeight ( ) , tileBoundingBox , overlap ) ; \nRectF dest = TileBoundingBoxAndroidUtils . getRoundedFloatRectangle ( tileWidth , tileHeight , requestProjectedBoundingBox , overlap ) ; \nif ( tileBitmap == null ) { \ntileBitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; \ncanvas = new Canvas ( tileBitmap ) ; \npaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; \n} \ncanvas . drawBitmap ( tileDataBitmap , src , dest , paint ) ; \n} \n} \nreturn tileBitmap ; \n} \n} \n"}
{"6066": "public class CoverageDataPngImage { \nprivate void readPixels ( ) { \nif ( reader != null ) { \npixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; \nint rowCount = 0 ; \nfor ( ; \nreader . hasMoreRows ( ) ; \n) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] columnValues = new int [ reader . imgInfo . cols ] ; \nSystem . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; \npixels [ rowCount ++ ] = columnValues ; \n} \nreader . close ( ) ; \n} \n} \n} \n"}
{"6142": "public class GeoPackageMetadataDataSource { \npublic List < GeoPackageMetadata > getAll ( ) { \nList < GeoPackageMetadata > allMetadata = new ArrayList < GeoPackageMetadata > ( ) ; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , null , null , null , null , null ) ; \ntry { \nfor ( ; \ncursor . moveToNext ( ) ; \n) { \nGeoPackageMetadata metadata = createGeoPackageMetadata ( cursor ) ; \nallMetadata . add ( metadata ) ; \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn allMetadata ; \n} \n} \n"}
{"6150": "public class GeoPackageMetadataDataSource { \nprivate List < String > getMetadataWhereNameLike ( String like , String sortColumn , boolean notLike ) { \nList < String > names = new ArrayList < > ( ) ; \nStringBuilder where = new StringBuilder ( GeoPackageMetadata . COLUMN_NAME ) ; \nif ( notLike ) { \nwhere . append ( \" not\" ) ; \n} \nwhere . append ( \" like ?\" ) ; \nString [ ] whereArgs = new String [ ] { \nlike } \n; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , new String [ ] { \nGeoPackageMetadata . COLUMN_NAME } \n, where . toString ( ) , whereArgs , null , null , sortColumn ) ; \ntry { \nfor ( ; \ncursor . moveToNext ( ) ; \n) { \nnames . add ( cursor . getString ( 0 ) ) ; \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn names ; \n} \n} \n"}
{"6163": "public class ConverterUtil { \npublic static < E > void startConverters ( Converter < E > head ) { \nConverter < E > c = head ; \nfor ( ; \nc != null ; \n) { \nif ( c instanceof CompositeConverter ) { \nCompositeConverter < E > cc = ( CompositeConverter < E > ) c ; \nConverter < E > childConverter = cc . childConverter ; \nstartConverters ( childConverter ) ; \ncc . start ( ) ; \n} \nelse if ( c instanceof DynamicConverter ) { \nDynamicConverter < E > dc = ( DynamicConverter < E > ) c ; \ndc . start ( ) ; \n} \nc = c . getNext ( ) ; \n} \n} \n} \n"}
{"6171": "public class FileNamePattern { \npublic String toRegexForFixedDate ( Date date ) { \nStringBuilder buf = new StringBuilder ( ) ; \nConverter < Object > p = headTokenConverter ; \nfor ( ; \np != null ; \n) { \nif ( p instanceof LiteralConverter ) { \nbuf . append ( p . convert ( null ) ) ; \n} \nelse if ( p instanceof IntegerTokenConverter ) { \nbuf . append ( FileFinder . regexEscapePath ( \"(\\\\d+)\" ) ) ; \n} \nelse if ( p instanceof DateTokenConverter ) { \nDateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; \nif ( dtc . isPrimary ( ) ) { \nbuf . append ( p . convert ( date ) ) ; \n} \nelse { \nbuf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; \n} \n} \np = p . getNext ( ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6189": "public class EnsureExceptionHandling { \npublic boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { \nConverter < ILoggingEvent > c = head ; \nfor ( ; \nc != null ; \n) { \nif ( c instanceof ThrowableHandlingConverter ) { \nreturn true ; \n} \nc = c . getNext ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"6237": "public class DefaultSocketConnector { \npublic Socket call ( ) throws InterruptedException { \nuseDefaultsForMissingFields ( ) ; \nSocket socket = createSocket ( ) ; \nfor ( ; \nsocket == null && ! Thread . currentThread ( ) . isInterrupted ( ) ; \n) { \nThread . sleep ( delayStrategy . nextDelay ( ) ) ; \nsocket = createSocket ( ) ; \n} \nreturn socket ; \n} \n} \n"}
{"6241": "public class Loader { \npublic static Set < URL > getResourceOccurrenceCount ( String resource , ClassLoader classLoader ) throws IOException { \nSet < URL > urlSet = new HashSet < URL > ( ) ; \nEnumeration < URL > urlEnum = classLoader . getResources ( resource ) ; \nfor ( ; \nurlEnum . hasMoreElements ( ) ; \n) { \nURL url = urlEnum . nextElement ( ) ; \nurlSet . add ( url ) ; \n} \nreturn urlSet ; \n} \n} \n"}
{"6298": "public class StatusBase { \npublic synchronized int getEffectiveLevel ( ) { \nint result = level ; \nint effLevel ; \nIterator it = iterator ( ) ; \nStatus s ; \nfor ( ; \nit . hasNext ( ) ; \n) { \ns = ( Status ) it . next ( ) ; \neffLevel = s . getEffectiveLevel ( ) ; \nif ( effLevel > result ) { \nresult = effLevel ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6311": "public class Index { \npublic JSONObject waitTask ( String taskID , long timeToWait ) throws AlgoliaException { \ntry { \nfor ( ; \ntrue ; \n) { \nJSONObject obj = client . getRequest ( \"/1/indexes/\" + encodedIndexName + \"/task/\" + URLEncoder . encode ( taskID , \"UTF-8\" ) , null , false , null ) ; \nif ( obj . getString ( \"status\" ) . equals ( \"published\" ) ) { \nreturn obj ; \n} \ntry { \nThread . sleep ( timeToWait >= MAX_TIME_MS_TO_WAIT ? MAX_TIME_MS_TO_WAIT : timeToWait ) ; \n} \ncatch ( InterruptedException e ) { \ncontinue ; \n} \nfinal long newTimeout = timeToWait * 2 ; \ntimeToWait = ( newTimeout <= 0 || newTimeout >= MAX_TIME_MS_TO_WAIT ) ? MAX_TIME_MS_TO_WAIT : newTimeout ; \n} \n} \ncatch ( JSONException e ) { \nthrow new AlgoliaException ( e . getMessage ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"6313": "public class AbstractClient { \nprivate static String _toCharArray ( InputStream stream ) throws IOException { \nInputStreamReader is = new InputStreamReader ( stream , \"UTF-8\" ) ; \nStringBuilder builder = new StringBuilder ( ) ; \nchar [ ] buf = new char [ 1000 ] ; \nint l = 0 ; \nfor ( ; \nl >= 0 ; \n) { \nbuilder . append ( buf , 0 , l ) ; \nl = is . read ( buf ) ; \n} \nis . close ( ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"6314": "public class AbstractClient { \nprivate static byte [ ] _toByteArray ( InputStream stream ) throws AlgoliaException { \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nint read ; \nbyte [ ] buffer = new byte [ 1024 ] ; \ntry { \nfor ( ; \n( read = stream . read ( buffer , 0 , buffer . length ) ) != - 1 ; \n) { \nout . write ( buffer , 0 , read ) ; \n} \nout . flush ( ) ; \nreturn out . toByteArray ( ) ; \n} \ncatch ( IOException e ) { \nthrow new AlgoliaException ( \"Error while reading stream: \" + e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"6315": "public class AbstractClient { \nprivate static void consumeQuietly ( final HttpURLConnection connection ) { \ntry { \nint read = 0 ; \nfor ( ; \nread != - 1 ; \n) { \nread = connection . getInputStream ( ) . read ( ) ; \n} \nconnection . getInputStream ( ) . close ( ) ; \nread = 0 ; \nfor ( ; \nread != - 1 ; \n) { \nread = connection . getErrorStream ( ) . read ( ) ; \n} \nconnection . getErrorStream ( ) . close ( ) ; \nconnection . disconnect ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nint i = 0 ; \nfor ( ; \ni < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ; \n) { \ni ++ ; \n} \nif ( i < firstVersion . length && i < secondVersion . length ) { \nint diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \nelse { \nreturn Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) { \ncontext . read ( ) ; \n} \nreadJsonSyntaxChar ( QUOTE ) ; \nfor ( ; \ntrue ; \n) { \nbyte ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) { \nbreak ; \n} \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ch == ESCSEQ [ 1 ] ) { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nshort cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( Character . isHighSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) > 0 ) { \nthrow new ProtocolException ( \"Expected low surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \n} \nelse if ( Character . isLowSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) == 0 ) { \nthrow new ProtocolException ( \"Expected high surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse { \nbuffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \n} \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \nelse { \nint off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) { \nthrow new ProtocolException ( \"Expected control char\" ) ; \n} \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6337": "public class JsonProtocol { \nprivate String readJsonNumericChars ( ) throws IOException { \nStringBuilder strbld = new StringBuilder ( ) ; \nfor ( ; \ntrue ; \n) { \nbyte ch = reader . peek ( ) ; \nif ( ! isJsonNumeric ( ch ) ) { \nbreak ; \n} \nstrbld . append ( ( char ) reader . read ( ) ) ; \n} \nreturn strbld . toString ( ) ; \n} \n} \n"}
{"6357": "public class ConditionTerm { \npublic static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { \nConditionTerm term = new ConditionTerm ( ) ; \ntry { \nint token = tokenizer . ttype ; \nif ( token == '(' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"(\" ) ) ; \nfor ( ; \ntoken == StreamTokenizer . TT_WORD || token == '<' || token == '[' ; \n) { \nterm . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; \ntoken = tokenizer . ttype ; \n} \nif ( token == ')' ) token = tokenizer . nextToken ( ) ; \nelse throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \")\" ) ) ; \n} \ncatch ( IOException exc ) { \n} \nif ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingStateOrEntity\" ) ) ; \nreturn term ; \n} \n} \n"}
{"6358": "public class ConditionTerm { \npublic boolean matches ( ConditionTerm conditionTerm ) { \nint numberOfItemsToMatch = 0 ; \nboolean match = true ; \nEnumeration factors = getConditionFactors ( ) ; \nfor ( ; \nmatch && factors . hasMoreElements ( ) ; \n) { \nConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; \nif ( factor . not ( ) ) { \nmatch = ! conditionTerm . contains ( factor ) ; \n} \nelse { \nmatch = conditionTerm . contains ( factor ) ; \nnumberOfItemsToMatch ++ ; \n} \n} \nmatch = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; \nreturn match ; \n} \n} \n"}
{"6365": "public class HrefSet { \npublic void insertHrefBefore ( String newHref , String refHref ) { \nString refHrefEncoded = encodeHref ( refHref ) ; \nString newHrefEncoded = encodeHref ( newHref ) ; \nif ( isDuplicate ( newHrefEncoded ) ) return ; \nElement child = getFirstChild ( root , \"href\" ) ; \nfor ( ; \nchild != null ; \n) { \nif ( refHrefEncoded . equals ( getFirstText ( child ) ) ) { \ninsertBefore ( child , \"href\" , newHrefEncoded ) ; \nreturn ; \n} \nchild = getNextSibling ( child , \"href\" ) ; \n} \nAssert . isTrue ( false , Policy . bind ( \"assert.noHrefRef\" ) ) ; \n} \n} \n"}
{"6366": "public class HrefSet { \npublic void removeHref ( String href ) { \nString encodedHref = encodeHref ( href ) ; \nElement child = getFirstChild ( root , \"href\" ) ; \nfor ( ; \nchild != null ; \n) { \nif ( encodedHref . equals ( getFirstText ( child ) ) ) { \nroot . removeChild ( child ) ; \nreturn ; \n} \nchild = getNextSibling ( child , \"href\" ) ; \n} \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( file == null ) { \n( ( ByteArrayInputStream ) is ) . reset ( ) ; \n} \nelse { \nif ( fos != null ) { \nfor ( ; \nskip ( 4096 ) > 0 ; \n) ; \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) { \nlength = totalBytesRead ; \n} \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \ntotalBytesRead = 0 ; \n} \n} \n"}
{"6397": "public class FieldEditorPropertyPage { \nprotected void applyFont ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nfor ( ; \ne . hasNext ( ) ; \n) { \nFieldEditor pe = e . next ( ) ; \n} \n} \n} \n} \n"}
{"6398": "public class FieldEditorPropertyPage { \nprivate int calcNumberOfColumns ( ) { \nint result = 0 ; \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nfor ( ; \ne . hasNext ( ) ; \n) { \nFieldEditor pe = e . next ( ) ; \nresult = Math . max ( result , pe . getNumberOfControls ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6399": "public class FieldEditorPropertyPage { \nprotected void initialize ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nfor ( ; \ne . hasNext ( ) ; \n) { \nFieldEditor pe = e . next ( ) ; \npe . setPage ( this ) ; \npe . setPropertyChangeListener ( this ) ; \npe . setPreferenceStore ( getPreferenceStore ( ) ) ; \npe . load ( ) ; \n} \n} \n} \n} \n"}
{"6413": "public class Precondition { \npublic void addCondition ( Condition condition ) throws WebDAVException { \nEnumeration conditions = getConditions ( ) ; \nif ( condition . getResourceURI ( ) != null ) { \nfor ( ; \nconditions . hasMoreElements ( ) ; \n) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nif ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMultipleSpecification\" , condition . getResourceURI ( ) ) ) ; \n} \n} \nthis . conditions . addElement ( condition ) ; \n} \n} \n"}
{"6415": "public class Precondition { \npublic boolean matches ( Condition condition ) { \nboolean match = false ; \nEnumeration conditions = getConditions ( ) ; \nfor ( ; \n! match && conditions . hasMoreElements ( ) ; \n) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nmatch = existingCondition . matches ( condition ) ; \n} \nreturn match ; \n} \n} \n"}
{"6419": "public class DSLRuleCompletionProcessor { \npublic String getLastLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nfor ( ; \n( line = breader . readLine ( ) ) != null ; \n) { \nif ( line . length ( ) > 0 ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 ) { \nlast = last . substring ( last . lastIndexOf ( \"(\" ) + 1 ) ; \n} \nif ( last . indexOf ( \",\" ) > - 1 ) { \nlast = last . substring ( last . lastIndexOf ( \",\" ) + 1 ) ; \n} \nif ( last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \nreturn last ; \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nfor ( ; \n( line = breader . readLine ( ) ) != null ; \n) { \nline = line . trim ( ) ; \nif ( line . length ( ) > 0 && ! line . startsWith ( \"-\" ) ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 && ! last . endsWith ( \")\" ) ) { \nlast = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \n} \nelse if ( last . indexOf ( \"(\" ) > - 1 && last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \nreturn last ; \n} \n} \n"}
{"6435": "public class Condition { \npublic boolean contains ( ConditionTerm term ) { \nboolean match = false ; \nEnumeration terms = getConditionTerms ( ) ; \nfor ( ; \n! match && terms . hasMoreElements ( ) ; \n) { \nConditionTerm t = ( ConditionTerm ) terms . nextElement ( ) ; \nmatch = term . matches ( t ) ; \n} \nreturn match ; \n} \n} \n"}
{"6445": "public class AbstractCompletionProcessor { \nprotected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { \nif ( prefix != null && prefix . trim ( ) . length ( ) > 0 ) { \nIterator < ICompletionProposal > iterator = props . iterator ( ) ; \nString prefixLc = prefix . toLowerCase ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nICompletionProposal item = iterator . next ( ) ; \nString content = item . getDisplayString ( ) . toLowerCase ( ) ; \nif ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) { \niterator . remove ( ) ; \n} \n} \n} \n} \n} \n"}
{"6447": "public class ReteooLayoutFactory { \npublic static RowList calculateReteRows ( BaseVertex root ) { \nRowList rowList = new RowList ( ) ; \nrowList . add ( 0 , root ) ; \nint curRow = 0 ; \nfinal Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; \nseenVertices . add ( root ) ; \nfor ( ; \ncurRow < rowList . getDepth ( ) ; \n) { \nfinal List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; \nfor ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; \nrowNodeIter . hasNext ( ) ; \n) { \nfinal BaseVertex rowNode = rowNodeIter . next ( ) ; \nfinal List < Connection > edges = rowNode . getSourceConnections ( ) ; \nfor ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; \nedgeIter . hasNext ( ) ; \n) { \nfinal Connection edge = edgeIter . next ( ) ; \nfinal BaseVertex destNode = edge . getOpposite ( rowNode ) ; \nif ( ! seenVertices . contains ( destNode ) ) { \nrowList . add ( curRow + 1 , destNode ) ; \nseenVertices . add ( destNode ) ; \n} \n} \nseenVertices . add ( rowNode ) ; \n} \n++ curRow ; \n} \nrowList . optimize ( ) ; \nreturn rowList ; \n} \n} \n"}
{"6460": "public class DroolsDebugTarget { \npublic DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { \nif ( source == null ) { \nreturn null ; \n} \nIterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nIJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; \nif ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( \"mvel\" ) ) { \nDroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; \ntry { \nint matchLine = l . getLineNumber ( ) ; \nString matchSource = l . getRuleName ( ) ; \nif ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) { \nreturn l ; \n} \n} \ncatch ( CoreException e ) { \nlogError ( e ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6463": "public class AbstractResourceHandle { \npublic void copy ( ILocator destination , String depth , boolean overwrite , Collection propertyNames ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setDepth ( depth ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( propertyNames == null ) propertyBehavior . setIsKeepAllAlive ( true ) ; \nelse { \nIterator namesItr = propertyNames . iterator ( ) ; \nfor ( ; \nnamesItr . hasNext ( ) ; \n) { \nQualifiedName name = ( QualifiedName ) namesItr . next ( ) ; \nString nameURI = name . getQualifier ( ) + \"/\" + name . getLocalName ( ) ; \npropertyBehavior . addProperty ( nameURI ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . copy ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6464": "public class AbstractResourceHandle { \nprotected void examineMultiStatusResponse ( IResponse response ) throws DAVException { \nif ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) return ; \nif ( ! response . hasDocumentBody ( ) ) throw new DAVException ( Policy . bind ( \"exception.responseMustHaveDocBody\" ) ) ; \nElement documentElement ; \ntry { \ndocumentElement = response . getDocumentBody ( ) . getDocumentElement ( ) ; \nif ( documentElement == null ) throw new DAVException ( Policy . bind ( \"exception.invalidDoc\" ) ) ; \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \ntry { \nMultiStatus multistatus = new MultiStatus ( documentElement ) ; \nEnumeration responseEnum = multistatus . getResponses ( ) ; \nfor ( ; \nresponseEnum . hasMoreElements ( ) ; \n) { \nResponseBody responseBody = ( ResponseBody ) responseEnum . nextElement ( ) ; \nEnumeration propstatEnum = responseBody . getPropStats ( ) ; \nfor ( ; \npropstatEnum . hasMoreElements ( ) ; \n) { \nPropStat propstat = ( PropStat ) propstatEnum . nextElement ( ) ; \nexamineStatusCode ( propstat . getStatusCode ( ) , propstat . getResponseDescription ( ) ) ; \n} \n} \n} \ncatch ( MalformedElementException e ) { \nthrow new SystemException ( e ) ; \n} \n} \n} \n"}
{"6465": "public class AbstractResourceHandle { \nprotected URLTable extractPropStats ( MultiStatus multiStatus ) throws IOException , MalformedElementException { \nURLTable reply = new URLTable ( ) ; \nEnumeration responses = multiStatus . getResponses ( ) ; \nfor ( ; \nresponses . hasMoreElements ( ) ; \n) { \nResponseBody responseBody = ( ResponseBody ) responses . nextElement ( ) ; \nString href = responseBody . getHref ( ) ; \nURL resourceURL = new URL ( new URL ( locator . getResourceURL ( ) ) , href ) ; \nHashtable properties = new Hashtable ( ) ; \nreply . put ( resourceURL , properties ) ; \nEnumeration propstats = responseBody . getPropStats ( ) ; \nfor ( ; \npropstats . hasMoreElements ( ) ; \n) { \nPropStat propstat = ( PropStat ) propstats . nextElement ( ) ; \norg . eclipse . webdav . dom . Status status = new org . eclipse . webdav . dom . Status ( propstat . getStatus ( ) ) ; \nEnumeration elements = propstat . getProp ( ) . getProperties ( ) ; \nfor ( ; \nelements . hasMoreElements ( ) ; \n) { \nElement element = ( Element ) elements . nextElement ( ) ; \nQualifiedName name = ElementEditor . getQualifiedName ( element ) ; \nPropertyStatus propertyStatus = new PropertyStatus ( element , status . getStatusCode ( ) , status . getStatusMessage ( ) ) ; \nproperties . put ( name , propertyStatus ) ; \n} \n} \n} \nreturn reply ; \n} \n} \n"}
{"6471": "public class AbstractResourceHandle { \npublic void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( names == null ) { \npropertyBehavior . setIsKeepAllAlive ( true ) ; \n} \nelse { \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nObject obj = names . nextElement ( ) ; \nAssert . isTrue ( obj instanceof QualifiedName , Policy . bind ( \"assert.propNameMustBeEnumOverQual\" ) ) ; \npropertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . move ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6474": "public class AbstractResourceHandle { \npublic void removeProperties ( Collection propertyNames ) throws DAVException { \nAssert . isNotNull ( propertyNames ) ; \nif ( propertyNames . isEmpty ( ) ) return ; \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addRemove ( ) ; \nIterator namesItr = propertyNames . iterator ( ) ; \nfor ( ; \nnamesItr . hasNext ( ) ; \n) prop . addPropertyName ( ( QualifiedName ) namesItr . next ( ) ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6477": "public class AbstractResourceHandle { \npublic void setProperties ( Collection properties ) throws DAVException { \nAssert . isNotNull ( properties ) ; \nif ( properties . isEmpty ( ) ) return ; \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addSet ( ) ; \nIterator propertiesItr = properties . iterator ( ) ; \nfor ( ; \npropertiesItr . hasNext ( ) ; \n) { \nElement element = ( Element ) propertiesItr . next ( ) ; \ntry { \nprop . addProperty ( element ) ; \n} \ncatch ( MalformedElementException exception ) { \nthrow new SystemException ( exception ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nfor ( ; \nbytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ; \n) { \nif ( contentLength == - 1 ) { \nbytesRead = is . read ( buffer ) ; \n} \nelse { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nif ( bytesRead == - 1 ) { \nif ( contentLength >= 0 ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \nelse { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6496": "public class Parser { \npublic void skipWhiteSpace ( ) { \nfor ( ; \npos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ; \n) ++ pos ; \n} \n} \n"}
{"6508": "public class DSLTree { \nprotected void parseFile ( BufferedReader reader ) { \nString line = null ; \ntry { \nfor ( ; \n( line = reader . readLine ( ) ) != null ; \n) { \nSection section = getSection ( line ) ; \nString nl = stripHeadingAndCode ( line ) ; \nString objname = this . getObjMetadata ( nl ) ; \nnl = this . stripObjMetadata ( nl ) ; \naddEntry ( section , nl , objname ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"6512": "public class DSLTree { \npublic Node [ ] getConditionChildren ( String text ) { \nNode thenode = this . rootCond ; \nif ( text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nfor ( ; \ntokenz . hasMoreTokens ( ) ; \n) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) { \nfor ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nint index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null && obj . startsWith ( substring ) ) { \nthenode = child ; \n} \n} \n} \n} \n} \nif ( thenode != null && text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nfor ( ; \ntokenz . hasMoreTokens ( ) ; \n) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nif ( thenode == null ) { \nreturn null ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6520": "public class HttpClient { \npublic Response invoke ( Request request ) throws IOException { \nAssert . isNotNull ( request ) ; \ntry { \nopen ( ) ; \nURL resourceUrl = request . getResourceUrl ( ) ; \nURL originServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , \"/\" ) ; \nURL proxyServerUrl = getProxyServerUrl ( originServerUrl ) ; \nif ( proxyServerUrl == null && ! matchesProxyServerException ( originServerUrl ) ) { \nproxyServerUrl = getDefaultProxyServerUrl ( ) ; \n} \nIContext context = webDAVFactory . newContext ( request . getContext ( ) ) ; \nIContext defaultContext = getContext ( originServerUrl ) ; \nif ( defaultContext == null ) { \ndefaultContext = getDefaultContext ( ) ; \n} \nif ( defaultContext != null ) { \nEnumeration e = defaultContext . keys ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \nString key = ( String ) e . nextElement ( ) ; \ncontext . put ( key , defaultContext . get ( key ) ) ; \n} \n} \nif ( authority != null ) { \nauthority . authorize ( request , null , context , proxyServerUrl , true ) ; \nauthority . authorize ( request , null , context , proxyServerUrl , false ) ; \n} \nreturn invoke1 ( request , context , proxyServerUrl , originServerUrl , 0 , 0 ) ; \n} \nfinally { \nrequest . close ( ) ; \n} \n} \n} \n"}
{"6542": "public class YubikeyToUserMapImpl { \nprivate String get_username_for_id ( String publicId , String filename ) throws FileNotFoundException { \nScanner sc = null ; \nFile file = new File ( filename ) ; \ntry { \nsc = new Scanner ( file ) ; \nfor ( ; \nsc . hasNextLine ( ) ; \n) { \nString line = sc . nextLine ( ) ; \nif ( line . startsWith ( \"yk.\" + publicId + \".user\" ) ) { \nString ykuser = line . split ( \"=\" ) [ 1 ] . trim ( ) ; \nreturn ykuser ; \n} \n} \n} \nfinally { \nif ( sc != null ) { \nsc . close ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6544": "public class HttpOathOtpLoginModule { \nboolean verify_otp ( String userName , String otp ) { \ntry { \nString authString = userName + \":\" + otp ; \nString authStringEnc = Base64 . encodeBase64URLSafeString ( authString . getBytes ( ) ) ; \nBufferedReader in = attemptAuthentication ( authStringEnc ) ; \nString inputLine ; \nfor ( ; \n( inputLine = in . readLine ( ) ) != null ; \n) { \nif ( inputLine . contains ( expectedOutput ) ) { \nreturn true ; \n} \n} \n} \ncatch ( Exception ex ) { \nlog . error ( \"Failed verifying OATH OTP :\" , ex ) ; \n} \nreturn false ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nfor ( ; \n( c = ReadByte ( ) ) == 'u' ; \n) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6581": "public class OgnlParserTokenManager { \nprivate char escapeChar ( ) { \nint ofs = image . length ( ) - 1 ; \nswitch ( image . charAt ( ofs ) ) { \ncase 'n' : return '\\n' ; \ncase 'r' : return '\\r' ; \ncase 't' : return '\\t' ; \ncase 'b' : return '\\b' ; \ncase 'f' : return '\\f' ; \ncase '\\\\' : return '\\\\' ; \ncase '\\'' : return '\\'' ; \ncase '\\\"' : return '\\\"' ; \n} \nfor ( ; \nimage . charAt ( -- ofs ) != '\\\\' ; \n) { \n} \nint value = 0 ; \nfor ( ; \n++ ofs < image . length ( ) ; \n) value = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; \nreturn ( char ) value ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nint verifyWaitDelay = 1000 ; \nfor ( ; \n! started ; \n) { \nif ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) { \nthrow new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \n} \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( startTimeout > 0 ) { \nint connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( connectTimeOut > 0 ) { \nconn . setConnectTimeout ( connectTimeOut ) ; \n} \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( startTimeout > 0 ) { \nsleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \n} \nif ( sleepTime > 0 ) { \ntry { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6589": "public class Play2BuildFailure { \nprivate String readFileAsString ( ) throws IOException { \nFileInputStream is = new FileInputStream ( e . source ( ) ) ; \ntry { \nbyte [ ] buffer = new byte [ 8192 ] ; \nint len = is . read ( buffer ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nfor ( ; \nlen != - 1 ; \n) { \nout . write ( buffer , 0 , len ) ; \nlen = is . read ( buffer ) ; \n} \nreturn charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \n} \n"}
{"6593": "public class AbstractPlay2SourcePositionMapper { \nprotected String readFileAsString ( File file ) throws IOException { \nFileInputStream is = new FileInputStream ( file ) ; \ntry { \nbyte [ ] buffer = new byte [ 8192 ] ; \nint len = is . read ( buffer ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nfor ( ; \nlen != - 1 ; \n) { \nout . write ( buffer , 0 , len ) ; \nlen = is . read ( buffer ) ; \n} \nreturn charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse if ( len == 0 ) { \nreturn ; \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nfor ( ; \nremaining > 0 ; \n) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6627": "public class ByteArrayOutputStream { \npublic synchronized int write ( InputStream in ) throws IOException { \nint readCount = 0 ; \nint inBufferPos = count - filledBufferSum ; \nint n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \nfor ( ; \nn != - 1 ; \n) { \nreadCount += n ; \ninBufferPos += n ; \ncount += n ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( currentBuffer . length ) ; \ninBufferPos = 0 ; \n} \nn = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \n} \nreturn readCount ; \n} \n} \n"}
{"6645": "public class RTOperationManager { \nsynchronized void executed ( RTEditText editor , Operation op ) { \nStack < Operation > undoStack = getUndoStack ( editor ) ; \nStack < Operation > redoStack = getRedoStack ( editor ) ; \nfor ( ; \n! undoStack . empty ( ) && op . canMerge ( undoStack . peek ( ) ) ; \n) { \nOperation previousOp = undoStack . pop ( ) ; \nop . merge ( previousOp ) ; \n} \npush ( op , undoStack ) ; \nredoStack . clear ( ) ; \n} \n} \n"}
{"6646": "public class RTOperationManager { \nsynchronized void redo ( RTEditText editor ) { \nStack < Operation > redoStack = getRedoStack ( editor ) ; \nif ( ! redoStack . empty ( ) ) { \nStack < Operation > undoStack = getUndoStack ( editor ) ; \nOperation op = redoStack . pop ( ) ; \npush ( op , undoStack ) ; \nop . redo ( editor ) ; \nfor ( ; \n! redoStack . empty ( ) && op . canMerge ( redoStack . peek ( ) ) ; \n) { \nop = redoStack . pop ( ) ; \npush ( op , undoStack ) ; \nop . redo ( editor ) ; \n} \n} \n} \n} \n"}
{"6647": "public class ConverterTextToHtml { \nprivate static String replaceAll ( String source , String search , String replace ) { \nif ( USE_REPLACE_ALL ) { \nreturn source . replaceAll ( search , replace ) ; \n} \nelse { \nPattern p = Pattern . compile ( search ) ; \nMatcher m = p . matcher ( source ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nboolean atLeastOneFound = false ; \nfor ( ; \nm . find ( ) ; \n) { \nm . appendReplacement ( sb , replace ) ; \natLeastOneFound = true ; \n} \nif ( atLeastOneFound ) { \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nreturn source ; \n} \n} \n} \n} \n"}
{"6661": "public class Parser { \nprivate void restart ( Element e ) throws SAXException { \nfor ( ; \ntheSaved != null && theStack . canContain ( theSaved ) && ( e == null || theSaved . canContain ( e ) ) ; \n) { \nElement next = theSaved . next ( ) ; \npush ( theSaved ) ; \ntheSaved = next ; \n} \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nfor ( ; \ntrue ; \n) { \nfor ( sp = theStack ; \nsp != null ; \nsp = sp . next ( ) ) { \nif ( sp . canContain ( e ) ) break ; \n} \nif ( sp != null ) break ; \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) break ; \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) return ; \nfor ( ; \ntheStack != sp ; \n) { \nif ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) break ; \nrestartablyPop ( ) ; \n} \nfor ( ; \ne != null ; \n) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) push ( e ) ; \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \n} \n} \n"}
{"6687": "public class HTMLWriter { \n@ SuppressWarnings ( \"unchecked\" ) private void writeNSDecls ( ) throws SAXException { \nEnumeration < String > prefixes = ( Enumeration < String > ) nsSupport . getDeclaredPrefixes ( ) ; \nfor ( ; \nprefixes . hasMoreElements ( ) ; \n) { \nString prefix = ( String ) prefixes . nextElement ( ) ; \nString uri = nsSupport . getURI ( prefix ) ; \nif ( uri == null ) { \nuri = \"\" ; \n} \nwrite ( ' ' ) ; \nif ( \"\" . equals ( prefix ) ) { \nwrite ( \"xmlns=\\\"\" ) ; \n} \nelse { \nwrite ( \"xmlns:\" ) ; \nwrite ( prefix ) ; \nwrite ( \"=\\\"\" ) ; \n} \nwriteEscUTF16 ( uri , 0 , uri . length ( ) , true ) ; \nwrite ( '\\\"' ) ; \n} \n} \n} \n"}
{"6699": "public class StringUtils { \nprivate static String replace ( final String inString , final String oldPattern , final String newPattern ) { \nif ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { \nreturn inString ; \n} \nfinal StringBuffer sbuf = new StringBuffer ( ) ; \nint pos = 0 ; \nint index = inString . indexOf ( oldPattern ) ; \nfinal int patLen = oldPattern . length ( ) ; \nfor ( ; \nindex >= 0 ; \n) { \nsbuf . append ( inString . substring ( pos , index ) ) ; \nsbuf . append ( newPattern ) ; \npos = index + patLen ; \nindex = inString . indexOf ( oldPattern , pos ) ; \n} \nsbuf . append ( inString . substring ( pos ) ) ; \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"6743": "public class Injector { \nprivate Collection < Field > getAllFields ( final Object object ) { \nfinal Collection < Field > fields = new ArrayList < Field > ( ) ; \nfields . addAll ( Arrays . asList ( object . getClass ( ) . getDeclaredFields ( ) ) ) ; \nClass < ? > superClass = object . getClass ( ) . getSuperclass ( ) ; \nfor ( ; \nsuperClass != null ; \n) { \nfields . addAll ( Arrays . asList ( superClass . getDeclaredFields ( ) ) ) ; \nsuperClass = superClass . getSuperclass ( ) ; \n} \nreturn fields ; \n} \n} \n"}
{"6749": "public class CssVariablesProcessor { \nprivate Map < String , String > extractVariables ( final String variablesBody ) { \nfinal Map < String , String > map = new HashMap < String , String > ( ) ; \nfinal Matcher m = PATTERN_VARIABLES_BODY . matcher ( variablesBody ) ; \nLOG . debug ( \"parsing variables body\" ) ; \nfor ( ; \nm . find ( ) ; \n) { \nfinal String key = m . group ( 1 ) ; \nfinal String value = m . group ( 2 ) ; \nif ( map . containsKey ( key ) ) { \nLOG . warn ( \"A duplicate variable name found with name: {} and value: {}.\" , key , value ) ; \n} \nmap . put ( key , value ) ; \n} \nreturn map ; \n} \n} \n"}
{"6750": "public class CssVariablesProcessor { \nprivate String parseCss ( final String css ) { \nfinal Map < String , String > map = new HashMap < String , String > ( ) ; \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfinal Matcher m = PATTERN_VARIABLES_DEFINITION . matcher ( css ) ; \nfor ( ; \nm . find ( ) ; \n) { \nfinal String variablesBody = m . group ( 1 ) ; \nmap . putAll ( extractVariables ( variablesBody ) ) ; \nm . appendReplacement ( sb , \"\" ) ; \n} \nm . appendTail ( sb ) ; \nreturn replaceVariables ( sb . toString ( ) , map ) ; \n} \n} \n"}
{"6751": "public class CssVariablesProcessor { \nprivate String replaceVariables ( final String css , final Map < String , String > variables ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfinal Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; \nfor ( ; \nm . find ( ) ; \n) { \nfinal String oldMatch = m . group ( ) ; \nfinal String variableName = m . group ( 1 ) ; \nfinal String variableValue = variables . get ( variableName ) ; \nif ( variableValue != null ) { \nfinal String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; \nm . appendReplacement ( sb , newReplacement . trim ( ) ) ; \n} \nelse { \nLOG . warn ( \"No variable with name \" + variableName + \" was found!\" ) ; \n} \n} \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6837": "public class AbstractReasonerStage { \npublic void invalidateRecursive ( ) { \nQueue < AbstractReasonerStage > toInvalidate_ = new LinkedList < AbstractReasonerStage > ( ) ; \ntoInvalidate_ . add ( this ) ; \nAbstractReasonerStage next ; \nfor ( ; \n( next = toInvalidate_ . poll ( ) ) != null ; \n) { \nif ( next . invalidate ( ) ) { \nfor ( AbstractReasonerStage postStage : next . postStages_ ) { \ntoInvalidate_ . add ( postStage ) ; \n} \n} \n} \n} \n} \n"}
{"6859": "public class IOUtils { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ BUFFER_SIZE ] ; \nBufferedInputStream in = new BufferedInputStream ( input , BUFFER_SIZE ) ; \nBufferedOutputStream out = new BufferedOutputStream ( output , BUFFER_SIZE ) ; \nint count = 0 , n = 0 ; \ntry { \nfor ( ; \n( n = in . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ; \n) { \nout . write ( buffer , 0 , n ) ; \ncount += n ; \n} \nout . flush ( ) ; \n} \nfinally { \nIOUtils . closeQuietly ( in ) ; \nIOUtils . closeQuietly ( out ) ; \n} \nreturn count ; \n} \n} \n"}
{"6932": "public class IndentUtils { \npublic static StringBuilder indentSpace ( int len ) { \nStringBuilder sB = new StringBuilder ( ) ; \nif ( len < 1 ) { \nreturn sB ; \n} \nfor ( ; \nlen > SPACES_LENGTH_MINUS_ONE ; \n) { \nsB . append ( SPACES [ SPACES_LENGTH_MINUS_ONE ] ) ; \nlen = len - SPACES_LENGTH_MINUS_ONE ; \n} \nreturn sB . append ( SPACES [ len ] ) ; \n} \n} \n"}
{"6945": "public class LogStructureTreePanel { \nprivate TreeItem doTree ( FQDNNode localRoot ) { \nTreeItem localLeaf = new TreeItem ( ) ; \nLogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; \nlocalLeaf . setWidget ( logTreeNode ) ; \nif ( localRoot . getChildren ( ) . size ( ) > 0 ) { \nTree t = new Tree ( ) ; \nArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; \nCollections . sort ( names ) ; \nIterator it = names . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nt . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; \n} \nlocalLeaf . addItem ( t ) ; \n} \nreturn localLeaf ; \n} \n} \n"}
{"6986": "public class DeploymentManagerMBeanImpl { \nprivate File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { \nInputStream in = null ; \nOutputStream out = null ; \ntry { \nString filename = new File ( duURL . getPath ( ) ) . getName ( ) ; \nFile tempFile = new File ( deploymentRoot , filename ) ; \nout = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; \nURLConnection conn = duURL . openConnection ( ) ; \nin = conn . getInputStream ( ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nint numRead ; \nfor ( ; \n( numRead = in . read ( buffer ) ) != - 1 ; \n) { \nout . write ( buffer , 0 , numRead ) ; \n} \nreturn tempFile ; \n} \nfinally { \ntry { \nif ( in != null ) { \nin . close ( ) ; \nin = null ; \n} \nif ( out != null ) { \nout . close ( ) ; \nout = null ; \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n} \n"}
{"6988": "public class DeploymentManager { \npublic void installDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( du . isReadyToInstall ( true ) ) { \nsciAction ( du . getInstallActions ( ) , du ) ; \ndu . setInstalled ( true ) ; \ndeployedDUs . add ( du ) ; \nupdateDeployedComponents ( ) ; \nIterator < DeployableUnit > duIt = waitingForInstallDUs . iterator ( ) ; \nfor ( ; \nduIt . hasNext ( ) ; \n) { \nDeployableUnit waitingDU = duIt . next ( ) ; \nif ( waitingDU . isReadyToInstall ( false ) ) { \nsciAction ( waitingDU . getInstallActions ( ) , waitingDU ) ; \nwaitingDU . setInstalled ( true ) ; \ndeployedDUs . add ( waitingDU ) ; \nupdateDeployedComponents ( ) ; \nwaitingForInstallDUs . remove ( waitingDU ) ; \nduIt = waitingForInstallDUs . iterator ( ) ; \n} \n} \n} \nelse { \nlogger . warn ( \"Unable to INSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependencies to be resolved.\" ) ; \nwaitingForInstallDUs . add ( du ) ; \n} \n} \n} \n"}
{"6990": "public class DeploymentManager { \nprivate void processInternalUndeploy ( DeployableUnit du ) throws Exception { \ndu . setInstalled ( false ) ; \nwaitingForUninstallDUs . remove ( du ) ; \nupdateDeployedComponents ( ) ; \nIterator < DeployableUnit > duIt = waitingForUninstallDUs . iterator ( ) ; \nfor ( ; \nduIt . hasNext ( ) ; \n) { \nDeployableUnit waitingDU = duIt . next ( ) ; \nif ( waitingDU . isReadyToUninstall ( ) ) { \nsleeContainerDeployer . getSleeSubDeployer ( ) . stop ( waitingDU . getURL ( ) , waitingDU . getDeploymentInfoShortName ( ) ) ; \nwaitingForUninstallDUs . remove ( waitingDU ) ; \nduIt = waitingForUninstallDUs . iterator ( ) ; \n} \n} \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nfor ( ; \ndeployableUnits . containsKey ( fileName ) ; \n) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7038": "public class SLEESubDeployer { \npublic void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method start called for \" + du . getUrl ( ) + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \ntry { \nDeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; \nif ( realDU != null ) { \nfor ( ; \nisInUndeployList ( du . getFileName ( ) ) ; \n) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \nsleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"\" , e ) ; \n} \n} \n} \n"}
{"7072": "public class ComponentIDArrayPropertyEditor { \npublic void setAsText ( String text ) { \nif ( text == null || text . equals ( \"\" ) ) { \nsuper . setValue ( new ComponentID [ 0 ] ) ; \n} \nelse { \njava . util . ArrayList results = new java . util . ArrayList ( ) ; \njava . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; \nComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; \nfor ( ; \nst . hasMoreTokens ( ) ; \n) { \ncidPropEditor . setAsText ( st . nextToken ( ) ) ; \nif ( st . hasMoreTokens ( ) ) { \nst . nextToken ( ) ; \n} \nresults . add ( cidPropEditor . getValue ( ) ) ; \n} \nComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; \nresults . toArray ( cid ) ; \nthis . setValue ( cid ) ; \n} \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nelse if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nfor ( ; \nstringTokenizer . hasMoreTokens ( ) ; \n) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7156": "public class TracerImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { \nif ( tracerName . equals ( \"\" ) ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nString lastToken = null ; \nfor ( ; \nstringTokenizer . hasMoreTokens ( ) ; \n) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . equals ( token ) && token . equals ( \".\" ) ) { \nthrow new InvalidArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nlastToken = token ; \n} \nif ( lastToken . equals ( \".\" ) ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7179": "public class ResourceDeserializer { \nprivate String getOnType ( DeserializationContext ctxt ) { \nObject curVal = ctxt . getParser ( ) . getCurrentValue ( ) ; \nboolean isPaintingAnno = ( curVal != null && curVal instanceof Annotation && ( ( Annotation ) curVal ) . getMotivation ( ) != null && ( ( Annotation ) curVal ) . getMotivation ( ) . equals ( Motivation . PAINTING ) ) ; \nif ( isPaintingAnno ) { \nreturn \"sc:Canvas\" ; \n} \nJsonStreamContext parent = ctxt . getParser ( ) . getParsingContext ( ) . getParent ( ) ; \nfor ( ; \nparent != null && ( parent . getCurrentValue ( ) == null || ! ( parent . getCurrentValue ( ) instanceof Resource ) ) ; \n) { \nparent = parent . getParent ( ) ; \n} \nif ( parent != null ) { \nResource parentObj = ( Resource ) parent . getCurrentValue ( ) ; \nreturn parentObj . getType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nfor ( ; \n! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ; \n) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( int i = 0 ; \ni < devices . length ; \ni ++ ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7189": "public class AbstractDevice { \npublic String getDump ( ) { \npushAutomator2Device ( ) ; \nruntest ( ) ; \nString path = pullDump2PC ( ) ; \nString xml = \"\" ; \ntry { \nFileInputStream fileInputStream = new FileInputStream ( path ) ; \n@ SuppressWarnings ( \"resource\" ) BufferedReader in = new BufferedReader ( new InputStreamReader ( fileInputStream ) ) ; \nStringBuffer buffer = new StringBuffer ( ) ; \nString line = \"\" ; \nfor ( ; \n( line = in . readLine ( ) ) != null ; \n) { \nbuffer . append ( line ) ; \n} \nxml = buffer . toString ( ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn xml ; \n} \n} \n"}
{"7197": "public class TextEditor { \npublic Collection < HTMLToken > tokenizeHTML ( ) { \nList < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; \nString nestedTags = nestedTagsRegex ( 6 ) ; \nPattern p = Pattern . compile ( \"\" + \"(?s:<!(--.*?--\\\\s*)+>)\" + \"|\" + \"(?s:<\\\\?.*?\\\\?>)\" + \"|\" + nestedTags + \"\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( text ) ; \nint lastPos = 0 ; \nfor ( ; \nm . find ( ) ; \n) { \nif ( lastPos < m . start ( ) ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; \n} \ntokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; \nlastPos = m . end ( ) ; \n} \nif ( lastPos < text . length ( ) ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; \n} \nreturn tokens ; \n} \n} \n"}
{"7202": "public class BarberProcessor { \nprivate String findParentFqcn ( TypeElement typeElement , Set < String > parents ) { \nTypeMirror type ; \nfor ( ; \ntrue ; \n) { \ntype = typeElement . getSuperclass ( ) ; \nif ( type . getKind ( ) == TypeKind . NONE ) { \nreturn null ; \n} \ntypeElement = ( TypeElement ) ( ( DeclaredType ) type ) . asElement ( ) ; \nif ( parents . contains ( typeElement . toString ( ) ) ) { \nString packageName = getPackageName ( typeElement ) ; \nreturn packageName + \".\" + getClassName ( typeElement , packageName ) ; \n} \n} \n} \n} \n"}
{"7238": "public class LevelDBKeyValueStore { \n@ Override public Map < byte [ ] , byte [ ] > loadAllByKeys ( Collection < byte [ ] > keys ) { \nif ( keys == null || keys . size ( ) == 0 ) { \nreturn Collections . EMPTY_MAP ; \n} \nMap < byte [ ] , byte [ ] > results = new LinkedHashMap < > ( keys . size ( ) ) ; \nDBIterator iterator = null ; \ntry { \niterator = database . iterator ( ) ; \niterator . seek ( keys . iterator ( ) . next ( ) ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nfinal Map . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; \nresults . put ( next . getKey ( ) , next . getValue ( ) ) ; \n} \n} \nfinally { \ntry { \nif ( iterator != null ) { \niterator . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nExceptions . handle ( e ) ; \n} \n} \nreturn results ; \n} \n} \n"}
{"7266": "public class BaseDataStore { \nprivate void processReadQueue ( ) throws InterruptedException { \nReadStatus readStatus = new ReadStatus ( ) ; \nfor ( ; \ntrue ; \n) { \nDataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nfor ( ; \nrequest != null ; \n) { \nreadStatus . tracker . addCall ( request , outputDataQueue ) ; \nreadOperationsBatch . add ( request ) ; \nif ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \nrequest = readOperationsQueue . poll ( ) ; \n} \nif ( readOperationsBatch . size ( ) > 0 ) { \ntry { \nrecievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; \n} \nfinally { \nreadOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushReadsIfNeeded ( ) ; \n} \nif ( readStatus . readBatchSize . size ( ) > 1_000 ) { \nStatCount count ; \nfinal long now = Timer . timer ( ) . time ( ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; \noutputDataQueue . put ( count ) ; \nreadStatus . readBatchSize . clear ( ) ; \n} \n} \n} \n} \n"}
{"7267": "public class BaseDataStore { \nprivate void processWriteQueue ( ) throws InterruptedException { \nWriteStatus status = new WriteStatus ( ) ; \nfor ( ; \ntrue ; \n) { \nDataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nfor ( ; \noperation != null ; \n) { \nstatus . tracker . addCall ( operation , outputDataQueue ) ; \nwriteOperationsBatch . add ( operation ) ; \nif ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \noperation = writeOperationsQueue . poll ( ) ; \n} \nif ( writeOperationsBatch . size ( ) > 0 ) { \ntry { \nstatus . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; \nrecievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; \n} \nfinally { \nwriteOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushWritesIfNeeded ( ) ; \n} \nif ( status . writeBatchSize . size ( ) > 1000 ) { \nstatus . sendBatchSize ( source , outputDataQueue ) ; \n} \n} \n} \n} \n"}
{"7306": "public class Sorting { \npublic static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( list == null || list . size ( ) == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nIterator iterator = list . iterator ( ) ; \nObject object = iterator . next ( ) ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( ; \niterator . hasNext ( ) ; \n) { \nobject = iterator . next ( ) ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \nelse { \nhttpClientRequest . end ( ) ; \n} \n} \n} \n; \nif ( closed . get ( ) ) { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nfor ( ; \nclosed . get ( ) ; \n) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry ++ ; \nif ( retry > 10 ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! closed . get ( ) ) { \nrunnable . run ( ) ; \n} \nelse { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \n} \n} \n"}
{"7367": "public class CouchDbUtil { \npublic static List < String > listResources ( String path ) { \ntry { \nClass < CouchDbUtil > clazz = CouchDbUtil . class ; \nURL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"file\" ) ) { \nreturn Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; \n} \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"jar\" ) ) { \nString jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( \"!\" ) ) ; \nJarFile jar = new JarFile ( URLDecoder . decode ( jarPath , \"UTF-8\" ) ) ; \nEnumeration < JarEntry > entries = jar . entries ( ) ; \nSet < String > result = new HashSet < String > ( ) ; \nfor ( ; \nentries . hasMoreElements ( ) ; \n) { \nString name = entries . nextElement ( ) . getName ( ) ; \nif ( name . startsWith ( SPRING_BOOT_DIR ) ) { \nname = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; \n} \nif ( name . startsWith ( path ) ) { \nString entry = name . substring ( path . length ( ) ) ; \nint checkSubdir = entry . indexOf ( \"/\" ) ; \nif ( checkSubdir >= 0 ) { \nentry = entry . substring ( 0 , checkSubdir ) ; \n} \nif ( entry . length ( ) > 0 ) { \nresult . add ( entry ) ; \n} \n} \n} \nclose ( jar ) ; \nreturn new ArrayList < String > ( result ) ; \n} \nreturn null ; \n} \ncatch ( Exception e ) { \nthrow new CouchDbException ( e ) ; \n} \n} \n} \n"}
{"7432": "public class IOStreams { \npublic static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { \nbyte [ ] buffer = new byte [ bufferSize ] ; \nint numRead = Objects . requireNonNull ( in , \"Missing input\" ) . read ( buffer ) ; \nif ( numRead == 0 ) { \nthrow new IllegalArgumentException ( \"Missing content\" ) ; \n} \nObjects . requireNonNull ( out , \"Missing output\" ) ; \nfor ( ; \nnumRead > 0 ; \n) { \nout . write ( buffer , 0 , numRead ) ; \nhashAssembler . add ( buffer , numRead ) ; \nnumRead = in . read ( buffer ) ; \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( int i = 0 ; \ni < target . size ( ) ; \ni ++ ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \nfor ( int k = 0 ; \nk < numberOfSamples ; \nk ++ ) { \ndouble location = totalLength * k / numberOfSamples ; \nfor ( ; \nlocation > cornerLocationsB [ cornerB + 1 ] ; \n) { \ncornerB ++ ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < model . size ( ) + 1 ; \ni ++ ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) { \nbest = d ; \n} \n} \nerror += best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nhull . get ( i ) . set ( input [ i ] ) ; \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = input [ i ] ; \nfor ( ; \nwork . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ; \n) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \nfor ( int i = length - 1 ; \ni >= 0 ; \ni -- ) { \nPoint2D_F64 p = input [ i ] ; \nfor ( ; \nwork . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ; \n) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( int i = 0 ; \ni < work . size ( ) ; \ni ++ ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \n} \n} \n"}
{"7637": "public class InstallFeatureUtil { \npublic static Set < String > getOpenLibertyFeatureSet ( Set < File > jsons ) throws PluginExecutionException { \nSet < String > libertyFeatures = new HashSet < String > ( ) ; \nfor ( File file : jsons ) { \nScanner s = null ; \ntry { \ns = new Scanner ( file ) ; \nfor ( ; \ns . findWithinHorizon ( OPEN_LIBERTY_GROUP_ID + \":([^:]*):\" , 0 ) != null ; \n) { \nMatchResult match = s . match ( ) ; \nif ( match . groupCount ( ) >= 1 ) { \nlibertyFeatures . add ( match . group ( 1 ) ) ; \n} \n} \n} \ncatch ( FileNotFoundException e ) { \nthrow new PluginExecutionException ( \"The JSON file is not found at \" + file . getAbsolutePath ( ) , e ) ; \n} \nfinally { \nif ( s != null ) { \ns . close ( ) ; \n} \n} \n} \nreturn libertyFeatures ; \n} \n} \n"}
{"7647": "public class SpringBootUtil { \npublic static boolean isSpringBootUberJar ( File artifact ) { \nif ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) { \nreturn false ; \n} \ntry ( JarFile jarFile = new JarFile ( artifact ) ) { \nManifest manifest = jarFile . getManifest ( ) ; \nif ( manifest != null ) { \nAttributes attributes = manifest . getMainAttributes ( ) ; \nif ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) { \nreturn true ; \n} \nelse { \nEnumeration < JarEntry > entries = jarFile . entries ( ) ; \nfor ( ; \nentries . hasMoreElements ( ) ; \n) { \nJarEntry entry = entries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( ! entryName . startsWith ( \"org\" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) { \nreturn true ; \n} \n} \n} \n} \n} \ncatch ( IOException e ) { \n} \nreturn false ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nif ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \n} \nif ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nfor ( ; \ntrue ; \n) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) return i ; \n} \n} \n} \n} \n"}
{"7673": "public class JerseyUtil { \npublic static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { \nfor ( ; \ninjector != null ; \n) { \nfor ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { \nType type = key . getTypeLiteral ( ) . getType ( ) ; \nif ( type instanceof Class ) { \nClass < ? > c = ( Class ) type ; \nif ( isProviderClass ( c ) ) { \nlogger . info ( \"Registering {} as a provider class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse if ( isRootResourceClass ( c ) ) { \nif ( Resource . isAcceptable ( c ) ) { \nlogger . info ( \"Registering {} as a root resource class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse { \nlogger . warn ( \"Class {} was not registered as a resource. Bind a concrete implementation instead.\" , c . getName ( ) ) ; \n} \n} \n} \n} \ninjector = injector . getParent ( ) ; \n} \n} \n} \n"}
{"7681": "public class BufferedStreamingOutput { \n@ Override public void write ( OutputStream output ) throws IOException , WebApplicationException { \nfor ( ; \nbufferedInputStream . available ( ) > buffer . length ; \n) { \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \n} \nbuffer = new byte [ bufferedInputStream . available ( ) ] ; \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \nbufferedInputStream . close ( ) ; \n} \n} \n"}
{"7719": "public class CharStreams { \npublic static boolean equal ( Reader in1 , Reader in2 ) throws IOException { \nif ( in1 == in2 ) { \nreturn true ; \n} \nif ( in1 == null || in2 == null ) { \nreturn false ; \n} \nin1 = buffer ( in1 ) ; \nin2 = buffer ( in2 ) ; \nint c1 = in1 . read ( ) ; \nint c2 = in2 . read ( ) ; \nfor ( ; \nc1 != - 1 && c2 != - 1 && c1 == c2 ; \n) { \nc1 = in1 . read ( ) ; \nc2 = in2 . read ( ) ; \n} \nreturn in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; \n} \n} \n"}
{"7761": "public class CafConfigurationSource { \nprivate < T > T getConfig ( final Class < T > configClass ) throws ConfigurationException { \nIterator < Name > it = getServicePath ( ) . descendingPathIterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \ntry ( InputStream in = getConfigurationStream ( configClass , it . next ( ) ) ) { \nreturn decoder . deserialise ( in , configClass ) ; \n} \ncatch ( final ConfigurationException e ) { \nLOG . trace ( \"No configuration at this path level\" , e ) ; \n} \ncatch ( final CodecException | IOException e ) { \nincrementErrors ( ) ; \nthrow new ConfigurationException ( \"Failed to get configuration for \" + configClass . getSimpleName ( ) , e ) ; \n} \n} \nincrementErrors ( ) ; \nthrow new ConfigurationException ( \"No configuration found for \" + configClass . getSimpleName ( ) ) ; \n} \n} \n"}
{"7773": "public class Runtime { \nboolean exec ( HsrePattern re , CharSequence data , EnumSet < ExecFlags > execFlags ) throws RegexException { \nif ( 0 != ( re . guts . info & Flags . REG_UIMPOSSIBLE ) ) { \nthrow new RegexException ( \"Regex marked impossible\" ) ; \n} \neflags = 0 ; \nfor ( ExecFlags ef : execFlags ) { \nswitch ( ef ) { \ncase NOTBOL : eflags |= Flags . REG_NOTBOL ; \nbreak ; \ncase NOTEOL : eflags |= Flags . REG_NOTEOL ; \nbreak ; \ncase LOOKING_AT : eflags |= Flags . REG_LOOKING_AT ; \nbreak ; \ndefault : throw new RuntimeException ( \"impossible exec flag\" ) ; \n} \n} \nthis . re = re ; \nthis . g = re . guts ; \nthis . data = data ; \nthis . dataLength = this . data . length ( ) ; \nif ( this . match != null ) { \nthis . match . clear ( ) ; \n} \nelse { \nthis . match = Lists . newArrayList ( ) ; \n} \nmatch . add ( null ) ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) { \nfor ( ; \nmatch . size ( ) < g . nsub + 1 ; \n) { \nmatch . add ( null ) ; \n} \n} \nif ( mem != null && mem . length >= g . ntree ) { \nArrays . fill ( mem , 0 ) ; \n} \nelse { \nmem = new int [ g . ntree ] ; \n} \nassert g . tree != null ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) { \nreturn cfind ( g . tree . machine ) ; \n} \nelse { \nreturn find ( g . tree . machine ) ; \n} \n} \n} \n"}
{"7775": "public class Runtime { \nprivate void subset ( RuntimeSubexpression sub , int begin , int end ) { \nint n = sub . number ; \nassert n > 0 ; \nfor ( ; \nmatch . size ( ) < ( n + 1 ) ; \n) { \nmatch . add ( null ) ; \n} \nmatch . set ( n , new RegMatch ( begin , end ) ) ; \n} \n} \n"}
{"7783": "public class Compiler { \nprivate void deltraverse ( Nfa nfa , State leftend , State s ) { \nArc a ; \nState to ; \nif ( s . nouts == 0 ) { \nreturn ; \n} \nif ( s . tmp != null ) { \nreturn ; \n} \ns . tmp = s ; \nfor ( ; \n( a = s . outs ) != null ; \n) { \nto = a . to ; \ndeltraverse ( nfa , leftend , to ) ; \nassert to . nouts == 0 || to . tmp != null ; \nnfa . freearc ( a ) ; \nif ( to . nins == 0 && to . tmp == null ) { \nassert to . nouts == 0 ; \nnfa . freestate ( to ) ; \n} \n} \nassert s . no != State . FREESTATE ; \nassert s == leftend || s . nins != 0 ; \nassert s . nouts == 0 ; \ns . tmp = null ; \n} \n} \n"}
{"7786": "public class Compiler { \nprivate int scannum ( ) throws RegexException { \nint n = 0 ; \nfor ( ; \nsee ( DIGIT ) && n < DUPMAX ; \n) { \nn = n * 10 + nextvalue ; \nlex . next ( ) ; \n} \nif ( see ( DIGIT ) || n > DUPMAX ) { \nthrow new RegexException ( \"Unvalid reference number.\" ) ; \n} \nreturn n ; \n} \n} \n"}
{"7787": "public class Compiler { \nprivate void bracket ( State lp , State rp ) throws RegexException { \nassert see ( '[' ) ; \nlex . next ( ) ; \nfor ( ; \n! see ( ']' ) && ! see ( EOS ) ; \n) { \nbrackpart ( lp , rp ) ; \n} \nassert see ( ']' ) ; \ncm . okcolors ( nfa ) ; \n} \n} \n"}
{"7788": "public class Compiler { \nprivate String scanplain ( ) throws RegexException { \nint startp = now ; \nint endp ; \nassert see ( COLLEL ) || see ( ECLASS ) || see ( CCLASS ) ; \nlex . next ( ) ; \nendp = now ; \nfor ( ; \nsee ( PLAIN ) ; \n) { \nendp = now ; \nlex . next ( ) ; \n} \nString ret = new String ( pattern , startp , endp - startp ) ; \nassert see ( END ) ; \nlex . next ( ) ; \nreturn ret ; \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( ; \n( a = cd . arcs ) != null ; \n) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n"}
{"7810": "public class Nfa { \nvoid moveouts ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( ; \n( a = old . outs ) != null ; \n) { \ncparc ( a , newState , a . to ) ; \nfreearc ( a ) ; \n} \n} \n} \n"}
{"7811": "public class Nfa { \nvoid moveins ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( ; \n( a = old . ins ) != null ; \n) { \ncparc ( a , a . from , newState ) ; \nfreearc ( a ) ; \n} \nassert old . nins == 0 ; \nassert old . ins == null ; \n} \n} \n"}
{"7814": "public class Nfa { \nvoid dropstate ( State s ) { \nArc a ; \nfor ( ; \n( a = s . ins ) != null ; \n) { \nfreearc ( a ) ; \n} \nfor ( ; \n( a = s . outs ) != null ; \n) { \nfreearc ( a ) ; \n} \nfreestate ( s ) ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nfor ( ; \nlist . hasNext ( ) ; \n) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { \nthis . tlibversion = element . getBody ( ) ; \n} \nelse if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { \nthis . jspversion = element . getBody ( ) ; \n} \nelse if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nfor ( ; \noptEnd < i ; \n) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \nfor ( int rep = 0 ; \nrep < REPS ; \n++ rep ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) continue ; \nfor ( ; \noptEnd < optCur + len ; \n) opts [ ++ optEnd ] . reset ( ) ; \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( int i = len ; \ni >= MATCH_LEN_MIN ; \n-- i ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \nif ( rep == 0 ) startLen = len + 1 ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nfor ( ; \noptEnd < i ; \n) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nfor ( ; \nmatches . len [ matches . count ] < avail ; \n) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nfor ( ; \noptEnd < optCur + matches . len [ matches . count - 1 ] ; \n) opts [ ++ optEnd ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nfor ( ; \nstartLen > matches . len [ match ] ; \n) ++ match ; \nfor ( int len = startLen ; \n; \n++ len ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nfor ( ; \noptEnd < i ; \n) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n} \n} \n} \n"}
{"7901": "public class TldScanner { \nprivate TldInfo scanTld ( String resourcePath , String entryName , InputStream stream ) throws JasperException { \ntry { \nTreeNode tld = new ParserUtils ( ) . parseXMLDocument ( resourcePath , stream , isValidationEnabled ) ; \nString uri = null ; \nTreeNode uriNode = tld . findChild ( \"uri\" ) ; \nif ( uriNode != null ) { \nuri = uriNode . getBody ( ) ; \n} \nArrayList < String > listeners = new ArrayList < String > ( ) ; \nIterator < TreeNode > listenerNodes = tld . findChildren ( \"listener\" ) ; \nfor ( ; \nlistenerNodes . hasNext ( ) ; \n) { \nTreeNode listener = listenerNodes . next ( ) ; \nTreeNode listenerClass = listener . findChild ( \"listener-class\" ) ; \nif ( listenerClass != null ) { \nString listenerClassName = listenerClass . getBody ( ) ; \nif ( listenerClassName != null ) { \nlisteners . add ( listenerClassName ) ; \n} \n} \n} \nreturn new TldInfo ( uri , entryName , listeners . toArray ( new String [ listeners . size ( ) ] ) ) ; \n} \nfinally { \nif ( stream != null ) { \ntry { \nstream . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \n} \n} \n"}
{"7911": "public class JspRuntimeContext { \npublic void run ( ) { \nfor ( ; \n! threadDone ; \n) { \nthreadSleep ( ) ; \ntry { \ncheckCompile ( ) ; \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \nlog . log ( Level . SEVERE , Localizer . getMessage ( \"jsp.error.recompile\" ) , t ) ; \n} \n} \n} \n} \n"}
{"7916": "public class Streams { \npublic static long copy ( final InputStream in , final OutputStream out ) throws IOException { \nObjects . requireNonNull ( in ) ; \nObjects . requireNonNull ( out ) ; \nfinal byte [ ] buffer = new byte [ COPY_BUFFER_SIZE ] ; \nlong result = 0 ; \nint rc ; \nfor ( ; \n( rc = in . read ( buffer ) ) >= 0 ; \n) { \nresult += rc ; \nout . write ( buffer , 0 , rc ) ; \n} \nreturn result ; \n} \n} \n"}
{"7917": "public class Parser { \npublic static Node . Nodes parse ( ParserController pc , String path , JspReader reader , Node parent , boolean isTagFile , boolean directivesOnly , URL jarFileUrl , String pageEnc , String jspConfigPageEnc , boolean isDefaultPageEncoding , boolean hasBom ) throws JasperException { \nParser parser = new Parser ( pc , reader , isTagFile , directivesOnly , jarFileUrl , hasBom ) ; \nNode . Root root = new Node . Root ( reader . mark ( ) , parent , false ) ; \nroot . setPageEncoding ( pageEnc ) ; \nroot . setJspConfigPageEncoding ( jspConfigPageEnc ) ; \nroot . setIsDefaultPageEncoding ( isDefaultPageEncoding ) ; \nroot . setHasBom ( hasBom ) ; \nif ( hasBom ) { \nchar bomChar = ( char ) reader . nextChar ( ) ; \nif ( bomChar != 0xFEFF ) { \nparser . err . jspError ( reader . mark ( ) , \"jsp.error.invalidBom\" , Integer . toHexString ( bomChar ) . toUpperCase ( ) ) ; \n} \n} \nif ( directivesOnly ) { \nparser . parseTagFileDirectives ( root ) ; \nreturn new Node . Nodes ( root ) ; \n} \nPageInfo pageInfo = pc . getCompiler ( ) . getPageInfo ( ) ; \nif ( parent == null ) { \nparser . addInclude ( root , pageInfo . getIncludePrelude ( ) ) ; \n} \nfor ( ; \nreader . hasMoreInput ( ) ; \n) { \nparser . parseElements ( root ) ; \n} \nif ( parent == null ) { \nparser . addInclude ( root , pageInfo . getIncludeCoda ( ) ) ; \nparser . pageInfo . setRootPath ( path ) ; \n} \nNode . Nodes page = new Node . Nodes ( root ) ; \nreturn page ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nfor ( ; \ni < size ; \n) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nelse if ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7920": "public class Parser { \nprivate void addInclude ( Node parent , List files ) throws JasperException { \nif ( files != null ) { \nIterator iter = files . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nString file = ( String ) iter . next ( ) ; \nAttributesImpl attrs = new AttributesImpl ( ) ; \nattrs . addAttribute ( \"\" , \"file\" , \"file\" , \"CDATA\" , file ) ; \nNode includeNode = new Node . IncludeDirective ( attrs , reader . mark ( ) , parent ) ; \nprocessIncludeDirective ( file , includeNode ) ; \n} \n} \n} \n} \n"}
{"7940": "public class StorageManager { \nprivate static State getSameParent ( final State parent , final MetaKey key ) { \nState current = parent ; \nfor ( ; \ncurrent != null ; \n) { \nif ( current . key . equals ( key ) ) { \nreturn current ; \n} \ncurrent = current . parent ; \n} \nreturn null ; \n} \n} \n"}
{"7947": "public class LZMAEncoder { \npublic boolean encodeForLZMA2 ( ) { \ntry { \nif ( ! lz . isStarted ( ) && ! encodeInit ( ) ) return false ; \nfor ( ; \nuncompressedSize <= LZMA2_UNCOMPRESSED_LIMIT && rc . getPendingSize ( ) <= LZMA2_COMPRESSED_LIMIT ; \n) if ( ! encodeSymbol ( ) ) return false ; \n} \ncatch ( IOException e ) { \nthrow new Error ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"7958": "public class TagFileProcessor { \npublic void removeProtoTypeFiles ( String classFileName ) { \nIterator < Compiler > iter = tempVector . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nCompiler c = iter . next ( ) ; \nif ( classFileName == null ) { \nc . removeGeneratedClassFiles ( ) ; \n} \nelse if ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { \nc . removeGeneratedClassFiles ( ) ; \ntempVector . remove ( c ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nfor ( ; \n! dirs . isEmpty ( ) ; \n) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"7962": "public class JspC { \nprivate void locateUriRoot ( File f ) { \nString tUriBase = uriBase ; \nif ( tUriBase == null ) { \ntUriBase = \"/\" ; \n} \ntry { \nif ( f . exists ( ) ) { \nf = new File ( f . getCanonicalPath ( ) ) ; \nfor ( ; \nf != null ; \n) { \nFile g = new File ( f , \"WEB-INF\" ) ; \nif ( g . exists ( ) && g . isDirectory ( ) ) { \nuriRoot = f . getCanonicalPath ( ) ; \nuriBase = tUriBase ; \nif ( log . isLoggable ( Level . INFO ) ) { \nlog . info ( Localizer . getMessage ( \"jspc.implicit.uriRoot\" , uriRoot ) ) ; \n} \nbreak ; \n} \nif ( f . exists ( ) && f . isDirectory ( ) ) { \ntUriBase = \"/\" + f . getName ( ) + \"/\" + tUriBase ; \n} \nString fParent = f . getParent ( ) ; \nif ( fParent == null ) { \nbreak ; \n} \nelse { \nf = new File ( fParent ) ; \n} \n} \nif ( uriRoot != null ) { \nFile froot = new File ( uriRoot ) ; \nuriRoot = froot . getCanonicalPath ( ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n"}
{"7963": "public class JspC { \nprivate ClassLoader initSystemClassLoader ( ) throws IOException { \nString sysClassPath = getSystemClassPath ( ) ; \nif ( sysClassPath == null ) { \nreturn null ; \n} \nArrayList < URL > urls = new ArrayList < URL > ( ) ; \nStringTokenizer tokenizer = new StringTokenizer ( sysClassPath , File . pathSeparator ) ; \nfor ( ; \ntokenizer . hasMoreTokens ( ) ; \n) { \nurls . add ( new File ( tokenizer . nextToken ( ) ) . toURL ( ) ) ; \n} \nif ( urls . size ( ) == 0 ) { \nreturn null ; \n} \nURL urlsArray [ ] = new URL [ urls . size ( ) ] ; \nurls . toArray ( urlsArray ) ; \nreturn new URLClassLoader ( urlsArray , this . getClass ( ) . getClassLoader ( ) ) ; \n} \n} \n"}
{"7977": "public class ParserUtils { \nprivate static String uencode ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nStringTokenizer tokens = new StringTokenizer ( prefix , \"/\\\\:\" , true ) ; \nStringBuilder stringBuilder = new StringBuilder ( ) ; \nfor ( ; \ntokens . hasMoreElements ( ) ; \n) { \nString token = tokens . nextToken ( ) ; \nif ( \"/\" . equals ( token ) || \"\\\\\" . equals ( token ) || \":\" . equals ( token ) ) { \nstringBuilder . append ( token ) ; \n} \nelse { \ntry { \nstringBuilder . append ( URLEncoder . encode ( token , \"UTF-8\" ) ) ; \n} \ncatch ( java . io . UnsupportedEncodingException ex ) { \n} \n} \n} \nreturn stringBuilder . toString ( ) ; \n} \nelse { \nreturn prefix ; \n} \n} \n} \n"}
{"7991": "public class XMLEncodingDetector { \nprivate void scanXMLDecl ( ) throws IOException , JasperException { \nif ( skipString ( \"<?xml\" ) ) { \nfMarkupDepth ++ ; \nif ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . clear ( ) ; \nfStringBuffer . append ( \"xml\" ) ; \nfor ( ; \nXMLChar . isName ( peekChar ( ) ) ; \n) { \nfStringBuffer . append ( ( char ) scanChar ( ) ) ; \n} \nString target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; \nscanPIData ( target , fString ) ; \n} \nelse { \nscanXMLDeclOrTextDecl ( false ) ; \n} \n} \n} \n} \n"}
{"8005": "public class LZEncoder { \npublic int getMatchLen ( int dist , int lenLimit ) { \nint backPos = readPos - dist - 1 ; \nint len = 0 ; \nfor ( ; \nlen < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ; \n) ++ len ; \nreturn len ; \n} \n} \n"}
{"8006": "public class LZEncoder { \npublic int getMatchLen ( int forward , int dist , int lenLimit ) { \nint curPos = readPos + forward ; \nint backPos = curPos - dist - 1 ; \nint len = 0 ; \nfor ( ; \nlen < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ; \n) ++ len ; \nreturn len ; \n} \n} \n"}
{"8035": "public class ELParser { \npublic static ELNode . Nodes parse ( String expression ) { \nELParser parser = new ELParser ( expression ) ; \nfor ( ; \nparser . hasNextChar ( ) ; \n) { \nString text = parser . skipUntilEL ( ) ; \nif ( text . length ( ) > 0 ) { \nparser . expr . add ( new ELNode . Text ( text ) ) ; \n} \nELNode . Nodes elexpr = parser . parseEL ( ) ; \nif ( ! elexpr . isEmpty ( ) ) { \nparser . expr . add ( new ELNode . Root ( elexpr , parser . isDollarExpr ) ) ; \n} \n} \nreturn parser . expr ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) for ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nfor ( ; \nchars [ i ] != '\\n' && i < chars . length ; \n) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n"}
{"8041": "public class ServletWriter { \npublic void printMultiLn ( String s ) { \nint index = 0 ; \nfor ( ; \n( index = s . indexOf ( '\\n' , index ) ) > - 1 ; \n) { \njavaLine ++ ; \nindex ++ ; \n} \nwriter . print ( s ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nint pos = path . indexOf ( pat ) ; \nint start = 0 ; \nfor ( ; \npos >= 0 ; \n) { \nif ( pos > start ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( start < path . length ( ) ) { \ncomps . add ( path . substring ( start ) ) ; \n} \nString [ ] result = new String [ comps . size ( ) ] ; \nfor ( int i = 0 ; \ni < comps . size ( ) ; \ni ++ ) { \nresult [ i ] = comps . get ( i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nint i = 0 ; \nint j = javaKeywords . length ; \nfor ( ; \ni < j ; \n) { \nint k = ( i + j ) / 2 ; \nint result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) { \nreturn true ; \n} \nif ( result < 0 ) { \ni = k + 1 ; \n} \nelse { \nj = k ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8111": "public class Range { \npublic static Map < Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { \nif ( range . getStart ( ) >= range . getStop ( ) ) throw new IllegalArgumentException ( \"start cannot be greater than end. Start: \" + range . getStart ( ) + \" Stop:\" + range . getStop ( ) ) ; \nfinal long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; \nfinal long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; \nHashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; \nlong tempStartMillis = snappedStartMillis ; \nint numberOfMillis = g . milliseconds ( ) ; \nfor ( ; \ntempStartMillis <= ( snappedStopMillis - numberOfMillis ) ; \n) { \nRange slotRange = new Range ( tempStartMillis , tempStartMillis + numberOfMillis ) ; \nrangeMap . put ( slotRange , new IntervalRangeIterator ( g . finer ( ) , slotRange . start , slotRange . stop ) ) ; \ntempStartMillis = tempStartMillis + numberOfMillis ; \n} \nreturn rangeMap ; \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nfor ( ; \ndownloadDir . listFiles ( ) . length != 0 ; \n) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \nelse { \nlog . debug ( \"Download in progress\" ) ; \n} \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) { \nreturn true ; \n} \nif ( declaredExceptions != null ) { \nint i = 0 ; \nfor ( ; \ni < declaredExceptions . length ; \n) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8354": "public class XmlValidationModeDetector { \nprivate String consumeCommentTokens ( String line ) { \nif ( line . indexOf ( START_COMMENT ) == - 1 && line . indexOf ( END_COMMENT ) == - 1 ) { \nreturn line ; \n} \nfor ( ; \n( line = consume ( line ) ) != null ; \n) { \nif ( ! this . inComment && ! line . trim ( ) . startsWith ( START_COMMENT ) ) { \nreturn line ; \n} \n} \nreturn line ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nfor ( ; \nposition < argv . length ; \n) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8384": "public class PhoneNumberAddress { \npublic static String calcMobileCity ( String mobileNumber ) throws MalformedURLException { \nObjectMapper objectMapper = new ObjectMapper ( ) ; \nString jsonString = null ; \nString urlString = \"http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=\" + mobileNumber ; \nStringBuffer sb = new StringBuffer ( ) ; \nBufferedReader buffer ; \nURL url = new URL ( urlString ) ; \ntry { \nInputStream in = url . openStream ( ) ; \nbuffer = new BufferedReader ( new InputStreamReader ( in , \"gb2312\" ) ) ; \nString line = null ; \nfor ( ; \n( line = buffer . readLine ( ) ) != null ; \n) { \nsb . append ( line ) ; \n} \nin . close ( ) ; \nbuffer . close ( ) ; \njsonString = sb . toString ( ) ; \nEntityHelper . print ( jsonString ) ; \njsonString = jsonString . replaceAll ( \"^[__]\\\\w{14}+[_ = ]+\" , \"[\" ) ; \nString jsonString2 = jsonString + \"]\" ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8388": "public class JarArchive { \nprivate ITreeNode parseTree ( ) { \nITreeNode root = new TreeNodeUniqueChildren ( ) ; \nITreeNode newnode , oldnode ; \nEnumeration entries = this . jar . entries ( ) ; \nString entry ; \nfor ( ; \nentries . hasMoreElements ( ) ; \n) { \nnewnode = root ; \noldnode = root ; \nentry = ( ( JarEntry ) entries . nextElement ( ) ) . getName ( ) ; \nSystem . out . println ( \"Entry: \" + entry ) ; \nStringTokenizer tokenizer = new StringTokenizer ( entry , \"/\" ) ; \nfor ( ; \ntokenizer . hasMoreElements ( ) ; \n) { \nString path = tokenizer . nextToken ( ) ; \nnewnode = new TreeNodeUniqueChildren ( path ) ; \noldnode . addChildNode ( newnode ) ; \noldnode = newnode ; \n} \n} \nreturn root ; \n} \n} \n"}
{"8414": "public class MdPageGeneratorMojo { \nprivate String substituteVariables ( String template , String patternString , Map < String , String > variables ) { \nPattern pattern = Pattern . compile ( patternString ) ; \nMatcher matcher = pattern . matcher ( template ) ; \nStringBuffer buffer = new StringBuffer ( ) ; \nfor ( ; \nmatcher . find ( ) ; \n) { \nif ( variables . containsKey ( matcher . group ( 1 ) ) ) { \nString replacement = variables . get ( matcher . group ( 1 ) ) ; \nmatcher . appendReplacement ( buffer , replacement != null ? Matcher . quoteReplacement ( replacement ) : \"null\" ) ; \n} \n} \nmatcher . appendTail ( buffer ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"8419": "public class MdPageGeneratorMojo { \nprivate void copyFiles ( String fromDir , String toDir ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"fromDir=\" + fromDir + \"; toDir=\" + toDir ) ; \ntry { \nFile fromDirFile = new File ( fromDir ) ; \nif ( fromDirFile . exists ( ) ) { \nIterator < File > files = FileUtils . iterateFiles ( new File ( fromDir ) , null , false ) ; \nfor ( ; \nfiles . hasNext ( ) ; \n) { \nFile file = files . next ( ) ; \nif ( file . exists ( ) ) { \nFileUtils . copyFileToDirectory ( file , new File ( toDir ) ) ; \n} \nelse { \ngetLog ( ) . error ( \"File '\" + file . getAbsolutePath ( ) + \"' does not exist. Skipping copy\" ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to copy file \" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8577": "public class ConfigurationUtility { \npublic static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { \nint ibegin = 0 ; \nint ifind ; \nint inameEnd ; \nString tempStr ; \nString findStr ; \nString replaceStr ; \nString returnStr = attrValue ; \nfor ( ; \n( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ; \n) { \ninameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; \nif ( inameEnd > 0 ) { \nfindStr = attrValue . substring ( ifind , inameEnd ) ; \n} \nelse { \nfindStr = attrValue . substring ( ifind ) ; \n} \nif ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) { \ntempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; \n} \nelse { \ntempStr = findStr ; \n} \nreplaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; \nif ( replaceStr == null ) { \nreplaceStr = \"\" ; \n} \nreturnStr = attrValue . replace ( findStr , replaceStr ) ; \nibegin = ifind + 1 ; \n} \nreturn returnStr ; \n} \n} \n"}
{"8732": "public class ParserUtility { \npublic static Map < String , String > parseCommandAttributes ( final String attrString ) { \nMap < String , String > attrMap = new LinkedHashMap < > ( ) ; \nMatcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN . matcher ( attrString ) ; \nfor ( ; \nattrMatcher . find ( ) ; \n) { \nString attrData = attrMatcher . group ( ) ; \nint attrNameEndIndex = attrData . indexOf ( '=' ) ; \nString attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; \nString attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; \nString attrValue = attrValuePart . substring ( 1 , attrValuePart . length ( ) - 1 ) ; \nattrMap . put ( attrName , attrValue ) ; \n} \nreturn attrMap ; \n} \n} \n"}
{"8743": "public class WebSheetUtility { \npublic static String getExcelColumnName ( final int pnumber ) { \nStringBuilder converted = new StringBuilder ( ) ; \nint number = pnumber ; \nfor ( ; \nnumber >= 0 ; \n) { \nint remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; \nconverted . insert ( 0 , ( char ) ( remainder + 'A' ) ) ; \nnumber = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; \n} \nreturn converted . toString ( ) ; \n} \n} \n"}
{"8808": "public class BaseRequestBuilder { \nprotected Parameter removeParameter ( final String name ) { \nif ( name == null ) { \nthrow new IllegalArgumentException ( \"Parameter name cannot be null\" ) ; \n} \nfinal Iterator < Parameter > iter = result . simpleParameters . getChildren ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nfinal Parameter p = iter . next ( ) ; \nif ( name . equals ( p . name ) ) { \niter . remove ( ) ; \nreturn p ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8839": "public class FilePart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendData(OutputStream out)\" ) ; \n} \nif ( lengthOfData ( ) == 0 ) { \nif ( DEBUG ) { \nLog . d ( TAG , \"No data to send.\" ) ; \n} \nreturn ; \n} \nfinal int size = 4096 ; \nfinal byte [ ] tmp = new byte [ size ] ; \nfinal InputStream instream = source . createInputStream ( ) ; \ntry { \nint len ; \nfor ( ; \n( len = instream . read ( tmp ) ) >= 0 ; \n) { \nout . write ( tmp , 0 , len ) ; \n} \n} \nfinally { \ninstream . close ( ) ; \n} \n} \n} \n"}
{"8929": "public class LogPersister { \nprotected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { \nJSONObject jsonMetadata ; \nif ( additionalMetadata != null ) { \njsonMetadata = additionalMetadata ; \n} \nelse { \njsonMetadata = new JSONObject ( ) ; \n} \ntry { \nStackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; \nint index = 0 ; \nfor ( ; \n! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ; \n) { \nindex ++ ; \n} \nfor ( ; \nstackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ; \n) { \nindex ++ ; \n} \njsonMetadata . put ( \"$class\" , stackTraceElements [ index ] . getClassName ( ) ) ; \njsonMetadata . put ( \"$file\" , stackTraceElements [ index ] . getFileName ( ) ) ; \njsonMetadata . put ( \"$method\" , stackTraceElements [ index ] . getMethodName ( ) ) ; \njsonMetadata . put ( \"$line\" , stackTraceElements [ index ] . getLineNumber ( ) ) ; \njsonMetadata . put ( \"$src\" , \"java\" ) ; \n} \ncatch ( Exception e ) { \nLog . e ( LOG_TAG_NAME , \"Could not generate jsonMetadata object.\" , e ) ; \n} \nreturn jsonMetadata ; \n} \n} \n"}
{"8970": "public class GemFireMgmt { \npublic static void shutDownMember ( String name ) { \ntry { \nObjectName serverName = new ObjectName ( \"GemFire:type=Member,member=\" + name ) ; \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nMemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; \nbean . shutDownMember ( ) ; \nSystem . out . println ( \"Waiting for member:\" + name + \"  to shutdown\" ) ; \nfor ( ; \nGemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ; \n) { \nThread . sleep ( shutDownDelay ) ; \n} \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to shutdown member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"8987": "public class TableObject { \nprivate String getSchema ( ) { \nStringBuilder sb = new StringBuilder ( ) ; \nIterator < TableColumn > iterator = columns . iterator ( ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nTableColumn column = iterator . next ( ) ; \nif ( column . isOneToMany ( ) ) { \nif ( ! iterator . hasNext ( ) ) { \nint length = sb . length ( ) ; \nsb . replace ( length - 2 , length , \"\" ) ; \n} \ncontinue ; \n} \nsb . append ( column ) ; \nif ( iterator . hasNext ( ) ) { \nsb . append ( \", \" ) ; \n} \n} \nString idCol = idColumn == null ? \"id_missing\" : idColumn . getColumnName ( ) ; \nreturn String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; \n} \n} \n"}
{"9004": "public class IntPower { \npublic static double raise ( final double px , final int pexponent ) { \ndouble x = px ; \nint exponent = pexponent ; \nif ( exponent < 0 ) return 1 / raise ( x , - exponent ) ; \ndouble power = 1 ; \nfor ( ; \nexponent > 0 ; \n) { \nif ( ( exponent & 1 ) == 1 ) power *= x ; \nx *= x ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9006": "public class BigFunctions { \npublic static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) { \nBigDecimal x = px ; \nlong exponent = pexponent ; \nif ( exponent < 0 ) { \nreturn BigDecimal . ONE . divide ( intPower ( x , - exponent , scale ) , scale , RoundingMode . HALF_EVEN ) ; \n} \nBigDecimal power = BigDecimal . ONE ; \nfor ( ; \nexponent > 0 ; \n) { \nif ( ( exponent & 1 ) == 1 ) { \npower = power . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \nx = x . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nexponent >>= 1 ; \nThread . yield ( ) ; \n} \nreturn power ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nfor ( ; \nindex + 5 < length ; \n) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \n} \n} \n"}
{"9061": "public class ModuloArithmetic { \npublic static int multiply ( final int pa , final int pb , final int m ) { \nint a = pa ; \nint b = pb ; \nint product = 0 ; \nfor ( ; \na > 0 ; \n) { \nif ( ( a & 1 ) == 1 ) { \nproduct += b ; \nproduct %= m ; \n} \nb <<= 1 ; \nb %= m ; \na >>= 1 ; \n} \nreturn product ; \n} \n} \n"}
{"9062": "public class ModuloArithmetic { \npublic static int raise ( final int pbase , final int pexponent , final int m ) { \nint base = pbase ; \nint exponent = pexponent ; \nint power = 1 ; \nfor ( ; \nexponent > 0 ; \n) { \nif ( ( exponent & 1 ) == 1 ) { \npower = multiply ( power , base , m ) ; \n} \nbase = multiply ( base , base , m ) ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9075": "public class RandomNormal { \npublic float nextRatio ( ) { \nfloat u , v , x , xx ; \ndo { \nfor ( ; \n( u = GENERATOR . nextFloat ( ) ) == 0 ; \n) { \n} \nv = GENERATOR . nextFloat ( ) ; \nfinal float y = C1 * ( v - 0.5f ) ; \nx = y / u ; \nxx = x * x ; \n} \nwhile ( ( xx > 5f - C2 * u ) && ( ( xx >= C3 / u + 1.4f ) || ( xx > ( float ) ( - 4 * Math . log ( u ) ) ) ) ) ; \nreturn m_fStddev * x + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( int i = 2 ; \ni <= n ; \n++ i ) sieve [ i ] = true ; \nint prime = 2 ; \nfor ( ; \nprime < halfN ; \n) { \nfor ( int composite = prime << 1 ; \ncomposite <= n ; \ncomposite += prime ) sieve [ composite ] = false ; \nfor ( ; \n( ++ prime < halfN ) && ( ! sieve [ prime ] ) ; \n) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9092": "public class RSRServiceDiscoveryImpl { \npublic Collection < String > queryForNames ( ) throws Exception { \nSet < String > names = new HashSet < String > ( ) ; \nIterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; \nfor ( ; \nservices . hasNext ( ) ; \n) { \nService service = services . next ( ) ; \nif ( ! service . getTags ( ) . contains ( typeTag ) ) { \ncontinue ; \n} \nString name = service . getMetadata ( ) . get ( ServiceTracker . NAME ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nreturn names ; \n} \n} \n"}
{"9093": "public class RSRServiceDiscoveryImpl { \npublic Collection < ServiceInstance < T > > queryForInstances ( String name ) throws Exception { \nList < ServiceInstance < T > > serviceInstances = new ArrayList < ServiceInstance < T > > ( ) ; \nIterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; \nfor ( ; \nservices . hasNext ( ) ; \n) { \nService service = services . next ( ) ; \nif ( service . getTags ( ) . contains ( typeTag ) && service . getMetadata ( ) . get ( ServiceTracker . NAME ) . equals ( name ) ) { \nserviceInstances . add ( convert ( service ) ) ; \n} \n} \nreturn serviceInstances ; \n} \n} \n"}
{"9113": "public class AGenericListMessageHandler { \nprivate List < String > getEchoMessagesFromReturnValue ( ) { \nList < String > returnListing = new ArrayList ( ) ; \nif ( this . returnValue == null ) { \nreturn returnListing ; \n} \nIterator < T > iterForReturnVal = this . returnValue . iterator ( ) ; \nfor ( ; \niterForReturnVal . hasNext ( ) ; \n) { \nT returnVal = iterForReturnVal . next ( ) ; \nif ( returnVal . getEcho ( ) == null ) { \ncontinue ; \n} \nreturnListing . add ( returnVal . getEcho ( ) ) ; \n} \nreturn returnListing ; \n} \n} \n"}
{"9178": "public class SQLFormDefinitionUtil { \npublic Map < Long , String > getFormDefinitionIdAndTitle ( ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) { \nMap < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; \nif ( System . currentTimeMillis ( ) > timeToUpdateAgain ) { \nsynchronized ( LOCAL_MAPPING ) { \nLOCAL_MAPPING . clear ( ) ; \n} \n} \nreturn returnVal ; \n} \nsynchronized ( LOCAL_MAPPING ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) { \nreturn new HashMap < > ( LOCAL_MAPPING ) ; \n} \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( this . getSQLTypeFromConnection ( ) , ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; \npreparedStatement = this . getConnection ( ) . prepareStatement ( syntax . getPreparedStatement ( ) ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \nfor ( ; \nresultSet . next ( ) ; \n) { \nLong id = resultSet . getLong ( 1 ) ; \nString title = resultSet . getString ( 2 ) ; \nLOCAL_MAPPING . put ( id , title ) ; \n} \ntimeToUpdateAgain = ( System . currentTimeMillis ( ) + TimeUnit . MINUTES . toMillis ( 10 ) ) ; \n} \ncatch ( SQLException sqlError ) { \nthrow new FluidSQLException ( sqlError ) ; \n} \nfinally { \nthis . closeStatement ( preparedStatement , resultSet ) ; \n} \nreturn new HashMap < > ( LOCAL_MAPPING ) ; \n} \n} \n} \n"}
{"9255": "public class SoftSet { \nprivate void processQueue ( ) { \nComparableSoftReference cr ; \nfor ( ; \n( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ; \n) { \nmap . remove ( cr . getKey ( ) ) ; \n} \n} \n} \n"}
{"9269": "public class WorkerQueue { \nprotected Executable getJobImpl ( ) throws InterruptedException { \nfor ( ; \nm_currentJob == null ; \n) { \nwait ( ) ; \n} \nJobItem item = m_currentJob ; \nm_currentJob = m_currentJob . m_next ; \nreturn item . m_job ; \n} \n} \n"}
{"9270": "public class WorkerQueue { \nprotected void putJobImpl ( Executable job ) { \nJobItem posted = new JobItem ( job ) ; \nif ( m_currentJob == null ) { \nm_currentJob = posted ; \nnotifyAll ( ) ; \n} \nelse { \nJobItem item = m_currentJob ; \nfor ( ; \nitem . m_next != null ; \n) { \nitem = item . m_next ; \n} \nitem . m_next = posted ; \n} \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( int count = 0 ; \ncount < readerMap . size ( ) ; \ncount ++ ) { \nmapArr . add ( null ) ; \n} \nEnumeration enumt = readerMap . keys ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( int count = 0 ; \ncount < mapArr . size ( ) ; \ncount ++ ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nfor ( ; \nq . hasMoreElements ( ) ; \n) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nfor ( ; \n! catalogFiles . isEmpty ( ) ; \n) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nfor ( ; \nq . hasMoreElements ( ) ; \n) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9283": "public class Catalog { \npublic String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = null ; \ncatalogManager . debug . message ( 3 , \"resolveDoctype(\" + entityName + \",\" + publicId + \",\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( publicId != null && publicId . startsWith ( \"urn:publicid:\" ) ) { \npublicId = PublicId . decodeURN ( publicId ) ; \n} \nif ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nif ( publicId != null && ! publicId . equals ( systemId ) ) { \ncatalogManager . debug . message ( 1 , \"urn:publicid: system identifier differs from public identifier; using public identifier\" ) ; \nsystemId = null ; \n} \nelse { \npublicId = systemId ; \nsystemId = null ; \n} \n} \nif ( systemId != null ) { \nresolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nif ( publicId != null ) { \nresolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nboolean over = default_override ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == OVERRIDE ) { \nover = e . getEntryArg ( 0 ) . equalsIgnoreCase ( \"YES\" ) ; \ncontinue ; \n} \nif ( e . getEntryType ( ) == DOCTYPE && e . getEntryArg ( 0 ) . equals ( entityName ) ) { \nif ( over || systemId == null ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; \n} \n} \n"}
{"9284": "public class Catalog { \npublic String resolveDocument ( ) throws MalformedURLException , IOException { \ncatalogManager . debug . message ( 3 , \"resolveDocument\" ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DOCUMENT ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \nreturn resolveSubordinateCatalogs ( DOCUMENT , null , null , null ) ; \n} \n} \n"}
{"9286": "public class Catalog { \nprotected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == URI && ( e . getEntryArg ( 0 ) . equals ( uri ) ) ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \nenumt = catalogEntries . elements ( ) ; \nString startString = null ; \nString prefix = null ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == REWRITE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \nif ( startString == null || p . length ( ) > startString . length ( ) ) { \nstartString = p ; \nprefix = e . getEntryArg ( 1 ) ; \n} \n} \n} \nif ( prefix != null ) { \nreturn prefix + uri . substring ( startString . length ( ) ) ; \n} \n} \nenumt = catalogEntries . elements ( ) ; \nVector delCats = new Vector ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \ndelCats . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \nif ( delCats . size ( ) > 0 ) { \nEnumeration enumCats = delCats . elements ( ) ; \nif ( catalogManager . debug . getDebug ( ) > 1 ) { \ncatalogManager . debug . message ( 2 , \"Switching to delegated catalog(s):\" ) ; \nfor ( ; \nenumCats . hasMoreElements ( ) ; \n) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ncatalogManager . debug . message ( 2 , \"\\t\" + delegatedCatalog ) ; \n} \n} \nCatalog dcat = newCatalog ( ) ; \nenumCats = delCats . elements ( ) ; \nfor ( ; \nenumCats . hasMoreElements ( ) ; \n) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ndcat . parseCatalog ( delegatedCatalog ) ; \n} \nreturn dcat . resolveURI ( uri ) ; \n} \nreturn null ; \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nfor ( ; \nlocal . hasMoreElements ( ) ; \n) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( dp . length ( ) > partial . length ( ) ) { \npos ++ ; \n} \nif ( dp . length ( ) < partial . length ( ) ) { \nbreak ; \n} \n} \nif ( localDelegate . size ( ) == 0 ) { \nlocalDelegate . addElement ( entry ) ; \n} \nelse { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nint count = 0 ; \nfor ( ; \n( obj = ( SoftObject ) queue . poll ( ) ) != null ; \n) { \ncount ++ ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) { \nSystem . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; \n} \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \n-- size ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \n-- size ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) return res ; \nlong t = queue [ index ] . time ; \nint c = index << 1 ; \nfor ( ; \nc <= size ; \n) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( c + 1 <= size ) { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( l . time <= r . time ) { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nif ( t <= r . time ) break ; \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \n} \nelse { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9312": "public class URLStreamHandlerFactory { \nprivate synchronized void checkHandlerPkgs ( ) { \nString handlerPkgsProp = System . getProperty ( \"java.protocol.handler.pkgs\" ) ; \nif ( handlerPkgsProp != null && handlerPkgsProp . equals ( lastHandlerPkgs ) == false ) { \nStringTokenizer tokeninzer = new StringTokenizer ( handlerPkgsProp , \"|\" ) ; \nArrayList < String > tmp = new ArrayList < String > ( ) ; \nfor ( ; \ntokeninzer . hasMoreTokens ( ) ; \n) { \nString pkg = tokeninzer . nextToken ( ) . intern ( ) ; \nif ( tmp . contains ( pkg ) == false ) tmp . add ( pkg ) ; \n} \nif ( tmp . contains ( PACKAGE_PREFIX ) == false ) tmp . add ( PACKAGE_PREFIX ) ; \nhandlerPkgs = new String [ tmp . size ( ) ] ; \ntmp . toArray ( handlerPkgs ) ; \nlastHandlerPkgs = handlerPkgsProp ; \n} \n} \n} \n"}
{"9317": "public class OASISXMLCatalogReader { \nprotected boolean inExtensionNamespace ( ) { \nboolean inExtension = false ; \nEnumeration elements = namespaceStack . elements ( ) ; \nfor ( ; \n! inExtension && elements . hasMoreElements ( ) ; \n) { \nString ns = ( String ) elements . nextElement ( ) ; \nif ( ns == null ) { \ninExtension = true ; \n} \nelse { \ninExtension = ( ! ns . equals ( tr9401NamespaceName ) && ! ns . equals ( namespaceName ) ) ; \n} \n} \nreturn inExtension ; \n} \n} \n"}
{"9321": "public class Strings { \npublic static String subst ( final StringBuffer buff , final String string , final Map map , final String beginToken , final String endToken ) { \nint begin = 0 , rangeEnd = 0 ; \nRange range ; \nfor ( ; \n( range = rangeOf ( beginToken , endToken , string , rangeEnd ) ) != null ; \n) { \nbuff . append ( string . substring ( begin , range . begin ) ) ; \nString key = string . substring ( range . begin + beginToken . length ( ) , range . end ) ; \nObject value = map . get ( key ) ; \nif ( value == null ) value = EMPTY ; \nbuff . append ( value ) ; \nbegin = range . end + endToken . length ( ) ; \nrangeEnd = begin ; \n} \nbuff . append ( string . substring ( begin , string . length ( ) ) ) ; \nreturn buff . toString ( ) ; \n} \n} \n"}
{"9330": "public class TimedCachePolicy { \npublic void flush ( ) { \nMap tmpMap = null ; \nsynchronized ( this ) { \ntmpMap = entryMap ; \nif ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \nelse entryMap = new HashMap ( ) ; \n} \nIterator iter = tmpMap . values ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nTimedEntry entry = ( TimedEntry ) iter . next ( ) ; \nentry . destroy ( ) ; \n} \ntmpMap . clear ( ) ; \n} \n} \n"}
{"9331": "public class TimedCachePolicy { \npublic List getValidKeys ( ) { \nArrayList validKeys = new ArrayList ( ) ; \nsynchronized ( entryMap ) { \nIterator iter = entryMap . entrySet ( ) . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nTimedEntry value = ( TimedEntry ) entry . getValue ( ) ; \nif ( value . isCurrent ( now ) == true ) validKeys . add ( entry . getKey ( ) ) ; \n} \n} \nreturn validKeys ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nelse if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { \nreturn result ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9345": "public class Resolver { \npublic String resolvePublic ( String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nif ( systemId != null ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nresolved = resolveExternalPublic ( publicId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . PUBLIC , null , publicId , systemId ) ; \n} \n} \n"}
{"9353": "public class Resolver { \nprivate Vector resolveAllLocalSystem ( String systemId ) { \nVector map = new Vector ( ) ; \nString osname = System . getProperty ( \"os.name\" ) ; \nboolean windows = ( osname . indexOf ( \"Windows\" ) >= 0 ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nfor ( ; \nenumt . hasMoreElements ( ) ; \n) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) { \nmap . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \nif ( map . size ( ) == 0 ) { \nreturn null ; \n} \nelse { \nreturn map ; \n} \n} \n} \n"}
{"9391": "public class PublicId { \npublic static String normalize ( String publicId ) { \nString normal = publicId . replace ( '\\t' , ' ' ) ; \nnormal = normal . replace ( '\\r' , ' ' ) ; \nnormal = normal . replace ( '\\n' , ' ' ) ; \nnormal = normal . trim ( ) ; \nint pos ; \nfor ( ; \n( pos = normal . indexOf ( \"  \" ) ) >= 0 ; \n) { \nnormal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; \n} \nreturn normal ; \n} \n} \n"}
{"9394": "public class PublicId { \nprivate static String stringReplace ( String str , String oldStr , String newStr ) { \nString result = \"\" ; \nint pos = str . indexOf ( oldStr ) ; \nfor ( ; \npos >= 0 ; \n) { \nresult += str . substring ( 0 , pos ) ; \nresult += newStr ; \nstr = str . substring ( pos + 1 ) ; \npos = str . indexOf ( oldStr ) ; \n} \nreturn result + str ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nint ch , nextch ; \nif ( ! tokenStack . empty ( ) ) { \nreturn ( String ) tokenStack . pop ( ) ; \n} \nfor ( ; \ntrue ; \n) { \nch = catfile . read ( ) ; \nfor ( ; \nch <= ' ' ; \n) { \nch = catfile . read ( ) ; \nif ( ch < 0 ) { \nreturn null ; \n} \n} \nnextch = catfile . read ( ) ; \nif ( nextch < 0 ) { \nreturn null ; \n} \nif ( ch == '-' && nextch == '-' ) { \nch = ' ' ; \nnextch = nextChar ( ) ; \nfor ( ; \nch != '-' || nextch != '-' ; \n) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \nelse { \nstack [ ++ top ] = nextch ; \nstack [ ++ top ] = ch ; \nbreak ; \n} \n} \nch = nextChar ( ) ; \nif ( ch == '\"' || ch == '\\'' ) { \nint quote = ch ; \nfor ( ; \n( ch = nextChar ( ) ) != quote ; \n) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \nelse { \nfor ( ; \nch > ' ' ; \n) { \nnextch = nextChar ( ) ; \nif ( ch == '-' && nextch == '-' ) { \nstack [ ++ top ] = ch ; \nstack [ ++ top ] = nextch ; \nreturn token ; \n} \nelse { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \n} \nreturn token ; \n} \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nint colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( colIndex > 0 ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( \"xmlns\" . equals ( prefix ) ) { \nnamespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \n} \nelse { \nElement nsElement = el ; \nfor ( ; \nnamespaceURI . equals ( \"\" ) && nsElement != null ; \n) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; \n} \n} \nif ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9425": "public class DOMCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nDocumentBuilderFactory factory = null ; \nDocumentBuilder builder = null ; \nfactory = DocumentBuilderFactory . newInstance ( ) ; \nfactory . setNamespaceAware ( false ) ; \nfactory . setValidating ( false ) ; \ntry { \nbuilder = factory . newDocumentBuilder ( ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nDocument doc = null ; \ntry { \ndoc = builder . parse ( is ) ; \n} \ncatch ( SAXException se ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \nElement root = doc . getDocumentElement ( ) ; \nString namespaceURI = Namespaces . getNamespaceURI ( root ) ; \nString localName = Namespaces . getLocalName ( root ) ; \nString domParserClass = getCatalogParser ( namespaceURI , localName ) ; \nif ( domParserClass == null ) { \nif ( namespaceURI == null ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + localName ) ; \n} \nelse { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + \"{\" + namespaceURI + \"}\" + localName ) ; \n} \nreturn ; \n} \nDOMCatalogParser domParser = null ; \ntry { \ndomParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot load XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot instantiate XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot access XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ClassCastException cce ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot cast XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nNode node = root . getFirstChild ( ) ; \nfor ( ; \nnode != null ; \n) { \ndomParser . parseCatalogEntry ( catalog , node ) ; \nnode = node . getNextSibling ( ) ; \n} \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nfor ( ; \nparent != null ; \n) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nu < length ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < ifaces . length ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \n} \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nfor ( ; \nc != null ; \n) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn ++ ) { \nallIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nfor ( ; \nc != null ; \n) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn ++ ) { \nuniqueIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nint arraySize = 0 ; \nfor ( ; \nname . endsWith ( \"[]\" ) ; \n) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize ++ ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) { \ntry { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \n} \nif ( arraySize > 0 ) { \nint [ ] dims = new int [ arraySize ] ; \nfor ( int i = 0 ; \ni < arraySize ; \ni ++ ) { \ndims [ i ] = 1 ; \n} \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9445": "public class WeakSet { \nprotected final void maintain ( ) { \nWeakObject weak ; \nfor ( ; \n( weak = ( WeakObject ) queue . poll ( ) ) != null ; \n) { \nset . remove ( weak ) ; \n} \n} \n} \n"}
{"9446": "public class WeakSet { \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nIterator iter = set . iterator ( ) ; \nObject UNKNOWN = new Object ( ) ; \nObject next = UNKNOWN ; \npublic boolean hasNext ( ) { \nif ( next != UNKNOWN ) { \nreturn true ; \n} \nfor ( ; \niter . hasNext ( ) ; \n) { \nWeakObject weak = ( WeakObject ) iter . next ( ) ; \nObject obj = null ; \nif ( weak != null && ( obj = weak . get ( ) ) == null ) { \ncontinue ; \n} \nnext = obj ; \nreturn true ; \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( ( next == UNKNOWN ) && ! hasNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \nObject obj = next ; \nnext = UNKNOWN ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nfor ( ; \nnext == null ; \n) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9456": "public class ApplicationDeadlockException { \npublic static ApplicationDeadlockException isADE ( Throwable t ) { \nfor ( ; \nt != null ; \n) { \nif ( t instanceof ApplicationDeadlockException ) { \nreturn ( ApplicationDeadlockException ) t ; \n} \nelse { \nt = t . getCause ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9458": "public class TimeoutFactory { \nprivate void doWork ( ) { \nfor ( ; \ncancelled . get ( ) == false ; \n) { \nTimeoutExt work = queue . take ( ) ; \nif ( work != null ) { \nTimeoutWorker worker = new TimeoutWorker ( work ) ; \ntry { \nthreadPool . run ( worker ) ; \n} \ncatch ( Throwable t ) { \nThrowableHandler . add ( ThrowableHandler . Type . ERROR , t ) ; \n} \nsynchronized ( work ) { \nwork . done ( ) ; \n} \n} \n} \nqueue . cancel ( ) ; \n} \n} \n"}
{"9468": "public class CatalogManager { \npublic Vector getCatalogFiles ( ) { \nif ( catalogFiles == null ) { \ncatalogFiles = queryCatalogFiles ( ) ; \n} \nStringTokenizer files = new StringTokenizer ( catalogFiles , \";\" ) ; \nVector catalogs = new Vector ( ) ; \nfor ( ; \nfiles . hasMoreTokens ( ) ; \n) { \nString catalogFile = files . nextToken ( ) ; \nURL absURI = null ; \nif ( fromPropertiesFile && ! relativeCatalogs ( ) ) { \ntry { \nabsURI = new URL ( propertyFileURI , catalogFile ) ; \ncatalogFile = absURI . toString ( ) ; \n} \ncatch ( MalformedURLException mue ) { \nabsURI = null ; \n} \n} \ncatalogs . add ( catalogFile ) ; \n} \nreturn catalogs ; \n} \n} \n"}
{"9479": "public class CollectionsUtil { \npublic static List list ( Enumeration e ) { \nArrayList result = new ArrayList ( ) ; \nfor ( ; \ne . hasMoreElements ( ) ; \n) result . add ( e . nextElement ( ) ) ; \nreturn result ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nfor ( ; \n( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ; \n) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nfor ( ; \n( word = mmSeg . next ( ) ) != null ; \n) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \n} \n} \n"}
{"9532": "public class CsvUtils { \npublic static List < String > getValues ( String csvRow ) { \nList < String > values = new ArrayList < String > ( ) ; \nStringReader in = new StringReader ( csvRow ) ; \nString value ; \ntry { \nvalue = nextValue ( in ) ; \nfor ( ; \ntrue ; \n) { \nvalues . add ( value ) ; \nvalue = nextValue ( in ) ; \n} \n} \ncatch ( IOException e ) { \nif ( csvRow . lastIndexOf ( ',' ) == csvRow . length ( ) - 1 ) values . add ( null ) ; \nreturn values ; \n} \n} \n} \n"}
{"9537": "public class DatabaseModel { \npublic static DatabaseModel readFromIndex ( BufferedReader reader , ProcessorLogger logger ) throws IOException { \nString dbInfo = reader . readLine ( ) ; \nlogger . info ( dbInfo ) ; \nMap < String , String > props = CsvUtils . getAsMap ( dbInfo ) ; \nString dbName = props . get ( \"dbName\" ) ; \nint dbVersion = Integer . parseInt ( props . get ( \"dbVersion\" ) ) ; \nString helperClass = props . get ( \"helperClass\" ) ; \nDatabaseModel dbModel = new DatabaseModel ( dbName , dbVersion , helperClass ) ; \nList < String > tables = new ArrayList < String > ( ) ; \nString th = reader . readLine ( ) ; \nfor ( ; \nth != null && ! th . equals ( StormEnvironment . END_DATABASE ) ; \n) { \ntables . add ( th ) ; \nth = reader . readLine ( ) ; \n} \ndbModel . tableHelpers = tables ; \nreturn dbModel ; \n} \n} \n"}
{"9592": "public class ABeliefStore { \npublic static void main ( String [ ] args ) throws BeliefBaseException { \nBeliefBase bb = new ABeliefStore ( 100 , 4 ) ; \nbb . eval ( 0 , \"neighbour.age < 31\" ) ; \nConsole console = System . console ( ) ; \nif ( console == null ) { \nSystem . err . println ( \"No console.\" ) ; \nSystem . exit ( 1 ) ; \n} \nfor ( ; \ntrue ; \n) { \nPattern pattern = Pattern . compile ( console . readLine ( \"%nEnter your regex: \" ) ) ; \nMatcher matcher = pattern . matcher ( console . readLine ( \"Enter input string to search: \" ) ) ; \nboolean found = false ; \nfor ( ; \nmatcher . find ( ) ; \n) { \nconsole . format ( \"I found the text\" + \" \\\"%s\\\" starting at \" + \"index %d and ending at index %d.%n\" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; \nfound = true ; \n} \nif ( ! found ) { \nconsole . format ( \"No match found.%n\" ) ; \n} \n} \n} \n} \n"}
{"9613": "public class Main { \npublic static void waitUntilIdle ( ) { \nlong t0 = System . currentTimeMillis ( ) ; \nsynchronized ( poolsIdle ) { \nfor ( ; \n! arePoolsIdle ( ) ; \n) { \ntry { \npoolsIdle . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . error ( \"Failed to wait on termination condition: \" + e . getMessage ( ) ) ; \n} \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Finished running \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9660": "public class AbstractStreamEndpoint { \nStoppableObservable < TEntity > getObservable ( final long startIndex , Scheduler scheduler ) { \nreturn runAsync ( scheduler , ( rx . Observer < ? super TEntity > observer , Subscription subscription ) -> { \nlong currentStartIndex = startIndex ; \nfor ( ; \n! subscription . isUnsubscribed ( ) ; \n) { \nPartialResponse < TEntity > response ; \ntry { \nresponse = ( currentStartIndex >= 0 ) ? readRange ( currentStartIndex , null ) : readRange ( null , - currentStartIndex ) ; \n} \ncatch ( IllegalStateException ex ) { \ncontinue ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException error ) { \nobserver . onError ( error ) ; \nreturn ; \n} \nresponse . getElements ( ) . stream ( ) . forEach ( observer :: onNext ) ; \nif ( response . isEndReached ( ) ) { \nobserver . onCompleted ( ) ; \nreturn ; \n} \ncurrentStartIndex = response . getTo ( ) + 1 ; \n} \n} \n) ; \n} \n} \n"}
{"9666": "public class MultipartMixedArgumentsReader { \n@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { \ntry { \nObject [ ] arguments = new Object [ formalParameters . length ] ; \nint argumentIndex = 0 ; \nServletFileUpload multipart = new ServletFileUpload ( ) ; \nFileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; \nFileItemStream fileItemStream = null ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nfileItemStream = iterator . next ( ) ; \nString contentType = fileItemStream . getContentType ( ) ; \nType parameterType = formalParameters [ argumentIndex ] ; \nArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; \nboolean streamArgument = StreamFactory . isStream ( parameterType ) ; \nArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; \nInputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; \narguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; \n++ argumentIndex ; \nif ( streamArgument ) { \nthreadLocal . set ( inputStream ) ; \nbreak ; \n} \ninputStream . close ( ) ; \n} \nif ( argumentIndex != formalParameters . length ) { \nthrow new IllegalArgumentException ( \"Not all parameters processed due to stream argument that is not the last on arguments list.\" ) ; \n} \nreturn arguments ; \n} \ncatch ( FileUploadException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9668": "public class AbstractEMFParser { \nprotected final void resolveProxies ( ) { \nfinal List < String > unresolved = new ArrayList < String > ( ) ; \nif ( ! resolvedAllProxies ( unresolved , 0 ) ) { \nLOG . warn ( \"Could not resolve the following proxies ({}):\" , unresolved . size ( ) ) ; \nfor ( final String ref : unresolved ) { \nLOG . warn ( \"Not found: {}\" , ref ) ; \n} \nfinal Iterator < Notifier > it = resourceSet . getAllContents ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nfinal Notifier next = it . next ( ) ; \nif ( next instanceof EObject ) { \nfinal EObject obj = ( EObject ) next ; \nif ( obj . eIsProxy ( ) ) { \ntry { \nit . remove ( ) ; \n} \ncatch ( final UnsupportedOperationException ex ) { \nLOG . error ( \"Could not remove proxy: \" + obj , ex ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"9671": "public class AbstractEMFParser { \npublic boolean isModelFullyResolved ( ) { \nboolean resolved = true ; \nfinal Set < EObject > eObjects = findAllEObjects ( resourceSet ) ; \nfinal Iterator < EObject > it = eObjects . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nfinal EObject eObj = it . next ( ) ; \nif ( eObj instanceof InternalEObject ) { \nfinal InternalEObject iObj = ( InternalEObject ) eObj ; \nfor ( final EObject crossRef : iObj . eCrossReferences ( ) ) { \nif ( crossRef . eIsProxy ( ) ) { \nLOG . error ( \"Unresolved: {}\" , crossRef ) ; \nresolved = false ; \n} \n} \n} \n} \nreturn resolved ; \n} \n} \n"}
{"9693": "public class RequestContext { \npublic void dump ( ) { \nif ( ! attached ) { \nreturn ; \n} \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Request context |\" ) ; \nmessage . append ( httpRequest . getRequestURI ( ) ) ; \nmessage . append ( \"|:\" ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- remote-address: \" ) ; \nmessage . append ( httpRequest . getRemoteHost ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- method: \" ) ; \nmessage . append ( httpRequest . getMethod ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- query-string: \" ) ; \nif ( httpRequest . getQueryString ( ) != null ) { \nmessage . append ( httpRequest . getQueryString ( ) ) ; \n} \nEnumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; \nfor ( ; \nheaderNames . hasMoreElements ( ) ; \n) { \nmessage . append ( System . lineSeparator ( ) ) ; \nString headerName = headerNames . nextElement ( ) ; \nmessage . append ( \"\\t- \" ) ; \nmessage . append ( headerName ) ; \nmessage . append ( \": \" ) ; \nmessage . append ( httpRequest . getHeader ( headerName ) ) ; \n} \nlog . error ( message . toString ( ) ) ; \n} \n} \n"}
{"9698": "public class FileSystemDirectoryHelper { \npublic String removePrefix ( final String path , final String prefix ) { \nString pathWithoutPrefix = path ; \nif ( pathWithoutPrefix . startsWith ( prefix ) ) { \npathWithoutPrefix = pathWithoutPrefix . substring ( prefix . length ( ) ) ; \nfor ( ; \npathWithoutPrefix . startsWith ( \"/\" ) || pathWithoutPrefix . startsWith ( \"\\\\\" ) ; \n) { \npathWithoutPrefix = pathWithoutPrefix . substring ( 1 ) ; \n} \n} \nreturn pathWithoutPrefix ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nint i = index >> 6 ; \nif ( i >= wlen ) return - 1 ; \nint subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \n} \nfor ( ; \n++ i < wlen ; \n) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nfor ( ; \n( line = br . readLine ( ) ) != null ; \n) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nelse if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \nSystem . out . println ( output ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . println ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . println ( \"Unexpected exception: \" + exp . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nfor ( ; \nunfinishedBusiness . size ( ) > 0 ; \n) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nif ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) { \nunfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \n} \n} \n"}
{"9919": "public class ADiGraph { \npublic List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { \nif ( hasCycles ( ) ) { \nthrow new AGraphCircularityException ( ) ; \n} \nfinal Object [ ] result = new Object [ nodes . length ] ; \nint nextIdx = 0 ; \nfinal Set < N > unprocessed = new HashSet < > ( ) ; \nfor ( Object node : nodes ) { \nunprocessed . add ( ( N ) node ) ; \n} \nfor ( ; \n! unprocessed . isEmpty ( ) ; \n) { \nfinal Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { \n@ Override public boolean apply ( N n ) { \nfor ( E e : incomingEdges ( n ) ) { \nif ( unprocessed . contains ( e . getFrom ( ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n) ; \nunprocessed . removeAll ( nextBatch ) ; \nfor ( N n : nextBatch ) { \nresult [ nextIdx ] = n ; \nnextIdx += 1 ; \n} \n} \nreturn new ArrayIterable < > ( result ) ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nfor ( ; \nws [ i = ( i + step ) & m ] != null ; \n) { \nif ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nint sp , i ; \nWorkQueue v ; \nThread p ; \nfor ( ; \n( c = ctl ) < 0L ; \n) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; \nbreak ; \n} \nif ( ws == null ) break ; \nif ( ws . length <= ( i = sp & SMASK ) ) break ; \nif ( ( v = ws [ i ] ) == null ) break ; \nint vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nint d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) U . unpark ( p ) ; \nbreak ; \n} \nif ( q != null && q . base == q . top ) break ; \n} \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nfor ( ; \n( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ; \n) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( status >= 0 ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9945": "public class AList { \npublic AList < T > reverse ( ) { \nAList < T > remaining = this ; \nAList < T > result = nil ( ) ; \nfor ( ; \n! remaining . isEmpty ( ) ; \n) { \nresult = result . cons ( remaining . head ( ) ) ; \nremaining = remaining . tail ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"9948": "public class ACollectionHelper { \npublic static < T , R , E extends Throwable > R foldRight ( List < T > coll , R startValue , AFunction2 < R , ? super T , R , E > f ) throws E { \nR result = startValue ; \nListIterator < T > i = coll . listIterator ( coll . size ( ) ) ; \nfor ( ; \ni . hasPrevious ( ) ; \n) { \nresult = f . apply ( result , i . previous ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"9951": "public class ALongHashMap { \npublic static < V > ALongHashMap < V > fromKeysAndValues ( Iterable < ? extends Number > keys , Iterable < V > values ) { \nfinal Iterator < ? extends Number > ki = keys . iterator ( ) ; \nfinal Iterator < V > vi = values . iterator ( ) ; \nALongHashMap < V > result = ALongHashMap . empty ( ) ; \nfor ( ; \nki . hasNext ( ) ; \n) { \nfinal Number key = ki . next ( ) ; \nfinal V value = vi . next ( ) ; \nresult = result . updated ( key . longValue ( ) , value ) ; \n} \nreturn result ; \n} \n} \n"}
{"9954": "public class AListMap { \npublic static < K , V > AListMap < K , V > fromKeysAndValues ( AEquality equality , Iterable < K > keys , Iterable < V > values ) { \nfinal Iterator < K > ki = keys . iterator ( ) ; \nfinal Iterator < V > vi = values . iterator ( ) ; \nAListMap < K , V > result = empty ( equality ) ; \nfor ( ; \nki . hasNext ( ) ; \n) { \nfinal K key = ki . next ( ) ; \nfinal V value = vi . next ( ) ; \nresult = result . updated ( key , value ) ; \n} \nreturn result ; \n} \n} \n"}
{"9990": "public class Invoker { \npublic static void invokeInThread ( DirectInvocation invocation ) { \nboolean retry = true ; \nfor ( ; \nretry ; \n) { \ninvocation . run ( ) ; \nif ( invocation . retry == null ) { \nretry = false ; \n} \nelse { \ntry { \nif ( invocation . retry . task != null ) { \ninvocation . retry . task . get ( ) ; \n} \nelse { \nThread . sleep ( invocation . retry . timeout ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new UnexpectedException ( e ) ; \n} \nretry = true ; \n} \n} \n} \n} \n"}
{"9994": "public class Controller { \nprotected String template ( String view ) { \nfinal Enumeration < String > attrs = getAttrNames ( ) ; \nfinal Map < String , Object > root = Maps . newHashMap ( ) ; \nfor ( ; \nattrs . hasMoreElements ( ) ; \n) { \nString attrName = attrs . nextElement ( ) ; \nroot . put ( attrName , getAttr ( attrName ) ) ; \n} \nreturn Freemarkers . processString ( view , root ) ; \n} \n} \n"}
{"10006": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nfor ( ; \ntrue ; \n) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) { \nbreak ; \n} \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \nreturn count ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nbyte buffer [ ] = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nfor ( ; \nbyteCount > 0 ; \n) { \nif ( byteCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , byteCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \nbyteCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10009": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output ) throws IOException { \nchar [ ] buffer = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nfor ( ; \n( read = input . read ( buffer , 0 , ioBufferSize ) ) >= 0 ; \n) { \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \noutput . flush ( ) ; \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nfor ( ; \ncharCount > 0 ; \n) { \nif ( charCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , charCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \ncharCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10013": "public class StreamUtil { \npublic static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedInputStream ) ) { \ninput1 = new BufferedInputStream ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedInputStream ) ) { \ninput2 = new BufferedInputStream ( input2 ) ; \n} \nint ch = input1 . read ( ) ; \nfor ( ; \nch != - 1 ; \n) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \nreturn false ; \n} \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10014": "public class StreamUtil { \npublic static boolean compare ( Reader input1 , Reader input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedReader ) ) { \ninput1 = new BufferedReader ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedReader ) ) { \ninput2 = new BufferedReader ( input2 ) ; \n} \nint ch = input1 . read ( ) ; \nfor ( ; \nch != - 1 ; \n) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \nreturn false ; \n} \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nfor ( ; \nzipEntries . hasMoreElements ( ) ; \n) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null && patterns . length > 0 ) { \nif ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) { \ncontinue ; \n} \n} \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( entry . isDirectory ( ) ) { \nif ( ! file . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + file ) ; \n} \n} \n} \nelse { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null && ! parent . exists ( ) ) { \nif ( ! parent . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + parent ) ; \n} \n} \n} \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \n} \nclose ( zip ) ; \n} \n} \n"}
{"10034": "public class IO { \npublic static String readContentAsString ( File file , String encoding ) { \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nStringWriter result = new StringWriter ( ) ; \nPrintWriter out = new PrintWriter ( result ) ; \nBufferedReader reader = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; \nString line = null ; \nfor ( ; \n( line = reader . readLine ( ) ) != null ; \n) { \nout . println ( line ) ; \n} \nreturn result . toString ( ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n} \n"}
{"10043": "public class ClassKit { \npublic static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { \nPreconditions . checkNotNull ( clazz , \"Class must not be null\" ) ; \ntry { \nClassLoader target = clazz . getClassLoader ( ) ; \nif ( target == null ) { \nreturn true ; \n} \nClassLoader cur = classLoader ; \nif ( cur == target ) { \nreturn true ; \n} \nfor ( ; \ncur != null ; \n) { \ncur = cur . getParent ( ) ; \nif ( cur == target ) { \nreturn true ; \n} \n} \nreturn false ; \n} \ncatch ( SecurityException ex ) { \nreturn true ; \n} \n} \n} \n"}
{"10074": "public class ConcurrentSoftHashMap { \nprivate void processQueue ( ) { \nSoftValue < ? , ? > sv ; \nfor ( ; \n( sv = ( SoftValue < ? , ? > ) queue . poll ( ) ) != null ; \n) { \nmap . remove ( sv . key ) ; \n} \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nfor ( ; \nindex < end ; \n) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nfor ( ; \nindex < end ; \n) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nfor ( ; \nindex < end ; \n) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nfor ( ; \nindex < end ; \n) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10110": "public class PreparedStatementCreator { \nprotected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { \nPreparedStatement ps = conn . prepareStatement ( sql ) ; \nif ( parameters != null ) { \nint index = 1 ; \nfor ( ; \nparameters . hasNext ( ) ; \n) { \nObject parameter = parameters . next ( ) ; \nif ( parameter == null ) { \nps . setObject ( index , null ) ; \n} \nelse { \nps . setObject ( index , parameter ) ; \n} \nindex ++ ; \n} \n} \nreturn ps ; \n} \n} \n"}
{"10112": "public class MuffinManager { \npublic String getMuffin ( String strParam ) { \ntry { \nURL url = new URL ( m_strCodeBase + strParam ) ; \nFileContents fc = m_ps . get ( url ) ; \nif ( fc == null ) return null ; \nbyte [ ] buf = new byte [ ( int ) fc . getLength ( ) ] ; \nInputStream is = fc . getInputStream ( ) ; \nint pos = 0 ; \nfor ( ; \n( pos = is . read ( buf , pos , buf . length - pos ) ) > 0 ; \n) { \n} \nis . close ( ) ; \nString strValue = new String ( buf , ENCODING ) ; \nreturn strValue ; \n} \ncatch ( Exception ex ) { \n} \nreturn null ; \n} \n} \n"}
{"10117": "public class ServiceManager { \npublic static < T extends Service > Map < String , T > loadServicesByType ( Class < T > clazz ) { \nServiceLoader < T > loader = ServiceLoader . load ( clazz ) ; \nIterator < T > it = loader . iterator ( ) ; \nMap < String , T > ret = new HashMap < String , T > ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nT op = it . next ( ) ; \nret . put ( op . getId ( ) , op ) ; \nif ( op instanceof ParametrizedOperation ) addParametrizedService ( op . getId ( ) , ( ParametrizedOperation ) op ) ; \nif ( op instanceof ScriptObject ) addScriptObject ( ( ( ScriptObject ) op ) . getVarName ( ) , ( ScriptObject ) op ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nfor ( ; \nj < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ; \n) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( startIndex < 0 ) { \nstartIndex = 0 ; \n} \nint srclen = s . length ( ) ; \nif ( endIndex > srclen ) { \nendIndex = srclen ; \n} \nint sublen = substr . length ( ) ; \nif ( sublen == 0 ) { \nreturn startIndex > srclen ? srclen : startIndex ; \n} \nsubstr = substr . toLowerCase ( ) ; \nint total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : for ( int i = startIndex ; \ni < total ; \ni ++ ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { \ncontinue ; \n} \nint j = 1 ; \nint k = i + 1 ; \nfor ( ; \nj < sublen ; \n) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) { \ncontinue mainloop ; \n} \nj ++ ; \nk ++ ; \n} \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nint i = size ; \nObject [ ] els = elements ; \nfor ( ; \ni -- > 0 ; \n) { \nels [ i ] = null ; \n} \nthis . size = 0 ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nfor ( ; \npatNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ; \n) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \nreturn false ; \n} \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nif ( patNdxStart > patNdxEnd ) { \nreturn false ; \n} \nfor ( ; \npatNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ; \n) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \nreturn false ; \n} \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nfor ( ; \n( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ; \n) { \nint patIdxTmp = - 1 ; \nfor ( int i = patNdxStart + 1 ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : for ( int i = 0 ; \ni <= strLength - patLength ; \ni ++ ) { \nfor ( int j = 0 ; \nj < patLength ; \nj ++ ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \ncontinue strLoop ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) { \nreturn false ; \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10187": "public class JdbcLogSupport { \nprotected Throwable unwrapThrowable ( Throwable t ) { \nThrowable e = t ; \nfor ( ; \ntrue ; \n) { \nif ( e instanceof InvocationTargetException ) { \ne = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; \n} \nelse if ( t instanceof UndeclaredThrowableException ) { \ne = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; \n} \nelse { \nreturn e ; \n} \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nfor ( ; \ni1 . hasNext ( ) && i2 . hasNext ( ) ; \n) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) { \nreturn - 1 ; \n} \nelse if ( comp > 0 ) { \nreturn 1 ; \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10206": "public class DataStreamServlet { \npublic void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { \nlog . fine ( \"void service(HttpServletRequest, HttpServletResponse): called\" ) ; \nString contentType = ( String ) request . getAttribute ( \"contentType\" ) ; \nString contentDisposition = ( String ) request . getAttribute ( \"contentDisposition\" ) ; \nInputStream inputStream = ( InputStream ) request . getAttribute ( \"inputStream\" ) ; \nif ( contentType != null ) { \nresponse . setContentType ( contentType ) ; \n} \nif ( contentDisposition != null ) { \nresponse . addHeader ( \"Content-disposition\" , contentDisposition ) ; \n} \nBufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nint length = - 1 ; \nbyte [ ] chunk = new byte [ 8192 ] ; \nfor ( ; \n( length = inputStream . read ( chunk ) ) != - 1 ; \n) { \noutputStream . write ( chunk , 0 , length ) ; \n} \noutputStream . flush ( ) ; \ninputStream . close ( ) ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nint charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( charsRequired < length ) ? length : charsRequired ; \nint index = buffer . position ( ) + length - 1 ; \nint start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( value < 0 ) { \nbuffer . put ( MINUS_ASCII ) ; \nstart ++ ; \n} \nelse { \nvalue = - value ; \n} \ndo { \nint remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nfor ( ; \nindex >= start ; \n) { \nbuffer . put ( index -- , ZERO_ASCII ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10262": "public class FileUtils { \nprivate static String readStreamAsString ( BufferedInputStream is ) { \ntry { \nbyte [ ] data = new byte [ 4096 ] ; \nStringBuffer inBuffer = new StringBuffer ( ) ; \nint read ; \nfor ( ; \n( read = is . read ( data ) ) != - 1 ; \n) { \nString s = new String ( data , 0 , read ) ; \ninBuffer . append ( s ) ; \n} \nreturn inBuffer . toString ( ) ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10282": "public class MaxStepsAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nfor ( ; \n! queue . isEmpty ( ) ; \n) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nif ( ! headNode . isExpanded ( ) ) { \nheadNode . expandSuccessors ( queue , reverseEnqueue ) ; \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \ncurrentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10283": "public class PrologParser { \npublic static void main ( String [ ] args ) { \ntry { \nSimpleCharStream inputStream = new SimpleCharStream ( System . in , null , 1 , 1 ) ; \nPrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; \nSource < Token > tokenSource = new TokenSource ( tokenManager ) ; \nPrologParser parser = new PrologParser ( tokenSource , new VariableAndFunctorInternerImpl ( \"Prolog_Variable_Namespace\" , \"Prolog_Functor_Namespace\" ) ) ; \nfor ( ; \ntrue ; \n) { \nObject nextParsing = parser . clause ( ) ; \nconsole . info ( nextParsing . toString ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nconsole . log ( Level . SEVERE , e . getMessage ( ) , e ) ; \nSystem . exit ( 1 ) ; \n} \n} \n} \n"}
{"10300": "public class Filterators { \npublic static < T > Collection < T > collectIterator ( Iterator < T > iterator , Collection < T > targetCollection ) { \nfor ( ; \niterator . hasNext ( ) ; \n) { \ntargetCollection . add ( iterator . next ( ) ) ; \n} \nreturn targetCollection ; \n} \n} \n"}
{"10313": "public class SequentialCuckooFunction { \nprivate Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { \nEntry < K > uninsertedEntry = entry ; \nboolean createdNewEntry = false ; \nEntry < K > existingEntry = entryForKey ( key ) ; \nInteger result = null ; \nif ( existingEntry != null ) { \nresult = existingEntry . seq ; \n} \nelse { \nif ( uninsertedEntry == null ) { \nuninsertedEntry = new Entry < K > ( ) ; \nuninsertedEntry . key = key ; \nuninsertedEntry . seq = nextSequenceNumber ; \nnextSequenceNumber ++ ; \ncount ++ ; \ncreatedNewEntry = true ; \nresult = uninsertedEntry . seq ; \n} \nfor ( ; \ntrue ; \n) { \nint keyHashCode = uninsertedEntry . key . hashCode ( ) ; \nuninsertedEntry . hash1 = hash1 ( keyHashCode ) ; \nuninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; \nuninsertedEntry = cuckoo ( uninsertedEntry ) ; \nif ( uninsertedEntry == null ) { \nresult = createdNewEntry ? result : - 1 ; \nbreak ; \n} \nif ( tryRehashing ) { \nrehash ( ) ; \n} \nelse { \nresult = null ; \nbreak ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10329": "public class DebugTag { \npublic String getHeaders ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getHeaderNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nEnumeration values = req . getHeaders ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nboolean first = true ; \nfor ( ; \nvalues . hasMoreElements ( ) ; \n) { \nif ( ! first ) { \nsb . append ( \" | \" ) ; \n} \nfirst = false ; \nsb . append ( values . nextElement ( ) ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"headers\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni ++ ) { \nif ( i != 0 ) { \nsb . append ( \" | \" ) ; \n} \nsb . append ( values [ i ] ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10332": "public class DebugTag { \npublic String getRequestScope ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getAttributeNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nObject value = req . getAttribute ( name ) ; \ninfo . put ( name , toStringValue ( value ) ) ; \n} \nreturn toHTMLTable ( \"request scope\" , info ) ; \n} \n} \n"}
{"10333": "public class DebugTag { \npublic String getPageScope ( ) { \nMap info = new TreeMap ( ) ; \nEnumeration names = pageContext . getAttributeNamesInScope ( PageContext . PAGE_SCOPE ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nObject value = pageContext . getAttribute ( name ) ; \ninfo . put ( name , toStringValue ( value ) ) ; \n} \nreturn toHTMLTable ( \"page scope\" , info ) ; \n} \n} \n"}
{"10334": "public class DebugTag { \npublic String getSessionScope ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nHttpSession session = req . getSession ( ) ; \nEnumeration names = session . getAttributeNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nObject value = session . getAttribute ( name ) ; \ninfo . put ( name , toStringValue ( value ) ) ; \n} \nreturn toHTMLTable ( \"session scope\" , info ) ; \n} \n} \n"}
{"10335": "public class DebugTag { \npublic String getApplicationScope ( ) { \nMap info = new TreeMap ( ) ; \nServletContext context = pageContext . getServletContext ( ) ; \nEnumeration names = context . getAttributeNames ( ) ; \nfor ( ; \nnames . hasMoreElements ( ) ; \n) { \nString name = ( String ) names . nextElement ( ) ; \nObject value = context . getAttribute ( name ) ; \ninfo . put ( name , toStringValue ( value ) ) ; \n} \nreturn toHTMLTable ( \"application scope\" , info ) ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nfor ( ; \n! queue . isEmpty ( ) ; \n) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( boundProperty <= maxBound ) { \nqueue . offer ( successor ) ; \n} \nelse { \nbeyondFringe = true ; \nminBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nif ( beyondFringe ) { \nthrow new MaxBoundException ( \"Max bound reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10341": "public class TermWalker { \npublic void walk ( Term term ) { \nterm . setTermTraverser ( traverser ) ; \nsearch . reset ( ) ; \nif ( goalPredicate != null ) { \nsearch . setGoalPredicate ( goalPredicate ) ; \n} \nsearch . addStartState ( term ) ; \nIterator < Term > treeWalker = Searches . allSolutions ( search ) ; \nif ( traverser instanceof TermVisitor ) { \nterm . accept ( ( TermVisitor ) traverser ) ; \n} \nfor ( ; \ntreeWalker . hasNext ( ) ; \n) { \nTerm nextTerm = treeWalker . next ( ) ; \nnextTerm . accept ( visitor ) ; \n} \nterm . setTermTraverser ( null ) ; \n} \n} \n"}
{"10369": "public class BaseBiDirectionalQueueSearch { \npublic SearchNode < O , T > findGoalPath ( ) throws SearchNotExhaustiveException { \nfor ( ; \n! forwardQueue . isEmpty ( ) || ! reverseQueue . isEmpty ( ) ; \n) { \nif ( ! forwardQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; \nforwardFringe . remove ( currentForwardNode . getState ( ) ) ; \nif ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) { \nreturn joinBothPaths ( currentForwardNode , reverseFringe . get ( currentForwardNode . getState ( ) ) ) ; \n} \nelse { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentForwardNode . expandSuccessors ( newStates , false ) ; \nforwardQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nforwardFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \n} \nif ( ! reverseQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentReverseNode = reverseQueue . remove ( ) ; \nreverseFringe . remove ( currentReverseNode . getState ( ) ) ; \nif ( forwardFringe . containsKey ( currentReverseNode . getState ( ) ) ) { \nreturn joinBothPaths ( forwardFringe . get ( currentReverseNode . getState ( ) ) , currentReverseNode ) ; \n} \nelse { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentReverseNode . expandSuccessors ( newStates , false ) ; \nreverseQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nreverseFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10370": "public class BaseBiDirectionalQueueSearch { \nprivate SearchNode < O , T > joinBothPaths ( SearchNode < O , T > forwardPath , SearchNode < O , T > reversePath ) throws SearchNotExhaustiveException { \nif ( pathJoiner != null ) { \nreturn pathJoiner . joinBothPaths ( forwardPath , reversePath ) ; \n} \nelse { \nSearchNode < O , T > currentReverseNode = reversePath ; \nSearchNode < O , T > currentForwardNode = forwardPath ; \nfor ( ; \n! goalPredicate . evaluate ( currentReverseNode . getState ( ) ) ; \n) { \nSearchNode < O , T > reverseParentNode = currentReverseNode . getParent ( ) ; \nT state = currentReverseNode . getParent ( ) . getState ( ) ; \nOperator < O > operation = currentReverseNode . getAppliedOp ( ) ; \nfloat cost = currentReverseNode . getPathCost ( ) - reverseParentNode . getPathCost ( ) ; \ncurrentForwardNode = currentForwardNode . makeNode ( new Successor < O > ( state , operation , cost ) ) ; \ncurrentReverseNode = reverseParentNode ; \n} \nreturn currentForwardNode ; \n} \n} \n} \n"}
{"10388": "public class StringUtils { \npublic static String [ ] listToArray ( String value , String delim ) { \nList < String > result = new ArrayList < String > ( ) ; \nStringTokenizer tokenizer = new StringTokenizer ( value , delim ) ; \nfor ( ; \ntokenizer . hasMoreTokens ( ) ; \n) { \nresult . add ( tokenizer . nextToken ( ) ) ; \n} \nreturn result . toArray ( new String [ result . size ( ) ] ) ; \n} \n} \n"}
{"10407": "public class ProtoDTMachine { \npublic Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { \nDecisionTree currentNode = dt ; \nfor ( ; \ntrue ; \n) { \nDecisionTreeElement element = currentNode . getElement ( ) ; \nif ( element instanceof Decision ) { \nDecision decision = ( Decision ) element ; \ncurrentNode = decision . decide ( state ) ; \n} \nelse if ( element instanceof Assignment ) { \nAssignment assignment = ( Assignment ) element ; \nMap < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; \nassignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; \nreturn assignmentMap ; \n} \nelse { \nthrow new ClassifyingFailureException ( \"A node which is not a decision was encountered.\" , null ) ; \n} \n} \n} \n} \n"}
{"10434": "public class Variable { \npublic Term getValue ( ) { \nTerm result = this ; \nTerm assignment = this . substitution ; \nfor ( ; \nassignment != null ; \n) { \nresult = assignment ; \nif ( ! assignment . isVar ( ) ) { \nbreak ; \n} \nelse { \nassignment = ( ( Variable ) assignment ) . substitution ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10445": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void acquireGlobalWriteLock ( TxId txId ) throws InterruptedException { \nglobalLock . writeLock ( ) . lock ( ) ; \ntry { \nif ( ! txId . equals ( globalWriteLockTxId ) ) { \nfor ( ; \nglobalWriteLockTxId != null ; \n) { \nglobalWriteLockFree . await ( ) ; \n} \nglobalWriteLockTxId = txId ; \n} \n} \nfinally { \nglobalLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"10459": "public class BacktrackingAlgorithm { \nprotected void backtrack ( SearchNode checkNode ) { \nfor ( ; \n( checkNode != null ) && ( checkNode . unexaminedSuccessorCount == 0 ) ; \n) { \nReversable undoState = ( ReTraversable ) checkNode . getState ( ) ; \nundoState . undoOperator ( ) ; \ncheckNode = checkNode . getParent ( ) ; \n} \n} \n} \n"}
{"10463": "public class DirectMemento { \npublic void capture ( ) { \nClass cls = ob . getClass ( ) ; \nfor ( ; \n! cls . equals ( Object . class ) ; \n) { \nField [ ] attrs = cls . getDeclaredFields ( ) ; \nHashMap map = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \nfor ( Field attr : attrs ) { \nattr . setAccessible ( true ) ; \nif ( shouldBeSaved ( attr ) ) { \ntry { \nmap . put ( attr . getName ( ) , attr . get ( ob ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"Field '\" + attr . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; \n} \n} \n} \ncls = cls . getSuperclass ( ) ; \n} \n} \n} \n"}
{"10469": "public class LockFreeNQueue { \npublic boolean offer ( E o ) { \nif ( o == null ) { \nthrow new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; \n} \nint level = priorityToLevel ( p . apply ( o ) ) ; \nNode < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; \nfor ( ; \ntrue ; \n) { \nNode < E > t = markers [ level + 1 ] . getTail ( ) ; \nNode < E > s = t . getNext ( ) ; \nif ( t == markers [ level + 1 ] . getTail ( ) ) { \nif ( s == markers [ level + 1 ] ) { \nif ( t . casNext ( s , newNode ) ) { \nmarkers [ level + 1 ] . casTail ( t , newNode ) ; \ncount . incrementAndGet ( ) ; \nreturn true ; \n} \n} \nelse { \nmarkers [ level + 1 ] . casTail ( t , s ) ; \n} \n} \n} \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nfor ( ; \ntrue ; \n) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n"}
{"10487": "public class BaseState { \nprotected void firePropertyChange ( PropertyChangeEvent evt ) { \nfinal PropertyChangeEvent finalEvent = evt ; \nIterator it ; \nif ( listeners == null ) { \nreturn ; \n} \nsynchronized ( listeners ) { \nit = listeners . iterator ( ) ; \nfor ( ; \nit . hasNext ( ) ; \n) { \nfinal PropertyChangeListener l = ( PropertyChangeListener ) it . next ( ) ; \nRunnable r = new Runnable ( ) { \npublic void run ( ) { \nl . propertyChange ( finalEvent ) ; \n} \n} \n; \nSwingUtilities . invokeLater ( r ) ; \n} \n} \n} \n} \n"}
{"10494": "public class BaseUnaryCondition { \npublic void await ( T t ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nfor ( ; \nwaitNanos > 0 ; \n) { \nlong milliPause = waitNanos / 1000000 ; \nint nanoPause = ( int ) ( waitNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \n} \n} \n"}
{"10495": "public class BaseUnaryCondition { \npublic boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nfor ( ; \nwaitNanos > 0 ; \n) { \nlong remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; \nif ( remainingTimeNanos <= 0 ) { \nreturn false ; \n} \nlong timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; \nlong milliPause = timeToPauseNanos / 1000000 ; \nint nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10523": "public class CommandLineParser { \npublic static String rightPad ( String stringToPad , String padder , int size ) { \nif ( padder . length ( ) == 0 ) { \nreturn stringToPad ; \n} \nStringBuffer strb = new StringBuffer ( stringToPad ) ; \nCharacterIterator sci = new StringCharacterIterator ( padder ) ; \nfor ( ; \nstrb . length ( ) < size ; \n) { \nfor ( char ch = sci . first ( ) ; \nch != CharacterIterator . DONE ; \nch = sci . next ( ) ) { \nif ( strb . length ( ) < size ) { \nstrb . append ( String . valueOf ( ch ) ) ; \n} \n} \n} \nreturn strb . toString ( ) ; \n} \n} \n"}
{"10532": "public class Comparisons { \npublic static < T , U > String compareIterators ( Iterator < U > iterator , Iterator < T > expectedIterator , Function < U , T > mapping ) { \nString errorMessage = \"\" ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nU next = iterator . next ( ) ; \nT nextMapped = mapping . apply ( next ) ; \nT nextExpected = expectedIterator . next ( ) ; \nif ( ! nextMapped . equals ( nextExpected ) ) { \nerrorMessage += \"Expecting \" + nextExpected + \" but got \" + nextMapped ; \n} \n} \nreturn errorMessage ; \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( bp == 0 ) { \ni = TRAIL_BASE ; \n} \nelse { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nfor ( ; \ni < trp ; \n) { \nint addr = data . get ( i ) ; \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ni ++ ; \n} \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nfor ( ; \n! uEmpty ( ) && ! fail ; \n) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( int i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nint illegal = 0 ; \nint tileX = getXForTile ( t ) ; \nint tileY = getYForTile ( t ) ; \nfor ( ; \ntileX != x ; \n) { \nif ( ( tileX - x ) > 0 ) { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX -- ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX ++ ; \n} \n} \nfor ( ; \ntileY != y ; \n) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { \nillegal ++ ; \n} \ntileY -- ; \n} \nreturn illegal ; \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nint oa ; \nint i ; \nint b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nfor ( ; \nb != 0 ; \n) { \ni = ( i << 1 ) ; \nif ( n >= ( 1 << b ) ) { \nn /= ( 1 << b ) ; \ni = i | 1 ; \n} \nelse { \nn &= ( 1 << b ) - 1 ; \n} \nb /= 2 ; \n} \nif ( ( 1 << i ) == oa ) { \nreturn i ; \n} \nelse { \nreturn i + 1 ; \n} \n} \n} \n"}
{"10598": "public class Filterator { \npublic T nextInSequence ( ) { \nT result = null ; \nfor ( ; \nsource . hasNext ( ) ; \n) { \nS next = source . next ( ) ; \nresult = mapping . apply ( next ) ; \nif ( result != null ) { \nbreak ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10626": "public class ResolutionEngine { \npublic void consultInputStream ( InputStream stream ) throws SourceCodeException { \nSource < Token > tokenSource = TokenSource . getTokenSourceForInputStream ( stream ) ; \ngetParser ( ) . setTokenSource ( tokenSource ) ; \nfor ( ; \ntrue ; \n) { \nSentence < S > sentence = getParser ( ) . parse ( ) ; \nif ( sentence == null ) { \nbreak ; \n} \ngetCompiler ( ) . compile ( sentence ) ; \n} \n} \n} \n"}
{"10630": "public class SocketReadThread { \nprivate void readStream ( ) throws Exception { \nfor ( ; \n! shutdown ; \n) { \nElement doc = reader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nreturn ; \n} \nPacket packet ; \nString tag = doc . getName ( ) ; \nif ( \"message\" . equals ( tag ) ) { \npacket = new Message ( doc ) ; \n} \nelse if ( \"presence\" . equals ( tag ) ) { \npacket = new Presence ( doc ) ; \n} \nelse if ( \"iq\" . equals ( tag ) ) { \npacket = getIQ ( doc ) ; \n} \nelse { \nthrow new XmlPullParserException ( \"Unknown packet type was read: \" + tag ) ; \n} \ncomponent . processPacket ( packet ) ; \n} \n} \n} \n"}
{"10643": "public class PacketReader { \nprivate void parsePackets ( Thread thread ) { \ntry { \nfor ( ; \n! done ; \n) { \nif ( reset ) { \nstartStream ( ) ; \nLOGGER . debug ( \"Started xmlstream...\" ) ; \nreset = false ; \ncontinue ; \n} \nElement doc = innerReader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nconnection . disconnect ( ) ; \nLOGGER . debug ( \"End of xmlstream.\" ) ; \ncontinue ; \n} \nPacket packet = null ; \nLOGGER . debug ( \"Processing packet \" + doc . asXML ( ) ) ; \npacket = parseFromPlugins ( doc , packet ) ; \nif ( packet == null ) { \npacket = parseFromCore ( doc ) ; \n} \nif ( packet != null ) { \nprocessPacket ( packet ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( ! done && ! connection . isSocketClosed ( ) ) { \nconnection . notifyConnectionError ( e ) ; \nif ( ! connection . isConnected ( ) ) { \nreleaseConnectionIDLock ( ) ; \n} \n} \n} \n} \n} \n"}
{"10651": "public class ModificationRequest { \npublic void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { \nboolean debug = LOGGER . isDebugEnabled ( ) ; \nif ( ServletFileUpload . isMultipartContent ( request ) ) { \nif ( debug ) { \nLOGGER . debug ( \"Multipart POST \" ) ; \n} \nfeedback . add ( \"Multipart Upload\" ) ; \nServletFileUpload upload = new ServletFileUpload ( ) ; \nFileItemIterator iterator = upload . getItemIterator ( request ) ; \nfor ( ; \niterator . hasNext ( ) ; \n) { \nFileItemStream item = iterator . next ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Got Item {}\" , item ) ; \n} \nString name = item . getFieldName ( ) ; \nInputStream stream = item . openStream ( ) ; \nif ( item . isFormField ( ) ) { \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \nelse { \nif ( streamProcessor != null ) { \nfeedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; \n} \n} \n} \nif ( debug ) { \nLOGGER . debug ( \"No More items \" ) ; \n} \n} \nelse { \nif ( debug ) { \nLOGGER . debug ( \"Trad Post \" ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Traditional POST {} \" , parameters ) ; \n} \nSet < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; \nfor ( Entry < String , String [ ] > param : entries ) { \nString name = ( String ) param . getKey ( ) ; \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \n} \n} \n"}
{"10655": "public class PacketWriter { \nprivate Packet nextPacket ( ) { \nPacket packet = null ; \nfor ( ; \n! done && ( packet = queue . poll ( ) ) == null ; \n) { \ntry { \nsynchronized ( queue ) { \nqueue . wait ( ) ; \n} \n} \ncatch ( InterruptedException ie ) { \n} \n} \nreturn packet ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nfor ( ; \nlength > 0 ; \n) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10666": "public class TransactionalHashMap { \nEntry < K , V > getEntry ( Object key ) { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > e = table [ i ] ; \nfor ( ; \ne != null && ! ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) ; \n) e = e . next ; \nreturn e ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nint numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) return ; \nif ( numKeysToBeAdded > threshold ) { \nint targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; \nint newCapacity = table . length ; \nfor ( ; \nnewCapacity < targetCapacity ; \n) newCapacity <<= 1 ; \nif ( newCapacity > table . length ) resize ( newCapacity ) ; \n} \nfor ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nfor ( ; \ne != null ; \n) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \nreturn e ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) return null ; \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nfor ( ; \ne != null ; \n) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nreturn e ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10728": "public class CF_Locator { \npublic Map < URI , String > getCfLocations ( ) { \nif ( this . needsReRun == true ) { \nthis . locationMap . clear ( ) ; \nString pathSep = System . getProperty ( \"path.separator\" ) ; \nString classpath = System . getProperty ( \"java.class.path\" ) ; \nStringTokenizer st = new StringTokenizer ( classpath , pathSep ) ; \nFile file = null ; \nfor ( ; \nst . hasMoreTokens ( ) ; \n) { \nString path = st . nextToken ( ) ; \nfile = new File ( path ) ; \nthis . include ( file ) ; \n} \n} \nthis . needsReRun = false ; \nreturn this . locationMap ; \n} \n} \n"}
{"10738": "public class EventPropertiesAssistant { \nprivate void doWithLock ( FileChannel channel , Consumer < FileLock > consumer ) { \nFileLock lock = null ; \ntry { \nfor ( ; \nlock == null ; \n) { \ntry { \nlock = channel . tryLock ( ) ; \n} \ncatch ( OverlappingFileLockException e ) { \nThread . sleep ( 500 ) ; \n} \n} \nconsumer . accept ( lock ) ; \n} \ncatch ( IOException | InterruptedException e ) { \nerror ( \"Unable to write\" , e ) ; \n} \nfinally { \ntry { \nif ( lock != null ) { \nlock . release ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10739": "public class EventPropertiesAssistant { \npublic void unregisterEventID ( String eventKey ) { \nproperties . remove ( eventKey + \"_DESCRIPTION\" ) ; \nproperties . remove ( eventKey ) ; \nFileOutputStream out = null ; \nBufferedReader reader = null ; \nBufferedWriter writer = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nfinal File tempFile = new File ( eventPropertiesPath + \"temp.properties\" ) ; \nfinal BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; \nfinal BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( eventKey ) != null ) { \nreturn ; \n} \ntry { \nString currentLine = readerFinal . readLine ( ) ; \nfor ( ; \ncurrentLine != null ; \n) { \nString trimmedLine = currentLine . trim ( ) ; \nif ( trimmedLine . equals ( eventKey + \"_DESCRIPTION\" ) || trimmedLine . equals ( eventKey ) ) continue ; \nwriterFinal . write ( currentLine + System . getProperty ( \"line.separator\" ) ) ; \ncurrentLine = readerFinal . readLine ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \nreader = readerFinal ; \nwriter = writerFinal ; \ntempFile . renameTo ( new File ( eventPropertiesPath ) ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) { \nout . close ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nif ( reader != null ) { \nreader . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10755": "public class LaunchNakamura { \nprivate void isStartupFinished ( ) { \nboolean started = false ; \ntry { \nfor ( ; \n! started ; \n) { \nif ( exists ( localhostURL ) ) started = true ; \nThread . sleep ( 5 * 1000 ) ; \n} \n} \ncatch ( InterruptedException e ) { \ne . printStackTrace ( ) ; \n} \nif ( started ) { \nstatusLabel . setText ( \"Nakamura is running.\" ) ; \nstatusLabel . setForeground ( Color . green ) ; \nlaunchButton . setEnabled ( false ) ; \nbrowserButton . setEnabled ( true ) ; \n} \n} \n} \n"}
{"10779": "public class PacketCollector { \nprotected void processPacket ( Packet packet ) { \nif ( packet == null ) { \nreturn ; \n} \nif ( packetFilter == null || packetFilter . accept ( packet ) ) { \nfor ( ; \n! resultQueue . offer ( packet ) ; \n) { \nresultQueue . poll ( ) ; \n} \n} \n} \n} \n"}
{"10809": "public class PacketParserUtils { \npublic static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { \nDefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; \nboolean done = false ; \nfor ( ; \n! done ; \n) { \nint eventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . START_TAG ) { \nString name = parser . getName ( ) ; \nif ( parser . isEmptyElementTag ( ) ) { \nextension . setValue ( name , \"\" ) ; \n} \nelse { \neventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . TEXT ) { \nString value = parser . getText ( ) ; \nextension . setValue ( name , value ) ; \n} \n} \n} \nelse if ( eventType == XmlPullParser . END_TAG ) { \nif ( parser . getName ( ) . equals ( elementName ) ) { \ndone = true ; \n} \n} \n} \nreturn extension ; \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nint hash = ref . hashCode ( ) ; \nint index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nfor ( ; \nentry != null ; \n) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( previous == null ) { \ndata [ index ] = entry . next ; \n} \nelse { \nprevious . next = entry . next ; \n} \nthis . size -- ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \n} \n} \n"}
{"10845": "public class ExternalComponent { \npublic void connectionLost ( ) { \nsynchronized ( this ) { \nif ( reconnecting ) { \nreturn ; \n} \nreconnecting = true ; \n} \nreaderThread = null ; \nboolean isConnected = false ; \nif ( ! shutdown ) { \ncomponent . shutdown ( ) ; \n} \nfor ( ; \n! isConnected && ! shutdown ; \n) { \ntry { \nconnect ( host , port , subdomain ) ; \nisConnected = true ; \nif ( shutdown ) { \ndisconnect ( ) ; \n} \nelse { \nstart ( ) ; \n} \n} \ncatch ( ComponentException e ) { \nmanager . getLog ( ) . error ( \"Error trying to reconnect with the server\" , e ) ; \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e1 ) { \n} \n} \n} \nreconnecting = false ; \n} \n} \n"}
{"10851": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > lookup ( final Object data , final int index ) { \nNode < K , V > rval = null ; \nNode < K , V > node = rootNode [ index ] ; \nfor ( ; \nnode != null ; \n) { \nint cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; \nif ( cmp == 0 ) { \nrval = node ; \nbreak ; \n} \nelse { \nnode = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10853": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > leastNode ( final Node < K , V > node , final int index ) { \nNode < K , V > lval = node ; \nif ( lval != null ) { \nfor ( ; \nlval . getLeft ( index ) != null ; \n) { \nlval = lval . getLeft ( index ) ; \n} \n} \nreturn lval ; \n} \n} \n"}
{"10854": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > mostNode ( final Node < K , V > node , final int index ) { \nNode < K , V > rval = node ; \nif ( rval != null ) { \nfor ( ; \nrval . getRight ( index ) != null ; \n) { \nrval = rval . getRight ( index ) ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10855": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > nextGreater ( final Node < K , V > node , final int index ) { \nNode < K , V > rval ; \nif ( node == null ) { \nrval = null ; \n} \nelse if ( node . getRight ( index ) != null ) { \nrval = leastNode ( node . getRight ( index ) , index ) ; \n} \nelse { \nNode < K , V > parent = node . getParent ( index ) ; \nNode < K , V > child = node ; \nfor ( ; \n( parent != null ) && ( child == parent . getRight ( index ) ) ; \n) { \nchild = parent ; \nparent = parent . getParent ( index ) ; \n} \nrval = parent ; \n} \nreturn rval ; \n} \n} \n"}
{"10856": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > mostValidNode ( final Node < K , V > node , final int index , final String thread_id ) { \nNode < K , V > rval = node ; \nfor ( ; \nrval != null && ! validNode ( rval , thread_id ) ; \n) { \nrval = nextGreater ( rval , index ) ; \n} \nreturn rval ; \n} \n} \n"}
{"10857": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > leastValidNode ( final Node < K , V > node , final int index , final String thread_id ) { \nNode < K , V > lval = node ; \nfor ( ; \nlval != null && ! validNode ( lval , thread_id ) ; \n) { \nlval = nextSmaller ( lval , index ) ; \n} \nreturn lval ; \n} \n} \n"}
{"10867": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackInsert ( final Node < K , V > insertedNode , final int index ) { \nNode < K , V > currentNode = insertedNode ; \nmakeRed ( currentNode , index ) ; \nfor ( ; \n( currentNode != null ) && ( currentNode != rootNode [ index ] ) && ( isRed ( currentNode . getParent ( index ) , index ) ) ; \n) { \nif ( isLeftChild ( getParent ( currentNode , index ) , index ) ) { \nNode < K , V > y = getRightChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isRightChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateLeft ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateRight ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \n} \nelse { \nNode < K , V > y = getLeftChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isLeftChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateRight ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateLeft ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \n} \n} \nmakeBlack ( rootNode [ index ] , index ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nfor ( ; \ntrue ; \n) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n} \n"}
{"10877": "public class TransactionalBidiTreeMap { \n@ Override public Collection < V > values ( ) { \nif ( collectionOfValuesByKey == null ) { \ncollectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { \n@ Override public Iterator < V > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < V > ( KEY ) { \n@ Override protected V doGetNext ( ) { \nreturn ( V ) lastReturnedNode . getData ( VALUE ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsValue ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nint oldNodeCount = nodeCount ; \nremoveValue ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nboolean modified = false ; \nIterator < ? > iter = c . iterator ( ) ; \nfor ( ; \niter . hasNext ( ) ; \n) { \nif ( removeValue ( iter . next ( ) ) != null ) { \nmodified = true ; \n} \n} \nreturn modified ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \n} \nreturn collectionOfValuesByKey ; \n} \n} \n"}
{"10880": "public class Cache { \nprotected synchronized void deleteExpiredEntries ( ) { \nif ( maxLifetime <= 0 ) { \nreturn ; \n} \nLinkedListNode node = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \nlong expireTime = System . currentTimeMillis ( ) - maxLifetime ; \nfor ( ; \nexpireTime > node . timestamp ; \n) { \nif ( remove ( node . object , true ) == null ) { \nlog . warn ( \"Error attempting to remove(\" + node . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nnode . remove ( ) ; \n} \nnode = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \n} \n} \n} \n"}
{"10908": "public class IterativeCallback { \nprivate R doIteration ( Iterator < ? extends T > it ) { \nstate . i = it ; \nstate . iterations = 0 ; \nif ( state . do_break == true ) return state . return_object ; \nfor ( ; \nstate . i . hasNext ( ) ; \n) { \nT o = state . i . next ( ) ; \nif ( delegate != null ) delegate . delegate ( o ) ; \nelse iterateObject ( o ) ; \nif ( state . do_break == true ) return state . return_object ; \n} \nreturn state . amended_object ; \n} \n} \n"}
{"10914": "public class FireREST { \npublic JSONResult getJSON ( URL url ) { \ntry { \nlogger . debug ( \"Requesting {}\" , url ) ; \nStringBuilder text = new StringBuilder ( ) ; \nString line ; \nHttpURLConnection urlconn = ( HttpURLConnection ) url . openConnection ( ) ; \nurlconn . setReadTimeout ( msTimeout ) ; \nurlconn . setConnectTimeout ( msTimeout ) ; \nurlconn . setRequestMethod ( \"GET\" ) ; \nurlconn . connect ( ) ; \nBufferedReader br = new BufferedReader ( new InputStreamReader ( urlconn . getInputStream ( ) ) ) ; \nfor ( ; \n( line = br . readLine ( ) ) != null ; \n) { \ntext . append ( line ) ; \n} \nreturn new JSONResult ( text . toString ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new FireRESTException ( url . toString ( ) , e ) ; \n} \n} \n} \n"}
{"10915": "public class CollectionUtilities { \npublic static < K , V > void reverse ( Map < K , V > source , Map < V , K > target ) { \nIterator < K > i = source . keySet ( ) . iterator ( ) ; \nfor ( ; \ni . hasNext ( ) ; \n) { \nK key = i . next ( ) ; \nV value = source . get ( key ) ; \ntarget . put ( value , key ) ; \n} \n} \n} \n"}
{"10928": "public class OutputPluginArgument { \n@ Override public void run ( ) { \nfor ( ; \n! stop ; \n) { \nEventModel event ; \ntry { \nevent = blockingQueueHandling ( ) ; \n} \ncatch ( InterruptedException e ) { \ngetContext ( ) . getLogger ( ) . warn ( e ) ; \ncontinue ; \n} \nList < CompletableFuture < X > > outputExtensions = getContext ( ) . getOutput ( ) . generateAllOutputExtensions ( this , getArgument ( ) , event ) ; \ntry { \noutputExtensions = timeOut ( outputExtensions , getTimeoutLimit ( ) ) ; \n} \ncatch ( InterruptedException e ) { \ngetContext ( ) . getLogger ( ) . warn ( e ) ; \n} \nhandleFutures ( outputExtensions , event ) ; \nisDone ( event ) ; \n} \n} \n} \n"}
{"10940": "public class AbstractHashedMap { \npublic boolean containsKey ( Object key ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nHashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \nreturn false ; \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nfor ( ; \nentry != null ; \n) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10942": "public class AbstractHashedMap { \npublic V put ( K key , V value ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nint index = hashIndex ( hashCode , data . length ) ; \nHashEntry < K , V > entry = data [ index ] ; \nfor ( ; \nentry != null ; \n) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { \nV oldValue = entry . getValue ( ) ; \nupdateEntry ( entry , value ) ; \nreturn oldValue ; \n} \nentry = entry . next ; \n} \naddMapping ( index , hashCode , key , value ) ; \nreturn null ; \n} \n} \n"}
{"10948": "public class AbstractHashedMap { \nprotected int calculateNewCapacity ( int proposedCapacity ) { \nint newCapacity = 1 ; \nif ( proposedCapacity > MAXIMUM_CAPACITY ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \nelse { \nfor ( ; \nnewCapacity < proposedCapacity ; \n) { \nnewCapacity <<= 1 ; \n} \nif ( newCapacity > MAXIMUM_CAPACITY ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \n} \nreturn newCapacity ; \n} \n} \n"}
