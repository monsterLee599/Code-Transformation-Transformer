{"0": "public class QueueDrainObserver { \nprotected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { \nfinal Observer < ? super V > observer = downstream ; \nfinal SimplePlainQueue < U > q = queue ; \nif ( ! ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) ) { \nq . offer ( value ) ; \nif ( ! enter ( ) ) { \nreturn ; \n} \n} \nelse { \nif ( ! ( q . isEmpty ( ) ) ) { \nq . offer ( value ) ; \n} \nelse { \naccept ( observer , value ) ; \nif ( leave ( - 1 ) == 0 ) { \nreturn ; \n} \n} \n} \nQueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; \n} \n} \n"}
{"6": "public class FlowableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( t == null ) { \nEmptySubscription . complete ( subscriber ) ; \nreturn true ; \n} \nPublisher < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null Publisher\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( ! ( r instanceof Callable ) ) { \nr . subscribe ( subscriber ) ; \n} \nelse { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( u == null ) { \nEmptySubscription . complete ( subscriber ) ; \nreturn true ; \n} \nsubscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"24": "public class QueueDrainHelper { \npublic static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { \nint missed = 1 ; \nfor ( ; \n; \n) { \nfor ( ; \n; \n) { \nboolean d = qd . done ( ) ; \nT v = q . poll ( ) ; \nboolean empty = v == null ; \nif ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \nreturn ; \n} \nif ( empty ) { \nbreak ; \n} \nlong r = qd . requested ( ) ; \nif ( ! ( r != 0L ) ) { \nq . clear ( ) ; \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \na . onError ( new MissingBackpressureException ( \"Could not emit value due to lack of requests.\" ) ) ; \nreturn ; \n} \nelse { \nif ( qd . accept ( a , v ) ) { \nif ( r != Long . MAX_VALUE ) { \nqd . produced ( 1 ) ; \n} \n} \n} \n} \nmissed = qd . leave ( - missed ) ; \nif ( missed == 0 ) { \nbreak ; \n} \n} \n} \n} \n"}
{"38": "public class LinkedArrayList { \npublic void add ( Object o ) { \nif ( ! ( size == 0 ) ) if ( ! ( indexInTail == capacityHint ) ) { \ntail [ indexInTail ] = o ; \nindexInTail ++ ; \nsize ++ ; \n} \nelse { \nObject [ ] t = new Object [ capacityHint + 1 ] ; \nt [ 0 ] = o ; \ntail [ capacityHint ] = t ; \ntail = t ; \nindexInTail = 1 ; \nsize ++ ; \n} \nelse { \nhead = new Object [ capacityHint + 1 ] ; \ntail = head ; \nhead [ 0 ] = o ; \nindexInTail = 1 ; \nsize = 1 ; \n} \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( ! ( e instanceof CompositeException ) ) { \nlist . add ( e ) ; \n} \nelse { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( int i = exceptions . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"48": "public class ObservableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( t == null ) { \nEmptyDisposable . complete ( observer ) ; \nreturn true ; \n} \nObservableSource < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null ObservableSource\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( ! ( r instanceof Callable ) ) { \nr . subscribe ( observer ) ; \n} \nelse { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( u == null ) { \nEmptyDisposable . complete ( observer ) ; \nreturn true ; \n} \nScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; \nobserver . onSubscribe ( sd ) ; \nsd . run ( ) ; \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"56": "public class DeferredScalarDisposable { \npublic final void complete ( T value ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nreturn ; \n} \nObserver < ? super T > a = downstream ; \nif ( ! ( state == FUSED_EMPTY ) ) { \nlazySet ( TERMINATED ) ; \na . onNext ( value ) ; \n} \nelse { \nthis . value = value ; \nlazySet ( FUSED_READY ) ; \na . onNext ( null ) ; \n} \nif ( get ( ) != DISPOSED ) { \na . onComplete ( ) ; \n} \n} \n} \n"}
{"62": "public class PerfAsyncConsumer { \npublic PerfAsyncConsumer await ( int count ) { \nif ( ! ( count <= 1000 ) ) { \ntry { \nawait ( ) ; \n} \ncatch ( InterruptedException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \nelse { \nwhile ( getCount ( ) != 0 ) { \n} \n} \nreturn this ; \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( ! ( n == 1 ) ) { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nelse { \nb = EMPTY ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n"}
{"67": "public class HttpServiceMethod { \nstatic < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { \nboolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; \nboolean continuationWantsResponse = false ; \nboolean continuationBodyNullable = false ; \nAnnotation [ ] annotations = method . getAnnotations ( ) ; \nType adapterType ; \nif ( ! ( isKotlinSuspendFunction ) ) { \nadapterType = method . getGenericReturnType ( ) ; \n} \nelse { \nType [ ] parameterTypes = method . getGenericParameterTypes ( ) ; \nType responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; \nif ( ! ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) ) { \n} \nelse { \nresponseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; \ncontinuationWantsResponse = true ; \n} \nadapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; \nannotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; \n} \nCallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; \nType responseType = callAdapter . responseType ( ) ; \nif ( responseType == okhttp3 . Response . class ) { \nthrow methodError ( method , \"'\" + getRawType ( responseType ) . getName ( ) + \"' is not a valid response body type. Did you mean ResponseBody?\" ) ; \n} \nif ( responseType == Response . class ) { \nthrow methodError ( method , \"Response must include generic type (e.g., Response<String>)\" ) ; \n} \nif ( requestFactory . httpMethod . equals ( \"HEAD\" ) && ! Void . class . equals ( responseType ) ) { \nthrow methodError ( method , \"HEAD method must use Void as response type.\" ) ; \n} \nConverter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; \nokhttp3 . Call . Factory callFactory = retrofit . callFactory ; \nif ( ! ( ! isKotlinSuspendFunction ) ) if ( ! ( continuationWantsResponse ) ) { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; \n} \nelse { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; \n} \nelse { \nreturn new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; \n} \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \nfor ( int i = 0 ; \ni < params . length ; \ni ++ ) { \nencodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \n} \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( ! ( attributeNames == null || attributeNames . length == 0 ) ) { \nfor ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \n} \nelse { \ntry { \nfor ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nae . hasMore ( ) ; \n) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"111": "public class AbstractRememberMeServices { \nprotected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { \nString cookieValue = encodeCookie ( tokens ) ; \nCookie cookie = new Cookie ( cookieName , cookieValue ) ; \ncookie . setMaxAge ( maxAge ) ; \ncookie . setPath ( getCookiePath ( request ) ) ; \nif ( cookieDomain != null ) { \ncookie . setDomain ( cookieDomain ) ; \n} \nif ( maxAge < 1 ) { \ncookie . setVersion ( 1 ) ; \n} \nif ( ! ( useSecureCookie == null ) ) { \ncookie . setSecure ( useSecureCookie ) ; \n} \nelse { \ncookie . setSecure ( request . isSecure ( ) ) ; \n} \ncookie . setHttpOnly ( true ) ; \nresponse . addCookie ( cookie ) ; \n} \n} \n"}
{"115": "public class SpringSecurityAuthenticationSource { \npublic String getPrincipal ( ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( authentication == null ) { \nlog . warn ( \"No Authentication object set in SecurityContext - returning empty String as Principal\" ) ; \nreturn \"\" ; \n} \nObject principal = authentication . getPrincipal ( ) ; \nif ( ! ( principal instanceof LdapUserDetails ) ) if ( ! ( authentication instanceof AnonymousAuthenticationToken ) ) { \nthrow new IllegalArgumentException ( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\" ) ; \n} \nelse { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Anonymous Authentication, returning empty String as Principal\" ) ; \n} \nreturn \"\" ; \n} \nelse { \nLdapUserDetails details = ( LdapUserDetails ) principal ; \nreturn details . getDn ( ) ; \n} \n} \n} \n"}
{"123": "public class UserDetailsServiceFactoryBean { \nprivate UserDetailsService getUserDetailsService ( ) { \nMap < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; \nif ( beans . size ( ) == 0 ) { \nbeans = getBeansOfType ( UserDetailsService . class ) ; \n} \nif ( ! ( beans . size ( ) == 0 ) ) if ( beans . size ( ) > 1 ) { \nthrow new ApplicationContextException ( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\" ) ; \n} \nelse { \nthrow new ApplicationContextException ( \"No UserDetailsService registered.\" ) ; \n} \nreturn ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; \n} \n} \n"}
{"141": "public class MapBasedAttributes2GrantedAuthoritiesMapper { \nprivate void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { \nif ( value == null ) { \nreturn ; \n} \nif ( ! ( value instanceof Collection < ? > ) ) if ( ! ( value instanceof Object [ ] ) ) if ( ! ( value instanceof String ) ) if ( ! ( value instanceof GrantedAuthority ) ) { \nthrow new IllegalArgumentException ( \"Invalid object type: \" + value . getClass ( ) . getName ( ) ) ; \n} \nelse { \nresult . add ( ( GrantedAuthority ) value ) ; \n} \nelse { \naddGrantedAuthorityCollection ( result , ( String ) value ) ; \n} \nelse { \naddGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; \n} \nelse { \naddGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; \n} \n} \n} \n"}
{"167": "public class LdapAuthority { \npublic String getFirstAttributeValue ( String name ) { \nList < String > result = getAttributeValues ( name ) ; \nif ( ! ( result . isEmpty ( ) ) ) { \nreturn result . get ( 0 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"193": "public class UrlUtils { \nprivate static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { \nStringBuilder url = new StringBuilder ( ) ; \nif ( ! ( servletPath != null ) ) { \nurl . append ( requestURI . substring ( contextPath . length ( ) ) ) ; \n} \nelse { \nurl . append ( servletPath ) ; \nif ( pathInfo != null ) { \nurl . append ( pathInfo ) ; \n} \n} \nif ( queryString != null ) { \nurl . append ( \"?\" ) . append ( queryString ) ; \n} \nreturn url . toString ( ) ; \n} \n} \n"}
{"196": "public class AclClassIdUtils { \nSerializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { \nif ( ! ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) ) { \nidentifier = convertToLong ( identifier ) ; \n} \nelse { \nidentifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; \n} \nreturn identifier ; \n} \n} \n"}
{"200": "public class HttpSessionRequestCache { \npublic void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { \nif ( ! ( requestMatcher . matches ( request ) ) ) { \nlogger . debug ( \"Request not saved as configured RequestMatcher did not match\" ) ; \n} \nelse { \nDefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; \nif ( createSessionAllowed || request . getSession ( false ) != null ) { \nrequest . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; \nlogger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; \n} \n} \n} \n} \n"}
{"206": "public class XFrameOptionsHeaderWriter { \npublic void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { \nif ( ! ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; \n} \nelse { \nString allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; \nif ( ! ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) ) if ( allowFromValue != null ) { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + \" \" + allowFromValue ) ; \n} \n} \nelse { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"220": "public class LdapUserDetailsManager { \npublic void changePassword ( final String oldPassword , final String newPassword ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nAssert . notNull ( authentication , \"No authentication object found in security context. Can't change current user's password!\" ) ; \nString username = authentication . getName ( ) ; \nlogger . debug ( \"Changing password for user '\" + username ) ; \nDistinguishedName userDn = usernameMapper . buildDn ( username ) ; \nif ( ! ( usePasswordModifyExtensionOperation ) ) { \nchangePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; \n} \nelse { \nchangePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; \n} \n} \n} \n"}
{"236": "public class ResponsePrinter { \npublic static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nif ( logDetail == ALL || logDetail == STATUS ) { \nbuilder . append ( responseOptions . statusLine ( ) ) ; \n} \nif ( ! ( logDetail == ALL || logDetail == HEADERS ) ) if ( logDetail == COOKIES ) { \nfinal Cookies cookies = responseOptions . detailedCookies ( ) ; \nif ( cookies . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; \n} \n} \nelse { \nfinal Headers headers = responseOptions . headers ( ) ; \nif ( headers . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; \n} \n} \nif ( logDetail == ALL || logDetail == BODY ) { \nString responseBodyToAppend ; \nif ( ! ( shouldPrettyPrint ) ) { \nresponseBodyToAppend = responseBody . asString ( ) ; \n} \nelse { \nresponseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \n} \nif ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { \nbuilder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \n} \nbuilder . append ( responseBodyToAppend ) ; \n} \nString response = builder . toString ( ) ; \nstream . println ( response ) ; \nreturn response ; \n} \n} \n"}
{"284": "public class HttpRequestFactory { \nstatic HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { \nString method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , \"Http method\" ) ; \nClass < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; \nfinal HttpRequestBase httpRequest ; \nif ( ! ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) ) { \ntry { \nhttpRequest = type . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nhttpRequest . setURI ( uri ) ; \n} \nelse { \nhttpRequest = new CustomHttpMethod ( method , uri ) ; \n} \nreturn httpRequest ; \n} \n} \n"}
{"295": "public class JsonPath { \npublic int getInt ( String path ) { \nObject value = get ( path ) ; \nif ( ! ( value instanceof Integer ) ) if ( ! ( value instanceof Short ) ) if ( ! ( value instanceof Long ) ) { \nreturn ObjectConverter . convertObjectTo ( value , Integer . class ) ; \n} \nelse { \nreturn ( ( Long ) value ) . intValue ( ) ; \n} \nelse { \nreturn ( ( Short ) value ) . intValue ( ) ; \n} \nelse { \nreturn ( Integer ) value ; \n} \n} \n} \n"}
{"296": "public class JsonPath { \npublic byte getByte ( String path ) { \nObject value = get ( path ) ; \nif ( ! ( value instanceof Byte ) ) if ( ! ( value instanceof Long ) ) if ( ! ( value instanceof Integer ) ) { \nreturn ObjectConverter . convertObjectTo ( value , Byte . class ) ; \n} \nelse { \nreturn ( ( Integer ) value ) . byteValue ( ) ; \n} \nelse { \nreturn ( ( Long ) value ) . byteValue ( ) ; \n} \nelse { \nreturn ( Byte ) value ; \n} \n} \n} \n"}
{"297": "public class JsonPath { \npublic short getShort ( String path ) { \nObject value = get ( path ) ; \nif ( ! ( value instanceof Short ) ) if ( ! ( value instanceof Long ) ) if ( ! ( value instanceof Integer ) ) { \nreturn ObjectConverter . convertObjectTo ( value , Short . class ) ; \n} \nelse { \nreturn ( ( Integer ) value ) . shortValue ( ) ; \n} \nelse { \nreturn ( ( Long ) value ) . shortValue ( ) ; \n} \nelse { \nreturn ( Short ) value ; \n} \n} \n} \n"}
{"298": "public class JsonPath { \npublic float getFloat ( String path ) { \nfinal Object value = get ( path ) ; \nif ( ! ( value instanceof Double ) ) { \nreturn ObjectConverter . convertObjectTo ( value , Float . class ) ; \n} \nelse { \nreturn ( ( Double ) value ) . floatValue ( ) ; \n} \n} \n} \n"}
{"300": "public class JsonPath { \npublic long getLong ( String path ) { \nObject value = get ( path ) ; \nif ( ! ( value instanceof Long ) ) if ( ! ( value instanceof Short ) ) if ( ! ( value instanceof Integer ) ) { \nreturn ObjectConverter . convertObjectTo ( value , Long . class ) ; \n} \nelse { \nreturn ( ( Integer ) value ) . longValue ( ) ; \n} \nelse { \nreturn ( ( Short ) value ) . longValue ( ) ; \n} \nelse { \nreturn ( Long ) value ; \n} \n} \n} \n"}
{"301": "public class JsonPath { \npublic < T > List < T > getList ( String path , Class < T > genericType ) { \nif ( genericType == null ) { \nthrow new IllegalArgumentException ( \"Generic type cannot be null\" ) ; \n} \nfinal List < T > original = get ( path ) ; \nfinal List < T > newList = new LinkedList < T > ( ) ; \nif ( original != null ) { \nfor ( T t : original ) { \nT e ; \nif ( ! ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) ) { \ne = ObjectConverter . convertObjectTo ( t , genericType ) ; \n} \nelse { \nString str = objectToString ( t ) ; \ne = ( T ) jsonStringToObject ( str , genericType ) ; \n} \nnewList . add ( e ) ; \n} \n} \nreturn Collections . unmodifiableList ( newList ) ; \n} \n} \n"}
{"315": "public class InjectorImpl { \nprivate boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { \nboolean bindingFailed = false ; \nSet < Dependency < ? > > deps = getInternalDependencies ( binding ) ; \nfor ( Dependency dep : deps ) { \nKey < ? > depKey = dep . getKey ( ) ; \nInjectionPoint ip = dep . getInjectionPoint ( ) ; \nif ( encountered . add ( depKey ) ) { \nBindingImpl depBinding = jitBindings . get ( depKey ) ; \nif ( ! ( depBinding != null ) ) if ( state . getExplicitBinding ( depKey ) == null ) { \nbindingFailed = true ; \n} \nelse { \nboolean failed = cleanup ( depBinding , encountered ) ; \nif ( depBinding instanceof ConstructorBindingImpl ) { \nConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; \nip = ctorBinding . getInternalConstructor ( ) ; \nif ( ! ctorBinding . isInitialized ( ) ) { \nfailed = true ; \n} \n} \nif ( failed ) { \nremoveFailedJitBinding ( depBinding , ip ) ; \nbindingFailed = true ; \n} \n} \n} \n} \nreturn bindingFailed ; \n} \n} \n"}
{"317": "public class InjectorImpl { \n@ SuppressWarnings ( \"unchecked\" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { \nif ( ! ( binding instanceof ConstructorBindingImpl ) ) if ( ! ( binding instanceof HasDependencies ) ) { \nreturn ImmutableSet . of ( ) ; \n} \nelse { \nreturn ( ( HasDependencies ) binding ) . getDependencies ( ) ; \n} \nelse { \nreturn ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; \n} \n} \n} \n"}
{"331": "public class BytecodeGen { \nprivate static boolean isPubliclyCallable ( Member member ) { \nif ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { \nreturn false ; \n} \nClass < ? > [ ] parameterTypes ; \nif ( ! ( member instanceof Constructor ) ) { \nMethod method = ( Method ) member ; \nif ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { \nreturn false ; \n} \nparameterTypes = method . getParameterTypes ( ) ; \n} \nelse { \nparameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; \n} \nfor ( Class < ? > type : parameterTypes ) { \nif ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"339": "public class ServletUtils { \nstatic String normalizePath ( String path ) { \nStringBuilder sb = new StringBuilder ( path . length ( ) ) ; \nint queryStart = path . indexOf ( '?' ) ; \nString query = null ; \nif ( queryStart != - 1 ) { \nquery = path . substring ( queryStart ) ; \npath = path . substring ( 0 , queryStart ) ; \n} \nList < String > segments = new ArrayList < > ( ) ; \nfor ( String segment : SLASH_SPLITTER . split ( path ) ) { \nString normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; \nif ( ! ( \".\" . equals ( normalized ) ) ) if ( ! ( \"..\" . equals ( normalized ) ) ) { \nsegments . add ( normalized ) ; \n} \nelse { \nif ( segments . size ( ) > 1 ) { \nsegments . remove ( segments . size ( ) - 1 ) ; \n} \n} \nelse { \n} \n} \nSLASH_JOINER . appendTo ( sb , segments ) ; \nif ( query != null ) { \nsb . append ( query ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"342": "public class Annotations { \npublic static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { \nClass < ? extends Annotation > found = null ; \nfor ( Annotation annotation : annotations ) { \nClass < ? extends Annotation > annotationType = annotation . annotationType ( ) ; \nif ( isScopeAnnotation ( annotationType ) ) { \nif ( ! ( found != null ) ) { \nfound = annotationType ; \n} \nelse { \nerrors . duplicateScopeAnnotations ( found , annotationType ) ; \n} \n} \n} \nreturn found ; \n} \n} \n"}
{"344": "public class Annotations { \npublic static String nameOf ( Key < ? > key ) { \nAnnotation annotation = key . getAnnotation ( ) ; \nClass < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; \nif ( ! ( annotation != null && ! isMarker ( annotationType ) ) ) if ( ! ( key . getAnnotationType ( ) != null ) ) { \nreturn \"\" ; \n} \nelse { \nreturn \"@\" + key . getAnnotationType ( ) . getName ( ) ; \n} \nelse { \nreturn key . getAnnotation ( ) . toString ( ) ; \n} \n} \n} \n"}
{"355": "public class FactoryProvider2 { \nprivate boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { \nCollection < Message > messages = ce . getErrorMessages ( ) ; \nif ( ! ( messages . size ( ) == 1 ) ) { \nreturn false ; \n} \nelse { \nMessage msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; \nreturn msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; \n} \n} \n} \n"}
{"360": "public class FactoryProvider2 { \npublic Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { \ncheckState ( injector != null , \"Factories.create() factories cannot be used until they're initialized by Guice.\" ) ; \nfinal Key < ? > returnType = data . returnType ; \nfinal Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; \nModule assistedModule = new AbstractModule ( ) { \n@ Override @ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) protected void configure ( ) { \nBinder binder = binder ( ) . withSource ( method ) ; \nint p = 0 ; \nif ( ! ( ! data . optimized ) ) { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; \n} \n} \nelse { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; \n} \n} \nConstructor constructor = data . constructor ; \nif ( constructor != null ) { \nbinder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; \n} \n} \n} \n; \nInjector forCreate = injector . createChildInjector ( assistedModule ) ; \nBinding < ? > binding = forCreate . getBinding ( returnKey ) ; \nif ( data . optimized ) { \ndata . cachedBinding = binding ; \n} \nreturn binding ; \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) { \nreturn methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \n} \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( ! ( \"equals\" . equals ( method . getName ( ) ) ) ) if ( ! ( \"hashCode\" . equals ( method . getName ( ) ) ) ) { \nreturn method . invoke ( this , args ) ; \n} \nelse { \nreturn System . identityHashCode ( proxy ) ; \n} \nelse { \nreturn proxy == args [ 0 ] ; \n} \n} \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( ! ( data . cachedBinding != null ) ) { \nprovider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \n} \nelse { \nprovider = data . cachedBinding . getProvider ( ) ; \n} \ntry { \nint p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p ++ ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null && canRethrow ( method , cause ) ) { \nthrow cause ; \n} \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! ( ! sameTypes . isEmpty ( ) ) ) { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \n} \nif ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nelse { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( int i = 0 ; \ni < howMany ; \n++ i ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n} \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"367": "public class ConstructorBindingImpl { \nInjectionPoint getInternalConstructor ( ) { \nif ( ! ( factory . constructorInjector != null ) ) { \nreturn constructorInjectionPoint ; \n} \nelse { \nreturn factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; \n} \n} \n} \n"}
{"368": "public class ConstructorBindingImpl { \nSet < Dependency < ? > > getInternalDependencies ( ) { \nImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; \nif ( ! ( factory . constructorInjector == null ) ) { \nbuilder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; \n} \nelse { \nbuilder . add ( constructorInjectionPoint ) ; \ntry { \nbuilder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; \n} \ncatch ( ConfigurationException ignored ) { \n} \n} \nreturn Dependency . forInjectionPoints ( builder . build ( ) ) ; \n} \n} \n"}
{"383": "public class DependencyAndSource { \npublic String getBindingSource ( ) { \nif ( ! ( source instanceof Class ) ) if ( ! ( source instanceof Member ) ) { \nreturn source . toString ( ) ; \n} \nelse { \nreturn StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; \n} \nelse { \nreturn StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; \n} \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( int i = dependencies . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! ( ! causes . containsKey ( causeEquivalence ) ) ) { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \nelse { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( ! ( errorMessages . size ( ) == 1 ) ) { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nelse { \nfmt . format ( \"1 error\" ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"399": "public class FutureTaskUtil { \npublic static void launderThrowable ( Throwable t ) { \nif ( ! ( t instanceof RuntimeException ) ) if ( ! ( t instanceof Error ) ) { \nthrow new IllegalStateException ( \"Not unchecked!\" , t ) ; \n} \nelse { \nthrow ( Error ) t ; \n} \nelse { \nthrow ( RuntimeException ) t ; \n} \n} \n} \n"}
{"401": "public class ProcessorManager { \npublic void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { \nif ( ! ( this . defaultProcessor == null ) ) { \nthrow new IllegalStateException ( \"The defaultProcessor has already been registered: \" + this . defaultProcessor . getClass ( ) ) ; \n} \nelse { \nthis . defaultProcessor = processor ; \n} \n} \n} \n"}
{"407": "public class DefaultConnectionManager { \n@ Override public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { \nConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; \nif ( ! ( null != pool ) ) { \nlogger . error ( \"[NOTIFYME] bug detected! pool here must not be null!\" ) ; \nreturn null ; \n} \nelse { \nreturn pool . get ( ) ; \n} \n} \n} \n"}
{"408": "public class DefaultConnectionManager { \n@ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { \nConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; \nif ( ! ( null != pool ) ) { \nlogger . error ( \"[NOTIFYME] bug detected! pool here must not be null!\" ) ; \n} \nelse { \nhealIfNeed ( pool , url ) ; \n} \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nint numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( ! ( cause instanceof RemotingException ) ) { \nFutureTaskUtil . launderThrowable ( cause ) ; \n} \nelse { \nthrow ( RemotingException ) cause ; \n} \n} \nthis . healTasks . remove ( poolKey ) ; \n} \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( ! ( url . isConnWarmup ( ) ) ) { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( int i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \nelse { \nfor ( int i = actualNum ; \ni < expectNum ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \n} \n} \n} \n"}
{"416": "public class UserProcessorRegisterHelper { \npublic static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor ) { \nthrow new RuntimeException ( \"User processor should not be null!\" ) ; \n} \nif ( ! ( processor instanceof MultiInterestUserProcessor ) ) { \nif ( StringUtils . isBlank ( processor . interest ( ) ) ) { \nthrow new RuntimeException ( \"Processor interest should not be blank!\" ) ; \n} \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + processor . interest ( ) + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \nelse { \nregisterUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; \n} \n} \n} \n"}
{"418": "public class RpcRequestProcessor { \nprivate void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { \nfinal int id = cmd . getId ( ) ; \nfinal byte type = cmd . getType ( ) ; \nUserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; \nif ( ! ( processor instanceof AsyncUserProcessor ) ) { \ntry { \nObject responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \nelse { \ntry { \nprocessor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \n} \n} \n"}
{"423": "public class AbstractRemotingProcessor { \n@ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { \nProcessTask task = new ProcessTask ( ctx , msg ) ; \nif ( ! ( this . getExecutor ( ) != null ) ) { \ndefaultExecutor . execute ( task ) ; \n} \nelse { \nthis . getExecutor ( ) . execute ( task ) ; \n} \n} \n} \n"}
{"425": "public class BaseRemoting { \nprotected void oneway ( final Connection conn , final RemotingCommand request ) { \ntry { \nconn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture f ) throws Exception { \nif ( ! f . isSuccess ( ) ) { \nlogger . error ( \"Invoke send failed. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; \n} \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nif ( ! ( null == conn ) ) { \nlogger . error ( \"Exception caught when sending invocation. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; \n} \nelse { \nlogger . error ( \"Conn is null\" ) ; \n} \n} \n} \n} \n"}
{"430": "public class RpcRemoting { \nprotected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { \nRpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; \nif ( ! ( null != invokeContext ) ) { \ncommand . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \n} \nelse { \nObject clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; \nif ( null != clientCustomSerializer ) { \ntry { \ncommand . setSerializer ( ( Byte ) clientCustomSerializer ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new IllegalArgumentException ( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer . getClass ( ) . getName ( ) + \"].\" ) ; \n} \n} \nBoolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; \nif ( null != crcSwitch && crcSwitch ) { \ncommand . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \n} \n} \ncommand . setTimeout ( timeoutMillis ) ; \ncommand . setRequestClass ( request . getClass ( ) . getName ( ) ) ; \ncommand . setInvokeContext ( invokeContext ) ; \ncommand . serialize ( ) ; \nlogDebugInfo ( command ) ; \nreturn command ; \n} \n} \n"}
{"431": "public class ScheduledDisconnectStrategy { \n@ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { \nList < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; \nList < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; \nMap < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; \nfor ( Connection connection : connections ) { \nString serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; \nif ( ! ( serviceStatus != null ) ) { \nserviceOnConnections . add ( connection ) ; \n} \nelse { \nif ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { \nserviceOffConnections . add ( connection ) ; \n} \n} \n} \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; \nreturn filteredConnections ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools && ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( ! ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) ) { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \n} \nelse { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) { \noffConn . close ( ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \n} \n} \n"}
{"433": "public class ScheduledDisconnectStrategy { \nprivate void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { \nif ( null != lastSelectConnect ) { \nif ( ! ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) ) { \nThread . sleep ( RETRY_DETECT_PERIOD ) ; \nif ( ! ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) ) { \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Address={} won't close at this schedule turn\" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; \n} \n} \nelse { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \n} \nelse { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \n} \n} \n} \n"}
{"435": "public class ConnectionEventHandler { \nprivate void infoLog ( String format , String addr ) { \nif ( logger . isInfoEnabled ( ) ) { \nif ( ! ( StringUtils . isNotEmpty ( addr ) ) ) { \nlogger . info ( format , \"UNKNOWN-ADDR\" ) ; \n} \nelse { \nlogger . info ( format , addr ) ; \n} \n} \n} \n} \n"}
{"441": "public class RpcResponseResolver { \npublic static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { \npreProcess ( responseCommand , addr ) ; \nif ( ! ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) ) { \nString msg = String . format ( \"Rpc invocation exception: %s, the address is %s, id=%s\" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; \nlogger . warn ( msg ) ; \nif ( ! ( responseCommand . getCause ( ) != null ) ) { \nthrow new InvokeException ( msg + \", please check the server log for more.\" ) ; \n} \nelse { \nthrow new InvokeException ( msg , responseCommand . getCause ( ) ) ; \n} \n} \nelse { \nreturn toResponseObject ( responseCommand ) ; \n} \n} \n} \n"}
{"444": "public class RpcResponseResolver { \nprivate static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { \nRpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; \nif ( ! ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) ) { \nreturn String . format ( \"%s, ServerErrorMsg:null\" , clientErrMsg ) ; \n} \nelse { \nreturn String . format ( \"%s, ServerErrorMsg:%s\" , clientErrMsg , resp . getErrorMsg ( ) ) ; \n} \n} \n} \n"}
{"458": "public class ConnectionPool { \npublic Connection get ( ) { \nmarkAccess ( ) ; \nif ( ! ( null != this . conns ) ) { \nreturn null ; \n} \nelse { \nList < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; \nif ( ! ( snapshot . size ( ) > 0 ) ) { \nreturn null ; \n} \nelse { \nreturn this . strategy . select ( snapshot ) ; \n} \n} \n} \n} \n"}
{"465": "public class RpcServer { \nprivate void initWriteBufferWaterMark ( ) { \nint lowWaterMark = this . netty_buffer_low_watermark ( ) ; \nint highWaterMark = this . netty_buffer_high_watermark ( ) ; \nif ( ! ( lowWaterMark > highWaterMark ) ) { \nlogger . warn ( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\" , lowWaterMark , highWaterMark ) ; \n} \nelse { \nthrow new IllegalArgumentException ( String . format ( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\" , highWaterMark , lowWaterMark ) ) ; \n} \nthis . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; \n} \n} \n"}
{"467": "public class SocketChannelIOHelper { \npublic static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { \nif ( ws == null ) { \nreturn false ; \n} \nByteBuffer buffer = ws . outQueue . peek ( ) ; \nWrappedByteChannel c = null ; \nif ( ! ( buffer == null ) ) { \ndo { \nsockchannel . write ( buffer ) ; \nif ( ! ( buffer . remaining ( ) > 0 ) ) { \nws . outQueue . poll ( ) ; \nbuffer = ws . outQueue . peek ( ) ; \n} \nelse { \nreturn false ; \n} \n} \nwhile ( buffer != null ) ; \n} \nelse { \nif ( sockchannel instanceof WrappedByteChannel ) { \nc = ( WrappedByteChannel ) sockchannel ; \nif ( c . isNeedWrite ( ) ) { \nc . writeMore ( ) ; \n} \n} \n} \nif ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { \nws . closeConnection ( ) ; \n} \nreturn c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; \n} \n} \n"}
{"475": "public class Draft_6455 { \nprivate void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { \nif ( ! ( curop != Opcode . CONTINUOUS ) ) if ( ! ( frame . isFin ( ) ) ) if ( currentContinuousFrame == null ) { \nlog . error ( \"Protocol error: Continuous frame sequence was not started.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \nelse { \nprocessFrameIsFin ( webSocketImpl , frame ) ; \n} \nelse { \nprocessFrameIsNotFin ( frame ) ; \n} \nif ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { \nlog . error ( \"Protocol error: Payload is not UTF8\" ) ; \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \nif ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) { \naddToBufferList ( frame . getPayloadData ( ) ) ; \n} \n} \n} \n"}
{"479": "public class Draft_6455 { \nprivate void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { \nif ( currentContinuousFrame == null ) { \nlog . trace ( \"Protocol error: Previous continuous frame sequence not completed.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \naddToBufferList ( frame . getPayloadData ( ) ) ; \ncheckBufferLimit ( ) ; \nif ( ! ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) ) if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \nelse { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \ncurrentContinuousFrame = null ; \nclearBufferList ( ) ; \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nint code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( ! ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) ) { \nif ( ! ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) ) webSocketImpl . flushAndClose ( code , reason , false ) ; \nelse webSocketImpl . close ( code , reason , true ) ; \n} \nelse { \nwebSocketImpl . closeConnection ( code , reason , true ) ; \n} \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( ! ( readyState != ReadyState . NOT_YET_CONNECTED ) ) { \nif ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( ! ( socketBuffer . hasRemaining ( ) ) ) if ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \nelse { \ndecodeFrames ( socketBuffer ) ; \n} \n} \n} \nelse { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \n} \n} \n"}
{"494": "public class WebSocketClient { \nprivate int getPort ( ) { \nint port = uri . getPort ( ) ; \nif ( port == - 1 ) { \nString scheme = uri . getScheme ( ) ; \nif ( ! ( \"wss\" . equals ( scheme ) ) ) if ( ! ( \"ws\" . equals ( scheme ) ) ) { \nthrow new IllegalArgumentException ( \"unknown scheme: \" + scheme ) ; \n} \nelse { \nreturn WebSocketImpl . DEFAULT_PORT ; \n} \nelse { \nreturn WebSocketImpl . DEFAULT_WSS_PORT ; \n} \n} \nreturn port ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( ! ( part1 == null || part1 . length ( ) == 0 ) ) path = part1 ; \nelse path = \"/\" ; \nif ( part2 != null ) path += '?' + part2 ; \nint port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) { \nfor ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \n} \nengine . startHandshake ( handshake ) ; \n} \n} \n"}
{"500": "public class AbstractWebSocket { \nprivate void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { \nif ( ! ( webSocket instanceof WebSocketImpl ) ) { \nreturn ; \n} \nWebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; \nif ( ! ( webSocketImpl . getLastPong ( ) < minimumPongTime ) ) { \nif ( ! ( webSocketImpl . isOpen ( ) ) ) { \nlog . trace ( \"Trying to ping a non open connection: {}\" , webSocketImpl ) ; \n} \nelse { \nwebSocketImpl . sendPing ( ) ; \n} \n} \nelse { \nlog . trace ( \"Closing connection due to no pong received: {}\" , webSocketImpl ) ; \nwebSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ) ; \n} \n} \n} \n"}
{"506": "public class WebSocketServer { \nprivate void doAdditionalRead ( ) throws InterruptedException , IOException { \nWebSocketImpl conn ; \nwhile ( ! iqueue . isEmpty ( ) ) { \nconn = iqueue . remove ( 0 ) ; \nWrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; \nByteBuffer buf = takeBuffer ( ) ; \ntry { \nif ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; \nif ( ! ( buf . hasRemaining ( ) ) ) { \npushBuffer ( buf ) ; \n} \nelse { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n} \n} \n} \n"}
{"508": "public class WebSocketServer { \nprivate boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nByteBuffer buf = takeBuffer ( ) ; \nif ( conn . getChannel ( ) == null ) { \nkey . cancel ( ) ; \nhandleIOException ( key , conn , new IOException ( ) ) ; \nreturn false ; \n} \ntry { \nif ( ! ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) ) { \npushBuffer ( buf ) ; \n} \nelse { \nif ( ! ( buf . hasRemaining ( ) ) ) { \npushBuffer ( buf ) ; \n} \nelse { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \ni . remove ( ) ; \nif ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { \niqueue . add ( conn ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \nreturn true ; \n} \n} \n"}
{"518": "public class ByteBufferUtils { \npublic static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { \nif ( source == null || dest == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nint fremain = source . remaining ( ) ; \nint toremain = dest . remaining ( ) ; \nif ( ! ( fremain > toremain ) ) { \ndest . put ( source ) ; \nreturn fremain ; \n} \nelse { \nint limit = Math . min ( fremain , toremain ) ; \nsource . limit ( limit ) ; \ndest . put ( source ) ; \nreturn limit ; \n} \n} \n} \n"}
{"523": "public class MessagesApi { \n@ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { \nList < T > out ; \nif ( ! ( args != null && args . length == 1 && args [ 0 ] instanceof List ) ) { \nout = Arrays . asList ( args ) ; \n} \nelse { \nout = ( List < T > ) args [ 0 ] ; \n} \nreturn out ; \n} \n} \n"}
{"543": "public class F { \nprivate static Executor toExecutor ( ExecutionContext ec ) { \nExecutionContext prepared = ec . prepare ( ) ; \nif ( ! ( prepared instanceof Executor ) ) { \nreturn prepared :: execute ; \n} \nelse { \nreturn ( Executor ) prepared ; \n} \n} \n} \n"}
{"552": "public class DefaultHttpErrorHandler { \n@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { \nif ( ! ( statusCode == 400 ) ) if ( ! ( statusCode == 403 ) ) if ( ! ( statusCode == 404 ) ) if ( ! ( statusCode >= 400 && statusCode < 500 ) ) { \nthrow new IllegalArgumentException ( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message ) ; \n} \nelse { \nreturn onOtherClientError ( request , statusCode , message ) ; \n} \nelse { \nreturn onNotFound ( request , message ) ; \n} \nelse { \nreturn onForbidden ( request , message ) ; \n} \nelse { \nreturn onBadRequest ( request , message ) ; \n} \n} \n} \n"}
{"555": "public class DefaultHttpErrorHandler { \nprotected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { \nif ( ! ( environment . isProd ( ) ) ) { \nreturn CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; \n} \nelse { \nreturn CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; \n} \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( ! ( file . isDirectory ( ) ) ) { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \nelse { \nrepositories [ i ] = new FilesystemRepository ( file ) ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"564": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { \nFileRepository fileRepo = new FilesystemRepository ( directory ) ; \nFileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; \nFileRepository manualRepo ; \nif ( ! ( fallbackToJar ) ) { \nmanualRepo = fileRepo ; \n} \nelse { \nmanualRepo = new AggregateFileRepository ( new FileRepository [ ] { \nfileRepo , jarRepo } \n) ; \n} \nreturn new DocumentationHandler ( manualRepo , jarRepo ) ; \n} \n} \n"}
{"567": "public class HttpEntity { \npublic static final HttpEntity fromContent ( Content content , String charset ) { \nString body ; \nif ( ! ( content instanceof Xml ) ) { \nbody = content . body ( ) ; \n} \nelse { \nbody = content . body ( ) . trim ( ) ; \n} \nreturn new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content . contentType ( ) + \"; charset=\" + charset ) ) ; \n} \n} \n"}
{"589": "public class Paths { \npublic static String canonical ( String url ) { \nString [ ] urlPath = toSegments ( url ) ; \nStack < String > canonical = new Stack < > ( ) ; \nfor ( String comp : urlPath ) { \nif ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; \nif ( ! ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) ) canonical . pop ( ) ; \nelse canonical . push ( comp ) ; \n} \nString prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nString trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nreturn prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; \n} \n} \n"}
{"622": "public class JPAEntityManagerContext { \n@ SuppressWarnings ( \"unchecked\" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { \nreturn Http . Context . safeCurrent ( ) . map ( context -> { \nObject emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; \nif ( ! ( emsObject != null ) ) { \nDeque < EntityManager > ems = new ArrayDeque < > ( ) ; \ncontext . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; \nreturn ems ; \n} \nelse { \nreturn ( Deque < EntityManager > ) emsObject ; \n} \n} \n) . orElseGet ( ( ) -> { \nif ( ! ( threadLocalFallback ) ) { \nthrow new RuntimeException ( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\" ) ; \n} \nelse { \nreturn this . get ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"623": "public class JPAEntityManagerContext { \nvoid pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { \nDeque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; \nif ( ! ( em != null ) ) { \nif ( ems . isEmpty ( ) ) { \nthrow new IllegalStateException ( \"Tried to remove the EntityManager, but none was set.\" ) ; \n} \nems . pop ( ) ; \n} \nelse { \nems . push ( em ) ; \n} \n} \n} \n"}
{"625": "public class AkkaStreams { \npublic static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { \nreturn splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { \nUniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; \nUniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; \nFlow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { \nif ( ! ( x . left . isPresent ( ) ) ) { \nthrow Scala . noMatch ( ) ; \n} \nelse { \nreturn x . left . get ( ) ; \n} \n} \n) ) ; \nFlow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { \nif ( ! ( x . right . isPresent ( ) ) ) { \nthrow Scala . noMatch ( ) ; \n} \nelse { \nreturn x . right . get ( ) ; \n} \n} \n) ) ; \nFlow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; \nbuilder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add ( flow ) ) . toInlet ( merge . in ( 0 ) ) ; \nbuilder . from ( broadcast . out ( 1 ) ) . via ( builder . add ( blockCancel ) ) . via ( builder . add ( collectOut ) ) . toInlet ( merge . in ( 1 ) ) ; \nreturn new FlowShape < > ( broadcast . in ( ) , merge . out ( ) ) ; \n} \n) ) ) ; \n} \n} \n"}
{"630": "public class Form { \npublic JsonNode errorsAsJson ( Lang lang ) { \nMap < String , List < String > > allMessages = new HashMap < > ( ) ; \nerrors . forEach ( error -> { \nif ( error != null ) { \nfinal List < String > messages = new ArrayList < > ( ) ; \nif ( ! ( messagesApi != null && lang != null ) ) { \nmessages . add ( error . message ( ) ) ; \n} \nelse { \nfinal List < String > reversedMessages = new ArrayList < > ( error . messages ( ) ) ; \nCollections . reverse ( reversedMessages ) ; \nmessages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; \n} \nallMessages . put ( error . key ( ) , messages ) ; \n} \n} \n) ; \nreturn play . libs . Json . toJson ( allMessages ) ; \n} \n} \n"}
{"635": "public class Formatters { \npublic < T > String print ( T t ) { \nif ( t == null ) { \nreturn \"\" ; \n} \nif ( ! ( conversion . canConvert ( t . getClass ( ) , String . class ) ) ) { \nreturn t . toString ( ) ; \n} \nelse { \nreturn conversion . convert ( t , String . class ) ; \n} \n} \n} \n"}
{"637": "public class Formatters { \npublic < T > String print ( TypeDescriptor desc , T t ) { \nif ( t == null ) { \nreturn \"\" ; \n} \nif ( ! ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) ) if ( ! ( conversion . canConvert ( t . getClass ( ) , String . class ) ) ) { \nreturn t . toString ( ) ; \n} \nelse { \nreturn conversion . convert ( t , String . class ) ; \n} \nelse { \nreturn ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; \n} \n} \n} \n"}
{"638": "public class Formatters { \nprivate Formatters registerOptional ( ) { \nconversion . addConverter ( new GenericConverter ( ) { \npublic Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { \nif ( ! ( sourceType . getObjectType ( ) . equals ( String . class ) ) ) if ( targetType . getObjectType ( ) . equals ( String . class ) ) { \nif ( source == null ) return \"\" ; \nOptional < ? > opt = ( Optional ) source ; \nreturn opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( \"\" ) ; \n} \nelse { \nObject element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; \nreturn Optional . ofNullable ( element ) ; \n} \nreturn null ; \n} \npublic Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { \nSet < ConvertiblePair > result = new HashSet < > ( ) ; \nresult . add ( new ConvertiblePair ( Optional . class , String . class ) ) ; \nresult . add ( new ConvertiblePair ( String . class , Optional . class ) ) ; \nreturn result ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"641": "public class ServerCookieEncoder { \npublic String encode ( Cookie cookie ) { \nif ( cookie == null ) { \nthrow new NullPointerException ( \"cookie\" ) ; \n} \nfinal String name = cookie . name ( ) ; \nfinal String value = cookie . value ( ) != null ? cookie . value ( ) : \"\" ; \nvalidateCookie ( name , value ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nif ( ! ( cookie . wrap ( ) ) ) { \nadd ( buf , name , value ) ; \n} \nelse { \naddQuoted ( buf , name , value ) ; \n} \nif ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { \nadd ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; \nDate expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; \nadd ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; \n} \nif ( cookie . sameSite ( ) != null ) { \nadd ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; \n} \nif ( cookie . path ( ) != null ) { \nadd ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; \n} \nif ( cookie . domain ( ) != null ) { \nadd ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; \n} \nif ( cookie . isSecure ( ) ) { \nadd ( buf , CookieHeaderNames . SECURE ) ; \n} \nif ( cookie . isHttpOnly ( ) ) { \nadd ( buf , CookieHeaderNames . HTTPONLY ) ; \n} \nreturn stripTrailingSeparator ( buf ) ; \n} \n} \n"}
{"646": "public class WebSocket { \npublic static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { \nreturn new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { \ntry { \nif ( ! ( message instanceof Message . Binary ) ) if ( message instanceof Message . Text ) { \nreturn F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; \n} \nelse { \nreturn F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; \n} \n} \ncatch ( Exception e ) { \nreturn F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; \n} \nthrow Scala . noMatch ( ) ; \n} \n) , outMessage -> { \ntry { \nreturn new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n) ; \n} \n} \n"}
{"647": "public class WebSocket { \nprivate static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { \nreturn new WebSocket ( ) { \n@ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { \nreturn f . apply ( request ) . thenApply ( resultOrFlow -> { \nif ( ! ( resultOrFlow . left . isPresent ( ) ) ) { \nFlow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; \nreturn F . Either . Right ( flow ) ; \n} \nelse { \nreturn F . Either . Left ( resultOrFlow . left . get ( ) ) ; \n} \n} \n) ; \n} \n} \n; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( int i = 0 ; \ni < normalArgsLen ; \ni ++ ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( ! ( noVarArgsPassed ) ) if ( ! ( explicitArrayForVarags ) ) { \nfor ( int i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \nelse { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"659": "public class CodeEmitter { \npublic void cast_numeric ( Type from , Type to ) { \nif ( from != to ) { \nif ( ! ( from == Type . DOUBLE_TYPE ) ) if ( ! ( from == Type . FLOAT_TYPE ) ) if ( ! ( from == Type . LONG_TYPE ) ) { \nif ( ! ( to == Type . BYTE_TYPE ) ) if ( ! ( to == Type . CHAR_TYPE ) ) if ( ! ( to == Type . DOUBLE_TYPE ) ) if ( ! ( to == Type . FLOAT_TYPE ) ) if ( ! ( to == Type . LONG_TYPE ) ) if ( to == Type . SHORT_TYPE ) { \nmv . visitInsn ( Constants . I2S ) ; \n} \nelse { \nmv . visitInsn ( Constants . I2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . I2F ) ; \n} \nelse { \nmv . visitInsn ( Constants . I2D ) ; \n} \nelse { \nmv . visitInsn ( Constants . I2C ) ; \n} \nelse { \nmv . visitInsn ( Constants . I2B ) ; \n} \n} \nelse { \nif ( ! ( to == Type . DOUBLE_TYPE ) ) if ( ! ( to == Type . FLOAT_TYPE ) ) { \nmv . visitInsn ( Constants . L2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse { \nmv . visitInsn ( Constants . L2F ) ; \n} \nelse { \nmv . visitInsn ( Constants . L2D ) ; \n} \n} \nelse { \nif ( ! ( to == Type . DOUBLE_TYPE ) ) if ( ! ( to == Type . LONG_TYPE ) ) { \nmv . visitInsn ( Constants . F2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse { \nmv . visitInsn ( Constants . F2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . F2D ) ; \n} \n} \nelse { \nif ( ! ( to == Type . FLOAT_TYPE ) ) if ( ! ( to == Type . LONG_TYPE ) ) { \nmv . visitInsn ( Constants . D2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse { \nmv . visitInsn ( Constants . D2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . D2F ) ; \n} \n} \n} \n} \n} \n"}
{"662": "public class CodeEmitter { \npublic void zero_or_null ( Type type ) { \nif ( ! ( TypeUtils . isPrimitive ( type ) ) ) { \naconst_null ( ) ; \n} \nelse { \nswitch ( type . getSort ( ) ) { \ncase Type . DOUBLE : push ( 0d ) ; \nbreak ; \ncase Type . LONG : push ( 0L ) ; \nbreak ; \ncase Type . FLOAT : push ( 0f ) ; \nbreak ; \ncase Type . VOID : aconst_null ( ) ; \ndefault : push ( 0 ) ; \n} \n} \n} \n} \n"}
{"663": "public class CodeEmitter { \npublic void unbox_or_zero ( Type type ) { \nif ( ! ( TypeUtils . isPrimitive ( type ) ) ) { \ncheckcast ( type ) ; \n} \nelse { \nif ( type != Type . VOID_TYPE ) { \nLabel nonNull = make_label ( ) ; \nLabel end = make_label ( ) ; \ndup ( ) ; \nifnonnull ( nonNull ) ; \npop ( ) ; \nzero_or_null ( type ) ; \ngoTo ( end ) ; \nmark ( nonNull ) ; \nunbox ( type ) ; \nmark ( end ) ; \n} \n} \n} \n} \n"}
{"688": "public class HttpRequest { \npublic HttpRequest path ( String path ) { \nif ( ! path . startsWith ( StringPool . SLASH ) ) { \npath = StringPool . SLASH + path ; \n} \nint ndx = path . indexOf ( '?' ) ; \nif ( ! ( ndx != - 1 ) ) { \nquery = HttpMultiMap . newCaseInsensitiveMap ( ) ; \n} \nelse { \nString queryString = path . substring ( ndx + 1 ) ; \npath = path . substring ( 0 , ndx ) ; \nquery = HttpUtil . parseQuery ( queryString , true ) ; \n} \nthis . path = path ; \nreturn this ; \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( ! ( firstHandler == null ) ) { \nfirstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \n} \nelse { \nreturn null ; \n} \nint handlerStart = firstHandler . startPc . bytecodeOffset ; \nint handlerEnd = firstHandler . endPc . bytecodeOffset ; \nint rangeStart = start . bytecodeOffset ; \nint rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { \nreturn firstHandler ; \n} \nif ( ! ( rangeStart <= handlerStart ) ) if ( ! ( rangeEnd >= handlerEnd ) ) { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nif ( ! ( rangeEnd >= handlerEnd ) ) { \nreturn new Handler ( firstHandler , end , firstHandler . endPc ) ; \n} \nelse { \nreturn firstHandler . nextHandler ; \n} \n} \n} \n} \n"}
{"706": "public class BeanUtilBean { \n@ Override public < T > T getProperty ( final Object bean , final String name ) { \nBeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; \nif ( ! ( ! isSilent ) ) { \ntry { \nresolveNestedProperties ( beanProperty ) ; \nreturn ( T ) getIndexProperty ( beanProperty ) ; \n} \ncatch ( Exception ignore ) { \nreturn null ; \n} \n} \nelse { \nresolveNestedProperties ( beanProperty ) ; \nreturn ( T ) getIndexProperty ( beanProperty ) ; \n} \n} \n} \n"}
{"722": "public class ColumnNamingStrategy { \npublic String convertPropertyNameToColumnName ( final String propertyName ) { \nStringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; \nif ( ! ( splitCamelCase ) ) { \ntableName . append ( propertyName ) ; \n} \nelse { \nString convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; \ntableName . append ( convertedTableName ) ; \n} \nif ( ! changeCase ) { \nreturn tableName . toString ( ) ; \n} \nreturn uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nint len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \ncontinue ; \n} \nif ( ! ( toUpper ) ) { \npropertyName . append ( Character . toLowerCase ( c ) ) ; \n} \nelse { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"730": "public class FileNameUtil { \npublic static String separatorsToSystem ( final String path ) { \nif ( path == null ) { \nreturn null ; \n} \nif ( ! ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) ) { \nreturn separatorsToUnix ( path ) ; \n} \nelse { \nreturn separatorsToWindows ( path ) ; \n} \n} \n} \n"}
{"732": "public class FileNameUtil { \npublic static String [ ] split ( final String filename ) { \nString prefix = getPrefix ( filename ) ; \nif ( prefix == null ) { \nprefix = StringPool . EMPTY ; \n} \nint lastSeparatorIndex = indexOfLastSeparator ( filename ) ; \nint lastExtensionIndex = indexOfExtension ( filename ) ; \nString path ; \nString baseName ; \nString extension ; \nif ( ! ( lastSeparatorIndex == - 1 ) ) { \npath = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; \nif ( ! ( lastExtensionIndex == - 1 ) ) { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \n} \nelse { \npath = StringPool . EMPTY ; \nif ( ! ( lastExtensionIndex == - 1 ) ) { \nbaseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \n} \nreturn new String [ ] { \nprefix , path , baseName , extension } \n; \n} \n} \n"}
{"743": "public class ClassScanner { \nprotected void scanJarFile ( final File file ) { \nfinal ZipFile zipFile ; \ntry { \nzipFile = new ZipFile ( file ) ; \n} \ncatch ( IOException ioex ) { \nif ( ! ignoreException ) { \nthrow new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; \n} \nreturn ; \n} \nfinal Enumeration entries = zipFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nfinal ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; \nfinal String zipEntryName = zipEntry . getName ( ) ; \ntry { \nif ( ! ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) ) if ( includeResources ) { \nfinal String entryName = prepareEntryName ( zipEntryName , false ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \nelse { \nfinal String entryName = prepareEntryName ( zipEntryName , true ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nZipUtil . close ( zipFile ) ; \nthrow rex ; \n} \n} \n} \nZipUtil . close ( zipFile ) ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) { \nrootPath += File . separatorChar ; \n} \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nwhile ( ( file = ff . nextFile ( ) ) != null ) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( ! ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) ) if ( includeResources ) { \nscanClassFile ( filePath , rootPath , file , false ) ; \n} \nelse { \nscanClassFile ( filePath , rootPath , file , true ) ; \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nthrow rex ; \n} \n} \n} \n} \n} \n"}
{"747": "public class ClassScanner { \npublic void start ( ) { \nif ( detectEntriesMode ) { \nrulesEntries . detectMode ( ) ; \n} \nfilesToScan . forEach ( file -> { \nfinal String path = file . getAbsolutePath ( ) ; \nif ( ! ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) ) if ( file . isDirectory ( ) ) { \nscanClassPath ( file ) ; \n} \nelse { \nif ( ! acceptJar ( file ) ) { \nreturn ; \n} \nscanJarFile ( file ) ; \n} \n} \n) ; \n} \n} \n"}
{"759": "public class TableChunk { \n@ Override public void init ( final TemplateData templateData ) { \nsuper . init ( templateData ) ; \nif ( ! ( entity != null ) ) { \nObject object = templateData . getObjectReference ( entityName ) ; \nif ( ! ( object != null ) ) { \nded = lookupName ( entityName ) ; \n} \nelse { \nded = lookupType ( resolveClass ( object ) ) ; \n} \n} \nelse { \nded = lookupType ( entity ) ; \n} \nString tableReference = this . tableReference ; \nif ( tableReference == null ) { \ntableReference = tableAlias ; \n} \nif ( tableReference == null ) { \ntableReference = entityName ; \n} \nif ( tableReference == null ) { \ntableReference = ded . getEntityName ( ) ; \n} \ntemplateData . registerTableReference ( tableReference , ded , tableAlias ) ; \n} \n} \n"}
{"762": "public class PetiteBeans { \nprotected void registerBean ( final String name , final BeanDefinition beanDefinition ) { \nbeans . put ( name , beanDefinition ) ; \nif ( ! petiteConfig . isUseAltBeanNames ( ) ) { \nreturn ; \n} \nClass type = beanDefinition . type ( ) ; \nif ( annotationResolver . beanHasAnnotationName ( type ) ) { \nreturn ; \n} \nClass [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; \nfor ( Class anInterface : interfaces ) { \nString altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; \nif ( name . equals ( altName ) ) { \ncontinue ; \n} \nif ( beans . containsKey ( altName ) ) { \ncontinue ; \n} \nif ( ! ( beansAlt . containsKey ( altName ) ) ) { \nbeansAlt . put ( altName , beanDefinition ) ; \n} \nelse { \nBeanDefinition existing = beansAlt . get ( altName ) ; \nif ( existing != null ) { \nbeansAlt . put ( altName , null ) ; \n} \n} \n} \n} \n} \n"}
{"764": "public class PetiteBeans { \nprotected String [ ] resolveBeanNamesForType ( final Class type ) { \nString [ ] beanNames = beanCollections . get ( type ) ; \nif ( beanNames != null ) { \nreturn beanNames ; \n} \nArrayList < String > list = new ArrayList < > ( ) ; \nfor ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { \nBeanDefinition beanDefinition = entry . getValue ( ) ; \nif ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { \nString beanName = entry . getKey ( ) ; \nlist . add ( beanName ) ; \n} \n} \nif ( ! ( list . isEmpty ( ) ) ) { \nbeanNames = list . toArray ( new String [ 0 ] ) ; \n} \nelse { \nbeanNames = StringPool . EMPTY_ARRAY ; \n} \nbeanCollections . put ( type , beanNames ) ; \nreturn beanNames ; \n} \n} \n"}
{"765": "public class PetiteBeans { \npublic void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nConstructor constructor = null ; \nif ( ! ( paramTypes == null ) ) { \nCtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; \nif ( ctorDescriptor != null ) { \nconstructor = ctorDescriptor . getConstructor ( ) ; \n} \n} \nelse { \nCtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; \nif ( ctors != null && ctors . length > 0 ) { \nif ( ctors . length > 1 ) { \nthrow new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nconstructor = ctors [ 0 ] . getConstructor ( ) ; \n} \n} \nif ( constructor == null ) { \nthrow new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; \nbeanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; \n} \n} \n"}
{"768": "public class PetiteBeans { \npublic void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nMethod method = null ; \nif ( ! ( arguments == null ) ) { \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md != null ) { \nmethod = md . getMethod ( ) ; \n} \n} \nelse { \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; \nif ( methods != null && methods . length > 0 ) { \nif ( methods . length > 1 ) { \nthrow new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nmethod = methods [ 0 ] . getMethod ( ) ; \n} \n} \nif ( method == null ) { \nthrow new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; \nMethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; \nbeanDefinition . addMethodInjectionPoint ( mip ) ; \n} \n} \n"}
{"777": "public class ProxettaAsmUtil { \npublic static void pushInt ( final MethodVisitor mv , final int value ) { \nif ( ! ( value <= 5 ) ) if ( ! ( value <= Byte . MAX_VALUE ) ) { \nmv . visitIntInsn ( SIPUSH , value ) ; \n} \nelse { \nmv . visitIntInsn ( BIPUSH , value ) ; \n} \nelse { \nmv . visitInsn ( ICONST_0 + value ) ; \n} \n} \n} \n"}
{"798": "public class ServletUtil { \npublic static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { \nString charEncoding = request . getCharacterEncoding ( ) ; \nif ( charEncoding == null ) { \ncharEncoding = JoddCore . encoding ; \n} \nCharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; \nBufferedReader bufferedReader = null ; \ntry { \nInputStream inputStream = request . getInputStream ( ) ; \nif ( ! ( inputStream != null ) ) { \nreturn StringPool . EMPTY ; \n} \nelse { \nbufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; \nStreamUtil . copy ( bufferedReader , charArrayWriter ) ; \n} \n} \nfinally { \nStreamUtil . close ( bufferedReader ) ; \n} \nreturn charArrayWriter . toString ( ) ; \n} \n} \n"}
{"813": "public class PropsData { \nprotected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { \nString realValue = value ; \nif ( append || appendDuplicateProps ) { \nPropsEntry pv = map . get ( key ) ; \nif ( pv != null ) { \nrealValue = pv . value + APPEND_SEPARATOR + realValue ; \n} \n} \nPropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; \nif ( ! ( first == null ) ) { \nlast . next = propsEntry ; \n} \nelse { \nfirst = propsEntry ; \n} \nlast = propsEntry ; \nmap . put ( key , propsEntry ) ; \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ( ! ignoreMissingMacros ) ) { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nelse { \nstringTemplateParser . setReplaceMissingKey ( false ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nint leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nint loopCount = 0 ; \nwhile ( loopCount ++ < MAX_INNER_MACROS ) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) { \nbreak ; \n} \nif ( skipEmptyProps ) { \nif ( newValue . length ( ) == 0 ) { \nreturn null ; \n} \n} \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"820": "public class BCrypt { \npublic static String hashpw ( String password , String salt ) { \nBCrypt B ; \nString real_salt ; \nbyte [ ] passwordb , saltb , hashed ; \nchar minor = ( char ) 0 ; \nint rounds , off ; \nStringBuffer rs = new StringBuffer ( ) ; \nif ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { \nthrow new IllegalArgumentException ( \"Invalid salt version\" ) ; \n} \nif ( ! ( salt . charAt ( 2 ) == '$' ) ) { \nminor = salt . charAt ( 2 ) ; \nif ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { \nthrow new IllegalArgumentException ( \"Invalid salt revision\" ) ; \n} \noff = 4 ; \n} \nelse { \noff = 3 ; \n} \nif ( salt . charAt ( off + 2 ) > '$' ) { \nthrow new IllegalArgumentException ( \"Missing salt rounds\" ) ; \n} \nrounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; \nreal_salt = salt . substring ( off + 3 , off + 25 ) ; \ntry { \npasswordb = ( password + ( minor >= 'a' ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nthrow new AssertionError ( \"UTF-8 is not supported\" ) ; \n} \nsaltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; \nB = new BCrypt ( ) ; \nhashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; \nrs . append ( \"$2\" ) ; \nif ( minor >= 'a' ) { \nrs . append ( minor ) ; \n} \nrs . append ( '$' ) ; \nif ( rounds < 10 ) { \nrs . append ( '0' ) ; \n} \nif ( rounds > 30 ) { \nthrow new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; \n} \nrs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; \nreturn rs . toString ( ) ; \n} \n} \n"}
{"825": "public class ActionMethodParser { \nprotected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { \nfinal Class < ? extends Annotation > annotationType ; \nif ( ! ( annotationValues == null ) ) { \nannotationType = annotationValues . annotationType ( ) ; \n} \nelse { \nannotationType = Action . class ; \n} \nreturn actionConfigManager . lookup ( annotationType ) ; \n} \n} \n"}
{"829": "public class ActionMethodParser { \nprotected String [ ] readPackageActionPath ( final Class actionClass ) { \nPackage actionPackage = actionClass . getPackage ( ) ; \nfinal String actionPackageName = actionPackage . getName ( ) ; \nString packageActionPathFromAnnotation ; \nmainloop : while ( true ) { \nMadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; \npackageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; \nif ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { \npackageActionPathFromAnnotation = null ; \n} \nif ( ! ( packageActionPathFromAnnotation == null ) ) { \nrootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; \nbreak ; \n} \nelse { \nString newPackage = actionPackage . getName ( ) ; \nactionPackage = null ; \nwhile ( actionPackage == null ) { \nfinal int ndx = newPackage . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak mainloop ; \n} \nnewPackage = newPackage . substring ( 0 , ndx ) ; \nactionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; \n} \n} \n} \nString packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; \nif ( packagePath == null ) { \nreturn ArraysUtil . array ( null , null ) ; \n} \nreturn ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; \n} \n} \n"}
{"830": "public class ActionMethodParser { \nprotected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { \nString methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; \nif ( ! ( methodActionPath == null ) ) { \nif ( methodActionPath . equals ( Action . NONE ) ) { \nreturn ArraysUtil . array ( null , null ) ; \n} \n} \nelse { \nmethodActionPath = methodName ; \n} \nfor ( String path : actionConfig . getActionMethodNames ( ) ) { \nif ( methodActionPath . equals ( path ) ) { \nmethodActionPath = null ; \nbreak ; \n} \n} \nreturn ArraysUtil . array ( methodName , methodActionPath ) ; \n} \n} \n"}
{"833": "public class DecoraResponseWrapper { \n@ Override protected void preResponseCommit ( ) { \nlong lastModified = lastModifiedData . getLastModified ( ) ; \nlong ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; \nif ( lastModified > - 1 && ! response . containsHeader ( \"Last-Modified\" ) ) { \nif ( ! ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) ) { \nresponse . reset ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \n} \nelse { \nresponse . setDateHeader ( \"Last-Modified\" , lastModified ) ; \n} \n} \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nif ( ! ( referenceKind <= Opcodes . H_PUTSTATIC ) ) { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"881": "public class ProxettaMethodBuilder { \nprotected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { \nmethodVisitor . visitCode ( ) ; \nif ( ! ( tmd . msign . isStatic ) ) { \nloadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; \nmethodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; \n} \nelse { \nloadStaticMethodArguments ( methodVisitor , tmd . msign ) ; \nmethodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; \n} \nvisitReturn ( methodVisitor , tmd . msign , false ) ; \nmethodVisitor . visitMaxs ( 0 , 0 ) ; \nmethodVisitor . visitEnd ( ) ; \n} \n} \n"}
{"892": "public class Buffer { \npublic void writeTo ( final Writer writer ) throws IOException { \nfor ( Object o : list ) { \nif ( ! ( o instanceof FastByteBuffer ) ) if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \nelse { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] array = fastByteBuffer . toArray ( ) ; \nwriter . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; \n} \n} \n} \n} \n"}
{"893": "public class Buffer { \npublic void writeTo ( final OutputStream out ) throws IOException { \nfor ( Object o : list ) { \nif ( ! ( o instanceof FastByteBuffer ) ) if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , out ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \nelse { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nout . write ( fastByteBuffer . toArray ( ) ) ; \n} \n} \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( ! ( o instanceof FastByteBuffer ) ) if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \nelse { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( offset < bytes . length ) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( ! ( filter == null ) ) { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nelse { \nmessages = folder . getMessages ( ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( int i = 0 ; \ni < messages . length ; \ni ++ ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"910": "public class RawData { \npublic RawData as ( final String mimeOrExtension ) { \nif ( ! ( mimeOrExtension . contains ( StringPool . SLASH ) ) ) { \nthis . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; \n} \nelse { \nthis . mimeType = mimeOrExtension ; \n} \nreturn this ; \n} \n} \n"}
{"928": "public class SystemUtil { \npublic static String get ( final String name , final String defaultValue ) { \nObjects . requireNonNull ( name ) ; \nString value = null ; \ntry { \nif ( ! ( System . getSecurityManager ( ) == null ) ) { \nvalue = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; \n} \nelse { \nvalue = System . getProperty ( name ) ; \n} \n} \ncatch ( Exception ignore ) { \n} \nif ( value == null ) { \nreturn defaultValue ; \n} \nreturn value ; \n} \n} \n"}
{"933": "public class KeyValueJsonSerializer { \nprotected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { \nif ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { \nreturn count ; \n} \nif ( ! ( key != null ) ) { \ncurrentPath . push ( StringPool . NULL ) ; \n} \nelse { \ncurrentPath . push ( key . toString ( ) ) ; \n} \nboolean include = true ; \nif ( value != null ) { \ninclude = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; \ninclude = jsonContext . matchPathToQueries ( include ) ; \n} \nif ( ! include ) { \ncurrentPath . pop ( ) ; \nreturn count ; \n} \nif ( ! ( key == null ) ) { \njsonContext . pushName ( key . toString ( ) , count > 0 ) ; \n} \nelse { \njsonContext . pushName ( null , count > 0 ) ; \n} \njsonContext . serialize ( value ) ; \nif ( jsonContext . isNamePopped ( ) ) { \ncount ++ ; \n} \ncurrentPath . pop ( ) ; \nreturn count ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nwhile ( i < len ) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( ! ( i == 0 ) ) { \nresult . append ( value . substring ( i ) ) ; \n} \nelse { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( ! ( alias != null ) ) { \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \n} \nelse { \nresult . append ( alias ) ; \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( i < len ) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni ++ ; \n} \nif ( i > 1 ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( ! ( StringUtil . startsWithChar ( value , '/' ) ) ) { \nint i = 0 ; \nwhile ( i < value . length ( ) ) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni ++ ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( ! ( StringUtil . startsWithChar ( value , '.' ) ) ) { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( ! ( dotNdx != - 1 ) ) { \nif ( value . length ( ) > 0 ) { \nif ( ! ( StringUtil . endsWithChar ( path , '/' ) ) ) { \npath += '.' + value ; \n} \nelse { \npath += value ; \n} \n} \nvalue = null ; \n} \nelse { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \n} \nelse { \nvalue = value . substring ( 1 ) ; \n} \n} \n} \nelse { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( ! ( dotNdx != - 1 ) ) { \npath = value ; \nvalue = null ; \n} \nelse { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"938": "public class MadvocUtil { \npublic static int lastIndexOfSlashDot ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nint dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \nif ( dotNdx == - 1 ) { \nif ( slashNdx == - 1 ) { \nreturn - 1 ; \n} \nslashNdx ++ ; \nif ( ! ( slashNdx < str . length ( ) - 1 ) ) { \ndotNdx = - 1 ; \n} \nelse { \ndotNdx = slashNdx ; \n} \n} \nreturn dotNdx ; \n} \n} \n"}
{"943": "public class DbMetaUtil { \npublic static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { \nString columnName = null ; \nboolean isId = false ; \nClass < ? extends SqlType > sqlTypeClass = null ; \nDbId dbId = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId == null && property . getReadMethodDescriptor ( ) != null ) { \ndbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) { \ndbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( ! ( dbId != null ) ) { \nDbColumn dbColumn = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) { \ndbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) { \ndbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( ! ( dbColumn != null ) ) { \nif ( isAnnotated ) { \nreturn null ; \n} \n} \nelse { \ncolumnName = dbColumn . value ( ) . trim ( ) ; \nsqlTypeClass = dbColumn . sqlType ( ) ; \n} \n} \nelse { \ncolumnName = dbId . value ( ) . trim ( ) ; \nsqlTypeClass = dbId . sqlType ( ) ; \nisId = true ; \n} \nif ( ! ( StringUtil . isEmpty ( columnName ) ) ) { \nif ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) { \ncolumnName = columnNamingStrategy . applyToColumnName ( columnName ) ; \n} \n} \nelse { \ncolumnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; \n} \nif ( sqlTypeClass == SqlType . class ) { \nsqlTypeClass = null ; \n} \nreturn new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( ! ( i == nw - 3 ) ) if ( ! ( i == nw - 2 ) ) if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \nelse { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \n} \n} \n} \n"}
{"965": "public class ParamManager { \npublic String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { \nbeanName = beanName + '.' ; \nList < String > list = new ArrayList < > ( ) ; \nfor ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { \nString key = entry . getKey ( ) ; \nif ( ! key . startsWith ( beanName ) ) { \ncontinue ; \n} \nlist . add ( key ) ; \nif ( ! resolveReferenceParams ) { \ncontinue ; \n} \nString value = PropertiesUtil . resolveProperty ( params , key ) ; \nentry . setValue ( value ) ; \n} \nif ( ! ( list . isEmpty ( ) ) ) { \nreturn list . toArray ( new String [ 0 ] ) ; \n} \nelse { \nreturn StringPool . EMPTY_ARRAY ; \n} \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( ! ( named ) ) { \nwhile ( numElementValuePairs -- > 0 ) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nelse { \nwhile ( numElementValuePairs -- > 0 ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( ! ( valueComponentType . isPrimitive ( ) ) ) { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nresult [ i ] = convertType ( array [ i ] ) ; \n} \n} \nelse { \nresult = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \n} \nreturn result ; \n} \n} \n"}
{"979": "public class DecoraServletFilter { \n@ Override public void init ( final FilterConfig filterConfig ) throws ServletException { \nfinal String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; \nif ( ! ( decoraManagerClass != null ) ) { \ndecoraManager = createDecoraManager ( ) ; \n} \nelse { \ntry { \nfinal Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; \ndecoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora manager class: \" + decoraManagerClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \n} \nfinal String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; \nif ( ! ( decoraParserClass != null ) ) { \ndecoraParser = createDecoraParser ( ) ; \n} \nelse { \ntry { \nfinal Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; \ndecoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora parser class: \" + decoraParserClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \n} \nfinal String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; \nif ( decoraCache != null ) { \ncached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; \n} \n} \n} \n"}
{"980": "public class FindFile { \npublic FindFile onFile ( final Consumer < File > fileConsumer ) { \nif ( ! ( consumers == null ) ) { \nconsumers . add ( fileConsumer ) ; \n} \nelse { \nconsumers = Consumers . of ( fileConsumer ) ; \n} \nreturn this ; \n} \n} \n"}
{"990": "public class AnnotationResolver { \npublic String resolveBeanName ( final Class type , final boolean useLongTypeName ) { \nPetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; \nString name = null ; \nif ( petiteBean != null ) { \nname = petiteBean . value ( ) . trim ( ) ; \n} \nif ( ( name == null ) || ( name . length ( ) == 0 ) ) { \nif ( ! ( useLongTypeName ) ) { \nname = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; \n} \nelse { \nname = type . getName ( ) ; \n} \n} \nreturn name ; \n} \n} \n"}
{"997": "public class Type { \nprivate void appendDescriptor ( final StringBuilder stringBuilder ) { \nif ( ! ( sort == OBJECT ) ) if ( ! ( sort == INTERNAL ) ) { \nstringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; \n} \nelse { \nstringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; \n} \nelse { \nstringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; \n} \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nint argumentsSize = 1 ; \nint currentOffset = 1 ; \nint currentChar = methodDescriptor . charAt ( currentOffset ) ; \nwhile ( currentChar != ')' ) { \nif ( ! ( currentChar == 'J' || currentChar == 'D' ) ) { \nwhile ( methodDescriptor . charAt ( currentOffset ) == '[' ) { \ncurrentOffset ++ ; \n} \nif ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { \ncurrentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \n} \nargumentsSize += 1 ; \n} \nelse { \ncurrentOffset ++ ; \nargumentsSize += 2 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( ! ( currentChar == 'V' ) ) { \nint returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \nelse { \nreturn argumentsSize << 2 ; \n} \n} \n} \n"}
{"1001": "public class JtxTransaction { \nprotected void commitOrRollback ( boolean doCommit ) { \nif ( log . isDebugEnabled ( ) ) { \nif ( ! ( doCommit ) ) { \nlog . debug ( \"Rollback JTX\" ) ; \n} \nelse { \nlog . debug ( \"Commit JTX\" ) ; \n} \n} \nboolean forcedRollback = false ; \nif ( ! isNoTransaction ( ) ) { \nif ( ! ( isRollbackOnly ( ) ) ) if ( ! isActive ( ) ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, commit or rollback should be called once per TX\" ) ; \n} \nthrow new JtxException ( \"No active TX to \" + ( doCommit ? \"commit\" : \"rollback\" ) ) ; \n} \nelse { \nif ( doCommit ) { \ndoCommit = false ; \nforcedRollback = true ; \n} \n} \n} \nif ( ! ( doCommit ) ) { \nrollbackAllResources ( forcedRollback ) ; \n} \nelse { \ncommitAllResources ( ) ; \n} \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( ! ( strictStringEncoding ) ) { \nwrite ( c ) ; \n} \nelse { \nwrite ( \"\\\\/\" ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( ! ( Character . isISOControl ( c ) ) ) { \nwrite ( c ) ; \n} \nelse { \nunicode ( c ) ; \n} \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1018": "public class BinarySearchBase { \npublic int findLast ( int low , int high ) { \nint ndx = - 1 ; \nwhile ( low <= high ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( mid ) ; \nif ( ! ( delta > 0 ) ) { \nif ( delta == 0 ) { \nndx = mid ; \n} \nlow = mid + 1 ; \n} \nelse { \nhigh = mid - 1 ; \n} \n} \nif ( ndx == - 1 ) { \nreturn - ( low + 1 ) ; \n} \nreturn ndx ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( ! ( type . isArray ( ) ) ) if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( ! ( componentType . isPrimitive ( ) ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( ! ( componentType == int . class ) ) if ( ! ( componentType == long . class ) ) if ( ! ( componentType == double . class ) ) if ( ! ( componentType == float . class ) ) if ( ! ( componentType == boolean . class ) ) if ( ! ( componentType == short . class ) ) if ( ! ( componentType == byte . class ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ! ( ch == separator ) ) if ( ! ( upperCase ) ) { \nsb . append ( ch ) ; \n} \nelse { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nupperCase = true ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nint total = src . length ( ) ; \nint from = 0 ; \nwhile ( from < total ) { \nint to = from + len ; \nif ( ! ( to >= total ) ) if ( breakOnWhitespace ) { \nint ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) { \nto = ndx + 1 ; \n} \n} \nelse { \nto = total ; \n} \nint cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nint cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nint strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \nfor ( int i = 0 ; \ni < strLen ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ! ( ( c < 32 ) || ( c > 127 ) ) ) { \nsb . append ( c ) ; \n} \nelse { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \nfor ( int k = hex . length ( ) ; \nk < 4 ; \nk ++ ) { \nsb . append ( '0' ) ; \n} \nsb . append ( hex ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1046": "public class PetiteContainer { \nprotected Object invokeProvider ( final ProviderDefinition provider ) { \nif ( provider . method != null ) { \nfinal Object bean ; \nif ( ! ( provider . beanName != null ) ) { \nbean = null ; \n} \nelse { \nbean = getBean ( provider . beanName ) ; \n} \ntry { \nreturn provider . method . invoke ( bean ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid provider method: \" + provider . method . getName ( ) , ex ) ; \n} \n} \nthrow new PetiteException ( \"Invalid provider\" ) ; \n} \n} \n"}
{"1051": "public class Paramo { \npublic static MethodParameter [ ] resolveParameters ( final AccessibleObject methodOrCtor ) { \nClass [ ] paramTypes ; \nClass declaringClass ; \nString name ; \nif ( ! ( methodOrCtor instanceof Method ) ) { \nConstructor constructor = ( Constructor ) methodOrCtor ; \nparamTypes = constructor . getParameterTypes ( ) ; \ndeclaringClass = constructor . getDeclaringClass ( ) ; \nname = CTOR_METHOD ; \n} \nelse { \nMethod method = ( Method ) methodOrCtor ; \nparamTypes = method . getParameterTypes ( ) ; \nname = method . getName ( ) ; \ndeclaringClass = method . getDeclaringClass ( ) ; \n} \nif ( paramTypes . length == 0 ) { \nreturn MethodParameter . EMPTY_ARRAY ; \n} \nInputStream stream ; \ntry { \nstream = ClassLoaderUtil . getClassAsStream ( declaringClass ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ParamoException ( \"Failed to read class bytes: \" + declaringClass . getName ( ) , ioex ) ; \n} \nif ( stream == null ) { \nthrow new ParamoException ( \"Class not found: \" + declaringClass ) ; \n} \ntry { \nClassReader reader = new ClassReader ( stream ) ; \nMethodFinder visitor = new MethodFinder ( declaringClass , name , paramTypes ) ; \nreader . accept ( visitor , 0 ) ; \nreturn visitor . getResolvedParameters ( ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ParamoException ( ioex ) ; \n} \nfinally { \nStreamUtil . close ( stream ) ; \n} \n} \n} \n"}
{"1055": "public class LagartoDOMBuilderTagVisitor { \nprotected Element createElementNode ( final Tag tag ) { \nboolean hasVoidTags = htmlVoidRules != null ; \nboolean isVoid = false ; \nboolean selfClosed = false ; \nif ( ! ( hasVoidTags ) ) { \nselfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; \n} \nelse { \nisVoid = htmlVoidRules . isVoidTag ( tag . getName ( ) ) ; \nif ( isVoid ) { \nselfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; \n} \n} \nreturn new Element ( rootNode , tag , isVoid , selfClosed ) ; \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( ! ( parameterValues . size ( ) > 1 + qMarkCount ) ) { \nif ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \n} \nelse { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1074": "public class StringUtil { \npublic static String [ ] toStringArray ( final Object value ) { \nif ( value == null ) { \nreturn new String [ 0 ] ; \n} \nClass < ? > type = value . getClass ( ) ; \nif ( ! type . isArray ( ) ) { \nreturn new String [ ] { \nvalue . toString ( ) } \n; \n} \nClass componentType = type . getComponentType ( ) ; \nif ( ! ( componentType . isPrimitive ( ) ) ) { \nreturn ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; \n} \nelse { \nif ( ! ( componentType == int . class ) ) if ( ! ( componentType == long . class ) ) if ( ! ( componentType == double . class ) ) if ( ! ( componentType == float . class ) ) if ( ! ( componentType == boolean . class ) ) if ( ! ( componentType == short . class ) ) if ( ! ( componentType == byte . class ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( byte [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( short [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( boolean [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( float [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( double [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( long [ ] ) value ) ; \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( int [ ] ) value ) ; \n} \n} \n} \n} \n"}
{"1075": "public class StringUtil { \nprivate static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { \nint strLen = string . length ( ) ; \nif ( strLen == 0 ) { \nreturn string ; \n} \nchar ch = string . charAt ( 0 ) ; \nchar modifiedCh ; \nif ( ! ( capitalize ) ) { \nmodifiedCh = Character . toLowerCase ( ch ) ; \n} \nelse { \nmodifiedCh = Character . toUpperCase ( ch ) ; \n} \nif ( modifiedCh == ch ) { \nreturn string ; \n} \nchar [ ] chars = string . toCharArray ( ) ; \nchars [ 0 ] = modifiedCh ; \nreturn new String ( chars ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \nfor ( int i = 0 ; \ni < chars . length ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( ! ( CharUtil . isWhitespace ( c ) ) ) { \nif ( ! ( wasWhitespace ) ) { \nchars [ i ] = Character . toLowerCase ( c ) ; \n} \nelse { \nchars [ i ] = Character . toUpperCase ( c ) ; \n} \nwasWhitespace = false ; \n} \nelse { \nwasWhitespace = true ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nint len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c1 = s . charAt ( i ) ; \nif ( ! ( c1 == c ) ) { \nwasChar = false ; \n} \nelse { \nif ( wasChar ) { \ncontinue ; \n} \nwasChar = true ; \n} \nsb . append ( c1 ) ; \n} \nif ( sb . length ( ) == len ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( ! ( i == 0 ) ) { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \nelse { \nc = s . charAt ( index ) ; \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1124": "public class AnnotatedPropertyInterceptor { \nprotected PropertyDescriptor [ ] lookupAnnotatedProperties ( final Class type ) { \nPropertyDescriptor [ ] properties = annotatedProperties . get ( type ) ; \nif ( properties != null ) { \nreturn properties ; \n} \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nList < PropertyDescriptor > list = new ArrayList < > ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nAnnotation ann = null ; \nif ( propertyDescriptor . getFieldDescriptor ( ) != null ) { \nann = propertyDescriptor . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( annotations ) ; \n} \nif ( ann == null && propertyDescriptor . getWriteMethodDescriptor ( ) != null ) { \nann = propertyDescriptor . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \n} \nif ( ann == null && propertyDescriptor . getReadMethodDescriptor ( ) != null ) { \nann = propertyDescriptor . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \n} \nif ( ann != null ) { \nlist . add ( propertyDescriptor ) ; \n} \n} \nif ( ! ( list . isEmpty ( ) ) ) { \nproperties = list . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \nelse { \nproperties = EMPTY ; \n} \nannotatedProperties . put ( type , properties ) ; \nreturn properties ; \n} \n} \n"}
{"1126": "public class GzipResponseStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nif ( ! ( gzipstream != null ) ) { \nif ( bufferCount > 0 ) { \noutput . write ( buffer , 0 , bufferCount ) ; \nbufferCount = 0 ; \n} \n} \nelse { \nflushToGZip ( ) ; \ngzipstream . close ( ) ; \ngzipstream = null ; \n} \noutput . close ( ) ; \nclosed = true ; \n} \n} \n"}
{"1130": "public class EmailAttachment { \npublic byte [ ] toByteArray ( ) { \nfinal FastByteArrayOutputStream out ; \nif ( ! ( size != - 1 ) ) { \nout = new FastByteArrayOutputStream ( ) ; \n} \nelse { \nout = new FastByteArrayOutputStream ( size ) ; \n} \nwriteToStream ( out ) ; \nreturn out . toByteArray ( ) ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ni < textLength ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( ! ( CharUtil . isWhitespace ( c ) ) ) { \nregularChar = true ; \n} \nelse { \nif ( ! ( regularChar ) ) { \ncontinue ; \n} \nelse { \nregularChar = false ; \nc = ' ' ; \n} \n} \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( ! ( regularChar || ( ndx != 1 ) ) ) { \nstrippedCharsCount += textLength ; \n} \nelse { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nint ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) { \nreturn html ; \n} \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nint lastIndex = 0 ; \nint len = html . length ( ) ; \nmainloop : while ( ndx != - 1 ) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nwhile ( html . charAt ( lastIndex ) != ';' ) { \nlastIndex ++ ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( ! ( html . charAt ( ndx + 1 ) == '#' ) ) { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( ! ( replacement == null ) ) { \nresult . append ( replacement ) ; \nlastIndex ++ ; \n} \nelse { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \n} \nelse { \nchar c = html . charAt ( ndx + 2 ) ; \nint radix ; \nif ( ! ( ( c == 'x' ) || ( c == 'X' ) ) ) { \nradix = 10 ; \nndx += 2 ; \n} \nelse { \nradix = 16 ; \nndx += 3 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nint i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex ++ ; \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( ! ( newIndex > index ) ) if ( newIndex < index ) { \nfor ( int i = newIndex ; \ni < index ; \ni ++ ) { \narray [ i ] = null ; \n} \n} \nelse { \nfor ( int i = index ; \ni < newIndex ; \ni ++ ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1170": "public class ScopedProxyManager { \nprotected Object createScopedProxyBean ( final PetiteContainer petiteContainer , final BeanDefinition refBeanDefinition ) { \nClass beanType = refBeanDefinition . type ; \nClass proxyClass = proxyClasses . get ( beanType ) ; \nif ( proxyClass == null ) { \nif ( ! ( refBeanDefinition instanceof ProxettaBeanDefinition ) ) { \nProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspect ( aspect ) ; \nproxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; \nproxetta . setVariableClassName ( true ) ; \nProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( beanType ) ; \nproxyClass = builder . define ( ) ; \nproxyClasses . put ( beanType , proxyClass ) ; \n} \nelse { \nProxettaBeanDefinition pbd = ( ProxettaBeanDefinition ) refBeanDefinition ; \nProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspects ( ArraysUtil . insert ( pbd . proxyAspects , aspect , 0 ) ) ; \nproxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; \nproxetta . setVariableClassName ( true ) ; \nProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( pbd . originalTarget ) ; \nproxyClass = builder . define ( ) ; \nproxyClasses . put ( beanType , proxyClass ) ; \n} \n} \nObject proxy ; \ntry { \nproxy = ClassUtil . newInstance ( proxyClass ) ; \nField field = proxyClass . getField ( \"$__petiteContainer$0\" ) ; \nfield . set ( proxy , petiteContainer ) ; \nfield = proxyClass . getField ( \"$__name$0\" ) ; \nfield . set ( proxy , refBeanDefinition . name ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( ex ) ; \n} \nreturn proxy ; \n} \n} \n"}
{"1184": "public class DecoraParser { \nprotected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { \nint ndx = 0 ; \nfor ( DecoraTag decoraTag : decoraTags ) { \nint decoratorLen = decoraTag . getStartIndex ( ) - ndx ; \nif ( decoratorLen <= 0 ) { \ncontinue ; \n} \nout . write ( decoratorContent , ndx , decoratorLen ) ; \nndx = decoraTag . getEndIndex ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nif ( ! ( regionLen == 0 ) ) { \nwriteRegion ( out , pageContent , decoraTag , decoraTags ) ; \n} \nelse { \nif ( decoraTag . hasDefaultValue ( ) ) { \nout . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; \n} \n} \n} \nout . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; \n} \n} \n"}
{"1188": "public class ImapSslServer { \n@ Override protected IMAPSSLStore getStore ( final Session session ) { \nSimpleAuthenticator simpleAuthenticator = ( SimpleAuthenticator ) authenticator ; \nfinal URLName url ; \nif ( ! ( simpleAuthenticator == null ) ) { \nfinal PasswordAuthentication pa = simpleAuthenticator . getPasswordAuthentication ( ) ; \nurl = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , pa . getUserName ( ) , pa . getPassword ( ) ) ; \n} \nelse { \nurl = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , null , null ) ; \n} \nreturn new IMAPSSLStore ( session , url ) ; \n} \n} \n"}
{"1191": "public class ColumnsSelectChunk { \nprotected void appendAlias ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { \nfinal ColumnAliasType columnAliasType = templateData . getColumnAliasType ( ) ; \nif ( ! ( columnAliasType == null || columnAliasType == ColumnAliasType . TABLE_REFERENCE ) ) if ( ! ( columnAliasType == ColumnAliasType . COLUMN_CODE ) ) if ( columnAliasType == ColumnAliasType . TABLE_NAME ) { \nfinal String tableName = ded . getTableNameForQuery ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \nquery . append ( tableName ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \nelse { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnName ( ) ; \nfinal String code = templateData . registerColumnDataForColumnCode ( tableName , columnName ) ; \nquery . append ( code ) ; \n} \nelse { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \ntemplateData . registerColumnDataForTableRef ( tableRef , tableName ) ; \nquery . append ( tableRef ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \n} \n} \n"}
{"1193": "public class InExRules { \nprotected void addRule ( final D ruleDefinition , final boolean include ) { \nif ( rules == null ) { \nrules = new ArrayList < > ( ) ; \n} \nif ( ! ( include ) ) { \nexcludesCount ++ ; \n} \nelse { \nincludesCount ++ ; \n} \nRule < R > newRule = new Rule < > ( makeRule ( ruleDefinition ) , include ) ; \nif ( rules . contains ( newRule ) ) { \nreturn ; \n} \nrules . add ( newRule ) ; \n} \n} \n"}
{"1194": "public class InExRules { \npublic boolean apply ( final V value , final boolean blacklist , boolean flag ) { \nif ( rules == null ) { \nreturn flag ; \n} \nif ( ! ( blacklist ) ) { \nflag = processIncludes ( value , flag ) ; \nflag = processExcludes ( value , flag ) ; \n} \nelse { \nflag = processExcludes ( value , flag ) ; \nflag = processIncludes ( value , flag ) ; \n} \nreturn flag ; \n} \n} \n"}
{"1199": "public class SortedArrayList { \nprotected int findInsertionPoint ( final E o , int low , int high ) { \nwhile ( low <= high ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( get ( mid ) , o ) ; \nif ( ! ( delta > 0 ) ) { \nlow = mid + 1 ; \n} \nelse { \nhigh = mid - 1 ; \n} \n} \nreturn low ; \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nint lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) { \nif ( ! ( reqProxyClassName . startsWith ( DOT ) ) ) if ( ! ( reqProxyClassName . endsWith ( DOT ) ) ) { \nname = reqProxyClassName . replace ( '.' , '/' ) ; \n} \nelse { \nname = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \n} \nelse { \nname = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \n} \n} \nif ( suffix != null ) { \nname += suffix ; \n} \nthis . thisReference = name ; \nthis . superReference = this . superName ; \n} \n} \n"}
{"1213": "public class PropsParser { \nprotected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { \nif ( key == null ) { \nreturn ; \n} \nString fullKey = key ; \nif ( section != null ) { \nif ( ! ( fullKey . length ( ) != 0 ) ) { \nfullKey = section ; \n} \nelse { \nfullKey = section + '.' + fullKey ; \n} \n} \nString v = value . toString ( ) ; \nif ( trim ) { \nif ( ! ( valueTrimLeft && valueTrimRight ) ) if ( ! ( valueTrimLeft ) ) { \nv = StringUtil . trimRight ( v ) ; \n} \nelse { \nv = StringUtil . trimLeft ( v ) ; \n} \nelse { \nv = v . trim ( ) ; \n} \n} \nif ( v . length ( ) == 0 && skipEmptyProps ) { \nreturn ; \n} \nextractProfilesAndAdd ( fullKey , v , operator ) ; \n} \n} \n"}
{"1215": "public class PropsParser { \nprotected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { \nif ( operator == Operator . COPY ) { \nHashMap < String , Object > target = new HashMap < > ( ) ; \nString [ ] profiles = null ; \nif ( keyProfiles != null ) { \nprofiles = keyProfiles . toArray ( new String [ 0 ] ) ; \n} \nString [ ] sources = StringUtil . splitc ( value , ',' ) ; \nfor ( String source : sources ) { \nsource = source . trim ( ) ; \nString [ ] lookupProfiles = profiles ; \nString lookupProfilesString = null ; \nint leftIndex = source . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = source . indexOf ( '>' ) ; \nlookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; \nsource = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nString [ ] wildcards = new String [ ] { \nsource + \".*\" } \n; \npropsData . extract ( target , lookupProfiles , wildcards , null ) ; \nfor ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { \nString entryKey = entry . getKey ( ) ; \nString suffix = entryKey . substring ( source . length ( ) ) ; \nString newKey = key + suffix ; \nString newValue = \"${\" + entryKey ; \nif ( lookupProfilesString != null ) { \nnewValue += \"<\" + lookupProfilesString + \">\" ; \n} \nnewValue += \"}\" ; \nif ( ! ( profiles == null ) ) { \nfor ( final String p : profiles ) { \npropsData . putProfileProperty ( newKey , newValue , p , false ) ; \n} \n} \nelse { \npropsData . putBaseProperty ( newKey , newValue , false ) ; \n} \n} \n} \nreturn ; \n} \nboolean append = operator == Operator . QUICK_APPEND ; \nif ( keyProfiles == null ) { \npropsData . putBaseProperty ( key , value , append ) ; \nreturn ; \n} \nfor ( final String p : keyProfiles ) { \npropsData . putProfileProperty ( key , value , p , append ) ; \n} \n} \n} \n"}
{"1221": "public class CollectionConverter { \n@ SuppressWarnings ( \"unchecked\" ) protected Collection < T > createCollection ( final int length ) { \nif ( collectionType . isInterface ( ) ) { \nif ( collectionType == List . class ) { \nif ( ! ( length > 0 ) ) { \nreturn new ArrayList < > ( ) ; \n} \nelse { \nreturn new ArrayList < > ( length ) ; \n} \n} \nif ( collectionType == Set . class ) { \nif ( ! ( length > 0 ) ) { \nreturn new HashSet < > ( ) ; \n} \nelse { \nreturn new HashSet < > ( length ) ; \n} \n} \nthrow new TypeConversionException ( \"Unknown collection: \" + collectionType . getName ( ) ) ; \n} \nif ( length > 0 ) { \ntry { \nConstructor < Collection < T > > ctor = ( Constructor < Collection < T > > ) collectionType . getConstructor ( int . class ) ; \nreturn ctor . newInstance ( Integer . valueOf ( length ) ) ; \n} \ncatch ( Exception ex ) { \n} \n} \ntry { \nreturn collectionType . getDeclaredConstructor ( ) . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new TypeConversionException ( ex ) ; \n} \n} \n} \n"}
{"1223": "public class CollectionConverter { \nprotected Collection < T > convertValueToCollection ( Object value ) { \nif ( value instanceof Iterable ) { \nIterable iterable = ( Iterable ) value ; \nCollection < T > collection = createCollection ( 0 ) ; \nfor ( Object element : iterable ) { \ncollection . add ( convertType ( element ) ) ; \n} \nreturn collection ; \n} \nif ( value instanceof CharSequence ) { \nvalue = CsvUtil . toStringArray ( value . toString ( ) ) ; \n} \nClass type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nClass componentType = type . getComponentType ( ) ; \nif ( ! ( componentType . isPrimitive ( ) ) ) { \nObject [ ] array = ( Object [ ] ) value ; \nCollection < T > result = createCollection ( array . length ) ; \nfor ( Object a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \nreturn result ; \n} \nelse { \nreturn convertPrimitiveArrayToCollection ( value , componentType ) ; \n} \n} \nreturn convertToSingleElementCollection ( value ) ; \n} \n} \n"}
{"1225": "public class CollectionConverter { \n@ SuppressWarnings ( \"AutoBoxing\" ) protected Collection < T > convertPrimitiveArrayToCollection ( final Object value , final Class primitiveComponentType ) { \nCollection < T > result = null ; \nif ( ! ( primitiveComponentType == int . class ) ) if ( ! ( primitiveComponentType == long . class ) ) if ( ! ( primitiveComponentType == float . class ) ) if ( ! ( primitiveComponentType == double . class ) ) if ( ! ( primitiveComponentType == short . class ) ) if ( ! ( primitiveComponentType == byte . class ) ) if ( ! ( primitiveComponentType == char . class ) ) if ( primitiveComponentType == boolean . class ) { \nboolean [ ] array = ( boolean [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( boolean a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nchar [ ] array = ( char [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( char a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nbyte [ ] array = ( byte [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( byte a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nshort [ ] array = ( short [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( short a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \ndouble [ ] array = ( double [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( double a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nfloat [ ] array = ( float [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( float a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nlong [ ] array = ( long [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( long a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nint [ ] array = ( int [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( int a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( ! ( this . lineNumber == 0 ) ) { \nif ( otherLineNumbers == null ) { \notherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \n} \nint otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; \nif ( otherLineNumberIndex >= otherLineNumbers . length ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \nelse { \nthis . lineNumber = ( short ) lineNumber ; \n} \n} \n} \n"}
{"1228": "public class Label { \nfinal void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { \nif ( ! ( ( flags & FLAG_RESOLVED ) == 0 ) ) { \nif ( ! ( wideReference ) ) { \ncode . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \nelse { \ncode . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \n} \nelse { \nif ( ! ( wideReference ) ) { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; \ncode . putShort ( - 1 ) ; \n} \nelse { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; \ncode . putInt ( - 1 ) ; \n} \n} \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ! ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) ) { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( ! ( opcode < Opcodes . IFNULL ) ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1270": "public class ExceptionUtil { \n@ SuppressWarnings ( { \n\"ThrowCaughtLocally\" } \n) public static StackTraceElement [ ] getCurrentStackTrace ( ) { \nStackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; \nif ( ! ( ste . length > 1 ) ) { \nreturn ste ; \n} \nelse { \nStackTraceElement [ ] result = new StackTraceElement [ ste . length - 1 ] ; \nSystem . arraycopy ( ste , 1 , result , 0 , ste . length - 1 ) ; \nreturn result ; \n} \n} \n} \n"}
{"1276": "public class ExceptionUtil { \npublic static String buildMessage ( final String message , Throwable cause ) { \nif ( ! ( cause != null ) ) { \nreturn message ; \n} \nelse { \ncause = getRootCause ( cause ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nif ( message != null ) { \nbuf . append ( message ) . append ( \"; \" ) ; \n} \nbuf . append ( \"<--- \" ) . append ( cause ) ; \nreturn buf . toString ( ) ; \n} \n} \n} \n"}
{"1277": "public class ExceptionUtil { \npublic static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { \nThrowable unwrapped = wrappedThrowable ; \nwhile ( true ) { \nif ( ! ( unwrapped instanceof InvocationTargetException ) ) if ( ! ( unwrapped instanceof UndeclaredThrowableException ) ) { \nreturn unwrapped ; \n} \nelse { \nunwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; \n} \nelse { \nunwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; \n} \n} \n} \n} \n"}
{"1278": "public class AutomagicMadvocConfigurator { \nprotected void registerAsConsumer ( final ClassScanner classScanner ) { \nclassScanner . registerEntryConsumer ( classPathEntry -> { \nfinal String entryName = classPathEntry . name ( ) ; \nif ( ! ( entryName . endsWith ( actionClassSuffix ) ) ) if ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) { \ntry { \nacceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc component ignoring: {}\" + entryName ) ; \n} \n} \nelse { \ntry { \nacceptActionClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc action, ignoring: \" + entryName ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"1280": "public class ClassLoaderUtil { \npublic static ClassLoader getSystemClassLoader ( ) { \nif ( ! ( System . getSecurityManager ( ) == null ) ) { \nreturn AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) ClassLoader :: getSystemClassLoader ) ; \n} \nelse { \nreturn ClassLoader . getSystemClassLoader ( ) ; \n} \n} \n} \n"}
{"1285": "public class RouteChunk { \npublic RouteChunk add ( final String newValue ) { \nRouteChunk routeChunk = new RouteChunk ( routes , this , newValue ) ; \nif ( ! ( children == null ) ) { \nchildren = ArraysUtil . append ( children , routeChunk ) ; \n} \nelse { \nchildren = new RouteChunk [ ] { \nrouteChunk } \n; \n} \nreturn routeChunk ; \n} \n} \n"}
{"1287": "public class MultipartRequest { \npublic void parseRequest ( ) throws IOException { \nif ( ! ( ServletUtil . isMultipartRequest ( request ) ) ) { \nEnumeration names = request . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString paramName = ( String ) names . nextElement ( ) ; \nString [ ] values = request . getParameterValues ( paramName ) ; \nputParameters ( paramName , values ) ; \n} \n} \nelse { \nparseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; \n} \n} \n} \n"}
{"1289": "public class BeanUtilUtil { \nprotected Object invokeSetter ( final Setter setter , final BeanProperty bp , Object value ) { \ntry { \nfinal MapperFunction setterMapperFunction = setter . getMapperFunction ( ) ; \nif ( setterMapperFunction != null ) { \nvalue = setterMapperFunction . apply ( value ) ; \n} \nfinal Class type = setter . getSetterRawType ( ) ; \nif ( ! ( ClassUtil . isTypeOf ( type , Collection . class ) ) ) { \nvalue = convertType ( value , type ) ; \n} \nelse { \nClass componentType = setter . getSetterRawComponentType ( ) ; \nvalue = convertToCollection ( value , type , componentType ) ; \n} \nsetter . invokeSetter ( bp . bean , value ) ; \n} \ncatch ( Exception ex ) { \nif ( isSilent ) { \nreturn null ; \n} \nthrow new BeanException ( \"Setter failed: \" + setter , ex ) ; \n} \nreturn value ; \n} \n} \n"}
{"1302": "public class ValidationContext { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected void collectAnnotationChecks ( final List < Check > annChecks , final Class targetType , final String targetName , final Annotation [ ] annotations ) { \nfor ( Annotation annotation : annotations ) { \nConstraint c = annotation . annotationType ( ) . getAnnotation ( Constraint . class ) ; \nClass < ? extends ValidationConstraint > constraintClass ; \nif ( ! ( c == null ) ) { \nconstraintClass = c . value ( ) ; \n} \nelse { \nString constraintClassName = annotation . annotationType ( ) . getName ( ) + \"Constraint\" ; \ntry { \nconstraintClass = ClassLoaderUtil . loadClass ( constraintClassName , this . getClass ( ) . getClassLoader ( ) ) ; \n} \ncatch ( ClassNotFoundException ingore ) { \ncontinue ; \n} \n} \nValidationConstraint vc ; \ntry { \nvc = newConstraint ( constraintClass , targetType ) ; \n} \ncatch ( Exception ex ) { \nthrow new VtorException ( \"Invalid constraint: \" + constraintClass . getClass ( ) . getName ( ) , ex ) ; \n} \nvc . configure ( annotation ) ; \nCheck check = new Check ( targetName , vc ) ; \ncopyDefaultCheckProperties ( check , annotation ) ; \nannChecks . add ( check ) ; \n} \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \nfor ( int iteration = 0 ; \niteration < 2 ; \niteration ++ ) { \nfor ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \ncontinue ; \n} \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( ! ( iteration == 0 ) ) { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) { \ncontinue ; \n} \nString name = field . getName ( ) ; \nif ( prefix != null ) { \nfor ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) { \ncontinue ; \n} \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \n} \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"1322": "public class MapToBean { \npublic Object map2bean ( final Map map , Class targetType ) { \nObject target = null ; \nString className = ( String ) map . get ( classMetadataName ) ; \nif ( ! ( className == null ) ) { \ncheckClassName ( jsonParser . classnameWhitelist , className ) ; \ntry { \ntargetType = ClassLoaderUtil . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new JsonException ( cnfex ) ; \n} \n} \nelse { \nif ( targetType == null ) { \ntarget = map ; \n} \n} \nif ( target == null ) { \ntarget = jsonParser . newObjectInstance ( targetType ) ; \n} \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; \nboolean targetIsMap = target instanceof Map ; \nfor ( Object key : map . keySet ( ) ) { \nString keyName = key . toString ( ) ; \nif ( classMetadataName != null ) { \nif ( keyName . equals ( classMetadataName ) ) { \ncontinue ; \n} \n} \nPropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; \nif ( ! targetIsMap && pd == null ) { \ncontinue ; \n} \nObject value = map . get ( key ) ; \nClass propertyType = pd == null ? null : pd . getType ( ) ; \nClass componentType = pd == null ? null : pd . resolveComponentType ( true ) ; \nif ( value != null ) { \nif ( ! ( value instanceof List ) ) if ( value instanceof Map ) { \nif ( ! ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) ) { \nClass keyType = pd == null ? null : pd . resolveKeyType ( true ) ; \nif ( keyType != String . class || componentType != String . class ) { \nvalue = generifyMap ( ( Map ) value , keyType , componentType ) ; \n} \n} \nelse { \nvalue = map2bean ( ( Map ) value , propertyType ) ; \n} \n} \nelse { \nif ( componentType != null && componentType != String . class ) { \nvalue = generifyList ( ( List ) value , componentType ) ; \n} \n} \n} \nif ( ! ( targetIsMap ) ) { \ntry { \nsetValue ( target , pd , value ) ; \n} \ncatch ( Exception ignore ) { \nignore . printStackTrace ( ) ; \n} \n} \nelse { \n( ( Map ) target ) . put ( keyName , value ) ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nObject element = list . get ( i ) ; \nif ( element != null ) { \nif ( ! ( element instanceof Map ) ) { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \nelse { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"1328": "public class HttpBrowser { \npublic HttpResponse sendRequest ( HttpRequest httpRequest ) { \nelapsedTime = System . currentTimeMillis ( ) ; \nhttpRequest . followRedirects ( false ) ; \nwhile ( true ) { \nthis . httpRequest = httpRequest ; \nHttpResponse previousResponse = this . httpResponse ; \nthis . httpResponse = null ; \naddDefaultHeaders ( httpRequest ) ; \naddCookies ( httpRequest ) ; \nif ( ! ( catchTransportExceptions ) ) { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \nelse { \ntry { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \ncatch ( HttpException httpException ) { \nhttpResponse = new HttpResponse ( ) ; \nhttpResponse . assignHttpRequest ( httpRequest ) ; \nhttpResponse . statusCode ( 503 ) ; \nhttpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; \n} \n} \nreadCookies ( httpResponse ) ; \nint statusCode = httpResponse . statusCode ( ) ; \nif ( statusCode == 301 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 302 || statusCode == 303 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 307 || statusCode == 308 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nbreak ; \n} \nelapsedTime = System . currentTimeMillis ( ) - elapsedTime ; \nreturn this . httpResponse ; \n} \n} \n"}
{"1329": "public class HttpBrowser { \nprotected HttpResponse _sendRequest ( final HttpRequest httpRequest , final HttpResponse previouseResponse ) { \nif ( ! ( ! keepAlive ) ) { \nif ( ! ( previouseResponse == null ) ) { \nhttpRequest . keepAlive ( previouseResponse , true ) ; \n} \nelse { \nhttpRequest . open ( httpConnectionProvider ) . connectionKeepAlive ( true ) ; \n} \n} \nelse { \nhttpRequest . open ( httpConnectionProvider ) ; \n} \nreturn httpRequest . send ( ) ; \n} \n} \n"}
{"1334": "public class SendMailSession { \nprivate void setSubject ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nif ( ! ( emailWithData . subjectEncoding ( ) != null ) ) { \nmsgToSet . setSubject ( emailWithData . subject ( ) ) ; \n} \nelse { \nmsgToSet . setSubject ( emailWithData . subject ( ) , emailWithData . subjectEncoding ( ) ) ; \n} \n} \n} \n"}
{"1339": "public class SendMailSession { \nprivate void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal List < EmailMessage > messages = emailWithData . messages ( ) ; \nfinal int totalMessages = messages . size ( ) ; \nfinal List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; \nif ( ! ( attachments . isEmpty ( ) && totalMessages == 1 ) ) { \nfinal MimeMultipart multipart = new MimeMultipart ( ) ; \nfinal MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; \nmultipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; \nfor ( final EmailMessage emailMessage : messages ) { \nmsgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; \n} \naddAnyAttachments ( attachments , multipart ) ; \nmsgToSet . setContent ( multipart ) ; \n} \nelse { \nsetContent ( messages . get ( 0 ) , msgToSet ) ; \n} \n} \n} \n"}
{"1345": "public class DbQueryBase { \nprotected SQLException closeQuery ( ) { \nSQLException sqlException = closeQueryResultSets ( ) ; \nif ( statement != null ) { \ntry { \nstatement . close ( ) ; \n} \ncatch ( SQLException sex ) { \nif ( ! ( sqlException == null ) ) { \nsqlException . setNextException ( sex ) ; \n} \nelse { \nsqlException = sex ; \n} \n} \nstatement = null ; \n} \nquery = null ; \nqueryState = CLOSED ; \nreturn sqlException ; \n} \n} \n"}
{"1349": "public class DbQueryBase { \nprotected int executeUpdate ( final boolean closeQuery ) { \nstart = System . currentTimeMillis ( ) ; \ninit ( ) ; \nfinal int result ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Executing update: \" + getQueryString ( ) ) ; \n} \ntry { \nif ( ! ( preparedStatement == null ) ) { \nresult = preparedStatement . executeUpdate ( ) ; \n} \nelse { \nif ( ! ( generatedColumns != null ) ) { \nresult = statement . executeUpdate ( query . sql ) ; \n} \nelse { \nif ( ! ( generatedColumns . length == 0 ) ) { \nresult = statement . executeUpdate ( query . sql , generatedColumns ) ; \n} \nelse { \nresult = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; \n} \n} \n} \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Query execution failed\" , sex ) ; \n} \nif ( closeQuery ) { \nclose ( ) ; \n} \nelapsed = System . currentTimeMillis ( ) - start ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"execution time: \" + elapsed + \"ms\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"1350": "public class DbQueryBase { \nprotected long executeCount ( final boolean close ) { \nstart = System . currentTimeMillis ( ) ; \ninit ( ) ; \nResultSet rs = null ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Executing prepared count: \" + getQueryString ( ) ) ; \n} \ntry { \nif ( ! ( preparedStatement == null ) ) { \nrs = preparedStatement . executeQuery ( ) ; \n} \nelse { \nrs = statement . executeQuery ( query . sql ) ; \n} \nfinal long firstLong = DbUtil . getFirstLong ( rs ) ; \nelapsed = System . currentTimeMillis ( ) - start ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"execution time: \" + elapsed + \"ms\" ) ; \n} \nreturn firstLong ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Count query failed\" , sex ) ; \n} \nfinally { \nDbUtil . close ( rs ) ; \nif ( close ) { \nclose ( ) ; \n} \n} \n} \n} \n"}
{"1361": "public class JsonSerializer { \npublic JsonSerializer excludeTypes ( final Class ... types ) { \nif ( ! ( excludedTypes == null ) ) { \nexcludedTypes = ArraysUtil . join ( excludedTypes , types ) ; \n} \nelse { \nexcludedTypes = types ; \n} \nreturn this ; \n} \n} \n"}
{"1371": "public class DefaultResultSetMapper { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected Object readColumnValue ( final int colNdx , final Class destinationType , final Class < ? extends SqlType > sqlTypeClass , final int columnDbSqlType ) { \nif ( colNdx != cachedColumnNdx ) { \ntry { \nSqlType sqlType ; \nif ( ! ( sqlTypeClass != null ) ) { \nsqlType = SqlTypeManager . get ( ) . lookup ( destinationType ) ; \n} \nelse { \nsqlType = SqlTypeManager . get ( ) . lookupSqlType ( sqlTypeClass ) ; \n} \nif ( ! ( sqlType != null ) ) { \ncachedColumnValue = resultSet . getObject ( colNdx + 1 ) ; \ncachedColumnValue = TypeConverterManager . get ( ) . convertType ( cachedColumnValue , destinationType ) ; \n} \nelse { \ncachedColumnValue = sqlType . readValue ( resultSet , colNdx + 1 , destinationType , columnDbSqlType ) ; \n} \n} \ncatch ( SQLException sex ) { \nthrow new DbOomException ( dbOomQuery , \"Invalid value for column #\" + ( colNdx + 1 ) , sex ) ; \n} \ncachedColumnNdx = colNdx ; \n} \nreturn cachedColumnValue ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) { \nObject object = result [ i ] ; \nif ( object == null ) { \ncontinue ; \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \ncontinue ; \n} \nObject key ; \nif ( ! ( ded . hasIdColumn ( ) ) ) { \nkey = object ; \n} \nelse { \nkey = ded . getKeyValue ( object ) ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( ! ( cachedObject == null ) ) { \nresult [ i ] = cachedObject ; \n} \nelse { \nentitiesCache . put ( key , object ) ; \n} \n} \n} \n} \n"}
{"1373": "public class ProviderResolver { \npublic ProviderDefinition [ ] resolve ( final Class type , final String name ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( ) ; \nList < ProviderDefinition > list = new ArrayList < > ( ) ; \nfor ( MethodDescriptor methodDescriptor : methods ) { \nMethod method = methodDescriptor . getMethod ( ) ; \nPetiteProvider petiteProvider = method . getAnnotation ( PetiteProvider . class ) ; \nif ( petiteProvider == null ) { \ncontinue ; \n} \nString providerName = petiteProvider . value ( ) ; \nif ( StringUtil . isBlank ( providerName ) ) { \nproviderName = method . getName ( ) ; \nif ( providerName . endsWith ( \"Provider\" ) ) { \nproviderName = StringUtil . substring ( providerName , 0 , - 8 ) ; \n} \n} \nProviderDefinition providerDefinition ; \nif ( ! ( Modifier . isStatic ( method . getModifiers ( ) ) ) ) { \nproviderDefinition = new ProviderDefinition ( providerName , name , method ) ; \n} \nelse { \nproviderDefinition = new ProviderDefinition ( providerName , method ) ; \n} \nlist . add ( providerDefinition ) ; \n} \nProviderDefinition [ ] providers ; \nif ( ! ( list . isEmpty ( ) ) ) { \nproviders = list . toArray ( new ProviderDefinition [ 0 ] ) ; \n} \nelse { \nproviders = ProviderDefinition . EMPTY ; \n} \nreturn providers ; \n} \n} \n"}
{"1376": "public class ServletDispatcherActionResult { \n@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { \nHttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; \nHttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; \nRequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; \nif ( dispatcher == null ) { \nresponse . sendError ( SC_NOT_FOUND , \"Result not found: \" + target ) ; \nreturn ; \n} \nif ( ! ( DispatcherUtil . isPageIncluded ( request , response ) ) ) { \ndispatcher . forward ( request , response ) ; \n} \nelse { \ndispatcher . include ( request , response ) ; \n} \n} \n} \n"}
{"1380": "public class BufferResponseWrapper { \npublic void writeContentToResponse ( final char [ ] content ) throws IOException { \nif ( buffer == null ) { \nreturn ; \n} \nif ( ! ( buffer . isUsingStream ( ) ) ) { \nWriter out = getResponse ( ) . getWriter ( ) ; \nout . write ( content ) ; \nout . flush ( ) ; \n} \nelse { \nServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; \nString encoding = getContentTypeEncoding ( ) ; \nif ( ! ( encoding == null ) ) { \noutputStream . write ( CharUtil . toByteArray ( content , encoding ) ) ; \n} \nelse { \noutputStream . write ( CharUtil . toByteArray ( content ) ) ; \n} \noutputStream . flush ( ) ; \n} \n} \n} \n"}
{"1381": "public class BufferResponseWrapper { \n@ Override public void setContentType ( final String type ) { \nsuper . setContentType ( type ) ; \ncontentTypeResolver = new ContentTypeHeaderResolver ( type ) ; \nif ( ! ( bufferContentType ( type , contentTypeResolver . getMimeType ( ) , contentTypeResolver . getEncoding ( ) ) ) ) { \ndisableBuffering ( ) ; \n} \nelse { \nenableBuffering ( ) ; \n} \n} \n} \n"}
{"1382": "public class BufferResponseWrapper { \npublic void print ( final String string ) throws IOException { \nif ( isBufferStreamBased ( ) ) { \nString encoding = getContentTypeEncoding ( ) ; \nbyte [ ] bytes ; \nif ( ! ( encoding == null ) ) { \nbytes = string . getBytes ( encoding ) ; \n} \nelse { \nbytes = string . getBytes ( ) ; \n} \nbuffer . getOutputStream ( ) . write ( bytes ) ; \nreturn ; \n} \nbuffer . getWriter ( ) . write ( string ) ; \n} \n} \n"}
{"1394": "public class FileUtil { \npublic static void cleanDir ( final File destDir ) throws IOException { \ncheckExists ( destDir ) ; \ncheckIsDirectory ( destDir ) ; \nFile [ ] files = destDir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IOException ( \"Failed to list contents of: \" + destDir ) ; \n} \nIOException exception = null ; \nfor ( File file : files ) { \ntry { \nif ( ! ( file . isDirectory ( ) ) ) { \nfile . delete ( ) ; \n} \nelse { \ndeleteDir ( file ) ; \n} \n} \ncatch ( IOException ioex ) { \nexception = ioex ; \ncontinue ; \n} \n} \nif ( exception != null ) { \nthrow exception ; \n} \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( ! ( option . shortName != null ) ) if ( option . longName != null ) { \nusage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \nelse { \nusage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \n} \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \nSystem . out . println ( usage ) ; \n} \n} \n"}
{"1413": "public class LoopIterator { \npublic boolean next ( ) { \nif ( ! looping ) { \nreturn false ; \n} \nif ( last ) { \nreturn false ; \n} \nif ( ! ( count == 0 ) ) { \nvalue += step ; \nfirst = false ; \n} \nelse { \nvalue = start ; \nfirst = true ; \n} \ncount ++ ; \nlast = isLastIteration ( value + step ) ; \nreturn true ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( ! ( header . isFile ) ) { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \nelse { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) { \nif ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( ! ( escapesCount > 0 ) ) { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nelse { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nint end ; \nif ( ! ( template . startsWith ( MACRO_TABLE , mark ) ) ) if ( ! ( template . startsWith ( MACRO_COLUMN , mark ) ) ) if ( ! ( template . startsWith ( MACRO_MATCH , mark ) ) ) if ( ! ( template . startsWith ( MACRO_VALUE , mark ) ) ) { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nelse { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1431": "public class HttpUtil { \npublic static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { \nif ( queryMap . isEmpty ( ) ) { \nreturn StringPool . EMPTY ; \n} \nint queryMapSize = queryMap . size ( ) ; \nStringBand query = new StringBand ( queryMapSize * 4 ) ; \nint count = 0 ; \nfor ( Map . Entry < String , ? > entry : queryMap ) { \nString key = entry . getKey ( ) ; \nkey = URLCoder . encodeQueryParam ( key , encoding ) ; \nObject value = entry . getValue ( ) ; \nif ( ! ( value == null ) ) { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount ++ ; \nquery . append ( '=' ) ; \nString valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; \nquery . append ( valueString ) ; \n} \nelse { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount ++ ; \n} \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) { \nreturn queryMap ; \n} \nint lastNdx = 0 ; \nwhile ( lastNdx < query . length ( ) ) { \nint ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) { \nndx = query . length ( ) ; \n} \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ! ( ndx == - 1 ) ) { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) { \nname = URLDecoder . decodeQuery ( name ) ; \n} \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) { \nvalue = URLDecoder . decodeQuery ( value ) ; \n} \nqueryMap . add ( name , value ) ; \n} \nelse { \nqueryMap . add ( paramAndValue , null ) ; \n} \nlastNdx += paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) { \nreturn HttpBase . HEADER_ETAG ; \n} \nif ( headerName . equals ( \"www-authenticate\" ) ) { \nreturn \"WWW-Authenticate\" ; \n} \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \nfor ( int i = 0 ; \ni < name . length ; \ni ++ ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \ncontinue ; \n} \nif ( ! ( capitalize ) ) { \nname [ i ] = Character . toLowerCase ( c ) ; \n} \nelse { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( ! ( insideString ) ) if ( ! ( c == '\\\"' ) ) if ( ! ( c == '{' ) ) if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nelse { \nbracketCount ++ ; \n} \nelse { \ninsideString = true ; \n} \nelse { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1445": "public class JsonParser { \nprotected String parseString ( ) { \nchar quote = '\\\"' ; \nif ( ! ( looseMode ) ) { \nconsume ( quote ) ; \n} \nelse { \nquote = consumeOneOf ( '\\\"' , '\\'' ) ; \nif ( quote == 0 ) { \nreturn parseUnquotedStringContent ( ) ; \n} \n} \nreturn parseStringContent ( quote ) ; \n} \n} \n"}
{"1446": "public class JsonParser { \nprotected String parseStringContent ( final char quote ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nreturn new String ( input , startNdx , ndx - 1 - startNdx ) ; \n} \nif ( c == '\\\\' ) { \nbreak ; \n} \nndx ++ ; \n} \ntextLen = ndx - startNdx ; \ngrowEmpty ( ) ; \nSystem . arraycopy ( input , startNdx , text , 0 , textLen ) ; \nwhile ( true ) { \nchar c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nfinal String str = new String ( text , 0 , textLen ) ; \ntextLen = 0 ; \nreturn str ; \n} \nif ( c == '\\\\' ) { \nndx ++ ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase '\\\"' : c = '\\\"' ; \nbreak ; \ncase '\\\\' : c = '\\\\' ; \nbreak ; \ncase '/' : c = '/' ; \nbreak ; \ncase 'b' : c = '\\b' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'u' : ndx ++ ; \nc = parseUnicode ( ) ; \nbreak ; \ndefault : if ( ! ( looseMode ) ) { \nsyntaxError ( \"Invalid escape char: \" + c ) ; \n} \nelse { \nif ( c != '\\'' ) { \nc = '\\\\' ; \nndx -- ; \n} \n} \n} \n} \ntext [ textLen ] = c ; \ntextLen ++ ; \ngrowAndCopy ( ) ; \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( ! ( c == '.' ) ) if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nelse { \nisDouble = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( ! ( isExp ) ) { \nif ( ! ( value . length ( ) >= 19 ) ) { \nlongNumber = Long . parseLong ( value ) ; \n} \nelse { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \n} \nelse { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1452": "public class ProxettaWrapperClassBuilder { \nprotected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { \nint access = msign . getAccessFlags ( ) ; \naccess &= ~ ACC_ABSTRACT ; \naccess &= ~ ACC_NATIVE ; \nMethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; \nmv . visitCode ( ) ; \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; \nloadVirtualMethodArguments ( mv , msign ) ; \nif ( ! ( wd . wrapInterface ) ) { \nmv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; \n} \nelse { \nmv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; \n} \nProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; \nvisitReturn ( mv , msign , true ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \n} \n} \n"}
{"1453": "public class MethodSignatureVisitor { \nprivate String resolveRawTypeName ( String typeName ) { \nif ( typeName == null ) { \nreturn null ; \n} \nboolean isArray = typeName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ; \nif ( isArray ) { \ntypeName = typeName . substring ( 1 ) ; \n} \nString rawTypeName ; \nif ( ! ( generics . containsKey ( typeName ) ) ) { \nrawTypeName = declaredTypeGeneric . getOrDefault ( typeName , typeName ) ; \n} \nelse { \nrawTypeName = generics . get ( typeName ) ; \n} \nif ( isArray ) { \nrawTypeName = '[' + rawTypeName ; \n} \nreturn rawTypeName ; \n} \n} \n"}
{"1454": "public class ReferencesResolver { \npublic BeanReferences resolveReferenceFromValue ( final PropertyDescriptor propertyDescriptor , final String refName ) { \nBeanReferences references ; \nif ( ! ( refName == null || refName . isEmpty ( ) ) ) { \nreferences = BeanReferences . of ( refName ) ; \n} \nelse { \nreferences = buildDefaultReference ( propertyDescriptor ) ; \n} \nreferences = references . removeDuplicateNames ( ) ; \nreturn references ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( ! ( petiteInject != null ) ) { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nelse { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nint parametersWithAnnotationCount = 0 ; \nfor ( int i = 0 ; \ni < parameters . length ; \ni ++ ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) { \ncontinue ; \n} \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) { \nreferences [ i ] = BeanReferences . of ( annotationValue ) ; \n} \nparametersWithAnnotationCount ++ ; \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) { \nreturn null ; \n} \nif ( parametersWithAnnotationCount != parameters . length ) { \nthrow new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1467": "public class ClassUtil { \npublic static void forceAccess ( final AccessibleObject accObject ) { \ntry { \nif ( ! ( System . getSecurityManager ( ) == null ) ) { \nAccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { \naccObject . setAccessible ( true ) ; \nreturn null ; \n} \n) ; \n} \nelse accObject . setAccessible ( true ) ; \n} \ncatch ( SecurityException sex ) { \n} \n} \n} \n"}
{"1489": "public class MemoryFileUpload { \n@ Override public void processStream ( ) throws IOException { \nFastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; \nsize = 0 ; \nif ( ! ( maxFileSize == - 1 ) ) { \nsize += input . copyMax ( out , maxFileSize + 1 ) ; \nif ( size > maxFileSize ) { \nfileTooBig = true ; \nvalid = false ; \ninput . skipToBoundary ( ) ; \nreturn ; \n} \n} \nelse { \nsize += input . copyAll ( out ) ; \n} \ndata = out . toByteArray ( ) ; \nsize = data . length ; \nvalid = true ; \n} \n} \n"}
{"1491": "public class DbListIterator { \nprivate boolean moveToNext ( ) { \nif ( last ) { \nif ( ! ( closeOnEnd ) ) { \nquery . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; \n} \nelse { \nquery . close ( ) ; \n} \nreturn false ; \n} \nwhile ( true ) { \nif ( ! resultSetMapper . next ( ) ) { \nlast = true ; \nreturn entityAwareMode ; \n} \nObject [ ] objects = resultSetMapper . parseObjects ( types ) ; \nObject row = query . resolveRowResults ( objects ) ; \nnewElement = ( T ) row ; \nif ( entityAwareMode ) { \nif ( count == 0 && previousElement == null ) { \npreviousElement = newElement ; \ncontinue ; \n} \nif ( previousElement != null && newElement != null ) { \nboolean equals ; \nif ( ! ( newElement . getClass ( ) . isArray ( ) ) ) { \nequals = previousElement . equals ( newElement ) ; \n} \nelse { \nequals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; \n} \nif ( equals ) { \ncontinue ; \n} \n} \n} \nbreak ; \n} \nreturn true ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ! ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) ) { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1504": "public class MethodWriter { \nprivate void endCurrentBasicBlockWithNoSuccessor ( ) { \nif ( ! ( compute == COMPUTE_ALL_FRAMES ) ) if ( compute == COMPUTE_MAX_STACK_AND_LOCAL ) { \ncurrentBasicBlock . outputStackMax = ( short ) maxRelativeStackSize ; \ncurrentBasicBlock = null ; \n} \nelse { \nLabel nextBasicBlock = new Label ( ) ; \nnextBasicBlock . frame = new Frame ( nextBasicBlock ) ; \nnextBasicBlock . resolve ( code . data , code . length ) ; \nlastBasicBlock . nextBasicBlock = nextBasicBlock ; \nlastBasicBlock = nextBasicBlock ; \ncurrentBasicBlock = null ; \n} \n} \n} \n"}
{"1510": "public class BeanVisitor { \nprotected String [ ] getAllBeanPropertyNames ( final Class type , final boolean declared ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; \nArrayList < String > names = new ArrayList < > ( propertyDescriptors . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { \nMethodDescriptor getter = propertyDescriptor . getReadMethodDescriptor ( ) ; \nif ( ! ( getter != null ) ) if ( includeFields ) { \nFieldDescriptor field = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( field != null ) { \nif ( field . matchDeclared ( declared ) ) { \nnames . add ( field . getName ( ) ) ; \n} \n} \n} \nelse { \nif ( getter . matchDeclared ( declared ) ) { \nnames . add ( propertyDescriptor . getName ( ) ) ; \n} \n} \n} \nreturn names . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1511": "public class BeanVisitor { \npublic void visit ( ) { \nString [ ] properties = resolveProperties ( source , declared ) ; \nfor ( String name : properties ) { \nif ( name == null ) { \ncontinue ; \n} \nif ( ! rules . match ( name , blacklist ) ) { \ncontinue ; \n} \nObject value ; \nString propertyName = name ; \nif ( isSourceMap ) { \npropertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \n} \nif ( ! ( declared ) ) { \nvalue = BeanUtil . pojo . getProperty ( source , propertyName ) ; \n} \nelse { \nvalue = BeanUtil . declared . getProperty ( source , propertyName ) ; \n} \nif ( value == null && ignoreNullValues ) { \ncontinue ; \n} \nif ( value instanceof String && StringUtil . isEmpty ( ( String ) value ) ) { \ncontinue ; \n} \nvisitProperty ( name , value ) ; \n} \n} \n} \n"}
{"1513": "public class MethodResolver { \npublic MethodInjectionPoint [ ] resolve ( final Class type ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nList < MethodInjectionPoint > list = new ArrayList < > ( ) ; \nMethodDescriptor [ ] allMethods = cd . getAllMethodDescriptors ( ) ; \nfor ( MethodDescriptor methodDescriptor : allMethods ) { \nMethod method = methodDescriptor . getMethod ( ) ; \nif ( ClassUtil . isBeanPropertySetter ( method ) ) { \ncontinue ; \n} \nif ( method . getParameterTypes ( ) . length == 0 ) { \ncontinue ; \n} \nBeanReferences [ ] references = referencesResolver . readAllReferencesFromAnnotation ( method ) ; \nif ( references != null ) { \nMethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint ( method , references ) ; \nlist . add ( methodInjectionPoint ) ; \n} \n} \nfinal MethodInjectionPoint [ ] methodInjectionPoints ; \nif ( ! ( list . isEmpty ( ) ) ) { \nmethodInjectionPoints = list . toArray ( new MethodInjectionPoint [ 0 ] ) ; \n} \nelse { \nmethodInjectionPoints = MethodInjectionPoint . EMPTY ; \n} \nreturn methodInjectionPoints ; \n} \n} \n"}
{"1520": "public class HtmlStaplerBundlesManager { \nprotected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { \nfinal File bundleFile = createBundleFile ( bundleId ) ; \nif ( bundleFile . exists ( ) ) { \nreturn ; \n} \nStringBand sb = new StringBand ( sources . size ( ) * 2 ) ; \nfor ( String src : sources ) { \nif ( sb . length ( ) != 0 ) { \nsb . append ( StringPool . NEWLINE ) ; \n} \nString content ; \nif ( ! ( isExternalResource ( src ) ) ) { \nif ( ! ( ! downloadLocal ) ) { \nString localUrl = localAddressAndPort ; \nif ( ! ( src . startsWith ( StringPool . SLASH ) ) ) { \nlocalUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; \n} \nelse { \nlocalUrl += contextPath + src ; \n} \ncontent = downloadString ( localUrl ) ; \n} \nelse { \nString localFile = webRoot ; \nif ( src . startsWith ( contextPath + '/' ) ) { \nsrc = src . substring ( contextPath . length ( ) ) ; \n} \nif ( ! ( src . startsWith ( StringPool . SLASH ) ) ) { \nlocalFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; \n} \nelse { \nlocalFile += src ; \n} \nint qmndx = localFile . indexOf ( '?' ) ; \nif ( qmndx != - 1 ) { \nlocalFile = localFile . substring ( 0 , qmndx ) ; \n} \ntry { \ncontent = FileUtil . readString ( localFile ) ; \n} \ncatch ( IOException ioex ) { \nif ( notFoundExceptionEnabled ) { \nthrow ioex ; \n} \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( ioex . getMessage ( ) ) ; \n} \ncontent = null ; \n} \n} \nif ( content != null ) { \nif ( isCssResource ( src ) ) { \ncontent = fixCssRelativeUrls ( content , src ) ; \n} \n} \n} \nelse { \ncontent = downloadString ( src ) ; \n} \nif ( content != null ) { \ncontent = onResourceContent ( content ) ; \nsb . append ( content ) ; \n} \n} \nFileUtil . writeString ( bundleFile , sb . toString ( ) ) ; \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"Bundle created: \" + bundleId ) ; \n} \n} \n} \n"}
{"1522": "public class HtmlStaplerBundlesManager { \nprotected String fixCssRelativeUrls ( final String content , final String src ) { \nfinal String path = FileNameUtil . getPath ( src ) ; \nfinal Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; \nfinal StringBuilder sb = new StringBuilder ( content . length ( ) ) ; \nint start = 0 ; \nwhile ( matcher . find ( ) ) { \nsb . append ( content , start , matcher . start ( ) ) ; \nfinal String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , \"'\\\"\" ) ; \nfinal String url ; \nif ( ! ( matchedUrl . startsWith ( \"https://\" ) || matchedUrl . startsWith ( \"http://\" ) || matchedUrl . startsWith ( \"data:\" ) ) ) { \nurl = fixRelativeUrl ( matchedUrl , path ) ; \n} \nelse { \nurl = \"url('\" + matchedUrl + \"')\" ; \n} \nsb . append ( url ) ; \nstart = matcher . end ( ) ; \n} \nsb . append ( content . substring ( start ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1528": "public class SetResolver { \npublic SetInjectionPoint [ ] resolve ( final Class type , final boolean autowire ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nList < SetInjectionPoint > list = new ArrayList < > ( ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) { \ncontinue ; \n} \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ! ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { \ncontinue ; \n} \nMethodDescriptor writeMethodDescriptor = propertyDescriptor . getWriteMethodDescriptor ( ) ; \nFieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; \nPetiteInject ref = null ; \nif ( writeMethodDescriptor != null ) { \nref = writeMethodDescriptor . getMethod ( ) . getAnnotation ( PetiteInject . class ) ; \n} \nif ( ref == null && fieldDescriptor != null ) { \nref = fieldDescriptor . getField ( ) . getAnnotation ( PetiteInject . class ) ; \n} \nif ( ( ! autowire ) && ( ref == null ) ) { \ncontinue ; \n} \nlist . add ( new SetInjectionPoint ( propertyDescriptor ) ) ; \n} \nSetInjectionPoint [ ] fields ; \nif ( ! ( list . isEmpty ( ) ) ) { \nfields = list . toArray ( new SetInjectionPoint [ 0 ] ) ; \n} \nelse { \nfields = SetInjectionPoint . EMPTY ; \n} \nreturn fields ; \n} \n} \n"}
{"1544": "public class AnnotationTxAdviceManager { \npublic synchronized JtxTransactionMode getTxMode ( final Class type , final String methodName , final Class [ ] methodArgTypes , final String unique ) { \nString signature = type . getName ( ) + '#' + methodName + '%' + unique ; \nJtxTransactionMode txMode = txmap . get ( signature ) ; \nif ( txMode == null ) { \nif ( ! txmap . containsKey ( signature ) ) { \nfinal Method m ; \ntry { \nm = type . getMethod ( methodName , methodArgTypes ) ; \n} \ncatch ( NoSuchMethodException nsmex ) { \nthrow new ProxettaException ( nsmex ) ; \n} \nfinal TransactionAnnotationValues txAnn = readTransactionAnnotation ( m ) ; \nif ( ! ( txAnn != null ) ) { \ntxMode = defaultTransactionMode ; \n} \nelse { \ntxMode = new JtxTransactionMode ( txAnn . propagation ( ) , txAnn . isolation ( ) , txAnn . readOnly ( ) , txAnn . timeout ( ) ) ; \n} \ntxmap . put ( signature , txMode ) ; \n} \n} \nreturn txMode ; \n} \n} \n"}
{"1558": "public class Node { \npublic void insertAfter ( final Node newChild , final Node refChild ) { \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( ! ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) ) { \nrefChild . parentNode . insertChild ( newChild , siblingIndex ) ; \n} \nelse { \nrefChild . parentNode . addChild ( newChild ) ; \n} \n} \n} \n"}
{"1559": "public class Node { \npublic void insertAfter ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) { \nreturn ; \n} \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( ! ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) ) { \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \nelse { \nrefChild . parentNode . addChild ( newChilds ) ; \n} \n} \n} \n"}
{"1570": "public class Node { \npublic String getHtml ( ) { \nLagartoDomBuilderConfig lagartoDomBuilderConfig ; \nif ( ! ( ownerDocument == null ) ) { \nlagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; \n} \nelse { \nlagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; \n} \nLagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; \nreturn lagartoHtmlRenderer . toHtml ( this , new StringBuilder ( ) ) ; \n} \n} \n"}
{"1571": "public class Node { \npublic String getInnerHtml ( ) { \nLagartoDomBuilderConfig lagartoDomBuilderConfig ; \nif ( ! ( ownerDocument == null ) ) { \nlagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; \n} \nelse { \nlagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; \n} \nLagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; \nreturn lagartoHtmlRenderer . toInnerHtml ( this , new StringBuilder ( ) ) ; \n} \n} \n"}
{"1575": "public class DecoratorTagVisitor { \nprotected void onIdAttrStart ( final Tag tag ) { \nString id = tag . getId ( ) . toString ( ) . substring ( 7 ) ; \nString tagName ; \nString idName ; \nint dashIndex = id . indexOf ( '-' ) ; \nif ( ! ( dashIndex == - 1 ) ) { \ntagName = id . substring ( 0 , dashIndex ) ; \nidName = id . substring ( dashIndex + 1 ) ; \n} \nelse { \ntagName = id ; \nidName = null ; \n} \nif ( tag . getType ( ) == TagType . SELF_CLOSING ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \ndefineDecoraTag ( ) ; \nreturn ; \n} \nif ( tag . getType ( ) == TagType . START ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \nclosingTagName = tag . getName ( ) . toString ( ) ; \nclosingTagDeepLevel = tag . getDeepLevel ( ) ; \n} \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \nfor ( int i = 0 ; \ni < mappings . length ; \ni ++ ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( ! ( actionPath . equals ( mapping ) ) ) { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nelse { \nfound = true ; \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( int i = 0 ; \ni < methodParams . length ; \ni ++ ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( ! ( methodParam . annotationType ( ) == null ) ) if ( ! ( methodParam . annotationType ( ) == Out . class ) ) { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1589": "public class Targets { \n@ SuppressWarnings ( { \n\"unchecked\" , \"NullArgumentToVariableArgMethod\" } \n) protected Object createActionMethodArgument ( final Class type , final Object action ) { \ntry { \nif ( ! ( type . getEnclosingClass ( ) == null || Modifier . isStatic ( type . getModifiers ( ) ) ) ) { \nConstructor ctor = type . getDeclaredConstructor ( type . getDeclaringClass ( ) ) ; \nctor . setAccessible ( true ) ; \nreturn ctor . newInstance ( action ) ; \n} \nelse { \nreturn ClassUtil . newInstance ( type ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow new MadvocException ( ex ) ; \n} \n} \n} \n"}
{"1595": "public class AbstractTemplateViewActionResult { \nprotected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { \nString resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; \nResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; \nString actionPath = resultPath . path ( ) ; \nString path = actionPath ; \nString value = resultPath . value ( ) ; \nif ( StringUtil . isEmpty ( value ) ) { \nvalue = null ; \n} \nString target ; \nwhile ( true ) { \nif ( value != null ) { \nif ( ! ( path == null ) ) { \ntarget = path + '.' + value ; \n} \nelse { \nint lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; \nif ( ! ( lastSlashNdx != - 1 ) ) { \ntarget = '/' + value ; \n} \nelse { \ntarget = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; \n} \n} \ntarget = locateTarget ( actionRequest , target ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path != null ) { \ntarget = locateTarget ( actionRequest , path ) ; \nif ( target != null ) { \nbreak ; \n} \n} \nif ( path == null ) { \nreturn null ; \n} \nint dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; \nif ( ! ( dotNdx == - 1 ) ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \nelse { \npath = null ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1600": "public class PropertyResolver { \npublic PropertyInjectionPoint [ ] resolve ( Class type , final boolean autowire ) { \nfinal List < PropertyInjectionPoint > list = new ArrayList < > ( ) ; \nfinal Set < String > usedPropertyNames = new HashSet < > ( ) ; \nwhile ( type != Object . class ) { \nfinal ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nfinal PropertyDescriptor [ ] allPropertyDescriptors = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allPropertyDescriptors ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) { \ncontinue ; \n} \nif ( usedPropertyNames . contains ( propertyDescriptor . getName ( ) ) ) { \ncontinue ; \n} \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { \ncontinue ; \n} \nBeanReferences reference = referencesResolver . readReferenceFromAnnotation ( propertyDescriptor ) ; \nif ( reference == null ) { \nif ( ! ( ! autowire ) ) { \nreference = referencesResolver . buildDefaultReference ( propertyDescriptor ) ; \n} \nelse { \ncontinue ; \n} \n} \nlist . add ( new PropertyInjectionPoint ( propertyDescriptor , reference ) ) ; \nusedPropertyNames . add ( propertyDescriptor . getName ( ) ) ; \n} \ntype = type . getSuperclass ( ) ; \n} \nfinal PropertyInjectionPoint [ ] fields ; \nif ( ! ( list . isEmpty ( ) ) ) { \nfields = list . toArray ( new PropertyInjectionPoint [ 0 ] ) ; \n} \nelse { \nfields = PropertyInjectionPoint . EMPTY ; \n} \nreturn fields ; \n} \n} \n"}
{"1612": "public class Frame { \nstatic int getAbstractTypeFromApiFormat ( final SymbolTable symbolTable , final Object type ) { \nif ( ! ( type instanceof Integer ) ) if ( ! ( type instanceof String ) ) { \nreturn UNINITIALIZED_KIND | symbolTable . addUninitializedType ( \"\" , ( ( Label ) type ) . bytecodeOffset ) ; \n} \nelse { \nString descriptor = Type . getObjectType ( ( String ) type ) . getDescriptor ( ) ; \nreturn getAbstractTypeFromDescriptor ( symbolTable , descriptor , 0 ) ; \n} \nelse { \nreturn CONSTANT_KIND | ( ( Integer ) type ) . intValue ( ) ; \n} \n} \n} \n"}
{"1615": "public class Frame { \nprivate int getLocal ( final int localIndex ) { \nif ( ! ( outputLocals == null || localIndex >= outputLocals . length ) ) { \nint abstractType = outputLocals [ localIndex ] ; \nif ( abstractType == 0 ) { \nabstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; \n} \nreturn abstractType ; \n} \nelse { \nreturn LOCAL_KIND | localIndex ; \n} \n} \n} \n"}
{"1619": "public class Frame { \nprivate void pop ( final int elements ) { \nif ( ! ( outputStackTop >= elements ) ) { \noutputStackStart -= elements - outputStackTop ; \noutputStackTop = 0 ; \n} \nelse { \noutputStackTop -= elements ; \n} \n} \n} \n"}
{"1620": "public class Frame { \nprivate void pop ( final String descriptor ) { \nchar firstDescriptorChar = descriptor . charAt ( 0 ) ; \nif ( ! ( firstDescriptorChar == '(' ) ) if ( ! ( firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ) ) { \npop ( 1 ) ; \n} \nelse { \npop ( 2 ) ; \n} \nelse { \npop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; \n} \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( int i = 0 ; \ni < initializationCount ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( ! ( kind == LOCAL_KIND ) ) if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nelse { \ninitializedType = dim + inputLocals [ value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( ! ( abstractType == UNINITIALIZED_THIS ) ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( ! ( arrayDimensions == 0 ) ) { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( arrayDimensions -- > 0 ) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ! ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) ) { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \nelse { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n} \n"}
{"1646": "public class Props { \npublic Props load ( final File file ) throws IOException { \nfinal String extension = FileNameUtil . getExtension ( file . getAbsolutePath ( ) ) ; \nfinal String data ; \nif ( ! ( extension . equalsIgnoreCase ( \"properties\" ) ) ) { \ndata = FileUtil . readString ( file ) ; \n} \nelse { \ndata = FileUtil . readString ( file , StringPool . ISO_8859_1 ) ; \n} \nparse ( data ) ; \nreturn this ; \n} \n} \n"}
{"1653": "public class Props { \npublic void setValue ( final String key , final String value , final String profile ) { \nif ( ! ( profile == null ) ) { \ndata . putProfileProperty ( key , value , profile , false ) ; \n} \nelse { \ndata . putBaseProperty ( key , value , false ) ; \n} \ninitialized = false ; \n} \n} \n"}
{"1662": "public class BeanDefinition { \nprotected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { \nif ( ! ( properties == null ) ) { \nproperties = ArraysUtil . append ( properties , pip ) ; \n} \nelse { \nproperties = new PropertyInjectionPoint [ 1 ] ; \nproperties [ 0 ] = pip ; \n} \n} \n} \n"}
{"1663": "public class BeanDefinition { \nprotected void addSetInjectionPoint ( final SetInjectionPoint sip ) { \nif ( ! ( sets == null ) ) { \nsets = ArraysUtil . append ( sets , sip ) ; \n} \nelse { \nsets = new SetInjectionPoint [ 1 ] ; \nsets [ 0 ] = sip ; \n} \n} \n} \n"}
{"1664": "public class BeanDefinition { \nprotected void addMethodInjectionPoint ( final MethodInjectionPoint mip ) { \nif ( ! ( methods == null ) ) { \nmethods = ArraysUtil . append ( methods , mip ) ; \n} \nelse { \nmethods = new MethodInjectionPoint [ 1 ] ; \nmethods [ 0 ] = mip ; \n} \n} \n} \n"}
{"1665": "public class BeanDefinition { \nprotected void addInitMethodPoints ( final InitMethodPoint [ ] methods ) { \nif ( ! ( initMethods == null ) ) { \ninitMethods = ArraysUtil . join ( initMethods , methods ) ; \n} \nelse { \ninitMethods = methods ; \n} \n} \n} \n"}
{"1666": "public class BeanDefinition { \nprotected void addDestroyMethodPoints ( final DestroyMethodPoint [ ] methods ) { \nif ( ! ( destroyMethods == null ) ) { \ndestroyMethods = ArraysUtil . join ( destroyMethods , methods ) ; \n} \nelse { \ndestroyMethods = methods ; \n} \n} \n} \n"}
{"1671": "public class PropertyDescriptor { \npublic Class getType ( ) { \nif ( type == null ) { \nif ( ! ( fieldDescriptor != null ) ) if ( ! ( readMethodDescriptor != null ) ) if ( writeMethodDescriptor != null ) { \ntype = getSetter ( true ) . getSetterRawType ( ) ; \n} \nelse { \ntype = getGetter ( true ) . getGetterRawType ( ) ; \n} \nelse { \ntype = fieldDescriptor . getRawType ( ) ; \n} \n} \nreturn type ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx ++ ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! ( ! nextIsNotWildcard ) ) { \nnextIsNotWildcard = false ; \n} \nelse { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni -- ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1678": "public class ExtendedURLClassLoader { \nprotected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { \nboolean withParent = true ; \nboolean withLoader = true ; \nif ( ! ( parentFirstStrategy ) ) { \nif ( ! ( isMatchingRules ( className , parentOnlyRules ) ) ) if ( isMatchingRules ( className , loaderOnlyRules ) ) { \nwithParent = false ; \n} \nelse { \nwithLoader = false ; \n} \n} \nelse { \nif ( ! ( isMatchingRules ( className , loaderOnlyRules ) ) ) if ( isMatchingRules ( className , parentOnlyRules ) ) { \nwithLoader = false ; \n} \nelse { \nwithParent = false ; \n} \n} \nreturn new Loading ( withParent , withLoader ) ; \n} \n} \n"}
{"1680": "public class ExtendedURLClassLoader { \n@ Override protected synchronized Class < ? > loadClass ( final String className , final boolean resolve ) throws ClassNotFoundException { \nClass < ? > c = findLoadedClass ( className ) ; \nif ( c != null ) { \nif ( resolve ) { \nresolveClass ( c ) ; \n} \nreturn c ; \n} \nLoading loading = resolveLoading ( parentFirst , className ) ; \nif ( ! ( parentFirst ) ) { \nif ( loading . withLoader ) { \ntry { \nc = this . findClass ( className ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \n} \nif ( c == null ) { \nif ( ! ( loading . withParent ) ) { \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \nelse { \nc = parentClassLoader . loadClass ( className ) ; \n} \n} \n} \nelse { \nif ( loading . withParent ) { \ntry { \nc = parentClassLoader . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \n} \nif ( c == null ) { \nif ( ! ( loading . withLoader ) ) { \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \nelse { \nc = this . findClass ( className ) ; \n} \n} \n} \nif ( resolve ) { \nresolveClass ( c ) ; \n} \nreturn c ; \n} \n} \n"}
{"1681": "public class ExtendedURLClassLoader { \n@ Override public URL getResource ( final String resourceName ) { \nURL url = null ; \nLoading loading = resolveResourceLoading ( parentFirst , resourceName ) ; \nif ( ! ( parentFirst ) ) { \nif ( loading . withLoader ) { \nurl = this . findResource ( resourceName ) ; \n} \nif ( url == null ) { \nif ( loading . withParent ) { \nurl = parentClassLoader . getResource ( resourceName ) ; \n} \n} \n} \nelse { \nif ( loading . withParent ) { \nurl = parentClassLoader . getResource ( resourceName ) ; \n} \nif ( url == null ) { \nif ( loading . withLoader ) { \nurl = this . findResource ( resourceName ) ; \n} \n} \n} \nreturn url ; \n} \n} \n"}
{"1683": "public class ScopeDataInspector { \npublic Class < ? extends Annotation > detectAnnotationType ( final Annotation [ ] annotations ) { \nfor ( final Annotation annotation : annotations ) { \nif ( ! ( annotation instanceof In ) ) if ( annotation instanceof Out ) { \nreturn annotation . annotationType ( ) ; \n} \nelse { \nreturn annotation . annotationType ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1684": "public class ScopeDataInspector { \nprotected InjectionPoint buildInjectionPoint ( final String annotationValue , final String propertyName , final Class propertyType , final Class < ? extends MadvocScope > scope ) { \nfinal String value = annotationValue . trim ( ) ; \nfinal String name , targetName ; \nif ( ! ( StringUtil . isNotBlank ( value ) ) ) { \nname = propertyName ; \ntargetName = null ; \n} \nelse { \nname = value ; \ntargetName = propertyName ; \n} \nreturn new InjectionPoint ( propertyType , name , targetName , scopeResolver . defaultOrScopeType ( scope ) ) ; \n} \n} \n"}
{"1689": "public class BeanProperty { \nprivate void loadPropertyDescriptor ( ) { \nif ( updateProperty ) { \nif ( ! ( cd == null ) ) { \npropertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; \n} \nelse { \npropertyDescriptor = null ; \n} \nupdateProperty = false ; \n} \n} \n} \n"}
{"1696": "public class SocketHttpConnectionProvider { \nprotected Socket createSocket ( final String host , final int port , final int connectionTimeout ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , false , false , connectionTimeout ) ; \nif ( ! ( connectionTimeout < 0 ) ) { \nSocket socket = socketFactory . createSocket ( ) ; \nsocket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout ) ; \nreturn socket ; \n} \nelse { \nreturn socketFactory . createSocket ( host , port ) ; \n} \n} \n} \n"}
{"1697": "public class SocketHttpConnectionProvider { \nprotected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; \nfinal Socket socket ; \nif ( ! ( connectionTimeout < 0 ) ) { \nsocket = Sockets . connect ( host , port , connectionTimeout ) ; \n} \nelse { \nsocket = socketFactory . createSocket ( host , port ) ; \n} \nSSLSocket sslSocket ; \nif ( ! ( socket instanceof SSLSocket ) ) { \nif ( ! ( socketFactory instanceof SSLSocketFactory ) ) { \nsslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; \n} \nelse { \nsslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; \n} \n} \nelse { \nsslSocket = ( SSLSocket ) socket ; \n} \nif ( secureEnabledProtocols != null ) { \nfinal String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ',' ) ; \nStringUtil . trimAll ( values ) ; \nsslSocket . setEnabledProtocols ( values ) ; \n} \nif ( verifyHttpsHost ) { \nfinal SSLParameters sslParams = new SSLParameters ( ) ; \nsslParams . setEndpointIdentificationAlgorithm ( \"HTTPS\" ) ; \nsslSocket . setSSLParameters ( sslParams ) ; \n} \nreturn sslSocket ; \n} \n} \n"}
{"1698": "public class SocketHttpConnectionProvider { \nprotected SSLSocketFactory getDefaultSSLSocketFactory ( final boolean trustAllCertificates ) throws IOException { \nif ( ! ( trustAllCertificates ) ) { \nreturn ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ; \n} \nelse { \ntry { \nSSLContext sc = SSLContext . getInstance ( sslProtocol ) ; \nsc . init ( null , TrustManagers . TRUST_ALL_CERTS , new java . security . SecureRandom ( ) ) ; \nreturn sc . getSocketFactory ( ) ; \n} \ncatch ( NoSuchAlgorithmException | KeyManagementException e ) { \nthrow new IOException ( e ) ; \n} \n} \n} \n} \n"}
{"1699": "public class SocketHttpConnectionProvider { \nprotected SocketFactory getSocketFactory ( final ProxyInfo proxy , final boolean ssl , final boolean trustAllCertificates , final int connectionTimeout ) throws IOException { \nswitch ( proxy . getProxyType ( ) ) { \ncase NONE : if ( ! ( ssl ) ) { \nreturn SocketFactory . getDefault ( ) ; \n} \nelse { \nreturn getDefaultSSLSocketFactory ( trustAllCertificates ) ; \n} \ncase HTTP : return new HTTPProxySocketFactory ( proxy , connectionTimeout ) ; \ncase SOCKS4 : return new Socks4ProxySocketFactory ( proxy , connectionTimeout ) ; \ncase SOCKS5 : return new Socks5ProxySocketFactory ( proxy , connectionTimeout ) ; \ndefault : return null ; \n} \n} \n} \n"}
{"1710": "public class NetUtil { \npublic static String resolveIpAddress ( final String hostname ) { \ntry { \nInetAddress netAddress ; \nif ( ! ( hostname == null || hostname . equalsIgnoreCase ( LOCAL_HOST ) ) ) { \nnetAddress = Inet4Address . getByName ( hostname ) ; \n} \nelse { \nnetAddress = InetAddress . getLocalHost ( ) ; \n} \nreturn netAddress . getHostAddress ( ) ; \n} \ncatch ( UnknownHostException ignore ) { \nreturn null ; \n} \n} \n} \n"}
{"1720": "public class Sockets { \npublic static Socket connect ( final String hostname , final int port , final int connectionTimeout ) throws IOException { \nfinal Socket socket = new Socket ( ) ; \nif ( ! ( connectionTimeout <= 0 ) ) { \nsocket . connect ( new InetSocketAddress ( hostname , port ) , connectionTimeout ) ; \n} \nelse { \nsocket . connect ( new InetSocketAddress ( hostname , port ) ) ; \n} \nreturn socket ; \n} \n} \n"}
{"1723": "public class DefaultClassLoaderStrategy { \nprotected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nint ndx = className . indexOf ( '[' ) ; \nint multi = StringUtil . count ( className , '[' ) ; \nString componentTypeName = className . substring ( 0 , ndx ) ; \nClass componentType = loadClass ( componentTypeName , classLoader ) ; \nif ( multi == 1 ) { \nreturn Array . newInstance ( componentType , 0 ) . getClass ( ) ; \n} \nint [ ] multiSizes ; \nif ( ! ( multi == 2 ) ) if ( ! ( multi == 3 ) ) { \nmultiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; \n} \nelse { \nmultiSizes = new int [ ] { \n0 , 0 , 0 } \n; \n} \nelse { \nmultiSizes = new int [ ] { \n0 , 0 } \n; \n} \nreturn Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; \n} \n} \n"}
{"1732": "public class DbOomQuery { \nprotected void resolveColumnDbSqlType ( final Connection connection , final DbEntityColumnDescriptor dec ) { \nif ( dec . dbSqlType != SqlType . DB_SQLTYPE_UNKNOWN ) { \nreturn ; \n} \nResultSet rs = null ; \nDbEntityDescriptor ded = dec . getDbEntityDescriptor ( ) ; \ntry { \nDatabaseMetaData dmd = connection . getMetaData ( ) ; \nrs = dmd . getColumns ( null , ded . getSchemaName ( ) , ded . getTableName ( ) , dec . getColumnName ( ) ) ; \nif ( ! ( rs . next ( ) ) ) { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Column SQL type not available: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) ) ; \n} \n} \nelse { \ndec . dbSqlType = rs . getInt ( \"DATA_TYPE\" ) ; \n} \n} \ncatch ( SQLException sex ) { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Column SQL type not resolved: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) , sex ) ; \n} \n} \nfinally { \nDbUtil . close ( rs ) ; \n} \n} \n} \n"}
{"1733": "public class DbOomQuery { \nprotected String preprocessSql ( String sqlString ) { \nif ( sqlString . charAt ( 0 ) == '{' ) { \nreturn sqlString ; \n} \nif ( ! ( ! CharUtil . isAlpha ( sqlString . charAt ( 0 ) ) ) ) if ( sqlString . indexOf ( ' ' ) != - 1 ) { \nreturn sqlString ; \n} \nelse { \nsqlString = sqlString . substring ( 1 ) ; \n} \nfinal String sqlFromMap = dbOom . queryMap ( ) . getQuery ( sqlString ) ; \nif ( sqlFromMap != null ) { \nsqlString = sqlFromMap . trim ( ) ; \n} \nreturn sqlString ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( int i = 0 ; \ni < generatedColumns . length ; \ni ++ ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! ( ! keyValues . getClass ( ) . isArray ( ) ) ) { \nfor ( int i = 0 ; \ni < properties . length ; \ni ++ ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \nelse { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \n} \n} \n"}
{"1768": "public class EmailFilter { \nprotected void concat ( SearchTerm searchTerm ) { \nif ( nextIsNot ) { \nsearchTerm = new NotTerm ( searchTerm ) ; \nnextIsNot = false ; \n} \nif ( ! ( operatorAnd ) ) { \nor ( searchTerm ) ; \n} \nelse { \nand ( searchTerm ) ; \n} \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) { \nreturn Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) { \nreturn false ; \n} \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( ! ( matches == null ) ) { \nif ( ! ( wildcards ) ) { \nfor ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \n} \nelse { \nresult = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \n} \n} \nelse { \nif ( extensions == null ) { \nreturn true ; \n} \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( extension . length ( ) > 0 ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { \nresult = true ; \n} \n} \n} \nif ( ( result ) && ( excludes != null ) ) { \nif ( ! ( wildcards ) ) { \nfor ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \n} \nelse { \nif ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { \nresult = false ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { \nreturn true ; \n} \nif ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) { \nreturn true ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn true ; \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \nreturn true ; \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( ! ( StringUtil . isEmpty ( profile ) ) ) if ( ! ( profile . charAt ( 0 ) == '-' ) ) if ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \nelse { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse { \nprofile = DEFAULT_PROFILE ; \n} \nif ( ! ( enabledProfiles . contains ( profile ) ) ) { \nif ( must ) { \nreturn false ; \n} \n} \nelse { \nif ( ! b ) { \nreturn false ; \n} \nresult = true ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1784": "public class LagartoParser { \nprotected void _error ( String message ) { \nif ( ! ( config . calculatePosition ) ) { \nmessage = message . concat ( \" [@\" ) . concat ( Integer . toString ( ndx ) ) . concat ( StringPool . RIGHT_SQ_BRACKET ) ; \n} \nelse { \nPosition currentPosition = position ( ndx ) ; \nmessage = message . concat ( StringPool . SPACE ) . concat ( currentPosition . toString ( ) ) ; \n} \nvisitor . error ( message ) ; \n} \n} \n"}
{"1790": "public class EmailAttachmentBuilder { \nprotected EmailAttachmentBuilder setContentIdFromNameIfMissing ( ) { \nif ( contentId == null ) { \nif ( ! ( name != null ) ) { \ncontentId ( NO_NAME ) ; \n} \nelse { \ncontentId ( FileNameUtil . getName ( name ) ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nint offset = startOffset ; \nchar currentChar = signature . charAt ( offset ++ ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : int start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nwhile ( true ) { \ncurrentChar = signature . charAt ( offset ++ ) ; \nif ( ! ( currentChar == '.' || currentChar == ';' ) ) if ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( ! ( inner ) ) { \nsignatureVisitor . visitClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nvisited = true ; \nwhile ( ( currentChar = signature . charAt ( offset ) ) != '>' ) { \nswitch ( currentChar ) { \ncase '*' : ++ offset ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \nelse { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( ! ( inner ) ) { \nsignatureVisitor . visitClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( ! ( c == FIELD_SEPARATOR ) ) if ( c == FIELD_QUOTE ) { \nif ( ! ( inQuotedField ) ) if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \nelse { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \n} \nelse { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \n} \nif ( len > 0 && fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1804": "public class CtorResolver { \npublic CtorInjectionPoint resolve ( final Class type , final boolean useAnnotation ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nCtorDescriptor [ ] allCtors = cd . getAllCtorDescriptors ( ) ; \nConstructor foundedCtor = null ; \nConstructor defaultCtor = null ; \nBeanReferences [ ] references = null ; \nfor ( CtorDescriptor ctorDescriptor : allCtors ) { \nConstructor < ? > ctor = ctorDescriptor . getConstructor ( ) ; \nClass < ? > [ ] paramTypes = ctor . getParameterTypes ( ) ; \nif ( paramTypes . length == 0 ) { \ndefaultCtor = ctor ; \n} \nif ( ! useAnnotation ) { \ncontinue ; \n} \nBeanReferences [ ] ctorReferences = referencesResolver . readAllReferencesFromAnnotation ( ctor ) ; \nif ( ctorReferences == null ) { \ncontinue ; \n} \nif ( foundedCtor != null ) { \nthrow new PetiteException ( \"Two or more constructors are annotated as injection points in the bean: \" + type . getName ( ) ) ; \n} \nfoundedCtor = ctor ; \nreferences = ctorReferences ; \n} \nif ( foundedCtor == null ) { \nif ( ! ( allCtors . length == 1 ) ) { \nfoundedCtor = defaultCtor ; \n} \nelse { \nfoundedCtor = allCtors [ 0 ] . getConstructor ( ) ; \n} \nif ( foundedCtor == null ) { \nreturn CtorInjectionPoint . EMPTY ; \n} \nreferences = referencesResolver . readAllReferencesFromAnnotation ( foundedCtor ) ; \nif ( references == null ) { \nreferences = new BeanReferences [ 0 ] ; \n} \n} \nreturn new CtorInjectionPoint ( foundedCtor , references ) ; \n} \n} \n"}
{"1824": "public class ExclusivePublication { \npublic long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { \nfinal int length = DirectBufferVector . validateAndComputeLength ( vectors ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( ! ( position < limit ) ) { \nnewPosition = backPressureStatus ( position , length ) ; \n} \nelse { \nfinal int result ; \nif ( ! ( length <= maxPayloadLength ) ) { \ncheckMaxMessageLength ( length ) ; \nresult = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; \n} \nelse { \nresult = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; \n} \nnewPosition = newPosition ( result ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1825": "public class ExclusivePublication { \npublic long appendPadding ( final int length ) { \ncheckMaxMessageLength ( length ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( ! ( position < limit ) ) { \nnewPosition = backPressureStatus ( position , length ) ; \n} \nelse { \ncheckPositiveLength ( length ) ; \nfinal int result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; \nnewPosition = newPosition ( result ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1858": "public class PublicationImage { \nvoid addDestination ( final int transportIndex , final ReceiveDestinationUdpTransport transport ) { \nimageConnections = ArrayUtil . ensureCapacity ( imageConnections , transportIndex + 1 ) ; \nif ( ! ( transport . isMulticast ( ) ) ) if ( transport . hasExplicitControl ( ) ) { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . explicitControlAddress ( ) ) ; \n} \nelse { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . udpChannel ( ) . remoteControl ( ) ) ; \n} \n} \n} \n"}
{"1859": "public class PublicationImage { \nint insertPacket ( final int termId , final int termOffset , final UnsafeBuffer buffer , final int length , final int transportIndex , final InetSocketAddress srcAddress ) { \nfinal boolean isHeartbeat = DataHeaderFlyweight . isHeartbeat ( buffer , length ) ; \nfinal long packetPosition = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; \nfinal long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length ; \nif ( ! isFlowControlUnderRun ( packetPosition ) && ! isFlowControlOverRun ( proposedPosition ) ) { \ntrackConnection ( transportIndex , srcAddress , lastPacketTimestampNs ) ; \nif ( ! ( isHeartbeat ) ) { \nfinal UnsafeBuffer termBuffer = termBuffers [ indexByPosition ( packetPosition , positionBitsToShift ) ] ; \nTermRebuilder . insert ( termBuffer , termOffset , buffer , length ) ; \n} \nelse { \nif ( DataHeaderFlyweight . isEndOfStream ( buffer ) && ! isEndOfStream && allEos ( transportIndex ) ) { \nLogBufferDescriptor . endOfStreamPosition ( rawLog . metaData ( ) , proposedPosition ) ; \nisEndOfStream = true ; \n} \nheartbeatsReceived . incrementOrdered ( ) ; \n} \nlastPacketTimestampNs = cachedNanoClock . nanoTime ( ) ; \nhwmPosition . proposeMaxOrdered ( proposedPosition ) ; \n} \nreturn length ; \n} \n} \n"}
{"1866": "public class ExclusiveTermAppender { \npublic int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { \nfinal int frameLength = length + HEADER_LENGTH ; \nfinal int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nfinal UnsafeBuffer termBuffer = this . termBuffer ; \nfinal int termLength = termBuffer . capacity ( ) ; \nint resultingOffset = termOffset + alignedLength ; \nputRawTailOrdered ( termId , resultingOffset ) ; \nif ( ! ( resultingOffset > termLength ) ) { \nheader . write ( termBuffer , termOffset , frameLength , termId ) ; \nframeType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; \nframeLengthOrdered ( termBuffer , termOffset , frameLength ) ; \n} \nelse { \nresultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; \n} \nreturn resultingOffset ; \n} \n} \n"}
{"1867": "public class NetworkPublication { \nfinal int updatePublisherLimit ( ) { \nint workCount = 0 ; \nfinal long senderPosition = this . senderPosition . getVolatile ( ) ; \nif ( ! ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) ) if ( publisherLimit . get ( ) > senderPosition ) { \npublisherLimit . setOrdered ( senderPosition ) ; \n} \nelse { \nlong minConsumerPosition = senderPosition ; \nfor ( final ReadablePosition spyPosition : spyPositions ) { \nminConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; \n} \nfinal long proposedPublisherLimit = minConsumerPosition + termWindowLength ; \nif ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { \ncleanBuffer ( proposedPublisherLimit ) ; \nworkCount = 1 ; \n} \n} \nreturn workCount ; \n} \n} \n"}
{"1879": "public class UdpChannelTransport { \npublic void openDatagramChannel ( final AtomicCounter statusIndicator ) { \ntry { \nsendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \nreceiveDatagramChannel = sendDatagramChannel ; \nif ( ! ( udpChannel . isMulticast ( ) ) ) { \nsendDatagramChannel . bind ( bindAddress ) ; \n} \nelse { \nif ( null != connectAddress ) { \nreceiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \n} \nreceiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; \nreceiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; \nreceiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; \nif ( ! ( udpChannel . isHasMulticastTtl ( ) ) ) if ( context . socketMulticastTtl ( ) != 0 ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \nelse { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \n} \nif ( null != connectAddress ) { \nsendDatagramChannel . connect ( connectAddress ) ; \n} \nif ( 0 != context . socketSndbufLength ( ) ) { \nsendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; \n} \nif ( 0 != context . socketRcvbufLength ( ) ) { \nreceiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; \n} \nsendDatagramChannel . configureBlocking ( false ) ; \nreceiveDatagramChannel . configureBlocking ( false ) ; \n} \ncatch ( final IOException ex ) { \nif ( null != statusIndicator ) { \nstatusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; \n} \nCloseHelper . quietClose ( sendDatagramChannel ) ; \nif ( receiveDatagramChannel != sendDatagramChannel ) { \nCloseHelper . quietClose ( receiveDatagramChannel ) ; \n} \nsendDatagramChannel = null ; \nreceiveDatagramChannel = null ; \nthrow new AeronException ( \"channel error - \" + ex . getMessage ( ) + \" (at \" + ex . getStackTrace ( ) [ 0 ] . toString ( ) + \"): \" + udpChannel . originalUriString ( ) , ex ) ; \n} \n} \n} \n"}
{"1881": "public class UdpChannelTransport { \npublic boolean isValidFrame ( final UnsafeBuffer buffer , final int length ) { \nboolean isFrameValid = true ; \nif ( ! ( frameVersion ( buffer , 0 ) != HeaderFlyweight . CURRENT_VERSION ) ) if ( length < HeaderFlyweight . MIN_HEADER_LENGTH ) { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \nelse { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \nreturn isFrameValid ; \n} \n} \n"}
{"1883": "public class RetransmitHandler { \npublic void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { \nif ( ! isInvalid ( termOffset , termLength ) ) { \nif ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { \nfinal RetransmitAction action = assignRetransmitAction ( ) ; \naction . termId = termId ; \naction . termOffset = termOffset ; \naction . length = Math . min ( length , termLength - termOffset ) ; \nfinal long delay = delayGenerator . generateDelay ( ) ; \nif ( ! ( 0 == delay ) ) { \naction . delay ( delay , nanoClock . nanoTime ( ) ) ; \n} \nelse { \nretransmitSender . resend ( termId , termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nactiveRetransmitsMap . put ( termId , termOffset , action ) ; \n} \n} \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( activeRetransmitsMap . size ( ) > 0 ) { \nfor ( final RetransmitAction action : retransmitActionPool ) { \nif ( ! ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) ) if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \nelse { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"1906": "public class ClusterMember { \npublic static ClusterMember determineMember ( final ClusterMember [ ] clusterMembers , final int memberId , final String memberEndpoints ) { \nClusterMember member = NULL_VALUE != memberId ? ClusterMember . findMember ( clusterMembers , memberId ) : null ; \nif ( ! ( ( null == clusterMembers || 0 == clusterMembers . length ) && null == member ) ) { \nif ( null == member ) { \nthrow new ClusterException ( \"memberId=\" + memberId + \" not found in clusterMembers\" ) ; \n} \nif ( ! \"\" . equals ( memberEndpoints ) ) { \nClusterMember . validateMemberEndpoints ( member , memberEndpoints ) ; \n} \n} \nelse { \nmember = ClusterMember . parseEndpoints ( NULL_VALUE , memberEndpoints ) ; \n} \nreturn member ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( ! ( bytesUsed == 0 ) ) if ( ! ( bytesUsed > maxCapacityHint / 5 ) ) { \nnextSlabSize = bytesUsed ; \n} \nelse { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = initialSlabSize ; \n} \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"1978": "public class ColumnIndexBuilder { \npublic void add ( Statistics < ? > stats ) { \nif ( ! ( stats . hasNonNullValue ( ) ) ) { \nnullPages . add ( true ) ; \n} \nelse { \nnullPages . add ( false ) ; \nObject min = stats . genericGetMin ( ) ; \nObject max = stats . genericGetMax ( ) ; \naddMinMax ( min , max ) ; \npageIndexes . add ( nextPageIndex ) ; \nminMaxSize += sizeOf ( min ) ; \nminMaxSize += sizeOf ( max ) ; \n} \nnullCounts . add ( stats . getNumNulls ( ) ) ; \n++ nextPageIndex ; \n} \n} \n"}
{"1987": "public class ParquetFileReader { \n@ Deprecated public static final ParquetMetadata readFooter ( InputFile file , MetadataFilter filter ) throws IOException { \nParquetReadOptions options ; \nif ( ! ( file instanceof HadoopInputFile ) ) { \noptions = ParquetReadOptions . builder ( ) . withMetadataFilter ( filter ) . build ( ) ; \n} \nelse { \noptions = HadoopReadOptions . builder ( ( ( HadoopInputFile ) file ) . getConfiguration ( ) ) . withMetadataFilter ( filter ) . build ( ) ; \n} \ntry ( SeekableInputStream in = file . newStream ( ) ) { \nreturn readFooter ( file , options , in ) ; \n} \n} \n} \n"}
{"1991": "public class MemoryManager { \nsynchronized void addWriter ( InternalParquetRecordWriter writer , Long allocation ) { \nLong oldValue = writerList . get ( writer ) ; \nif ( ! ( oldValue == null ) ) { \nthrow new IllegalArgumentException ( \"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer ) ; \n} \nelse { \nwriterList . put ( writer , allocation ) ; \n} \nupdateAllocation ( ) ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( ! ( totalAllocations <= totalMemoryPool ) ) { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nelse { \nscale = 1.0 ; \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"1994": "public class MemoryManager { \npublic void registerScaleCallBack ( String callBackName , Runnable callBack ) { \nPreconditions . checkNotNull ( callBackName , \"callBackName\" ) ; \nPreconditions . checkNotNull ( callBack , \"callBack\" ) ; \nif ( ! ( callBacks . containsKey ( callBackName ) ) ) { \ncallBacks . put ( callBackName , callBack ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The callBackName \" + callBackName + \" is duplicated and has been registered already.\" ) ; \n} \n} \n} \n"}
{"2009": "public class Schemas { \npublic static boolean nullOk ( Schema schema ) { \nif ( ! ( Schema . Type . NULL == schema . getType ( ) ) ) if ( Schema . Type . UNION == schema . getType ( ) ) { \nfor ( Schema possible : schema . getTypes ( ) ) { \nif ( nullOk ( possible ) ) { \nreturn true ; \n} \n} \n} \nelse { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"2011": "public class RecordBuilder { \nprivate static Object makeValue ( String string , Schema schema ) { \nif ( string == null ) { \nreturn null ; \n} \ntry { \nswitch ( schema . getType ( ) ) { \ncase BOOLEAN : return Boolean . valueOf ( string ) ; \ncase STRING : return string ; \ncase FLOAT : return Float . valueOf ( string ) ; \ncase DOUBLE : return Double . valueOf ( string ) ; \ncase INT : return Integer . valueOf ( string ) ; \ncase LONG : return Long . valueOf ( string ) ; \ncase ENUM : if ( ! ( schema . hasEnumSymbol ( string ) ) ) { \ntry { \nreturn schema . getEnumSymbols ( ) . get ( Integer . parseInt ( string ) ) ; \n} \ncatch ( IndexOutOfBoundsException ex ) { \nreturn null ; \n} \n} \nelse { \nreturn string ; \n} \ncase UNION : Object value = null ; \nfor ( Schema possible : schema . getTypes ( ) ) { \nvalue = makeValue ( string , possible ) ; \nif ( value != null ) { \nreturn value ; \n} \n} \nreturn null ; \ncase NULL : return null ; \ndefault : throw new RecordException ( \"Unsupported field type:\" + schema . getType ( ) ) ; \n} \n} \ncatch ( NumberFormatException e ) { \nif ( ! ( string . isEmpty ( ) ) ) { \nthrow e ; \n} \nelse { \nreturn null ; \n} \n} \n} \n} \n"}
{"2024": "public class Statistics { \npublic void mergeStatistics ( Statistics stats ) { \nif ( stats . isEmpty ( ) ) return ; \nif ( ! ( type . equals ( stats . type ) ) ) { \nthrow StatisticsClassException . create ( this , stats ) ; \n} \nelse { \nincrementNumNulls ( stats . getNumNulls ( ) ) ; \nif ( stats . hasNonNullValue ( ) ) { \nmergeStatisticsMinMax ( stats ) ; \nmarkAsNotEmpty ( ) ; \n} \n} \n} \n} \n"}
{"2025": "public class AvroSchemaConverter { \npublic static Schema getNonNull ( Schema schema ) { \nif ( ! ( schema . getType ( ) . equals ( Schema . Type . UNION ) ) ) { \nreturn schema ; \n} \nelse { \nList < Schema > schemas = schema . getTypes ( ) ; \nif ( ! ( schemas . size ( ) == 2 ) ) { \nreturn schema ; \n} \nelse { \nif ( ! ( schemas . get ( 0 ) . getType ( ) . equals ( Schema . Type . NULL ) ) ) if ( ! ( schemas . get ( 1 ) . getType ( ) . equals ( Schema . Type . NULL ) ) ) { \nreturn schema ; \n} \nelse { \nreturn schemas . get ( 0 ) ; \n} \nelse { \nreturn schemas . get ( 1 ) ; \n} \n} \n} \n} \n} \n"}
{"2029": "public class GroupType { \nList < Type > mergeFields ( GroupType toMerge , boolean strict ) { \nList < Type > newFields = new ArrayList < Type > ( ) ; \nfor ( Type type : this . getFields ( ) ) { \nType merged ; \nif ( ! ( toMerge . containsField ( type . getName ( ) ) ) ) { \nmerged = type ; \n} \nelse { \nType fieldToMerge = toMerge . getType ( type . getName ( ) ) ; \nif ( type . getLogicalTypeAnnotation ( ) != null && ! type . getLogicalTypeAnnotation ( ) . equals ( fieldToMerge . getLogicalTypeAnnotation ( ) ) ) { \nthrow new IncompatibleSchemaModificationException ( \"cannot merge logical type \" + fieldToMerge . getLogicalTypeAnnotation ( ) + \" into \" + type . getLogicalTypeAnnotation ( ) ) ; \n} \nmerged = type . union ( fieldToMerge , strict ) ; \n} \nnewFields . add ( merged ) ; \n} \nfor ( Type type : toMerge . getFields ( ) ) { \nif ( ! this . containsField ( type . getName ( ) ) ) { \nnewFields . add ( type ) ; \n} \n} \nreturn newFields ; \n} \n} \n"}
{"2040": "public class Util { \npublic static FileMetaData readFileMetaData ( InputStream from , boolean skipRowGroups ) throws IOException { \nFileMetaData md = new FileMetaData ( ) ; \nif ( ! ( skipRowGroups ) ) { \nread ( from , md ) ; \n} \nelse { \nreadFileMetaData ( from , new DefaultFileMetaDataConsumer ( md ) , skipRowGroups ) ; \n} \nreturn md ; \n} \n} \n"}
{"2044": "public class ValidTypeMap { \npublic static < T extends Comparable < T > > void assertTypeValid ( Column < T > foundColumn , PrimitiveTypeName primitiveType ) { \nClass < T > foundColumnType = foundColumn . getColumnType ( ) ; \nColumnPath columnPath = foundColumn . getColumnPath ( ) ; \nSet < PrimitiveTypeName > validTypeDescriptors = classToParquetType . get ( foundColumnType ) ; \nif ( validTypeDescriptors == null ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" was declared as type: \" ) . append ( foundColumnType . getName ( ) ) . append ( \" which is not supported in FilterPredicates.\" ) ; \nSet < Class < ? > > supportedTypes = parquetTypeToClass . get ( primitiveType ) ; \nif ( ! ( supportedTypes != null ) ) { \nmessage . append ( \" There are no supported types for columns of \" + primitiveType ) ; \n} \nelse { \nmessage . append ( \" Supported types for this column are: \" ) . append ( supportedTypes ) ; \n} \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \nif ( ! validTypeDescriptors . contains ( primitiveType ) ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"FilterPredicate column: \" ) . append ( columnPath . toDotString ( ) ) . append ( \"'s declared type (\" ) . append ( foundColumnType . getName ( ) ) . append ( \") does not match the schema found in file metadata. Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" is of type: \" ) . append ( primitiveType ) . append ( \"\\nValid types for this column are: \" ) . append ( parquetTypeToClass . get ( primitiveType ) ) ; \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \n} \n} \n"}
{"2053": "public class LruCache { \npublic void put ( final K key , final V newValue ) { \nif ( newValue == null || ! newValue . isCurrent ( key ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because it is {}\" , key , ( newValue == null ? \"null\" : \"not current\" ) ) ; \n} \nreturn ; \n} \nV oldValue = cacheMap . get ( key ) ; \nif ( oldValue != null && oldValue . isNewerThan ( newValue ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because \" + \"existing cache entry is newer\" , key ) ; \n} \nreturn ; \n} \noldValue = cacheMap . put ( key , newValue ) ; \nif ( LOG . isDebugEnabled ( ) ) { \nif ( ! ( oldValue == null ) ) { \nLOG . debug ( \"Overwrote existing cache entry for '{}'\" , key ) ; \n} \nelse { \nLOG . debug ( \"Added new cache entry for '{}'\" , key ) ; \n} \n} \n} \n} \n"}
{"2055": "public class AvroWriteSupport { \nprivate void writeValue ( Type type , Schema avroSchema , Object value ) { \nSchema nonNullAvroSchema = AvroSchemaConverter . getNonNull ( avroSchema ) ; \nLogicalType logicalType = nonNullAvroSchema . getLogicalType ( ) ; \nif ( ! ( logicalType != null ) ) { \nwriteValueWithoutConversion ( type , nonNullAvroSchema , value ) ; \n} \nelse { \nConversion < ? > conversion = model . getConversionByClass ( value . getClass ( ) , logicalType ) ; \nwriteValueWithoutConversion ( type , nonNullAvroSchema , convert ( nonNullAvroSchema , logicalType , conversion , value ) ) ; \n} \n} \n} \n"}
{"2056": "public class AvroWriteSupport { \n@ SuppressWarnings ( \"unchecked\" ) private void writeValueWithoutConversion ( Type type , Schema avroSchema , Object value ) { \nswitch ( avroSchema . getType ( ) ) { \ncase BOOLEAN : recordConsumer . addBoolean ( ( Boolean ) value ) ; \nbreak ; \ncase INT : if ( ! ( value instanceof Character ) ) { \nrecordConsumer . addInteger ( ( ( Number ) value ) . intValue ( ) ) ; \n} \nelse { \nrecordConsumer . addInteger ( ( Character ) value ) ; \n} \nbreak ; \ncase LONG : recordConsumer . addLong ( ( ( Number ) value ) . longValue ( ) ) ; \nbreak ; \ncase FLOAT : recordConsumer . addFloat ( ( ( Number ) value ) . floatValue ( ) ) ; \nbreak ; \ncase DOUBLE : recordConsumer . addDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; \nbreak ; \ncase FIXED : recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( ( GenericFixed ) value ) . bytes ( ) ) ) ; \nbreak ; \ncase BYTES : if ( ! ( value instanceof byte [ ] ) ) { \nrecordConsumer . addBinary ( Binary . fromReusedByteBuffer ( ( ByteBuffer ) value ) ) ; \n} \nelse { \nrecordConsumer . addBinary ( Binary . fromReusedByteArray ( ( byte [ ] ) value ) ) ; \n} \nbreak ; \ncase STRING : recordConsumer . addBinary ( fromAvroString ( value ) ) ; \nbreak ; \ncase RECORD : writeRecord ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase ENUM : recordConsumer . addBinary ( Binary . fromString ( value . toString ( ) ) ) ; \nbreak ; \ncase ARRAY : listWriter . writeList ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase MAP : writeMap ( type . asGroupType ( ) , avroSchema , ( Map < CharSequence , ? > ) value ) ; \nbreak ; \ncase UNION : writeUnion ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \n} \n} \n\n"}
{"2058": "public class BaseCommand { \npublic void output ( String content , Logger console , String filename ) throws IOException { \nif ( ! ( filename == null || \"-\" . equals ( filename ) ) ) { \nFSDataOutputStream outgoing = create ( filename ) ; \ntry { \noutgoing . write ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; \n} \nfinally { \noutgoing . close ( ) ; \n} \n} \nelse { \nconsole . info ( content ) ; \n} \n} \n} \n"}
{"2059": "public class BaseCommand { \npublic InputStream open ( String filename ) throws IOException { \nif ( STDIN_AS_SOURCE . equals ( filename ) ) { \nreturn System . in ; \n} \nURI uri = qualifiedURI ( filename ) ; \nif ( ! ( RESOURCE_URI_SCHEME . equals ( uri . getScheme ( ) ) ) ) { \nPath filePath = new Path ( uri ) ; \nFileSystem fs = filePath . getFileSystem ( getConf ( ) ) ; \nreturn fs . open ( filePath ) ; \n} \nelse { \nreturn Resources . getResource ( uri . getRawSchemeSpecificPart ( ) ) . openStream ( ) ; \n} \n} \n} \n"}
{"2065": "public class ParquetRecordReaderWrapper { \nprotected ParquetInputSplit getSplit ( final InputSplit oldSplit , final JobConf conf ) throws IOException { \nif ( ! ( oldSplit instanceof FileSplit ) ) { \nthrow new IllegalArgumentException ( \"Unknown split type: \" + oldSplit ) ; \n} \nelse { \nFileSplit fileSplit = ( FileSplit ) oldSplit ; \nfinal long splitStart = fileSplit . getStart ( ) ; \nfinal long splitLength = fileSplit . getLength ( ) ; \nfinal Path finalPath = fileSplit . getPath ( ) ; \nfinal JobConf cloneJob = hiveBinding . pushProjectionsAndFilters ( conf , finalPath . getParent ( ) ) ; \nfinal ParquetMetadata parquetMetadata = ParquetFileReader . readFooter ( cloneJob , finalPath , SKIP_ROW_GROUPS ) ; \nfinal FileMetaData fileMetaData = parquetMetadata . getFileMetaData ( ) ; \nfinal ReadContext readContext = new DataWritableReadSupport ( ) . init ( cloneJob , fileMetaData . getKeyValueMetaData ( ) , fileMetaData . getSchema ( ) ) ; \nschemaSize = MessageTypeParser . parseMessageType ( readContext . getReadSupportMetadata ( ) . get ( DataWritableReadSupport . HIVE_SCHEMA_KEY ) ) . getFieldCount ( ) ; \nreturn new ParquetInputSplit ( finalPath , splitStart , splitStart + splitLength , splitLength , fileSplit . getLocations ( ) , null ) ; \n} \n} \n} \n"}
{"2068": "public class MergeCommand { \nprivate List < Path > getInputFiles ( List < String > input ) throws IOException { \nList < Path > inputFiles = null ; \nif ( ! ( input . size ( ) == 1 ) ) { \ninputFiles = parseInputFiles ( input ) ; \n} \nelse { \nPath p = new Path ( input . get ( 0 ) ) ; \nFileSystem fs = p . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( p ) ; \nif ( status . isDir ( ) ) { \ninputFiles = getInputFilesFromDirectory ( status ) ; \n} \n} \ncheckParquetFiles ( inputFiles ) ; \nreturn inputFiles ; \n} \n} \n"}
{"2083": "public class PipelineBeanCreator { \npublic StageBean createStageBean ( boolean forExecution , StageLibraryTask library , StageConfiguration stageConf , boolean validateAnnotations , boolean errorStage , boolean pipelineLifecycleStage , Map < String , Object > constants , InterceptorCreatorContextBuilder interceptorContextBuilder , List < Issue > errors ) { \nIssueCreator issueCreator = IssueCreator . getStage ( stageConf . getInstanceName ( ) ) ; \nStageBean bean = null ; \nStageDefinition stageDef = library . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , forExecution ) ; \nif ( ! ( stageDef != null ) ) { \nerrors . add ( issueCreator . create ( CreationError . CREATION_006 , stageConf . getLibrary ( ) , stageConf . getStageName ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \nelse { \nif ( validateAnnotations ) { \nif ( ! ( pipelineLifecycleStage ) ) if ( stageDef . isErrorStage ( ) != errorStage ) { \nif ( ! ( stageDef . isErrorStage ( ) ) ) { \nerrors . add ( issueCreator . create ( CreationError . CREATION_008 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \nelse { \nerrors . add ( issueCreator . create ( CreationError . CREATION_007 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \n} \nelse { \nif ( ! stageDef . isPipelineLifecycleStage ( ) ) { \nerrors . add ( issueCreator . create ( CreationError . CREATION_018 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \n} \n} \nbean = createStage ( library , stageDef , library , stageConf , serviceClass -> library . getServiceDefinition ( serviceClass , true ) , interceptorContextBuilder , constants , errors ) ; \n} \nreturn bean ; \n} \n} \n"}
{"2087": "public class AvroTypeUtil { \nprivate static int millisToDays ( long millisLocal ) { \nlong millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; \nint days ; \nif ( ! ( millisUtc >= 0L ) ) { \ndays = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; \n} \nelse { \ndays = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; \n} \nreturn days ; \n} \n} \n"}
{"2090": "public class RecordWriter { \npublic long getLength ( ) throws IOException { \nlong length = - 1 ; \nif ( ! ( generator != null ) ) if ( seqWriter != null ) { \nlength = seqWriter . getLength ( ) ; \n} \nelse { \nlength = textOutputStream . getByteCount ( ) ; \n} \nreturn length ; \n} \n} \n"}
{"2095": "public class RuntimeInfo { \npublic static void storeControlHubConfigs ( RuntimeInfo runtimeInfo , Map < String , String > newConfigs ) throws IOException { \nFile configFile = new File ( runtimeInfo . getDataDir ( ) , SCH_CONF_OVERRIDE ) ; \nProperties properties = new Properties ( ) ; \nif ( configFile . exists ( ) ) { \ntry ( FileReader reader = new FileReader ( configFile ) ) { \nproperties . load ( reader ) ; \n} \n} \nfor ( Map . Entry < String , String > entry : newConfigs . entrySet ( ) ) { \nif ( ! ( entry . getValue ( ) == null ) ) { \nproperties . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nelse { \nproperties . remove ( entry . getKey ( ) ) ; \n} \n} \ntry ( FileWriter writer = new FileWriter ( configFile ) ) { \nproperties . store ( writer , null ) ; \n} \n} \n} \n"}
{"2102": "public class FieldValueReplacerProcessor { \nprivate List < String > getFieldsToNull ( List < NullReplacerConditionalConfig > nullReplacerConditionalConfigs , Set < String > fieldsThatDoNotExist , Set < String > fieldPaths , Record record ) throws OnRecordErrorException { \nList < String > fieldsToNull = new ArrayList < > ( ) ; \nfor ( NullReplacerConditionalConfig nullReplacerConditionalConfig : nullReplacerConditionalConfigs ) { \nList < String > fieldNamesToNull = nullReplacerConditionalConfig . fieldsToNull ; \nList < String > fieldPathsToNull = new ArrayList < > ( ) ; \nfor ( String fieldNameToNull : fieldNamesToNull ) { \ntry { \nfinal List < String > matchingPaths = FieldPathExpressionUtil . evaluateMatchingFieldPaths ( fieldNameToNull , fieldPathEval , fieldPathVars , record , fieldPaths ) ; \nif ( ! ( matchingPaths . isEmpty ( ) ) ) { \nfor ( String matchingField : matchingPaths ) { \nif ( ! ( record . has ( matchingField ) ) ) { \nfieldsThatDoNotExist . add ( matchingField ) ; \n} \nelse { \nfieldPathsToNull . add ( matchingField ) ; \n} \n} \n} \nelse { \nfieldsThatDoNotExist . add ( fieldNameToNull ) ; \n} \n} \ncatch ( ELEvalException e ) { \nLOG . error ( \"Error evaluating condition: \" + nullReplacerConditionalConfig . condition , e ) ; \nthrow new OnRecordErrorException ( record , Errors . VALUE_REPLACER_07 , fieldNameToNull , e . toString ( ) , e ) ; \n} \n} \ntry { \nboolean evaluatedCondition = true ; \nif ( ! StringUtils . isEmpty ( nullReplacerConditionalConfig . condition ) ) { \nevaluatedCondition = nullConditionELEval . eval ( nullConditionELVars , nullReplacerConditionalConfig . condition , Boolean . class ) ; \n} \nif ( evaluatedCondition ) { \nfieldsToNull . addAll ( fieldPathsToNull ) ; \n} \n} \ncatch ( ELEvalException e ) { \nLOG . error ( \"Error evaluating condition: \" + nullReplacerConditionalConfig . condition , e ) ; \nthrow new OnRecordErrorException ( record , Errors . VALUE_REPLACER_06 , nullReplacerConditionalConfig . condition , e . toString ( ) ) ; \n} \n} \nreturn fieldsToNull ; \n} \n} \n"}
{"2103": "public class SystemPackage { \nprivate static boolean isSystemClass ( String name , List < String > packageList ) { \nboolean result = false ; \nif ( packageList != null ) { \nString canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; \nfor ( String c : packageList ) { \nboolean shouldInclude = true ; \nif ( c . startsWith ( \"-\" ) ) { \nc = c . substring ( 1 ) ; \nshouldInclude = false ; \n} \nif ( canonicalName . startsWith ( c ) ) { \nif ( c . endsWith ( \".\" ) || canonicalName . length ( ) == c . length ( ) || canonicalName . length ( ) > c . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) { \nif ( ! ( shouldInclude ) ) { \nreturn false ; \n} \nelse { \nresult = true ; \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2114": "public class ProtobufTypeUtil { \nprivate static DynamicMessage sdcFieldToProtobufMsg ( Record record , Field field , String fieldPath , Descriptors . Descriptor desc , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Map < String , Object > defaultValueMap ) throws DataGeneratorException { \nif ( field == null ) { \nreturn null ; \n} \nDynamicMessage . Builder builder = DynamicMessage . newBuilder ( desc ) ; \nList < Descriptors . FieldDescriptor > fields = new ArrayList < > ( ) ; \nfields . addAll ( desc . getFields ( ) ) ; \nif ( messageTypeToExtensionMap . containsKey ( desc . getFullName ( ) ) ) { \nfields . addAll ( messageTypeToExtensionMap . get ( desc . getFullName ( ) ) ) ; \n} \nMap < String , Field > valueAsMap = field . getValueAsMap ( ) ; \nfor ( Descriptors . FieldDescriptor f : fields ) { \nField mapField = valueAsMap . get ( f . getName ( ) ) ; \nif ( ! ( f . isMapField ( ) ) ) if ( ! ( f . isRepeated ( ) ) ) { \nhandleNonRepeatedField ( record , valueAsMap , fieldPath , messageTypeToExtensionMap , defaultValueMap , desc , f , builder ) ; \n} \nelse { \nif ( mapField != null ) { \nhandleRepeatedField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \n} \n} \nelse { \nhandleMapField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \n} \n} \ntry { \nhandleUnknownFields ( record , fieldPath , builder ) ; \n} \ncatch ( IOException e ) { \nthrow new DataGeneratorException ( Errors . PROTOBUF_05 , e . toString ( ) , e ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"2122": "public class HttpProcessor { \nprivate Record parseResponse ( InputStream response ) throws StageException { \nRecord record = null ; \nif ( ! ( conf . httpMethod == HttpMethod . HEAD ) ) if ( response != null ) { \ntry ( DataParser parser = parserFactory . getParser ( \"\" , response , \"0\" ) ) { \nrecord = parser . parse ( ) ; \nif ( conf . dataFormat == DataFormat . TEXT ) { \nrecord . set ( record . get ( \"/text\" ) ) ; \n} \n} \ncatch ( IOException | DataParserException e ) { \nerrorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; \n} \n} \nelse { \nrecord = getContext ( ) . createRecord ( \"\" ) ; \nrecord . set ( Field . create ( new HashMap ( ) ) ) ; \n} \nreturn record ; \n} \n} \n"}
{"2123": "public class HttpProcessor { \nprivate void addResponseHeaders ( Record record , Response response ) throws StageException { \nif ( conf . headerOutputLocation == HeaderOutputLocation . NONE ) { \nreturn ; \n} \nRecord . Header header = record . getHeader ( ) ; \nif ( ! ( conf . headerOutputLocation == HeaderOutputLocation . FIELD ) ) if ( conf . headerOutputLocation == HeaderOutputLocation . HEADER ) { \nwriteResponseHeaderToRecordHeader ( response , header ) ; \n} \nelse { \nwriteResponseHeaderToField ( record , response ) ; \n} \n} \n} \n"}
{"2129": "public class HttpClientSource { \nprivate void incrementSourceOffset ( HttpSourceOffset sourceOffset , int increment ) { \nif ( ! ( conf . pagination . mode == PaginationMode . BY_PAGE ) ) if ( conf . pagination . mode == PaginationMode . BY_OFFSET ) { \nsourceOffset . incrementStartAt ( increment ) ; \n} \nelse { \nsourceOffset . incrementStartAt ( 1 ) ; \n} \n} \n} \n"}
{"2130": "public class HttpClientSource { \nprivate int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { \nint numSubRecords = 0 ; \nif ( ! record . has ( conf . pagination . resultFieldPath ) ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nField resultField = record . get ( conf . pagination . resultFieldPath ) ; \nif ( resultField . getType ( ) != Field . Type . LIST ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nList < Field > results = resultField . getValueAsList ( ) ; \nint subRecordIdx = 0 ; \nfor ( Field result : results ) { \nRecord r = getContext ( ) . createRecord ( sourceOffset + \"::\" + subRecordIdx ++ ) ; \nif ( ! ( conf . pagination . keepAllFields ) ) { \nr . set ( result ) ; \n} \nelse { \nr . set ( record . get ( ) . clone ( ) ) ; \nr . set ( conf . pagination . resultFieldPath , result ) ; \n} \naddResponseHeaders ( r . getHeader ( ) ) ; \nbatchMaker . addRecord ( r ) ; \n++ numSubRecords ; \n} \nif ( conf . pagination . mode != PaginationMode . LINK_FIELD ) { \nhaveMorePages = numSubRecords > 0 ; \n} \nreturn numSubRecords ; \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) { \nreturn newSourceOffset ; \n} \nint status = getResponse ( ) . getStatus ( ) ; \nif ( status < 200 || status >= 300 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) { \nhaveMorePages = false ; \n} \n} \nif ( ! ( getResponse ( ) . hasEntity ( ) ) ) if ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) { \nnewSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \n} \nelse { \nnewSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \n} \nreturn newSourceOffset ; \n} \n} \n"}
{"2137": "public class GoogleCloudCredentialsConfig { \nprivate Credentials getCredentials ( Stage . Context context , List < Stage . ConfigIssue > issues ) { \nCredentials credentials = null ; \nFile credentialsFile ; \nif ( ! ( Paths . get ( path ) . isAbsolute ( ) ) ) { \ncredentialsFile = new File ( context . getResourcesDirectory ( ) , path ) ; \n} \nelse { \ncredentialsFile = new File ( path ) ; \n} \nif ( ! credentialsFile . exists ( ) || ! credentialsFile . isFile ( ) ) { \nLOG . error ( GOOGLE_01 . getMessage ( ) , credentialsFile . getPath ( ) ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_01 , credentialsFile . getPath ( ) ) ) ; \nreturn null ; \n} \ntry ( InputStream in = new FileInputStream ( credentialsFile ) ) { \ncredentials = ServiceAccountCredentials . fromStream ( in ) ; \n} \ncatch ( IOException | IllegalArgumentException e ) { \nLOG . error ( GOOGLE_02 . getMessage ( ) , e ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_02 ) ) ; \n} \nreturn credentials ; \n} \n} \n"}
{"2139": "public class AbstractOverrunDelimitedReader { \nprotected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { \nint overrun = 0 ; \nint currentSize = s . length ( ) - initialLen ; \nint readSize = currentChar - startChar ; \nif ( ! ( maxLine > - 1 && currentSize + readSize > maxLine ) ) { \ns . append ( cb , startChar , readSize ) ; \n} \nelse { \nint adjustedReadSize = maxLine - currentSize ; \nif ( ! ( adjustedReadSize > 0 ) ) { \noverrun = readSize ; \n} \nelse { \ns . append ( cb , startChar , adjustedReadSize ) ; \noverrun = readSize - adjustedReadSize ; \n} \n} \nreturn overrun ; \n} \n} \n"}
{"2140": "public class ApplicationPackage { \nstatic void removeLogicalDuplicates ( SortedSet < String > packages ) { \nIterator < String > iterator = packages . iterator ( ) ; \nif ( ! iterator . hasNext ( ) ) { \nreturn ; \n} \nString last = iterator . next ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nString current = iterator . next ( ) ; \nif ( ! ( current . startsWith ( last ) ) ) { \nlast = current ; \n} \nelse { \niterator . remove ( ) ; \n} \n} \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \nfor ( int i = pos ; \ni < idx ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \ni < chunkLines . size ( ) ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( ! ( completeLines . isEmpty ( ) ) ) { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nelse { \nchunk = null ; \n} \nreturn chunk ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nif ( ! ( ( i % 2 ) == 1 ) ) { \noutput . append ( parts [ i ] ) ; \n} \nelse { \noutput . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \n} \n} \nreturn output . toString ( ) ; \n} \n} \n"}
{"2155": "public class JSON { \npublic String serialize ( Object obj ) throws ApiException { \ntry { \nif ( ! ( obj != null ) ) return null ; \nelse return mapper . writeValueAsString ( obj ) ; \n} \ncatch ( Exception e ) { \nthrow new ApiException ( 400 , e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"2156": "public class JSON { \npublic < T > T deserialize ( String body , TypeRef returnType ) throws ApiException { \nJavaType javaType = mapper . constructType ( returnType . getType ( ) ) ; \ntry { \nreturn mapper . readValue ( body , javaType ) ; \n} \ncatch ( IOException e ) { \nif ( ! ( returnType . getType ( ) . equals ( String . class ) ) ) throw new ApiException ( 500 , e . getMessage ( ) , null , body ) ; \nelse return ( T ) body ; \n} \n} \n} \n"}
{"2160": "public class HiveMetastoreUtil { \nprivate static < T > Field generateInnerFieldFromTheList ( LinkedHashMap < String , T > original , String innerPairFirstFieldName , String innerPairSecondFieldName , boolean isSecondFieldHiveType ) throws HiveStageCheckedException { \nList < Field > columnList = new LinkedList < > ( ) ; \nfor ( Map . Entry < String , T > pair : original . entrySet ( ) ) { \nLinkedHashMap < String , Field > entry = new LinkedHashMap < > ( ) ; \nentry . put ( innerPairFirstFieldName , Field . create ( pair . getKey ( ) ) ) ; \nif ( ! ( isSecondFieldHiveType ) ) { \nentry . put ( innerPairSecondFieldName , Field . create ( pair . getValue ( ) . toString ( ) ) ) ; \n} \nelse { \nHiveTypeInfo hiveTypeInfo = ( HiveTypeInfo ) pair . getValue ( ) ; \nentry . put ( innerPairSecondFieldName , hiveTypeInfo . getHiveType ( ) . getSupport ( ) . generateHiveTypeInfoFieldForMetadataRecord ( hiveTypeInfo ) ) ; \n} \ncolumnList . add ( Field . createListMap ( entry ) ) ; \n} \nreturn ! columnList . isEmpty ( ) ? Field . create ( columnList ) : null ; \n} \n} \n"}
{"2171": "public class HiveMetastoreUtil { \npublic static String serializeSchemaToHDFS ( UserGroupInformation loginUGI , final FileSystem fs , final String location , final String schemaFolder , final String databaseName , final String tableName , final String schemaJson ) throws StageException { \nString folderLocation ; \nif ( ! ( schemaFolder . startsWith ( SEP ) ) ) { \nfolderLocation = location + SEP + schemaFolder ; \n} \nelse { \nfolderLocation = schemaFolder ; \n} \nfinal Path schemasFolderPath = new Path ( folderLocation ) ; \nfinal String path = folderLocation + SEP + String . format ( AVRO_SCHEMA_FILE_FORMAT , databaseName , tableName , UUID . randomUUID ( ) . toString ( ) ) ; \ntry { \nloginUGI . doAs ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nif ( ! fs . exists ( schemasFolderPath ) ) { \nfs . mkdirs ( schemasFolderPath ) ; \n} \nPath schemaFilePath = new Path ( path ) ; \nif ( ! ( ! fs . exists ( schemaFilePath ) ) ) { \nLOG . error ( Utils . format ( \"Already schema file {} exists in HDFS\" , path ) ) ; \nthrow new IOException ( \"Already schema file exists\" ) ; \n} \nelse { \ntry ( FSDataOutputStream os = fs . create ( schemaFilePath ) ) { \nbyte [ ] schemaBytes = schemaJson . getBytes ( \"UTF-8\" ) ; \nos . write ( schemaBytes , 0 , schemaBytes . length ) ; \n} \n} \nreturn null ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nLOG . error ( \"Error in Writing Schema to HDFS: \" + e . toString ( ) , e ) ; \nthrow new StageException ( Errors . HIVE_18 , path , e . getMessage ( ) ) ; \n} \nreturn path ; \n} \n} \n"}
{"2174": "public class SyslogDecoder { \npublic static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { \nLocalDateTime now = LocalDateTime . now ( ) ; \nint year = now . getYear ( ) ; \nts = TWO_SPACES . matcher ( ts ) . replaceFirst ( \" \" ) ; \nLocalDateTime date ; \ntry { \nMonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; \nLocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; \ndate = now ; \ndate = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; \ndate = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; \ndate = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; \n} \ncatch ( DateTimeParseException e ) { \nthrow new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; \n} \nLocalDateTime fixed = date ; \nif ( ! ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) ) if ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) { \nfixed = date . withYear ( year + 1 ) ; \n} \nelse { \nfixed = date . withYear ( year - 1 ) ; \n} \ndate = fixed ; \nreturn date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; \n} \n} \n"}
{"2182": "public class CouchbaseConnector { \npublic static synchronized CouchbaseConnector getInstance ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { \nMap < String , Object > runnerSharedMap = context . getStageRunnerSharedMap ( ) ; \nif ( ! ( runnerSharedMap . containsKey ( INSTANCE ) ) ) { \nLOG . debug ( \"CouchbaseConnector not yet instantiated. Creating new instance\" ) ; \nvalidateConfig ( config , issues , context ) ; \nif ( issues . isEmpty ( ) ) { \nrunnerSharedMap . put ( INSTANCE , new CouchbaseConnector ( config , issues , context ) ) ; \n} \n} \nelse { \nLOG . debug ( \"Using existing instance of CouchbaseConnector\" ) ; \n} \nreturn ( CouchbaseConnector ) runnerSharedMap . get ( INSTANCE ) ; \n} \n} \n"}
{"2187": "public class Vault { \npublic String read ( String path , String key , long delay ) { \nif ( ! secrets . containsKey ( path ) ) { \nVaultClient vault = new VaultClient ( getConfig ( ) ) ; \nSecret secret ; \ntry { \nsecret = vault . logical ( ) . read ( path ) ; \n} \ncatch ( VaultException e ) { \nLOG . error ( e . toString ( ) , e ) ; \nthrow new VaultRuntimeException ( e . toString ( ) ) ; \n} \nString leaseId ; \nif ( ! ( secret . isRenewable ( ) ) ) { \nleaseId = path + \"/\" ; \n} \nelse { \nleaseId = secret . getLeaseId ( ) ; \n} \nleases . put ( leaseId , System . currentTimeMillis ( ) + ( secret . getLeaseDuration ( ) * 1000 ) ) ; \nsecrets . put ( path , secret ) ; \ntry { \nThread . sleep ( delay ) ; \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \n} \nMap < String , Object > data = secrets . get ( path ) . getData ( ) ; \nString value = getSecretValue ( data , key ) . orElseThrow ( ( ) -> new VaultRuntimeException ( \"Value not found for key\" ) ) ; \nLOG . trace ( \"CredentialStore '{}' Vault, retrieved value for key '{}'\" , csId , key ) ; \nreturn value ; \n} \n} \n"}
{"2189": "public class CouchbaseTarget { \nprivate Observable < AbstractDocument > writeDoc ( String key , int ttl , long cas , ByteArrayOutputStream baos , Record record ) { \nWriteOperationType opType = getOperationFromHeader ( record , key ) ; \nif ( opType == null ) { \nreturn Observable . empty ( ) ; \n} \nAbstractDocument doc ; \nif ( ! ( config . dataFormat == DataFormat . JSON ) ) { \ndoc = ByteArrayDocument . create ( key , ttl , baos . toByteArray ( ) , cas ) ; \n} \nelse { \ntry { \ndoc = JsonDocument . create ( key , ttl , JsonObject . fromJson ( baos . toString ( config . dataFormatConfig . charset ) ) , cas ) ; \n} \ncatch ( Exception e ) { \nreturn handleError ( record , Errors . COUCHBASE_10 , e ) ; \n} \n} \nswitch ( opType ) { \ncase DELETE : { \nLOG . debug ( \"DELETE key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . remove ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase INSERT : { \nLOG . debug ( \"INSERT key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . insert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase REPLACE : { \nLOG . debug ( \"REPLACE key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . replace ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase UPSERT : { \nLOG . debug ( \"UPSERT key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . upsert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ndefault : return Observable . empty ( ) ; \n} \n} \n} \n"}
{"2191": "public class H2SchemaWriter { \n@ Override protected String makeAlterTableSqlString ( String schema , String tableName , LinkedHashMap < String , JdbcTypeInfo > columnDiff ) { \nString tableSchema = ( schema == null ) ? getDefaultSchema ( ) : schema ; \nStringBuilder sqlString = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Map . Entry < String , JdbcTypeInfo > entry : columnDiff . entrySet ( ) ) { \nif ( ! ( first ) ) { \nsqlString . append ( \"\\n\" ) ; \n} \nelse { \nfirst = false ; \n} \nsqlString . append ( ALTER_TABLE ) . append ( \" \" ) ; \nif ( tableSchema != null ) { \nsqlString . append ( tableSchema ) ; \nsqlString . append ( \".\" ) ; \n} \nsqlString . append ( tableName ) . append ( \" \" ) . append ( \"ADD COLUMN\" ) . append ( \" \" ) . append ( entry . getKey ( ) ) . append ( \" \" ) . append ( entry . getValue ( ) . toString ( ) ) . append ( \";\" ) ; \n} \nreturn sqlString . toString ( ) ; \n} \n} \n"}
{"2205": "public class DataLakeGeneratorManager { \npublic String getFilePath ( String dirPathTemplate , Record record , Date recordTime ) throws StageException { \nString dirPath ; \nif ( ! ( dirPathTemplateInHeader ) ) { \ndirPath = resolvePath ( dirPathTemplateEval , dirPathTemplateVars , dirPathTemplate , recordTime , record ) ; \n} \nelse { \ndirPath = record . getHeader ( ) . getAttribute ( DataLakeTarget . TARGET_DIRECTORY_HEADER ) ; \nUtils . checkArgument ( ! ( dirPath == null || dirPath . isEmpty ( ) ) , \"Directory Path cannot be null\" ) ; \n} \ndirPath = dirPath . replaceAll ( \"/+\" , \"/\" ) ; \nif ( dirPath . endsWith ( \"/\" ) ) { \ndirPath = dirPath . substring ( 0 , dirPath . length ( ) - 1 ) ; \n} \nreturn outputStreamHelper . getTempFilePath ( dirPath , record , recordTime ) ; \n} \n} \n"}
{"2215": "public class KinesisUtil { \npublic static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { \nAmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; \nString lastShardId = null ; \ntry { \nStreamDescription description ; \ndo { \nif ( ! ( lastShardId == null ) ) { \ndescription = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; \n} \nelse { \ndescription = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; \n} \nint pageSize = description . getShards ( ) . size ( ) ; \nlastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; \n} \nwhile ( description . getHasMoreShards ( ) ) ; \nreturn lastShardId ; \n} \nfinally { \nkinesisClient . shutdown ( ) ; \n} \n} \n} \n"}
{"2221": "public class FieldHasherProcessor { \nprivate Set < String > validateAndExtractFieldsToHash ( Record record , Set < String > fieldsDontExist , Set < String > fieldsWithListOrMapType , Set < String > fieldsWithNull , Collection < String > matchingFieldsPath ) { \nSet < String > validFieldsToHashForThisConfig = new HashSet < String > ( ) ; \nfor ( String matchingFieldPath : matchingFieldsPath ) { \nif ( ! ( record . has ( matchingFieldPath ) ) ) { \nfieldsDontExist . add ( matchingFieldPath ) ; \n} \nelse { \nField field = record . get ( matchingFieldPath ) ; \nif ( ! ( UNSUPPORTED_FIELD_TYPES . contains ( field . getType ( ) ) ) ) if ( ! ( field . getValue ( ) == null ) ) { \nvalidFieldsToHashForThisConfig . add ( matchingFieldPath ) ; \n} \nelse { \nfieldsWithNull . add ( matchingFieldPath ) ; \n} \nelse { \nfieldsWithListOrMapType . add ( matchingFieldPath ) ; \n} \n} \n} \nreturn validFieldsToHashForThisConfig ; \n} \n} \n"}
{"2228": "public class JdbcUtil { \npublic < T > void write ( Iterator < Record > recordIterator , T key , LoadingCache < T , JdbcRecordWriter > recordWriters , ErrorRecordHandler errorRecordHandler , boolean perRecord ) throws StageException { \nfinal JdbcRecordWriter jdbcRecordWriter ; \ntry { \njdbcRecordWriter = recordWriters . getUnchecked ( key ) ; \n} \ncatch ( UncheckedExecutionException ex ) { \nfinal Throwable throwable = ex . getCause ( ) ; \nfinal ErrorCode errorCode ; \nfinal Object [ ] messageParams ; \nif ( ! ( throwable instanceof StageException ) ) { \nerrorCode = JdbcErrors . JDBC_301 ; \nmessageParams = new Object [ ] { \nex . getMessage ( ) , ex . getCause ( ) } \n; \n} \nelse { \nStageException stageEx = ( StageException ) ex . getCause ( ) ; \nerrorCode = stageEx . getErrorCode ( ) ; \nmessageParams = stageEx . getParams ( ) ; \n} \nwhile ( recordIterator . hasNext ( ) ) { \nRecord record = recordIterator . next ( ) ; \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , errorCode , messageParams ) ) ; \n} \nreturn ; \n} \nList < OnRecordErrorException > errors = perRecord ? jdbcRecordWriter . writePerRecord ( recordIterator ) : jdbcRecordWriter . writeBatch ( recordIterator ) ; \nfor ( OnRecordErrorException error : errors ) { \nerrorRecordHandler . onError ( error ) ; \n} \n} \n} \n"}
{"2235": "public class HttpClientCommon { \nprivate void configureAuthAndBuildClient ( ClientBuilder clientBuilder , List < Stage . ConfigIssue > issues ) { \nif ( ! ( jerseyClientConfig . authType == AuthenticationType . OAUTH ) ) if ( jerseyClientConfig . authType . isOneOf ( AuthenticationType . DIGEST , AuthenticationType . BASIC , AuthenticationType . UNIVERSAL ) ) { \nString username = jerseyClientConfig . basicAuth . resolveUsername ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nString password = jerseyClientConfig . basicAuth . resolvePassword ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nJerseyClientUtil . configurePasswordAuth ( jerseyClientConfig . authType , username , password , clientBuilder ) ; \n} \n} \nelse { \nString consumerKey = jerseyClientConfig . oauth . resolveConsumerKey ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString consumerSecret = jerseyClientConfig . oauth . resolveConsumerSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString token = jerseyClientConfig . oauth . resolveToken ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString tokenSecret = jerseyClientConfig . oauth . resolveTokenSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nauthToken = JerseyClientUtil . configureOAuth1 ( consumerKey , consumerSecret , token , tokenSecret , clientBuilder ) ; \n} \n} \ntry { \nbuildNewAuthenticatedClient ( issues , false ) ; \nclientInitialized = true ; \n} \ncatch ( StageException e ) { \nExceptionUtils . throwUndeclared ( e ) ; \n} \n} \n} \n"}
{"2240": "public class AvroSchemaHelper { \npublic Schema loadFromRegistry ( String subject , int schemaId ) throws SchemaRegistryException { \ntry { \nif ( ! ( isEmpty ( subject ) ) ) { \nreturn loadFromRegistry ( subject ) ; \n} \nelse { \nreturn loadFromRegistry ( schemaId ) ; \n} \n} \ncatch ( SchemaRegistryException e ) { \nthrow new SchemaRegistryException ( e ) ; \n} \n} \n} \n"}
{"2255": "public class OffsetUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static Map < String , String > deserializeOffsetMap ( String lastSourceOffset ) throws IOException { \nMap < String , String > offsetMap ; \nif ( ! ( lastSourceOffset == null || lastSourceOffset . isEmpty ( ) ) ) { \noffsetMap = JSON_MAPPER . readValue ( lastSourceOffset , Map . class ) ; \n} \nelse { \noffsetMap = new HashMap < > ( ) ; \n} \nreturn offsetMap ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! ( ! root . has ( \"error\" ) ) ) { \nif ( ! ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) ) { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \nelse { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \n} \nelse { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2264": "public class FileContext { \npublic void releaseReader ( boolean inErrorDiscardReader ) throws IOException { \nUtils . checkState ( open , \"FileContext is closed\" ) ; \nboolean hasNext ; \ntry { \nhasNext = reader != null && reader . hasNext ( ) ; \n} \ncatch ( IOException ex ) { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nhasNext = false ; \n} \nboolean doneWithFile = ! hasNext || inErrorDiscardReader ; \nif ( ! ( doneWithFile ) ) { \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( getReader ( ) . getOffset ( ) ) ; \n} \nelse { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( Long . MAX_VALUE ) ; \nif ( currentFile == null ) { \nreturn ; \n} \nLiveFile file = currentFile . refresh ( ) ; \nif ( ! ( inErrorDiscardReader ) ) { \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . END ) ) ; \nswitch ( postProcessing ) { \ncase NONE : LOG . debug ( \"File '{}' processing completed, post processing action 'NONE'\" , file ) ; \nbreak ; \ncase DELETE : if ( ! inPreviewMode ) { \ntry { \nFiles . delete ( file . getPath ( ) ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'DELETED'\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not delete '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \n} \nbreak ; \ncase ARCHIVE : if ( ! inPreviewMode ) { \nPath fileArchive = Paths . get ( archiveDir , file . getPath ( ) . toString ( ) ) ; \nif ( fileArchive == null ) { \nthrow new IOException ( \"Could not find archive file\" ) ; \n} \ntry { \nFiles . createDirectories ( fileArchive . getParent ( ) ) ; \nFiles . move ( file . getPath ( ) , fileArchive ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'ARCHIVED' as\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not archive '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \n} \nbreak ; \n} \n} \nelse { \nLOG . warn ( \"Processing file '{}' produced an error, skipping '{}' post processing on that file\" , file , postProcessing ) ; \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . ERROR ) ) ; \n} \n} \n} \n} \n"}
{"2274": "public class AvroSchemaGenerator { \npublic static Schema buildSchema ( Map < String , Schema > fields , Object ... levels ) { \nList < Schema . Field > recordFields = new ArrayList < > ( fields . size ( ) ) ; \nfor ( Map . Entry < String , Schema > entry : fields . entrySet ( ) ) { \nrecordFields . add ( new Schema . Field ( entry . getKey ( ) , entry . getValue ( ) , null , entry . getValue ( ) . getJsonProp ( \"default\" ) ) ) ; \n} \nSchema recordSchema ; \nif ( ! ( levels . length == 0 ) ) { \nLinkedList < String > lvl = ( LinkedList < String > ) levels [ 0 ] ; \nrecordSchema = Schema . createRecord ( joiner . join ( lvl ) , null , null , false ) ; \n} \nelse { \nrecordSchema = Schema . createRecord ( schemaName , null , null , false ) ; \n} \nrecordSchema . setFields ( recordFields ) ; \nreturn recordSchema ; \n} \n} \n"}
{"2281": "public class BootstrapMain { \npublic static void premain ( String args , Instrumentation instrumentation ) { \nif ( ! ( BootstrapMain . instrumentation == null ) ) { \nthrow new IllegalStateException ( \"Premain method cannot be called twice (\" + BootstrapMain . instrumentation + \")\" ) ; \n} \nelse { \nBootstrapMain . instrumentation = instrumentation ; \n} \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( timeout >= 1000 , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( ! ( queryJob == null ) ) if ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \nelse { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nwhile ( ! queryJob . isDone ( ) ) { \nif ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { \nif ( ! ( bigquery . cancel ( queryJob . getJobId ( ) ) ) ) { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( ! ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) ) if ( ! ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) ) if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \nelse { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \n} \nreturn root ; \n} \n} \n"}
{"2286": "public class KineticaTableUtils { \nprivate void validateTableAcceptsInserts ( ) throws GPUdbException { \nfor ( String s : tableDescription ) { \nif ( ! ( s . equalsIgnoreCase ( \"COLLECTION\" ) ) ) if ( ! ( s . equalsIgnoreCase ( \"VIEW\" ) ) ) if ( ! ( s . equalsIgnoreCase ( \"JOIN\" ) ) ) if ( s . equalsIgnoreCase ( \"RESULT_TABLE\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Result Table\" ) ; \n} \nelse { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Join Table\" ) ; \n} \nelse { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a View\" ) ; \n} \nelse { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Collection\" ) ; \n} \n} \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( ! ( field . get ( \"type\" ) instanceof JSONArray ) ) { \ncolumnType = getClassForType ( field . getString ( \"type\" ) ) ; \n} \nelse { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \n} \n} \nif ( columnType == null ) { \nthrow new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \n} \nreturn columnType ; \n} \n} \n"}
{"2291": "public class KineticaTableUtils { \nprivate Class < ? > getClassForType ( String typeName ) throws GPUdbException { \ntypeName = typeName . replace ( \" \" , \"\" ) ; \nif ( ! ( typeName . equalsIgnoreCase ( STRING_TYPE_NAME ) ) ) if ( ! ( typeName . equalsIgnoreCase ( LONG_TYPE_NAME ) ) ) if ( ! ( typeName . equalsIgnoreCase ( INTEGER_TYPE_NAME ) ) ) if ( ! ( typeName . equalsIgnoreCase ( FLOAT_TYPE_NAME ) ) ) if ( ! ( typeName . equalsIgnoreCase ( DOUBLE_TYPE_NAME ) ) ) if ( ! ( typeName . equalsIgnoreCase ( BYTES_TYPE_NAME ) ) ) { \nthrow new GPUdbException ( \"Error: unknown type '\" + typeName + \"' in table schema\" ) ; \n} \nelse { \nreturn ByteBuffer . class ; \n} \nelse { \nreturn Double . class ; \n} \nelse { \nreturn Float . class ; \n} \nelse { \nreturn Integer . class ; \n} \nelse { \nreturn Long . class ; \n} \nelse { \nreturn String . class ; \n} \n} \n} \n"}
{"2308": "public class LoginManager { \npublic void release ( ) { \nsynchronized ( LoginManager . class ) { \nif ( ! ( refCount == 0 ) ) if ( refCount == 1 ) { \nCACHED_INSTANCES . remove ( loginType ) ; \nlogin . shutdown ( ) ; \n} \nelse throw new IllegalStateException ( \"release called on LoginManager with refCount == 0\" ) ; \n-- refCount ; \n} \n} \n} \n"}
{"2314": "public class CassandraTarget { \n@ SuppressWarnings ( \"unchecked\" ) private BoundStatement recordToBoundStatement ( Record record ) throws StageException { \nImmutableList . Builder < Object > values = new ImmutableList . Builder < > ( ) ; \nSortedSet < String > columnsPresent = Sets . newTreeSet ( columnMappings . keySet ( ) ) ; \nfor ( Map . Entry < String , String > mapping : columnMappings . entrySet ( ) ) { \nString columnName = mapping . getKey ( ) ; \nString fieldPath = mapping . getValue ( ) ; \nif ( ! record . has ( fieldPath ) || record . get ( fieldPath ) . getValue ( ) == null ) { \ncolumnsPresent . remove ( columnName ) ; \ncontinue ; \n} \nfinal Object value = record . get ( fieldPath ) . getValue ( ) ; \nif ( ! ( value instanceof List ) ) if ( ! ( value instanceof Map ) ) { \nvalues . add ( value ) ; \n} \nelse { \nMap < Object , Object > unpackedMap = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Field > entry : ( ( Map < String , Field > ) value ) . entrySet ( ) ) { \nunpackedMap . put ( entry . getKey ( ) , entry . getValue ( ) . getValue ( ) ) ; \n} \nvalues . add ( unpackedMap ) ; \n} \nelse { \nList < Object > unpackedList = new ArrayList < > ( ) ; \nfor ( Field item : ( List < Field > ) value ) { \nunpackedList . add ( item . getValue ( ) ) ; \n} \nvalues . add ( unpackedList ) ; \n} \n} \nPreparedStatement stmt = statementCache . getUnchecked ( columnsPresent ) ; \nObject [ ] valuesArray = values . build ( ) . toArray ( ) ; \nBoundStatement boundStmt = null ; \ntry { \nboundStmt = stmt . bind ( valuesArray ) ; \n} \ncatch ( CodecNotFoundException | InvalidTypeException | NullPointerException e ) { \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) , e ) ) ; \n} \nreturn boundStmt ; \n} \n} \n"}
{"2315": "public class Configuration { \npublic void set ( Map < String , String > newConfiguration ) { \nfor ( Map . Entry < String , String > entry : newConfiguration . entrySet ( ) ) { \nif ( ! ( entry . getValue ( ) == null ) ) { \nthis . set ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nelse { \nthis . unset ( entry . getKey ( ) ) ; \n} \n} \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { \ncontinue ; \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( ! ( partitioningTurnedOff ) ) if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nelse { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2320": "public class SchAdmin { \npublic static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { \nUtils . checkNotNull ( dpmInfo , \"DPMInfo\" ) ; \nString dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; \nString currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ; \nString currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , \"\" ) . trim ( ) ; \nif ( ! currentDPMBaseURL . equals ( dpmBaseURL ) || currentAppAuthToken . length ( ) == 0 ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) { \nthrow new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( ! ( newComponent . size ( ) > 0 ) ) { \nthrow new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \nelse { \nappAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nupdateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; \n} \n} \n"}
{"2326": "public class SchAdmin { \nprivate static void updateDpmProperties ( Context context , String dpmBaseURL , List < String > labels , boolean enableSch ) { \nif ( context . skipUpdatingDpmProperties ) { \nreturn ; \n} \ntry { \nFileBasedConfigurationBuilder < PropertiesConfiguration > builder = new FileBasedConfigurationBuilder < > ( PropertiesConfiguration . class ) . configure ( new Parameters ( ) . properties ( ) . setFileName ( context . runtimeInfo . getConfigDir ( ) + \"/dpm.properties\" ) . setThrowExceptionOnMissing ( true ) . setListDelimiterHandler ( new DefaultListDelimiterHandler ( ';' ) ) . setIncludesAllowed ( false ) ) ; \nPropertiesConfiguration config = null ; \nconfig = builder . getConfiguration ( ) ; \nconfig . setProperty ( RemoteSSOService . DPM_ENABLED , Boolean . toString ( enableSch ) ) ; \nconfig . setProperty ( RemoteSSOService . DPM_BASE_URL_CONFIG , dpmBaseURL ) ; \nconfig . setProperty ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , APP_TOKEN_FILE_PROP_VAL ) ; \nif ( ! ( labels != null && labels . size ( ) > 0 ) ) { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , \"\" ) ; \n} \nelse { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , StringUtils . join ( labels , ',' ) ) ; \n} \nbuilder . save ( ) ; \n} \ncatch ( ConfigurationException e ) { \nthrow new RuntimeException ( Utils . format ( \"Updating dpm.properties file failed: {}\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n"}
{"2339": "public class Pattern { \nstatic public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { \nMap < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; \njava . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; \nwhile ( matcher . find ( ) ) { \nint pos = matcher . start ( ) ; \nif ( isEscapedChar ( namedPattern , pos ) ) continue ; \nString name = matcher . group ( INDEX_GROUP_NAME ) ; \nint groupIndex = countOpenParens ( namedPattern , pos ) ; \nList < GroupInfo > list ; \nif ( ! ( groupInfo . containsKey ( name ) ) ) { \nlist = new ArrayList < GroupInfo > ( ) ; \n} \nelse { \nlist = groupInfo . get ( name ) ; \n} \nlist . add ( new GroupInfo ( groupIndex , pos ) ) ; \ngroupInfo . put ( name , list ) ; \n} \nreturn groupInfo ; \n} \n} \n"}
{"2341": "public class JMXJsonServlet { \n@ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) { \ntry { \nJsonGenerator jg = null ; \nString jsonpcb = null ; \nPrintWriter writer = null ; \ntry { \nwriter = response . getWriter ( ) ; \njsonpcb = request . getParameter ( CALLBACK_PARAM ) ; \nif ( ! ( jsonpcb != null ) ) { \nresponse . setContentType ( \"application/json; charset=utf8\" ) ; \n} \nelse { \nresponse . setContentType ( \"application/javascript; charset=utf8\" ) ; \nwriter . write ( jsonpcb + \"(\" ) ; \n} \njg = jsonFactory . createGenerator ( writer ) ; \njg . disable ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ; \njg . useDefaultPrettyPrinter ( ) ; \njg . writeStartObject ( ) ; \nString getmethod = request . getParameter ( \"get\" ) ; \nif ( getmethod != null ) { \nString [ ] splitStrings = getmethod . split ( \"\\\\:\\\\:\" ) ; \nif ( splitStrings . length != 2 ) { \njg . writeStringField ( \"result\" , \"ERROR\" ) ; \njg . writeStringField ( \"message\" , \"query format is not as expected.\" ) ; \njg . flush ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nlistBeans ( jg , new ObjectName ( splitStrings [ 0 ] ) , splitStrings [ 1 ] , response ) ; \nreturn ; \n} \nString qry = request . getParameter ( \"qry\" ) ; \nif ( qry == null ) { \nqry = \"*:*\" ; \n} \nlistBeans ( jg , new ObjectName ( qry ) , null , response ) ; \n} \nfinally { \nif ( jg != null ) { \njg . close ( ) ; \n} \nif ( jsonpcb != null ) { \nwriter . write ( \");\" ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \nresponse . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \n} \n} \n} \n"}
{"2345": "public class SingleLineLiveFileReader { \nprivate boolean fastForward ( ) throws IOException { \ntry { \nboolean stillTruncate ; \nbuffer . clear ( ) ; \nif ( ! ( channel . read ( buffer ) > - 1 || isEof ( ) ) ) { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \nelse { \nbuffer . flip ( ) ; \nint firstEolIdx = findEndOfFirstLine ( buffer ) ; \nif ( ! ( firstEolIdx > - 1 ) ) { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \nelse { \nbuffer . position ( firstEolIdx + 1 ) ; \nbuffer . compact ( ) ; \nstillTruncate = false ; \noffset = channel . position ( ) - buffer . position ( ) ; \n} \n} \nreturn stillTruncate ; \n} \ncatch ( IOException ex ) { \ncloseChannel ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2347": "public class MathEL { \nprivate static Object convertStringToAppropriateNumber ( String value ) { \nif ( ! ( value . contains ( \".\" ) ) ) { \nreturn Long . valueOf ( value ) ; \n} \nelse { \nreturn Double . valueOf ( value ) ; \n} \n} \n} \n"}
{"2353": "public class JdbcBaseRecordWriter { \nprotected String getTableName ( ) { \nif ( ! Strings . isNullOrEmpty ( schema ) ) { \nif ( ! ( caseSensitive ) ) { \nreturn schema + \".\" + tableName ; \n} \nelse { \nreturn \"\\\"\" + schema + \"\\\".\" + \"\\\"\" + tableName + \"\\\"\" ; \n} \n} \nif ( caseSensitive ) { \nreturn \"\\\"\" + tableName + \"\\\"\" ; \n} \nreturn tableName ; \n} \n} \n"}
{"2365": "public class SupportBundleManager { \nprivate List < BundleContentGeneratorDefinition > getRequestedDefinitions ( List < String > generators ) { \nStream < BundleContentGeneratorDefinition > stream = definitions . stream ( ) ; \nif ( ! ( generators == null || generators . isEmpty ( ) ) ) { \nstream = stream . filter ( def -> generators . contains ( def . getId ( ) ) ) ; \n} \nelse { \nstream = stream . filter ( BundleContentGeneratorDefinition :: isEnabledByDefault ) ; \n} \nreturn stream . sorted ( Comparator . comparingInt ( BundleContentGeneratorDefinition :: getOrder ) ) . collect ( Collectors . toList ( ) ) ; \n} \n} \n"}
{"2376": "public class JdbcRecordReaderWriterFactory { \npublic static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , DuplicateKeyAction duplicateKeyAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { \nif ( ! ( defaultOpCode == OperationType . LOAD_CODE ) ) { \nreturn createJdbcRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , null , rollbackOnError , useMultiRowOp , maxPrepStmtParameters , defaultOpCode , unsupportedAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; \n} \nelse { \nreturn new JdbcLoadRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , duplicateKeyAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; \n} \n} \n} \n"}
{"2377": "public class JdbcRecordReaderWriterFactory { \npublic static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , List < JdbcFieldColumnMapping > generatedColumnMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { \nJdbcRecordWriter recordWriter ; \nif ( ! ( useMultiRowOp ) ) { \nrecordWriter = new JdbcGenericRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; \n} \nelse { \nrecordWriter = new JdbcMultiRowRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , maxPrepStmtParameters , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; \n} \nreturn recordWriter ; \n} \n} \n"}
{"2383": "public class RemoteDataCollector { \n@ Override public List < PipelineAndValidationStatus > getRemotePipelinesWithChanges ( ) throws PipelineException { \nList < PipelineAndValidationStatus > pipelineAndValidationStatuses = new ArrayList < > ( ) ; \nfor ( Pair < PipelineState , Map < String , String > > pipelineStateAndOffset : stateEventListener . getPipelineStateEvents ( ) ) { \nPipelineState pipelineState = pipelineStateAndOffset . getLeft ( ) ; \nMap < String , String > offset = pipelineStateAndOffset . getRight ( ) ; \nString name = pipelineState . getPipelineId ( ) ; \nString rev = pipelineState . getRev ( ) ; \nboolean isClusterMode = ( pipelineState . getExecutionMode ( ) != ExecutionMode . STANDALONE ) ? true : false ; \nList < WorkerInfo > workerInfos = new ArrayList < > ( ) ; \nString title ; \nint runnerCount = 0 ; \nif ( ! ( pipelineStore . hasPipeline ( name ) ) ) { \ntitle = null ; \n} \nelse { \ntitle = pipelineStore . getInfo ( name ) . getTitle ( ) ; \nRunner runner = manager . getRunner ( name , rev ) ; \nif ( isClusterMode ) { \nworkerInfos = getWorkers ( runner . getSlaveCallbackList ( CallbackObjectType . METRICS ) ) ; \n} \nrunnerCount = runner . getRunnerCount ( ) ; \n} \npipelineAndValidationStatuses . add ( new PipelineAndValidationStatus ( getSchGeneratedPipelineName ( name , rev ) , title , rev , pipelineState . getTimeStamp ( ) , true , pipelineState . getStatus ( ) , pipelineState . getMessage ( ) , workerInfos , isClusterMode , getSourceOffset ( name , offset ) , null , runnerCount ) ) ; \n} \nreturn pipelineAndValidationStatuses ; \n} \n} \n"}
{"2386": "public class JdbcMongoDBOplogRecordReader { \n@ Override public SortedMap < String , String > getColumnsToParameters ( final Record record , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { \nSortedMap < String , String > columnsToParameters = new TreeMap < > ( ) ; \nfor ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { \nString columnName = entry . getKey ( ) ; \nString fieldPath = getFieldPath ( columnName , columnsToFields , op ) ; \nif ( ! ( record . has ( fieldPath ) ) ) { \nLOG . trace ( \"Record is missing a field for column {} for the operation code {}\" , columnName , op ) ; \n} \nelse { \ncolumnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; \n} \n} \nreturn columnsToParameters ; \n} \n} \n"}
{"2397": "public class FieldEncrypter { \npublic byte [ ] prepareEncrypt ( Field field , Map < String , String > context ) { \ncontext . put ( SDC_FIELD_TYPE , field . getType ( ) . name ( ) ) ; \nif ( ! ( field . getType ( ) == Field . Type . BYTE_ARRAY ) ) { \nreturn field . getValueAsString ( ) . getBytes ( Charsets . UTF_8 ) ; \n} \nelse { \nreturn field . getValueAsByteArray ( ) ; \n} \n} \n} \n"}
{"2403": "public class Util { \npublic static String getGlobalVariable ( DataSource dataSource , String variable ) throws SQLException { \ntry ( Connection conn = dataSource . getConnection ( ) ) { \ntry ( Statement stmt = conn . createStatement ( ) ; \nResultSet rs = stmt . executeQuery ( String . format ( \"show global variables like '%s'\" , variable ) ) ; \n) { \nif ( ! ( rs . next ( ) ) ) { \nreturn \"\" ; \n} \nelse { \nreturn rs . getString ( 2 ) ; \n} \n} \n} \n} \n} \n"}
{"2407": "public class ConfigValueExtractor { \nprivate Object extractAsRuntime ( Field field , String valueStr ) { \nif ( ! ( field . getType ( ) == Byte . TYPE || field . getType ( ) == Byte . class || field . getType ( ) == Short . TYPE || field . getType ( ) == Short . class || field . getType ( ) == Integer . TYPE || field . getType ( ) == Integer . class || field . getType ( ) == Long . TYPE || field . getType ( ) == Long . class || field . getType ( ) == Float . TYPE || field . getType ( ) == Float . class || field . getType ( ) == Double . TYPE || field . getType ( ) == Double . class ) ) if ( String . class . isAssignableFrom ( field . getType ( ) ) ) { \nreturn valueStr ; \n} \nelse { \nreturn extractAsNumber ( field , valueStr ) ; \n} \nthrow new IllegalArgumentException ( Utils . format ( \"Invalid type for RUNTIME type: {}\" , field . getType ( ) ) ) ; \n} \n} \n"}
{"2444": "public class HTTPSession { \npublic long getBodySize ( ) { \nif ( ! ( this . headers . containsKey ( \"content-length\" ) ) ) if ( this . splitbyte < this . rlen ) { \nreturn this . rlen - this . splitbyte ; \n} \nelse { \nreturn Long . parseLong ( this . headers . get ( \"content-length\" ) ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"2451": "public class Response { \npublic void send ( OutputStream outputStream ) { \nSimpleDateFormat gmtFrmt = new SimpleDateFormat ( \"E, d MMM yyyy HH:mm:ss 'GMT'\" , Locale . US ) ; \ngmtFrmt . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; \ntry { \nif ( this . status == null ) { \nthrow new Error ( \"sendResponse(): Status can't be null.\" ) ; \n} \nPrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( outputStream , new ContentType ( this . mimeType ) . getEncoding ( ) ) ) , false ) ; \npw . append ( \"HTTP/1.1 \" ) . append ( this . status . getDescription ( ) ) . append ( \" \\r\\n\" ) ; \nif ( this . mimeType != null ) { \nprintHeader ( pw , \"Content-Type\" , this . mimeType ) ; \n} \nif ( getHeader ( \"date\" ) == null ) { \nprintHeader ( pw , \"Date\" , gmtFrmt . format ( new Date ( ) ) ) ; \n} \nfor ( Entry < String , String > entry : this . header . entrySet ( ) ) { \nprintHeader ( pw , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nfor ( String cookieHeader : this . cookieHeaders ) { \nprintHeader ( pw , \"Set-Cookie\" , cookieHeader ) ; \n} \nif ( getHeader ( \"connection\" ) == null ) { \nprintHeader ( pw , \"Connection\" , ( this . keepAlive ? \"keep-alive\" : \"close\" ) ) ; \n} \nif ( getHeader ( \"content-length\" ) != null ) { \nsetUseGzip ( false ) ; \n} \nif ( useGzipWhenAccepted ( ) ) { \nprintHeader ( pw , \"Content-Encoding\" , \"gzip\" ) ; \nsetChunkedTransfer ( true ) ; \n} \nlong pending = this . data != null ? this . contentLength : 0 ; \nif ( ! ( this . requestMethod != Method . HEAD && this . chunkedTransfer ) ) if ( ! useGzipWhenAccepted ( ) ) { \npending = sendContentLengthHeaderIfNotAlreadyPresent ( pw , pending ) ; \n} \nelse { \nprintHeader ( pw , \"Transfer-Encoding\" , \"chunked\" ) ; \n} \npw . append ( \"\\r\\n\" ) ; \npw . flush ( ) ; \nsendBodyWithCorrectTransferAndEncoding ( outputStream , pending ) ; \noutputStream . flush ( ) ; \nNanoHTTPD . safeClose ( this . data ) ; \n} \ncatch ( IOException ioe ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not send response to the client\" , ioe ) ; \n} \n} \n} \n"}
{"2454": "public class Response { \npublic boolean useGzipWhenAccepted ( ) { \nif ( ! ( gzipUsage == GzipUsage . DEFAULT ) ) return gzipUsage == GzipUsage . ALWAYS ; \nelse return getMimeType ( ) != null && ( getMimeType ( ) . toLowerCase ( ) . contains ( \"text/\" ) || getMimeType ( ) . toLowerCase ( ) . contains ( \"/json\" ) ) ; \n} \n} \n"}
{"2466": "public class JCAOrderedLastSynchronizationList { \npublic void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { \nint status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; \nswitch ( status ) { \ncase javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; \ncase Status . STATUS_MARKED_ROLLBACK : return ; \ndefault : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; \n} \nif ( ! ( synchronization . getClass ( ) . getName ( ) . startsWith ( \"org.jboss.jca\" ) ) ) { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \npreJcaSyncs . add ( synchronization ) ; \n} \nelse { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \njcaSyncs . add ( synchronization ) ; \n} \n} \n} \n"}
{"2472": "public class EJBReadWriteLock { \nprivate void decReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nassert current != null : \"can't decrease, readLockCount is not set\" ; \nnext = current . intValue ( ) - 1 ; \nif ( ! ( next == 0 ) ) readLockCount . set ( new Integer ( next ) ) ; \nelse readLockCount . remove ( ) ; \n} \n} \n"}
{"2473": "public class EJBReadWriteLock { \nprivate void incReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nif ( ! ( current == null ) ) next = current . intValue ( ) + 1 ; \nelse next = 1 ; \nreadLockCount . set ( new Integer ( next ) ) ; \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) { \nsynchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) { \ncontinue ; \n} \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ! ( ejbsForViewName . isEmpty ( ) ) ) if ( ! ( ejbsForViewName . size ( ) > 1 ) ) { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \nelse { \nif ( ! ( beanName == null ) ) { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \n} \n} \nelse { \nif ( ! ( beanName == null ) ) { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \n} \n} \nresolved = true ; \n} \n} \n} \n} \n} \n"}
{"2499": "public class InitialContext { \npublic static synchronized void removeUrlContextFactory ( final String scheme , ObjectFactory factory ) { \nMap < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; \nObjectFactory f = factories . get ( scheme ) ; \nif ( ! ( f == factory ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse { \nfactories . remove ( scheme ) ; \nurlContextFactories = Collections . unmodifiableMap ( factories ) ; \nreturn ; \n} \n} \n} \n"}
{"2500": "public class WildFlyProviderResolver { \nprivate List < ValidationProvider < ? > > loadProviders ( ClassLoader classLoader ) { \n@ SuppressWarnings ( \"rawtypes\" ) Iterator < ValidationProvider > providerIterator = ServiceLoader . load ( ValidationProvider . class , classLoader ) . iterator ( ) ; \nLinkedList < ValidationProvider < ? > > providers = new LinkedList < ValidationProvider < ? > > ( ) ; \nwhile ( providerIterator . hasNext ( ) ) { \ntry { \nValidationProvider < ? > provider = providerIterator . next ( ) ; \nif ( ! ( provider . getClass ( ) . getName ( ) . equals ( \"org.hibernate.validator.HibernateValidator\" ) ) ) { \nproviders . add ( provider ) ; \n} \nelse { \nproviders . addFirst ( provider ) ; \n} \n} \ncatch ( ServiceConfigurationError e ) { \n} \n} \nreturn providers ; \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null && endpointClassName . length ( ) > 0 ) { \nif ( ! ( epNames . contains ( endpointClassName ) ) ) if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { \nthrow WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \nelse { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \n} \n} \n} \n} \n"}
{"2505": "public class SecurityActions { \nstatic RunAs setRunAsIdentity ( final RunAs principal , final SecurityContext sc ) { \nif ( ! ( WildFlySecurityManager . isChecking ( ) ) ) { \nif ( sc == null ) { \nthrow UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \n} \nRunAs old = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( principal ) ; \nreturn old ; \n} \nelse { \nreturn WildFlySecurityManager . doUnchecked ( new PrivilegedAction < RunAs > ( ) { \n@ Override public RunAs run ( ) { \nif ( sc == null ) { \nthrow UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \n} \nRunAs old = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( principal ) ; \nreturn old ; \n} \n} \n) ; \n} \n} \n} \n"}
{"2506": "public class SecurityActions { \nstatic RunAs popRunAsIdentity ( final SecurityContext sc ) { \nif ( ! ( WildFlySecurityManager . isChecking ( ) ) ) { \nif ( sc == null ) { \nthrow UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \n} \nRunAs principal = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( null ) ; \nreturn principal ; \n} \nelse { \nreturn AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { \n@ Override public RunAs run ( ) { \nif ( sc == null ) { \nthrow UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \n} \nRunAs principal = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( null ) ; \nreturn principal ; \n} \n} \n) ; \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( ! ( hits . size ( ) == 1 ) ) { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \nelse { \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( ! ( hits . size ( ) == 1 ) ) { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \nelse { \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2520": "public class StubStrategy { \npublic Exception readException ( String id , InputStream in ) { \nExceptionReader exceptionReader = ( ExceptionReader ) exceptionMap . get ( id ) ; \nif ( ! ( exceptionReader == null ) ) { \nreturn exceptionReader . read ( in ) ; \n} \nelse { \nreturn new UnexpectedException ( id ) ; \n} \n} \n} \n"}
{"2529": "public class JPAService { \npublic static Resource createManagementStatisticsResource ( final ManagementAdaptor managementAdaptor , final String scopedPersistenceUnitName , final DeploymentUnit deploymentUnit ) { \nsynchronized ( existingResourceDescriptionResolver ) { \nfinal EntityManagerFactoryLookup entityManagerFactoryLookup = new EntityManagerFactoryLookup ( ) ; \nfinal Statistics statistics = managementAdaptor . getStatistics ( ) ; \nif ( false == existingResourceDescriptionResolver . contains ( managementAdaptor . getVersion ( ) ) ) { \nResourceDescriptionResolver resourceDescriptionResolver = new StandardResourceDescriptionResolver ( statistics . getResourceBundleKeyPrefix ( ) , statistics . getResourceBundleName ( ) , statistics . getClass ( ) . getClassLoader ( ) ) { \nprivate ResourceDescriptionResolver fallback = JPAExtension . getResourceDescriptionResolver ( ) ; \n@ Override public String getResourceAttributeDescription ( String attributeName , Locale locale , ResourceBundle bundle ) { \nif ( ! ( bundle . containsKey ( getBundleKey ( attributeName ) ) ) ) { \nreturn fallback . getResourceAttributeDescription ( attributeName , locale , fallback . getResourceBundle ( locale ) ) ; \n} \nelse { \nreturn super . getResourceAttributeDescription ( attributeName , locale , bundle ) ; \n} \n} \n} \n; \nPathElement subsystemPE = PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM , JPAExtension . SUBSYSTEM_NAME ) ; \nManagementResourceRegistration deploymentResourceRegistration = deploymentUnit . getAttachment ( DeploymentModelUtils . MUTABLE_REGISTRATION_ATTACHMENT ) ; \nManagementResourceRegistration deploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( subsystemPE ) ) ; \nManagementResourceRegistration subdeploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBDEPLOYMENT ) , subsystemPE ) ) ; \nManagementResourceRegistration providerResource = deploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; \nproviderResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; \nproviderResource = subdeploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; \nproviderResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; \nexistingResourceDescriptionResolver . add ( managementAdaptor . getVersion ( ) ) ; \n} \nreturn new DynamicManagementStatisticsResource ( statistics , scopedPersistenceUnitName , managementAdaptor . getIdentificationLabel ( ) , entityManagerFactoryLookup ) ; \n} \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeSize ; \ni ++ ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { \nif ( ! ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) ) { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \nelse { \nif ( ! ( jndiName . contains ( \"/\" ) ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2574": "public class AbstractDeploymentDescriptorBindingsProcessor { \nprotected Class < ? > processInjectionTargets ( final ResourceInjectionTarget resourceInjectionTarget , InjectionSource injectionSource , ClassLoader classLoader , DeploymentReflectionIndex deploymentReflectionIndex , ResourceInjectionMetaData entry , Class < ? > classType ) throws DeploymentUnitProcessingException { \nif ( entry . getInjectionTargets ( ) != null ) { \nfor ( ResourceInjectionTargetMetaData injectionTarget : entry . getInjectionTargets ( ) ) { \nfinal String injectionTargetClassName = injectionTarget . getInjectionTargetClass ( ) ; \nfinal String injectionTargetName = injectionTarget . getInjectionTargetName ( ) ; \nfinal AccessibleObject fieldOrMethod = getInjectionTarget ( injectionTargetClassName , injectionTargetName , classLoader , deploymentReflectionIndex ) ; \nfinal Class < ? > injectionTargetType = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getType ( ) : ( ( Method ) fieldOrMethod ) . getParameterTypes ( ) [ 0 ] ; \nfinal String memberName = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getName ( ) : ( ( Method ) fieldOrMethod ) . getName ( ) ; \nif ( ! ( classType != null ) ) { \nclassType = injectionTargetType ; \n} \nelse { \nif ( ! injectionTargetType . isAssignableFrom ( classType ) ) { \nboolean ok = false ; \nif ( ! ( classType . isPrimitive ( ) ) ) if ( injectionTargetType . isPrimitive ( ) ) { \nif ( BOXED_TYPES . get ( injectionTargetType ) . equals ( classType ) ) { \nok = true ; \n} \n} \nelse { \nif ( BOXED_TYPES . get ( classType ) . equals ( injectionTargetType ) ) { \nok = true ; \n} \n} \nif ( ! ok ) { \nthrow EeLogger . ROOT_LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName ( ) , injectionTarget . getInjectionTargetClass ( ) , classType ) ; \n} \nclassType = injectionTargetType ; \n} \n} \nfinal InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ? new FieldInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) : new MethodInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) ; \nfinal ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration ( injectionTargetDescription , injectionSource ) ; \nresourceInjectionTarget . addResourceInjection ( injectionConfiguration ) ; \n} \n} \nreturn classType ; \n} \n} \n"}
{"2578": "public class WarJACCService { \nstatic int getPatternType ( String urlPattern ) { \nint type = EXACT ; \nif ( ! ( urlPattern . startsWith ( \"*.\" ) ) ) if ( ! ( urlPattern . startsWith ( \"/\" ) && urlPattern . endsWith ( \"/*\" ) ) ) if ( urlPattern . equals ( \"/\" ) ) type = DEFAULT ; \nelse type = PREFIX ; \nelse type = EXTENSION ; \nreturn type ; \n} \n} \n"}
{"2585": "public class EJBSuspendHandlerService { \n@ Override public void suspended ( ServerActivityCallback listener ) { \nthis . suspended = true ; \nlistenerUpdater . set ( this , listener ) ; \nlocalTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; \nfinal int activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; \nif ( activeInvocationCount == 0 ) { \nif ( ! ( gracefulTxnShutdown ) ) { \nthis . doneSuspended ( ) ; \n} \nelse { \nif ( ! ( activeTransactionCountUpdater . get ( this ) == 0 ) ) { \nEjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; \n} \nelse { \nthis . doneSuspended ( ) ; \n} \n} \n} \n} \n} \n"}
{"2592": "public class WarStructureDeploymentProcessor { \nprivate List < ResourceRoot > createResourceRoots ( final VirtualFile deploymentRoot , final DeploymentUnit deploymentUnit ) throws IOException , DeploymentUnitProcessingException { \nfinal List < ResourceRoot > entries = new ArrayList < ResourceRoot > ( ) ; \nfinal VirtualFile webinfClasses = deploymentRoot . getChild ( WEB_INF_CLASSES ) ; \nif ( webinfClasses . exists ( ) ) { \nfinal ResourceRoot webInfClassesRoot = new ResourceRoot ( webinfClasses . getName ( ) , webinfClasses , null ) ; \nModuleRootMarker . mark ( webInfClassesRoot ) ; \nentries . add ( webInfClassesRoot ) ; \n} \nMap < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_OVERLAY_LOCATIONS ) ; \nfinal VirtualFile webinfLib = deploymentRoot . getChild ( WEB_INF_LIB ) ; \nif ( webinfLib . exists ( ) ) { \nfinal List < VirtualFile > archives = webinfLib . getChildren ( DEFAULT_WEB_INF_LIB_FILTER ) ; \nfor ( final VirtualFile archive : archives ) { \ntry { \nString relativeName = archive . getPathNameRelativeTo ( deploymentRoot ) ; \nMountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; \nCloseable closable = null ; \nif ( ! ( overlay != null ) ) if ( ! ( archive . isFile ( ) ) ) { \nclosable = null ; \n} \nelse { \nclosable = VFS . mountZip ( archive , archive , TempFileProviderService . provider ( ) ) ; \n} \nelse { \noverlay . remountAsZip ( false ) ; \n} \nfinal ResourceRoot webInfArchiveRoot = new ResourceRoot ( archive . getName ( ) , archive , new MountHandle ( closable ) ) ; \nModuleRootMarker . mark ( webInfArchiveRoot ) ; \nentries . add ( webInfArchiveRoot ) ; \n} \ncatch ( IOException e ) { \nthrow new DeploymentUnitProcessingException ( UndertowLogger . ROOT_LOGGER . failToProcessWebInfLib ( archive ) , e ) ; \n} \n} \n} \nreturn entries ; \n} \n} \n"}
{"2594": "public class Configuration { \npublic static boolean needClassFileTransformer ( PersistenceUnitMetadata pu ) { \nboolean result = true ; \nString provider = pu . getPersistenceProviderClassName ( ) ; \nif ( ! ( pu . getProperties ( ) . containsKey ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ) if ( isHibernateProvider ( provider ) ) { \nresult = ( Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_USE_CLASS_ENHANCER ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_DIRTY_TRACKING ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_LAZY_INITIALIZATION ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT ) ) ) ; \n} \nelse { \nresult = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"2597": "public class Configuration { \npublic static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { \nboolean result = false ; \nif ( ! ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) ) if ( emf . getProperties ( ) != null && emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { \nresult = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \nelse { \nresult = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"2598": "public class CorbaUtils { \npublic static ORB getOrb ( String server , int port , Hashtable env ) { \nProperties orbProp ; \nif ( ! ( env != null ) ) { \norbProp = orbProperties ; \n} \nelse { \norbProp = new Properties ( ) ; \nfinal Enumeration envProp = env . keys ( ) ; \nwhile ( envProp . hasMoreElements ( ) ) { \nString key = ( String ) envProp . nextElement ( ) ; \nObject val = env . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \nfinal Enumeration mainProps = orbProperties . keys ( ) ; \nwhile ( mainProps . hasMoreElements ( ) ) { \nString key = ( String ) mainProps . nextElement ( ) ; \nObject val = orbProperties . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \n} \nif ( server != null ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialHost\" , server ) ; \n} \nif ( port >= 0 ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialPort\" , \"\" + port ) ; \n} \nif ( env != null ) { \nObject applet = env . get ( Context . APPLET ) ; \nif ( applet != null ) { \nreturn initAppletORB ( applet , orbProp ) ; \n} \n} \nreturn ORB . init ( new String [ 0 ] , orbProp ) ; \n} \n} \n"}
{"2599": "public class CorbaUtils { \nprivate static ORB initAppletORB ( Object applet , Properties orbProp ) { \ntry { \nClass < ? > appletClass = Class . forName ( \"java.applet.Applet\" , true , null ) ; \nif ( ! appletClass . isInstance ( applet ) ) { \nthrow new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \n} \nMethod method = ORB . class . getMethod ( \"init\" , appletClass , Properties . class ) ; \nreturn ( ORB ) method . invoke ( null , applet , orbProp ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable cause = e . getCause ( ) ; \nif ( ! ( cause instanceof RuntimeException ) ) if ( cause instanceof Error ) { \nthrow ( Error ) cause ; \n} \nelse { \nthrow ( RuntimeException ) cause ; \n} \nthrow new AssertionError ( e ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new AssertionError ( iae ) ; \n} \n} \n} \n"}
{"2603": "public class JaxrsMethodParameterProcessor { \nprivate Class checkParamType ( Type genParamType , final Method method , final int paramPos , final ClassLoader classLoader ) { \nClass paramClazz = null ; \nif ( ! ( genParamType instanceof ParameterizedType ) ) { \nClass < ? > [ ] paramArr = method . getParameterTypes ( ) ; \nif ( ! ( paramArr [ paramPos ] . isArray ( ) ) ) { \nif ( ! paramArr [ paramPos ] . isPrimitive ( ) ) { \nparamClazz = paramArr [ paramPos ] ; \n} \n} \nelse { \nClass compClazz = paramArr [ paramPos ] . getComponentType ( ) ; \nif ( ! compClazz . isPrimitive ( ) ) { \nparamClazz = compClazz ; \n} \n} \n} \nelse { \nParameterizedType pType = ( ParameterizedType ) genParamType ; \nType [ ] actualTypeArgs = pType . getActualTypeArguments ( ) ; \nif ( actualTypeArgs . length == 1 ) { \ntry { \nparamClazz = classLoader . loadClass ( actualTypeArgs [ 0 ] . getTypeName ( ) ) ; \n} \ncatch ( Exception ee ) { \nJAXRS_LOGGER . classIntrospectionFailure ( ee . getClass ( ) . getName ( ) , ee . getMessage ( ) ) ; \n} \n} \n} \nreturn paramClazz ; \n} \n} \n"}
{"2606": "public class CreatedEntityManagers { \npublic static ExtendedEntityManager [ ] getDeferredEntityManagers ( ) { \nList < ExtendedEntityManager > store = deferToPostConstruct . get ( ) ; \ntry { \nif ( ! ( store . isEmpty ( ) ) ) { \nreturn store . toArray ( new ExtendedEntityManager [ store . size ( ) ] ) ; \n} \nelse { \nreturn EMPTY ; \n} \n} \nfinally { \nstore . clear ( ) ; \n} \n} \n} \n"}
{"2607": "public class StatusHelper { \npublic static String statusAsString ( int status ) { \nif ( ! ( status >= Status . STATUS_ACTIVE && status <= Status . STATUS_ROLLING_BACK ) ) { \nreturn \"STATUS_INVALID(\" + status + \")\" ; \n} \nelse { \nreturn TxStatusStrings [ status ] ; \n} \n} \n} \n"}
{"2610": "public class DatabaseTimerPersistence { \nprivate void investigateDialect ( ) { \nConnection connection = null ; \nif ( ! ( database == null ) ) { \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Database dialect '%s' read from configuration, adjusting it to match the final database valid value.\" , database ) ; \ndatabase = identifyDialect ( database ) ; \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"New Database dialect is '%s'.\" , database ) ; \n} \nelse { \ntry { \nconnection = dataSource . getConnection ( ) ; \nDatabaseMetaData metaData = connection . getMetaData ( ) ; \nString dbProduct = metaData . getDatabaseProductName ( ) ; \ndatabase = identifyDialect ( dbProduct ) ; \nif ( database == null ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Attempting to guess on driver name.\" ) ; \ndatabase = identifyDialect ( metaData . getDriverName ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Unable to read JDBC metadata.\" , e ) ; \n} \nfinally { \nsafeClose ( connection ) ; \n} \nif ( ! ( database == null ) ) { \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s\" , database , databaseDialects ) ; \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString ( ) ) ; \n} \n} \n} \n} \n"}
{"2611": "public class DatabaseTimerPersistence { \nprivate String identifyDialect ( String name ) { \nString unified = null ; \nif ( name != null ) { \nif ( ! ( name . toLowerCase ( ) . contains ( \"postgres\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"mysql\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"mariadb\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"db2\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"hsql\" ) || name . toLowerCase ( ) . contains ( \"hypersonic\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"h2\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"oracle\" ) ) ) if ( ! ( name . toLowerCase ( ) . contains ( \"microsoft\" ) ) ) if ( name . toLowerCase ( ) . contains ( \"jconnect\" ) ) { \nunified = \"sybase\" ; \n} \nelse { \nunified = \"mssql\" ; \n} \nelse { \nunified = \"oracle\" ; \n} \nelse { \nunified = \"h2\" ; \n} \nelse { \nunified = \"hsql\" ; \n} \nelse { \nunified = \"db2\" ; \n} \nelse { \nunified = \"mariadb\" ; \n} \nelse { \nunified = \"mysql\" ; \n} \nelse { \nunified = \"postgresql\" ; \n} \n} \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Check dialect for '%s', result is '%s'\" , name , unified ) ; \nreturn unified ; \n} \n} \n"}
{"2612": "public class DatabaseTimerPersistence { \nprivate void checkDatabase ( ) { \nString loadTimer = sql ( LOAD_TIMER ) ; \nConnection connection = null ; \nStatement statement = null ; \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nif ( connection . getTransactionIsolation ( ) < Connection . TRANSACTION_READ_COMMITTED ) { \nEjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; \n} \npreparedStatement = connection . prepareStatement ( loadTimer ) ; \npreparedStatement . setString ( 1 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 2 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 3 , \"NON-EXISTENT\" ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \n} \ncatch ( SQLException e ) { \nif ( ! ( connection != null ) ) { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; \n} \nelse { \ntry { \nString createTable = sql ( CREATE_TABLE ) ; \nString [ ] statements = createTable . split ( \";\" ) ; \nfor ( final String sql : statements ) { \ntry { \nstatement = connection . createStatement ( ) ; \nstatement . executeUpdate ( sql ) ; \n} \nfinally { \nsafeClose ( statement ) ; \n} \n} \n} \ncatch ( SQLException e1 ) { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; \n} \n} \n} \nfinally { \nsafeClose ( resultSet ) ; \nsafeClose ( preparedStatement ) ; \nsafeClose ( statement ) ; \nsafeClose ( connection ) ; \n} \n} \n} \n"}
{"2614": "public class DatabaseTimerPersistence { \nprivate void setNodeName ( final TimerState timerState , PreparedStatement statement , int paramIndex ) throws SQLException { \nif ( ! ( timerState == TimerState . IN_TIMEOUT || timerState == TimerState . RETRY_TIMEOUT ) ) { \nstatement . setNull ( paramIndex , Types . VARCHAR ) ; \n} \nelse { \nstatement . setString ( paramIndex , nodeName ) ; \n} \n} \n} \n"}
{"2620": "public class SFSBCallStack { \npublic static void beginSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nif ( ! ( no == 0 ) ) { \nSFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; \n} \nelse { \ndata . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; \n} \ndata . creationBeanNestingLevel ++ ; \n} \n} \n"}
{"2621": "public class SFSBCallStack { \npublic static void endSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nno -- ; \ndata . creationBeanNestingLevel = no ; \nif ( ! ( no == 0 ) ) { \ndata . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; \n} \nelse { \ndata . creationTimeXPCRegistration = null ; \ndata . creationTimeInjectedXPCs = null ; \n} \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( ! ( event == XMLStreamConstants . START_ELEMENT ) ) if ( ! ( event == XMLStreamConstants . END_ELEMENT ) ) if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \nelse { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse { \nindent ++ ; \nif ( ! ( indent == 2 ) ) if ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \nelse { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( ! ( event == XMLStreamConstants . START_ELEMENT ) ) if ( ! ( event == XMLStreamConstants . END_ELEMENT ) ) if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \nelse { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse { \nindent ++ ; \nif ( ! ( indent == 2 ) ) if ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \nelse { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2630": "public class Util { \npublic static void insertAnyPrimitive ( Any any , Object primitive ) { \nClass type = primitive . getClass ( ) ; \nif ( ! ( type == Boolean . class ) ) if ( ! ( type == Character . class ) ) if ( ! ( type == Byte . class ) ) if ( ! ( type == Short . class ) ) if ( ! ( type == Integer . class ) ) if ( ! ( type == Long . class ) ) if ( ! ( type == Float . class ) ) if ( ! ( type == Double . class ) ) throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; \nelse any . insert_double ( ( ( Double ) primitive ) . doubleValue ( ) ) ; \nelse any . insert_float ( ( ( Float ) primitive ) . floatValue ( ) ) ; \nelse any . insert_longlong ( ( ( Long ) primitive ) . longValue ( ) ) ; \nelse any . insert_long ( ( ( Integer ) primitive ) . intValue ( ) ) ; \nelse any . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; \nelse any . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; \nelse any . insert_wchar ( ( ( Character ) primitive ) . charValue ( ) ) ; \nelse any . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( ! ( isLegalIDLIdentifierChar ( c ) ) ) res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \nelse res . append ( c ) ; \n} \nString s = res . toString ( ) ; \nif ( ! ( isReservedIDLKeyword ( s ) ) ) return s ; \nelse return \"_\" + s ; \n} \n} \n"}
{"2637": "public class TransactionScopedEntityManager { \nprivate EntityManager getOrCreateTransactionScopedEntityManager ( final EntityManagerFactory emf , final String scopedPuName , final Map properties , final SynchronizationType synchronizationType ) { \nEntityManager entityManager = TransactionUtil . getTransactionScopedEntityManager ( puScopedName , transactionSynchronizationRegistry ) ; \nif ( ! ( entityManager == null ) ) { \ntestForMixedSynchronizationTypes ( emf , entityManager , puScopedName , synchronizationType , properties ) ; \nif ( ROOT_LOGGER . isDebugEnabled ( ) ) { \nROOT_LOGGER . debugf ( \"%s: reuse entity manager session already in tx %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; \n} \n} \nelse { \nentityManager = createEntityManager ( emf , properties , synchronizationType ) ; \nif ( ROOT_LOGGER . isDebugEnabled ( ) ) { \nROOT_LOGGER . debugf ( \"%s: created entity manager session %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; \n} \nTransactionUtil . registerSynchronization ( entityManager , scopedPuName , transactionSynchronizationRegistry , transactionManager ) ; \nTransactionUtil . putEntityManagerInTransactionRegistry ( scopedPuName , entityManager , transactionSynchronizationRegistry ) ; \n} \nreturn entityManager ; \n} \n} \n"}
{"2639": "public class ManagementUtil { \nstatic ModelNode convertSecurityRole ( final ModelNode camelCase ) { \nfinal ModelNode result = new ModelNode ( ) ; \nresult . setEmptyList ( ) ; \nif ( camelCase . isDefined ( ) ) { \nfor ( ModelNode role : camelCase . asList ( ) ) { \nfinal ModelNode roleNode = result . add ( ) ; \nfor ( Property prop : role . asPropertyList ( ) ) { \nString key = prop . getName ( ) ; \nif ( ! ( \"createDurableQueue\" . equals ( key ) ) ) if ( ! ( \"deleteDurableQueue\" . equals ( key ) ) ) if ( ! ( \"createNonDurableQueue\" . equals ( key ) ) ) if ( \"deleteNonDurableQueue\" . equals ( key ) ) { \nkey = SecurityRoleDefinition . DELETE_NON_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nkey = SecurityRoleDefinition . CREATE_NON_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nkey = SecurityRoleDefinition . DELETE_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nkey = SecurityRoleDefinition . CREATE_DURABLE_QUEUE . getName ( ) ; \n} \nroleNode . get ( key ) . set ( prop . getValue ( ) ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2643": "public class NamingEventCoordinator { \nsynchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { \nfinal TargetScope targetScope = new TargetScope ( target , scope ) ; \nListenerHolder holder = holdersByListener . get ( namingListener ) ; \nif ( ! ( holder == null ) ) { \nholder . addTarget ( targetScope ) ; \n} \nelse { \nholder = new ListenerHolder ( namingListener , targetScope ) ; \nfinal Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; \nbyListenerCopy . put ( namingListener , holder ) ; \nholdersByListener = byListenerCopy ; \n} \nList < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; \nif ( holdersForTarget == null ) { \nholdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; \nfinal Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; \nbyTargetCopy . put ( targetScope , holdersForTarget ) ; \nholdersByTarget = byTargetCopy ; \n} \nholdersForTarget . add ( holder ) ; \n} \n} \n"}
{"2647": "public class ElytronSubjectFactory { \nprivate void addPrivateCredential ( final Subject subject , final Object credential ) { \nif ( ! ( ! WildFlySecurityManager . isChecking ( ) ) ) { \nAccessController . doPrivileged ( ( PrivilegedAction < Void > ) ( ) -> { \nsubject . getPrivateCredentials ( ) . add ( credential ) ; \nreturn null ; \n} \n) ; \n} \nelse { \nsubject . getPrivateCredentials ( ) . add ( credential ) ; \n} \n} \n} \n"}
{"2654": "public class ViewDescription { \npublic ServiceName getServiceName ( ) { \nif ( ! ( ! viewNameParts . isEmpty ( ) ) ) { \nreturn componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewClassName ) ; \n} \nelse { \nreturn componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewNameParts . toArray ( new String [ viewNameParts . size ( ) ] ) ) ; \n} \n} \n} \n"}
{"2672": "public class ASHelper { \npublic static JBossWebMetaData getJBossWebMetaData ( final DeploymentUnit unit ) { \nfinal WarMetaData warMetaData = getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; \nJBossWebMetaData result = null ; \nif ( ! ( warMetaData != null ) ) { \nresult = getOptionalAttachment ( unit , WSAttachmentKeys . JBOSSWEB_METADATA_KEY ) ; \n} \nelse { \nresult = warMetaData . getMergedJBossWebMetaData ( ) ; \nif ( result == null ) { \nresult = warMetaData . getJBossWebMetaData ( ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2684": "public class WSServerConfigAttributeHandler { \nprivate boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { \nfinal ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; \ntry { \nif ( ! ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) ) if ( ! ( WSDL_HOST . equals ( attributeName ) ) ) if ( ! ( WSDL_PORT . equals ( attributeName ) ) ) if ( ! ( WSDL_SECURE_PORT . equals ( attributeName ) ) ) if ( ! ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) ) if ( ! ( WSDL_URI_SCHEME . equals ( attributeName ) ) ) if ( ! ( STATISTICS_ENABLED . equals ( attributeName ) ) ) { \nthrow new IllegalArgumentException ( attributeName ) ; \n} \nelse { \nfinal boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; \nconfig . setStatisticsEnabled ( enabled ) ; \n} \nelse { \nif ( ! ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) ) { \nthrow new IllegalArgumentException ( attributeName + \" = \" + value ) ; \n} \nelse { \nconfig . setWebServiceUriScheme ( value , isRevert ) ; \n} \n} \nelse { \nfinal String path = value != null ? value : null ; \nconfig . setWebServicePathRewriteRule ( path , isRevert ) ; \n} \nelse { \nfinal int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServiceSecurePort ( securePort , isRevert ) ; \n} \nelse { \nfinal int port = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServicePort ( port , isRevert ) ; \n} \nelse { \nfinal String host = value != null ? value : null ; \ntry { \nconfig . setWebServiceHost ( host , isRevert ) ; \n} \ncatch ( final UnknownHostException e ) { \nthrow new OperationFailedException ( e . getMessage ( ) , e ) ; \n} \n} \nelse { \nfinal boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; \nconfig . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; \n} \n} \ncatch ( DisabledOperationException doe ) { \nif ( ! ( ! isRevert ) ) { \nthrow doe ; \n} \nelse { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2687": "public class AbstractDeploymentModelBuilder { \nprivate ArchiveDeployment newDeployment ( final DeploymentUnit unit ) { \nWSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit ) ; \nfinal ResourceRoot deploymentRoot = unit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; \nfinal VirtualFile root = deploymentRoot != null ? deploymentRoot . getRoot ( ) : null ; \nfinal ClassLoader classLoader ; \nfinal Module module = unit . getAttachment ( Attachments . MODULE ) ; \nif ( ! ( module == null ) ) { \nclassLoader = module . getClassLoader ( ) ; \n} \nelse { \nclassLoader = unit . getAttachment ( CLASSLOADER_KEY ) ; \nif ( classLoader == null ) { \nthrow WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( unit ) ; \n} \n} \nArchiveDeployment parentDep = null ; \nif ( unit . getParent ( ) != null ) { \nfinal Module parentModule = unit . getParent ( ) . getAttachment ( Attachments . MODULE ) ; \nif ( parentModule == null ) { \nthrow WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( deploymentRoot ) ; \n} \nWSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit . getParent ( ) ) ; \nparentDep = this . newDeployment ( null , unit . getParent ( ) . getName ( ) , parentModule . getClassLoader ( ) , null ) ; \n} \nfinal UnifiedVirtualFile uvf = root != null ? new VirtualFileAdaptor ( root ) : new ResourceLoaderAdapter ( classLoader ) ; \nfinal ArchiveDeployment dep = this . newDeployment ( parentDep , unit . getName ( ) , classLoader , uvf ) ; \ndep . addAttachment ( AnnotationsInfo . class , new JandexAnnotationsInfo ( unit ) ) ; \nreturn dep ; \n} \n} \n"}
{"2695": "public class ApplicableMethodInformation { \npublic boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { \nassert methodIntf != null : \"methodIntf is null\" ; \nassert method != null : \"method is null\" ; \nMethod classMethod = resolveRealMethod ( method ) ; \nString [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; \nfinal String methodName = classMethod . getName ( ) ; \nfinal String className = classMethod . getDeclaringClass ( ) . getName ( ) ; \nArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; \nT attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) return true ; \nattr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; \nif ( attr != null ) return true ; \nattr = get ( perViewStyle1 , methodIntf ) ; \nif ( attr != null ) return false ; \nattr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) return true ; \nattr = get ( style2 , methodName ) ; \nif ( attr != null ) return true ; \nattr = get ( style1 , className ) ; \nif ( attr != null ) return false ; \nif ( ! ( defaultMethodIntf == null ) ) { \nreturn isMethodLevel ( defaultMethodIntf , method , null ) ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( ! ( str . charAt ( i ) == compSeparator ) ) if ( ! ( str . charAt ( i ) == escapeChar ) ) if ( ! ( idMode && str . charAt ( i ) == kindSeparator ) ) { \nif ( ! ( idMode ) ) { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( ! ( i + 1 >= len ) ) if ( ! ( isMeta ( str . charAt ( i + 1 ) ) ) ) { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \nelse { \n++ i ; \nif ( ! ( idMode ) ) { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \n} \nelse { \nbreak ; \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( int i = 0 ; \ni < len && kindSep < 0 ; \ni ++ ) { \nif ( ! ( escaped ) ) if ( ! ( compStr . charAt ( i ) == escapeChar ) ) if ( ! ( compStr . charAt ( i ) == kindSeparator ) ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \nelse { \nkindSep = i ; \n} \nelse { \nif ( ! ( i + 1 >= len ) ) if ( ! ( isMeta ( compStr . charAt ( i + 1 ) ) ) ) { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \nelse { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( ! ( kindSep < 0 ) ) { \nj = 0 ; \nescaped = false ; \nfor ( int i = kindSep + 1 ; \ni < len ; \ni ++ ) { \nif ( ! ( escaped ) ) if ( ! ( compStr . charAt ( i ) == escapeChar ) ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \nelse { \nif ( ! ( i + 1 >= len ) ) if ( ! ( isMeta ( compStr . charAt ( i + 1 ) ) ) ) { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \nelse { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nelse { \ncomp . kind = \"\" ; \n} \nreturn comp ; \n} \n} \n"}
{"2707": "public class ElytronSecurityManager { \nprivate SecurityIdentity authenticate ( final String username , final String password ) { \nServerAuthenticationContext context = this . securityDomain . createNewAuthenticationContext ( ) ; \nPasswordGuessEvidence evidence = null ; \ntry { \nif ( password == null ) { \nif ( ! ( username == null ) ) { \ncontext . fail ( ) ; \nreturn null ; \n} \nelse { \nif ( ! ( context . authorizeAnonymous ( ) ) ) { \ncontext . fail ( ) ; \nreturn null ; \n} \nelse { \ncontext . succeed ( ) ; \nreturn context . getAuthorizedIdentity ( ) ; \n} \n} \n} \ncontext . setAuthenticationName ( username ) ; \nevidence = new PasswordGuessEvidence ( password . toCharArray ( ) ) ; \nif ( ! ( context . verifyEvidence ( evidence ) ) ) { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthentication ( username ) ; \n} \nelse { \nif ( ! ( context . authorize ( ) ) ) { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthorization ( username ) ; \n} \nelse { \ncontext . succeed ( ) ; \nreturn context . getAuthorizedIdentity ( ) ; \n} \n} \n} \ncatch ( IllegalArgumentException | IllegalStateException | RealmUnavailableException e ) { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthenticationWithException ( e , username , e . getMessage ( ) ) ; \n} \nfinally { \nif ( evidence != null ) { \nevidence . destroy ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2708": "public class GetDataSourceClassInfoOperationHandler { \nprivate static boolean isTypeMatched ( Class < ? > clz ) { \nif ( ! ( clz . equals ( String . class ) ) ) if ( ! ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) ) if ( ! ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) ) if ( ! ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) ) if ( ! ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) ) if ( ! ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) ) if ( ! ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) ) if ( ! ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) ) if ( ! ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) ) if ( ! ( clz . equals ( InetAddress . class ) ) ) if ( ! ( clz . equals ( Class . class ) ) ) if ( clz . equals ( Properties . class ) ) { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"2711": "public class BeanUtils { \npublic static Object instantiateBean ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , DeploymentReflectionIndex index , Module module ) throws Throwable { \nJoinpoint instantiateJoinpoint = null ; \nValueConfig [ ] parameters = new ValueConfig [ 0 ] ; \nString [ ] types = Configurator . NO_PARAMS_TYPES ; \nConstructorConfig ctorConfig = beanConfig . getConstructor ( ) ; \nif ( ctorConfig != null ) { \nparameters = ctorConfig . getParameters ( ) ; \ntypes = Configurator . getTypes ( parameters ) ; \nString factoryClass = ctorConfig . getFactoryClass ( ) ; \nFactoryConfig factory = ctorConfig . getFactory ( ) ; \nif ( factoryClass != null || factory != null ) { \nString factoryMethod = ctorConfig . getFactoryMethod ( ) ; \nif ( factoryMethod == null ) throw PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; \nif ( ! ( factoryClass != null ) ) if ( factory != null ) { \nReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; \nrj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; \nrj . setParameters ( parameters ) ; \ninstantiateJoinpoint = rj ; \n} \nelse { \nClass < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; \nMethod method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; \nMethodJoinpoint mj = new MethodJoinpoint ( method ) ; \nmj . setTarget ( new ImmediateValue < Object > ( null ) ) ; \nmj . setParameters ( parameters ) ; \ninstantiateJoinpoint = mj ; \n} \n} \n} \nif ( instantiateJoinpoint == null ) { \nif ( beanInfo == null ) throw new StartException ( PojoLogger . ROOT_LOGGER . missingBeanInfo ( beanConfig ) ) ; \nConstructor ctor = ( types . length == 0 ) ? beanInfo . getConstructor ( ) : beanInfo . findConstructor ( types ) ; \nConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint ( ctor ) ; \nconstructorJoinpoint . setParameters ( parameters ) ; \ninstantiateJoinpoint = constructorJoinpoint ; \n} \nreturn instantiateJoinpoint . dispatch ( ) ; \n} \n} \n"}
{"2716": "public class BeanMetaDataConfig { \npublic static ServiceName toInstancesName ( Class < ? > clazz , BeanState state ) { \nString clName ; \nClassLoader classLoader = clazz . getClassLoader ( ) ; \nif ( ! ( classLoader != null ) ) clName = \"SystemClassLoader\" ; \nelse clName = classLoader . toString ( ) ; \nif ( state == null ) state = BeanState . INSTALLED ; \nreturn JBOSS_POJO . append ( clName , clazz . getName ( ) , state . name ( ) ) ; \n} \n} \n"}
{"2719": "public class PersistenceUnitParseProcessor { \nprivate void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { \nfor ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { \nList < URL > jarfilesUrls = new ArrayList < URL > ( ) ; \nif ( pu . getJarFiles ( ) != null ) { \nfor ( String jar : pu . getJarFiles ( ) ) { \njarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; \n} \n} \npu . setJarFileUrls ( jarfilesUrls ) ; \nURL url = getPersistenceUnitURL ( persistence_xml ) ; \npu . setPersistenceUnitRootUrl ( url ) ; \nString scopedPersistenceUnitName ; \nscopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; \nif ( ! ( scopedPersistenceUnitName == null ) ) { \nROOT_LOGGER . tracef ( \"persistence unit '%s' specified a custom scoped persistence unit name hint \" + \"(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments.\" , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; \nif ( scopedPersistenceUnitName . indexOf ( '/' ) != - 1 ) { \nthrow JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , '/' ) ; \n} \n} \nelse { \nscopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; \n} \npu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; \n} \n} \n} \n"}
{"2720": "public class DescriptorUtils { \npublic static String validateDescriptor ( String descriptor ) { \nif ( descriptor . length ( ) == 0 ) { \nthrow EeLogger . ROOT_LOGGER . cannotBeEmpty ( \"descriptors\" ) ; \n} \nif ( ! ( descriptor . length ( ) > 1 ) ) { \nchar type = descriptor . charAt ( 0 ) ; \nswitch ( type ) { \ncase 'I' : case 'Z' : case 'S' : case 'B' : case 'F' : case 'D' : case 'V' : case 'J' : case 'C' : break ; \ndefault : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nelse { \nif ( ! ( descriptor . startsWith ( \"L\" ) ) ) if ( ! ( descriptor . startsWith ( \"[\" ) ) ) { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \nelse { \n} \nelse { \nif ( ! descriptor . endsWith ( \";\" ) ) { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \n} \nreturn descriptor ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; \nVirtualFile serviceXmlFile = null ; \nif ( ! ( deploymentRoot . isDirectory ( ) ) ) if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { \nserviceXmlFile = deploymentRoot ; \n} \nelse { \nserviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \n} \nif ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( ! ( xmlDescriptor != null ) ) throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \nelse phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( puList . size ( ) > 0 ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( ! ( deployPU ) ) { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \nelse { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( ! ( startEarly ) ) { \nif ( ! ( twoPhaseBootStrapCapable ) ) if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \nelse { \ndeployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \n} \n} \nelse { \nif ( ! ( twoPhaseBootStrapCapable ) ) if ( ! ( false == Configuration . needClassFileTransformer ( pu ) ) ) { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \n} \nelse { \ndeployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"2735": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProviderAdaptor getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final DeploymentUnit deploymentUnit , final PersistenceProvider provider , final Platform platform ) throws DeploymentUnitProcessingException { \nString adapterClass = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_CLASS ) ; \nif ( persistenceProviderDeploymentHolder != null && adapterClass != null ) { \nList < PersistenceProviderAdaptor > persistenceProviderAdaptors = persistenceProviderDeploymentHolder . getAdapters ( ) ; \nfor ( PersistenceProviderAdaptor persistenceProviderAdaptor : persistenceProviderAdaptors ) { \nif ( adapterClass . equals ( persistenceProviderAdaptor . getClass ( ) . getName ( ) ) ) { \nreturn persistenceProviderAdaptor ; \n} \n} \n} \nString adaptorModule = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_MODULE ) ; \nPersistenceProviderAdaptor adaptor ; \nadaptor = getPerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , provider ) ; \nif ( adaptor == null ) { \ntry { \nif ( ! ( adaptorModule != null ) ) { \nadaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapter ( provider , platform , createManager ( deploymentUnit ) ) ; \n} \nelse { \nadaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapterModule ( adaptorModule , platform , createManager ( deploymentUnit ) ) ; \n} \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . persistenceProviderAdaptorModuleLoadError ( e , adaptorModule ) ; \n} \nadaptor = savePerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , adaptor , provider ) ; \n} \nif ( adaptor == null ) { \nthrow JpaLogger . ROOT_LOGGER . failedToGetAdapter ( pu . getPersistenceProviderClassName ( ) ) ; \n} \nreturn adaptor ; \n} \n} \n"}
{"2736": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor ( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { \nif ( deploymentUnit . getParent ( ) != null ) { \ndeploymentUnit = deploymentUnit . getParent ( ) ; \n} \nsynchronized ( deploymentUnit ) { \nMap < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; \nString key ; \nif ( ! ( adaptorModule != null ) ) { \nkey = provider . getClass ( ) . getName ( ) ; \n} \nelse { \nkey = adaptorModule ; \n} \nPersistenceProviderAdaptor current = map . get ( key ) ; \nif ( current == null ) { \nmap . put ( key , adaptor ) ; \ncurrent = adaptor ; \n} \nreturn current ; \n} \n} \n} \n"}
{"2737": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { \nMap < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; \nif ( providerMap != null ) { \nsynchronized ( providerMap ) { \nif ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { \nROOT_LOGGER . tracef ( \"deployment %s is using %s\" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; \nreturn providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; \n} \n} \n} \nString configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; \nString persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; \nif ( persistenceProviderClassName == null ) { \npersistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; \n} \nif ( configuredPersistenceProviderModule != null ) { \nList < PersistenceProvider > providers ; \nif ( ! ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) ) { \ntry { \nproviders = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nPersistenceProvider provider = getProviderByName ( pu , providers ) ; \nif ( provider != null ) { \nreturn provider ; \n} \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; \n} \n} \nelse { \ntry { \nfinal ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; \nPersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; \nproviders = new ArrayList < > ( ) ; \nproviders . add ( provider ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nreturn provider ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \n} \n} \nString providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; \nPersistenceProvider provider = getProviderByName ( pu ) ; \nif ( provider == null && providerNameDerivedFromClassName != null ) { \ntry { \nList < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nprovider = getProviderByName ( pu , providers ) ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; \n} \n} \nif ( provider == null ) throw JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; \nreturn provider ; \n} \n} \n"}
{"2746": "public class ContainerAnalysis { \nprotected String toHexString ( int i ) { \nString s = Integer . toHexString ( i ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( ! ( s . length ( ) < 8 ) ) return s ; \nelse return \"00000000\" . substring ( 0 , 8 - s . length ( ) ) + s ; \n} \n} \n"}
{"2747": "public class ContainerAnalysis { \nprotected String toHexString ( long l ) { \nString s = Long . toHexString ( l ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( ! ( s . length ( ) < 16 ) ) return s ; \nelse return \"0000000000000000\" . substring ( 0 , 16 - s . length ( ) ) + s ; \n} \n} \n"}
{"2751": "public class ContainerAnalysis { \nprotected String attributeReadName ( String name ) { \nif ( ! ( name . startsWith ( \"get\" ) ) ) if ( ! ( name . startsWith ( \"is\" ) ) ) throw IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; \nelse name = name . substring ( 2 ) ; \nelse name = name . substring ( 3 ) ; \nreturn name ; \n} \n} \n"}
{"2752": "public class ContainerAnalysis { \nprotected String attributeWriteName ( String name ) { \nif ( ! ( name . startsWith ( \"set\" ) ) ) throw IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; \nelse name = name . substring ( 3 ) ; \nreturn name ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( ! ( idx == - 1 ) ) { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( ! ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) ) { \ns = s . substring ( idx + 2 ) ; \n} \nelse { \ns = s . substring ( idx + 3 ) ; \n} \n} \nelse { \nb . append ( s ) ; \ns = \"\" ; \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \nj < i ; \n++ j ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nj < name . length ( ) ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( ! ( noUpper ) ) b . append ( '_' ) ; \nelse noUpper = false ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( ! ( c < 256 ) ) b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \nelse b . append ( c ) ; \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2763": "public class MethodIntfHelper { \npublic static MethodIntf of ( final InterceptorContext invocation ) { \nMethodIntf methodIntf = invocation . getPrivateData ( MethodIntf . class ) ; \nif ( methodIntf == null ) { \nfinal ComponentView componentView = invocation . getPrivateData ( ComponentView . class ) ; \nif ( ! ( componentView != null ) ) { \nmethodIntf = MethodIntf . BEAN ; \n} \nelse { \nmethodIntf = componentView . getPrivateData ( MethodIntf . class ) ; \n} \n} \nreturn methodIntf ; \n} \n} \n"}
{"2764": "public class StatefulSessionComponent { \npublic SessionID createSessionRemote ( ) { \nControlPoint controlPoint = getControlPoint ( ) ; \nif ( ! ( controlPoint == null ) ) { \ntry { \nRunResult result = controlPoint . beginRequest ( ) ; \nif ( result == RunResult . REJECTED ) { \nthrow EjbLogger . ROOT_LOGGER . containerSuspended ( ) ; \n} \ntry { \nreturn createSession ( ) ; \n} \nfinally { \ncontrolPoint . requestComplete ( ) ; \n} \n} \ncatch ( EJBComponentUnavailableException | ComponentIsStoppedException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new EJBException ( e ) ; \n} \n} \nelse { \nreturn createSession ( ) ; \n} \n} \n} \n"}
{"2765": "public class JMSServerControlHandler { \nprivate String inferDestinationName ( String address ) { \nif ( ! ( address . startsWith ( JMS_QUEUE_PREFIX ) ) ) if ( ! ( address . startsWith ( JMS_TOPIC_PREFIX ) ) ) { \nreturn address ; \n} \nelse { \nreturn address . substring ( JMS_TOPIC_PREFIX . length ( ) ) ; \n} \nelse { \nreturn address . substring ( JMS_QUEUE_PREFIX . length ( ) ) ; \n} \n} \n} \n"}
{"2773": "public class CNCtx { \nprivate void callUnbind ( NameComponent [ ] path ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; \ntry { \n_nc . unbind ( path ) ; \n} \ncatch ( NotFound e ) { \nif ( ! ( leafNotFound ( e , path [ path . length - 1 ] ) ) ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \nelse { \n} \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \n} \n"}
{"2774": "public class CNCtx { \npublic NamingEnumeration listBindings ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nif ( name . size ( ) > 0 ) { \ntry { \njava . lang . Object obj = lookup ( name ) ; \nif ( ! ( obj instanceof CNCtx ) ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \nelse { \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; \n} \n} \ncatch ( NamingException ne ) { \nthrow ne ; \n} \ncatch ( BAD_PARAM e ) { \nNamingException ne = new NotContextException ( name . toString ( ) ) ; \nne . setRootCause ( e ) ; \nthrow ne ; \n} \n} \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; \n} \n} \n"}
{"2780": "public class CNCtx { \npublic java . lang . Object addToEnvironment ( String propName , java . lang . Object propValue ) throws NamingException { \nif ( ! ( _env == null ) ) { \n_env = ( Hashtable ) _env . clone ( ) ; \n} \nelse { \n_env = new Hashtable ( 7 , 0.75f ) ; \n} \nreturn _env . put ( propName , propValue ) ; \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nwhile ( reader . hasNext ( ) ) { \nswitch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( ! ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) ) { \nif ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { \nthrow new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \n} \n} \nelse { \nreturn new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \n} \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null && password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) password = resolvedPassword ; \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2785": "public class JNDIBasedSecurityManagement { \nprivate Object lookUpJNDI ( String contextName ) { \nObject result = null ; \ntry { \nContext ctx = new InitialContext ( ) ; \nif ( ! ( contextName . startsWith ( SecurityConstants . JAAS_CONTEXT_ROOT ) ) ) result = ctx . lookup ( SecurityConstants . JAAS_CONTEXT_ROOT + contextName ) ; \nelse result = ctx . lookup ( contextName ) ; \n} \ncatch ( Exception e ) { \nSecurityLogger . ROOT_LOGGER . tracef ( \"Look up of JNDI for %s failed with %s\" , contextName , e . getLocalizedMessage ( ) ) ; \nreturn null ; \n} \nreturn result ; \n} \n} \n"}
{"2798": "public class ConnectorServices { \npublic static synchronized ServiceName getDeploymentServiceName ( final String raName , final Activation raxml ) { \nif ( raName == null ) throw ConnectorLogger . ROOT_LOGGER . undefinedVar ( \"RaName\" ) ; \nServiceName serviceName = null ; \nModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; \nif ( ! ( ra != null && ra . getId ( ) != null ) ) { \nserviceName = getDeploymentServiceName ( raName , ( String ) null ) ; \n} \nelse { \nserviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; \n} \nROOT_LOGGER . tracef ( \"ConnectorServices: getDeploymentServiceName(%s,%s) -> %s\" , raName , raxml , serviceName ) ; \nreturn serviceName ; \n} \n} \n"}
{"2799": "public class ConstantAnalysis { \npublic void insertValue ( Any any ) { \nif ( ! ( type == String . class ) ) Util . insertAnyPrimitive ( any , value ) ; \nelse any . insert_wstring ( ( String ) value ) ; \n} \n} \n"}
{"2801": "public class JndiPermission { \npublic String getActions ( ) { \nfinal String actionString = this . actionString ; \nif ( actionString != null ) { \nreturn actionString ; \n} \nint actionBits = this . actionBits ; \nif ( actionBits == ACTION_ALL ) { \nreturn this . actionString = \"*\" ; \n} \nint m = Integer . lowestOneBit ( actionBits ) ; \nif ( ! ( m != 0 ) ) { \nreturn this . actionString = \"\" ; \n} \nelse { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \nwhile ( actionBits != 0 ) { \nm = Integer . lowestOneBit ( actionBits ) ; \nb . append ( ',' ) . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \n} \nreturn this . actionString = b . toString ( ) ; \n} \n} \n} \n"}
{"2805": "public class ValueConfig { \npublic Object getValue ( Type type ) { \nif ( ! ( type == null || ( type instanceof Class ) ) ) if ( ! ( type instanceof ParameterizedType ) ) { \nthrow PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \nelse { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn getPtValue ( pt ) ; \n} \nelse { \nreturn getClassValue ( ( Class ) type ) ; \n} \n} \n} \n"}
{"2806": "public class ComponentDescription { \npublic ServiceName getContextServiceName ( ) { \nif ( contextServiceName != null ) return contextServiceName ; \nif ( ! ( getNamingMode ( ) == ComponentNamingMode . CREATE ) ) if ( ! ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) ) { \nthrow new IllegalStateException ( ) ; \n} \nelse { \nreturn ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; \n} \nelse { \nreturn ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; \n} \n} \n} \n"}
{"2823": "public class ContextNames { \npublic static BindInfo bindInfoForEnvEntry ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { \nif ( ! ( envEntryName . startsWith ( \"java:\" ) ) ) { \nif ( ! ( useCompNamespace ) ) { \nreturn bindInfoFor ( app , module , module , \"java:module/env/\" + envEntryName ) ; \n} \nelse { \nreturn bindInfoFor ( app , module , comp , \"java:comp/env/\" + envEntryName ) ; \n} \n} \nelse { \nif ( ! ( useCompNamespace ) ) { \nif ( ! ( envEntryName . startsWith ( \"java:comp\" ) ) ) { \nreturn bindInfoFor ( app , module , module , envEntryName ) ; \n} \nelse { \nreturn bindInfoFor ( app , module , module , \"java:module\" + envEntryName . substring ( \"java:comp\" . length ( ) ) ) ; \n} \n} \nelse { \nreturn bindInfoFor ( app , module , comp , envEntryName ) ; \n} \n} \n} \n} \n"}
{"2824": "public class ContextNames { \npublic static BindInfo bindInfoFor ( final String jndiName ) { \nString bindName ; \nif ( ! ( jndiName . startsWith ( \"java:\" ) ) ) if ( ! ( ! jndiName . startsWith ( \"jboss\" ) && ! jndiName . startsWith ( \"global\" ) && ! jndiName . startsWith ( \"/\" ) ) ) { \nbindName = jndiName ; \n} \nelse { \nbindName = \"/\" + jndiName ; \n} \nelse { \nbindName = jndiName . substring ( 5 ) ; \n} \nfinal ServiceName parentContextName ; \nif ( ! ( bindName . startsWith ( \"jboss/exported/\" ) ) ) if ( ! ( bindName . startsWith ( \"jboss/\" ) ) ) if ( ! ( bindName . startsWith ( \"global/\" ) ) ) if ( ! ( bindName . startsWith ( \"/\" ) ) ) { \nthrow NamingLogger . ROOT_LOGGER . illegalContextInName ( jndiName ) ; \n} \nelse { \nparentContextName = JAVA_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 1 ) ; \n} \nelse { \nparentContextName = GLOBAL_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 7 ) ; \n} \nelse { \nparentContextName = JBOSS_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 6 ) ; \n} \nelse { \nparentContextName = EXPORTED_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 15 ) ; \n} \nreturn new BindInfo ( parentContextName , bindName ) ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { \nreturn null ; \n} \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nint attributeCount = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeCount ; \ni ++ ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) { \nthrow unexpectedAttribute ( reader , i ) ; \n} \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( ! ( modelNode . hasDefined ( key ) ) ) { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) { \nname = attributeValue ; \n} \n} \nelse { \nname = modelNode . get ( key ) . asString ( ) ; \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2836": "public class EEApplicationDescription { \npublic Set < ComponentDescription > getComponents ( final String componentName , final VirtualFile deploymentRoot ) { \nif ( ! ( componentName . contains ( \"#\" ) ) ) { \nfinal List < Description > info = componentsByName . get ( componentName ) ; \nif ( info == null ) { \nreturn Collections . emptySet ( ) ; \n} \nfinal Set < ComponentDescription > all = new HashSet < ComponentDescription > ( ) ; \nfinal Set < ComponentDescription > thisDeployment = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nall . add ( i . componentDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . componentDescription ) ; \n} \n} \nif ( all . size ( ) > 1 ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \nelse { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal List < Description > info = componentsByName . get ( name ) ; \nif ( info == null ) { \nreturn Collections . emptySet ( ) ; \n} \nfinal Set < ComponentDescription > ret = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . componentDescription ) ; \n} \n} \nreturn ret ; \n} \n} \n} \n"}
{"2837": "public class EEApplicationDescription { \npublic Set < ViewDescription > getComponents ( final String componentName , final String viewName , final VirtualFile deploymentRoot ) { \nfinal List < ViewInformation > info = componentsByViewName . get ( viewName ) ; \nif ( info == null ) { \nreturn Collections . < ViewDescription > emptySet ( ) ; \n} \nif ( ! ( componentName . contains ( \"#\" ) ) ) { \nfinal Set < ViewDescription > all = new HashSet < ViewDescription > ( ) ; \nfinal Set < ViewDescription > thisDeployment = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( componentName ) ) { \nall . add ( i . viewDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . viewDescription ) ; \n} \n} \n} \nif ( all . size ( ) > 1 ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \nelse { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( name ) ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . viewDescription ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n} \n"}
{"2838": "public class EEApplicationDescription { \npublic Set < String > resolveMessageDestination ( final String messageDestName , final VirtualFile deploymentRoot ) { \nif ( ! ( messageDestName . contains ( \"#\" ) ) ) { \nfinal Set < String > all = new HashSet < String > ( ) ; \nfinal Set < String > thisDeployment = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( messageDestName ) ; \nif ( data != null ) { \nfor ( final MessageDestinationMapping i : data ) { \nall . add ( i . jndiName ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . jndiName ) ; \n} \n} \n} \nif ( all . size ( ) > 1 ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \nelse { \nfinal String [ ] parts = messageDestName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < String > ret = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( name ) ; \nif ( data != null ) { \nfor ( final MessageDestinationMapping i : data ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . jndiName ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n} \n"}
{"2848": "public class InterfaceRepository { \nprivate ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { \nif ( \"\" . equals ( remainder ) ) return ( ModuleDefImpl ) c ; \nint idx = remainder . indexOf ( '.' ) ; \nString base ; \nif ( ! ( idx == - 1 ) ) base = remainder . substring ( 0 , idx ) ; \nelse base = remainder ; \nbase = Util . javaToIDLName ( base ) ; \nif ( ! ( previous . equals ( \"\" ) ) ) previous = previous + \"/\" + base ; \nelse previous = base ; \nif ( ! ( idx == - 1 ) ) remainder = remainder . substring ( idx + 1 ) ; \nelse remainder = \"\" ; \nLocalContainer next = null ; \nLocalContained contained = ( LocalContained ) c . _lookup ( base ) ; \nif ( ! ( contained instanceof LocalContainer ) ) if ( contained != null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \nelse next = ( LocalContainer ) contained ; \nif ( ! ( next == null ) ) if ( next . def_kind ( ) != DefinitionKind . dk_Module ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \nelse { \nString id = \"IDL:\" + previous + \":1.0\" ; \nModuleDefImpl m = new ModuleDefImpl ( id , base , \"1.0\" , c , impl ) ; \nc . add ( base , m ) ; \nif ( idx == - 1 ) return m ; \nnext = ( LocalContainer ) c . _lookup ( base ) ; \n} \nreturn ensurePackageExists ( next , previous , remainder ) ; \n} \n} \n"}
{"2851": "public class InterfaceRepository { \nprivate void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { \nif ( cls . isPrimitive ( ) ) return ; \nif ( ! ( cls . isArray ( ) ) ) if ( ! ( cls . isInterface ( ) ) ) if ( ! ( Exception . class . isAssignableFrom ( cls ) ) ) { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \nelse { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \naddException ( ea ) ; \n} \nelse { \nif ( ! ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) ) { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \nelse { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \naddInterface ( ia ) ; \n} \n} \nelse { \naddArray ( cls ) ; \n} \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) return vDef ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( ! ( superValue == null ) ) baseTypeCode = superValue . type ( ) ; \nelse baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \nfor ( int i = 0 ; \ni < vmas . length ; \n++ i ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2865": "public class Configurator { \npublic static Class < ? > toClass ( Type type ) { \nif ( ! ( type instanceof Class ) ) if ( ! ( type instanceof ParameterizedType ) ) { \nthrow PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \nelse { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn toClass ( pt . getRawType ( ) ) ; \n} \nelse { \nreturn ( Class ) type ; \n} \n} \n} \n"}
{"2869": "public class CNBindingEnumeration { \npublic java . lang . Object next ( ) throws NamingException { \nif ( more && counter >= _bindingList . value . length ) { \ngetMore ( ) ; \n} \nif ( ! ( more && counter < _bindingList . value . length ) ) { \nthrow new NoSuchElementException ( ) ; \n} \nelse { \norg . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; \ncounter ++ ; \nreturn mapBinding ( bndg ) ; \n} \n} \n} \n"}
{"2874": "public class EjbIIOPService { \npublic org . omg . CORBA . Object referenceForLocator ( final EJBLocator < ? > locator ) { \nfinal EJBComponent ejbComponent = ejbComponentInjectedValue . getValue ( ) ; \ntry { \nfinal String earApplicationName = ejbComponent . getEarApplicationName ( ) == null ? \"\" : ejbComponent . getEarApplicationName ( ) ; \nif ( ! ( locator . getBeanName ( ) . equals ( ejbComponent . getComponentName ( ) ) && locator . getAppName ( ) . equals ( earApplicationName ) && locator . getModuleName ( ) . equals ( ejbComponent . getModuleName ( ) ) && locator . getDistinctName ( ) . equals ( ejbComponent . getDistinctName ( ) ) ) ) { \nthrow EjbLogger . ROOT_LOGGER . incorrectEJBLocatorForBean ( locator , ejbComponent . getComponentName ( ) ) ; \n} \nelse { \nif ( ! ( locator instanceof EJBHomeLocator ) ) if ( ! ( locator instanceof StatelessEJBLocator ) ) if ( ! ( locator instanceof StatefulEJBLocator ) ) if ( locator instanceof EntityEJBLocator ) { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( EntityEJBLocator < ? > ) locator ) . getPrimaryKey ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \nelse { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( StatefulEJBLocator < ? > ) locator ) . getSessionId ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \nelse { \nreturn beanReferenceFactory . createReference ( beanRepositoryIds [ 0 ] ) ; \n} \nelse { \nreturn ( org . omg . CORBA . Object ) ejbHome ; \n} \nthrow EjbLogger . ROOT_LOGGER . unknownEJBLocatorType ( locator ) ; \n} \n} \ncatch ( Exception e ) { \nthrow EjbLogger . ROOT_LOGGER . couldNotCreateCorbaObject ( e , locator ) ; \n} \n} \n} \n"}
{"2898": "public class TimerTask { \nprotected void retryTimeout ( TimerImpl timer ) throws Exception { \nboolean callTimeout = false ; \ntimer . lock ( ) ; \ntry { \nif ( ! ( timer . isActive ( ) ) ) { \nEJB3_TIMER_LOGGER . timerNotActive ( timer ) ; \n} \nelse { \nEJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; \ntimer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; \ntimerService . persistTimer ( timer , false ) ; \ncallTimeout = true ; \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \nif ( callTimeout ) { \nthis . callTimeout ( timer ) ; \n} \n} \n} \n"}
{"2899": "public class TimerTask { \nprotected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { \ntimer . lock ( ) ; \ntry { \nTimerState timerState = timer . getState ( ) ; \nif ( timerState != TimerState . CANCELED && timerState != TimerState . EXPIRED ) { \nif ( ! ( timer . getInterval ( ) == 0 ) ) { \ntimer . setTimerState ( TimerState . ACTIVE , null ) ; \n} \nelse { \ntimerService . expireTimer ( timer ) ; \n} \ntimerService . persistTimer ( timer , false ) ; \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \n} \n} \n"}
{"2904": "public class MigrateOperation { \nprivate void addMessagingActiveMQExtension ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , boolean describe ) { \nResource root = context . readResourceFromRoot ( PathAddress . EMPTY_ADDRESS , false ) ; \nif ( root . getChildrenNames ( EXTENSION ) . contains ( MESSAGING_ACTIVEMQ_EXTENSION ) ) { \nreturn ; \n} \nPathAddress extensionAddress = pathAddress ( EXTENSION , MESSAGING_ACTIVEMQ_EXTENSION ) ; \nOperationEntry addEntry = context . getRootResourceRegistration ( ) . getOperationEntry ( extensionAddress , ADD ) ; \nModelNode addOperation = createAddOperation ( extensionAddress ) ; \naddOperation . get ( MODULE ) . set ( MESSAGING_ACTIVEMQ_MODULE ) ; \nif ( ! ( describe ) ) { \ncontext . addStep ( context . getResult ( ) . get ( extensionAddress . toString ( ) ) , addOperation , addEntry . getOperationHandler ( ) , MODEL ) ; \n} \nelse { \nmigrationOperations . put ( extensionAddress , addOperation ) ; \n} \n} \n} \n"}
{"2905": "public class MigrateOperation { \nprivate boolean parameterIsAllowed ( String name , String resourceType ) { \nswitch ( resourceType ) { \ncase REMOTE_ACCEPTOR : case HTTP_ACCEPTOR : case REMOTE_CONNECTOR : case HTTP_CONNECTOR : if ( ! ( \"use-nio\" . equals ( name ) ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \ndefault : return true ; \n} \n} \n} \n"}
{"2907": "public class CancellationFlag { \npublic boolean cancel ( boolean setFlag ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal , newVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( ! ( oldVal == ST_WAITING ) ) if ( ! ( oldVal == ST_CANCELLED ) ) if ( ! ( oldVal == ST_CANCELLED_FLAG_SET ) ) if ( ! ( oldVal == ST_STARTED ) ) { \nassert oldVal == ST_STARTED_FLAG_SET ; \nreturn false ; \n} \nelse { \nif ( ! setFlag ) { \nreturn false ; \n} \nnewVal = ST_STARTED_FLAG_SET ; \n} \nelse { \nreturn true ; \n} \nelse { \nif ( ! setFlag ) { \nreturn true ; \n} \nnewVal = ST_CANCELLED_FLAG_SET ; \n} \nelse { \nnewVal = ST_CANCELLED ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; \nreturn newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; \n} \n} \n"}
{"2908": "public class CancellationFlag { \npublic boolean runIfNotCancelled ( ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( ! ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) ) if ( oldVal != ST_WAITING ) { \nthrow Assert . unreachableCode ( ) ; \n} \nelse { \nreturn false ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; \nreturn true ; \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) { \ncount = count / 2 ; \n} \nif ( count < threshold ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( ! ( indexedFunctConditions != null ) ) { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( ! ( conditions . containsKey ( indexedField ) ) ) { \nbreak ; \n} \nelse { \nnMatchingKeys ++ ; \n} \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nelse { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \nif ( conditionEstimation > count ) { \nreturn count ; \n} \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2912": "public class OReflectionHelper { \nprivate static List < Class < ? > > findClasses ( final File iDirectory , String iPackageName , ClassLoader iClassLoader ) throws ClassNotFoundException { \nfinal List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; \nif ( ! iDirectory . exists ( ) ) return classes ; \niPackageName += \".\" + iDirectory . getName ( ) ; \nString className ; \nfinal File [ ] files = iDirectory . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \nif ( ! ( file . isDirectory ( ) ) ) if ( file . getName ( ) . endsWith ( CLASS_EXTENSION ) ) { \nclassName = file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - CLASS_EXTENSION . length ( ) ) ; \nclasses . add ( Class . forName ( iPackageName + '.' + className , true , iClassLoader ) ) ; \n} \nelse { \nif ( file . getName ( ) . contains ( \".\" ) ) continue ; \nclasses . addAll ( findClasses ( file , iPackageName , iClassLoader ) ) ; \n} \n} \nreturn classes ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( ! ( genericType != null && genericType instanceof ParameterizedType ) ) if ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; \nelse { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 0 ) { \nif ( ! ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) ) if ( ! ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) ) if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \nelse { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \n} \nelse { \nif ( ! ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) ) if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \nelse { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \n} \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"2918": "public class OLocalRecordCache { \npublic ORecord findRecord ( final ORID rid ) { \nORecord record ; \nrecord = underlying . get ( rid ) ; \nif ( ! ( record != null ) ) Orient . instance ( ) . getProfiler ( ) . updateCounter ( CACHE_MISS , \"Record not found in Level1 Cache\" , 1L , \"db.*.cache.level1.cache.notFound\" ) ; \nelse Orient . instance ( ) . getProfiler ( ) . updateCounter ( CACHE_HIT , \"Record found in Level1 Cache\" , 1L , \"db.*.cache.level1.cache.found\" ) ; \nreturn record ; \n} \n} \n"}
{"2920": "public class OSelectExecutionPlanner { \nprivate static List < OAndBlock > moveFlattededEqualitiesLeft ( List < OAndBlock > flattenedWhereClause ) { \nif ( flattenedWhereClause == null ) { \nreturn null ; \n} \nList < OAndBlock > result = new ArrayList < > ( ) ; \nfor ( OAndBlock block : flattenedWhereClause ) { \nList < OBooleanExpression > equalityExpressions = new ArrayList < > ( ) ; \nList < OBooleanExpression > nonEqualityExpressions = new ArrayList < > ( ) ; \nOAndBlock newBlock = block . copy ( ) ; \nfor ( OBooleanExpression exp : newBlock . getSubBlocks ( ) ) { \nif ( ! ( exp instanceof OBinaryCondition ) ) { \nnonEqualityExpressions . add ( exp ) ; \n} \nelse { \nif ( ! ( ( ( OBinaryCondition ) exp ) . getOperator ( ) instanceof OEqualsCompareOperator ) ) { \nnonEqualityExpressions . add ( exp ) ; \n} \nelse { \nequalityExpressions . add ( exp ) ; \n} \n} \n} \nOAndBlock newAnd = new OAndBlock ( - 1 ) ; \nnewAnd . getSubBlocks ( ) . addAll ( equalityExpressions ) ; \nnewAnd . getSubBlocks ( ) . addAll ( nonEqualityExpressions ) ; \nresult . add ( newAnd ) ; \n} \nreturn result ; \n} \n} \n"}
{"2921": "public class OSelectExecutionPlanner { \nprivate static void addOrderByProjections ( QueryPlanningInfo info ) { \nif ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null || ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) ) { \nreturn ; \n} \nOOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; \nList < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . orderBy = newOrderBy ; \n} \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . projectionAfterOrderBy = new OProjection ( - 1 ) ; \ninfo . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; \nfor ( String alias : info . projection . getAllAliases ( ) ) { \ninfo . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; \n} \nfor ( OProjectionItem item : additionalOrderByProjections ) { \nif ( ! ( info . preAggregateProjection != null ) ) { \ninfo . projection . getItems ( ) . add ( item ) ; \n} \nelse { \ninfo . preAggregateProjection . getItems ( ) . add ( item ) ; \ninfo . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \ninfo . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"2922": "public class OSelectExecutionPlanner { \nprivate static void extractSubQueries ( QueryPlanningInfo info ) { \nSubQueryCollector collector = new SubQueryCollector ( ) ; \nif ( info . perRecordLetClause != null ) { \ninfo . perRecordLetClause . extractSubQueries ( collector ) ; \n} \nint i = 0 ; \nint j = 0 ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( ! ( query . refersToParent ( ) ) ) { \naddGlobalLet ( info , alias , query , i ++ ) ; \n} \nelse { \naddRecordLevelLet ( info , alias , query , j ++ ) ; \n} \n} \ncollector . reset ( ) ; \nif ( info . whereClause != null ) { \ninfo . whereClause . extractSubQueries ( collector ) ; \n} \nif ( info . projection != null ) { \ninfo . projection . extractSubQueries ( collector ) ; \n} \nif ( info . orderBy != null ) { \ninfo . orderBy . extractSubQueries ( collector ) ; \n} \nif ( info . groupBy != null ) { \ninfo . groupBy . extractSubQueries ( collector ) ; \n} \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( ! ( query . refersToParent ( ) ) ) { \naddGlobalLet ( info , alias , query ) ; \n} \nelse { \naddRecordLevelLet ( info , alias , query ) ; \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( ! ( i == 0 ) ) { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nelse { \norderType = orderItem . getType ( ) ; \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2926": "public class OSelectExecutionPlanner { \nprivate Boolean getOrderDirection ( QueryPlanningInfo info ) { \nif ( info . orderBy == null ) { \nreturn null ; \n} \nString result = null ; \nfor ( OOrderByItem item : info . orderBy . getItems ( ) ) { \nif ( ! ( result == null ) ) { \nString newType = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; \nif ( ! newType . equals ( result ) ) { \nreturn null ; \n} \n} \nelse { \nresult = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; \n} \n} \nreturn result == null || result . equals ( OOrderByItem . ASC ) ; \n} \n} \n"}
{"2932": "public class OUser { \npublic ORole allow ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { \nif ( roles == null || roles . isEmpty ( ) ) { \nif ( ! ( document . field ( \"roles\" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( \"roles\" ) ) . isEmpty ( ) ) ) throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' has no role defined\" ) ; \nelse { \nfinal ODocument doc = document ; \ndocument = null ; \nfromStream ( doc ) ; \n} \n} \nfinal ORole role = checkIfAllowed ( resourceGeneric , resourceSpecific , iOperation ) ; \nif ( role == null ) throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' does not have permission to execute the operation '\" + ORole . permissionToString ( iOperation ) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific ) ; \nreturn role ; \n} \n} \n"}
{"2933": "public class OUser { \npublic boolean isRuleDefined ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific ) { \nfor ( ORole r : roles ) if ( ! ( r == null ) ) if ( r . hasRule ( resourceGeneric , resourceSpecific ) ) return true ; \nelse OLogManager . instance ( ) . warn ( this , \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\" , getName ( ) ) ; \nreturn false ; \n} \n} \n"}
{"2939": "public class OHazelcastPlugin { \nprivate void assignLockManagerFromCluster ( ) { \nString lockManagerServer = null ; \nwhile ( lockManagerServer == null ) { \nif ( ! ( activeNodes . size ( ) == 1 ) ) { \nlockManagerServer = ( String ) configurationMap . get ( CONFIG_LOCKMANAGER ) ; \nif ( lockManagerServer != null && lockManagerServer . equals ( nodeName ) ) { \nOLogManager . instance ( ) . info ( this , \"Found lock as current node, even if it was offline. Forcing a new election...\" ) ; \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nlockManagerServer = electNewLockManager ( ) ; \nbreak ; \n} \nif ( lockManagerServer != null ) break ; \n} \nelse { \nlockManagerServer = nodeName ; \nif ( configurationMap . putIfAbsent ( CONFIG_LOCKMANAGER , lockManagerServer ) == null ) break ; \n} \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException e ) { \nbreak ; \n} \n} \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nOLogManager . instance ( ) . info ( this , \"Distributed Lock Manager server is '%s'\" , lockManagerServer ) ; \n} \n} \n"}
{"2942": "public class OMicroTransaction { \npublic void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { \nif ( oldRid . equals ( newRid ) ) return ; \nfinal List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfor ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { \nfinal OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; \nif ( index == null ) throw new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; \nfinal Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; \nif ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; \nfinal OTransactionIndexChanges indexChanges = entry . getValue ( ) ; \nfor ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; \nif ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { \nkeyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; \niterator . remove ( ) ; \n} \n} \n} \nfinal ORecordOperation rec = resolveRecordOperation ( oldRid ) ; \nif ( rec != null ) { \nupdatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; \nif ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { \nORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; \nfinal ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; \nif ( ! ( recordId == null ) ) { \nrecordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; \nrecordId . setClusterId ( newRid . getClusterId ( ) ) ; \n} \nelse { \nORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; \n} \nORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; \n} \n} \nfor ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; \nfinal List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; \nif ( transactionIndexOperations != null ) { \nfor ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { \nOTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; \nif ( indexEntryChanges == null ) continue ; \nfinal OTransactionIndexChangesPerKey keyChanges ; \nif ( ! ( indexOperation . key == null ) ) { \nkeyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; \n} \nelse { \nkeyChanges = indexEntryChanges . nullKeyChanges ; \n} \nif ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; \n} \n} \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( ! ( involvedClusters . isEmpty ( ) ) ) { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nelse maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nif ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( ! ( dResult instanceof ONeedRetryException ) ) if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \nelse throw ( ONeedRetryException ) dResult ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( ! ( result instanceof ONeedRetryException ) ) if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \nelse throw ( ONeedRetryException ) result ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2953": "public class OIndexFullText { \n@ Override public OIndexFullText put ( Object key , final OIdentifiable singleValue ) { \nif ( key == null ) { \nreturn this ; \n} \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( ! ( apiVersion == 0 ) ) if ( ! ( apiVersion == 1 ) ) { \nthrow new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \nelse { \ndoPutV1 ( singleValue , word ) ; \n} \nelse { \ndoPutV0 ( singleValue , word ) ; \n} \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"2954": "public class OIndexFullText { \n@ Override public boolean remove ( Object key , final OIdentifiable value ) { \nif ( key == null ) { \nreturn false ; \n} \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfinal OModifiableBoolean removed = new OModifiableBoolean ( false ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( ! ( apiVersion == 0 ) ) if ( ! ( apiVersion == 1 ) ) { \nthrow new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \nelse { \nremoveV1 ( value , removed , word ) ; \n} \nelse { \nremoveV0 ( value , removed , word ) ; \n} \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn removed . getValue ( ) ; \n} \n} \n"}
{"2955": "public class OSQLQuery { \n@ SuppressWarnings ( \"unchecked\" ) public List < T > run ( final Object ... iArgs ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( database == null ) throw new OQueryParsingException ( \"No database configured\" ) ; \n( ( OMetadataInternal ) database . getMetadata ( ) ) . makeThreadLocalSchemaSnapshot ( ) ; \ntry { \nsetParameters ( iArgs ) ; \nObject o = database . getStorage ( ) . command ( this ) ; \nif ( ! ( o instanceof List ) ) { \nreturn ( List < T > ) Collections . singletonList ( o ) ; \n} \nelse { \nreturn ( List < T > ) o ; \n} \n} \nfinally { \n( ( OMetadataInternal ) database . getMetadata ( ) ) . clearThreadLocalSchemaSnapshot ( ) ; \n} \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) host = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \nif ( host . contains ( \"/\" ) ) host = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \nif ( ! ( ! host . contains ( \":\" ) ) ) if ( host . split ( \":\" ) . length < 2 || host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) host += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse host += \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2964": "public class OLazyCollectionUtil { \nprotected static OObjectDatabaseTx getDatabase ( ) { \nODatabaseInternal < ? > databaseOwner = ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ; \nif ( ! ( databaseOwner instanceof OObjectDatabaseTx ) ) if ( databaseOwner instanceof ODatabaseDocumentInternal ) { \nreturn new OObjectDatabaseTx ( ( ODatabaseDocumentInternal ) databaseOwner ) ; \n} \nelse { \nreturn ( OObjectDatabaseTx ) databaseOwner ; \n} \nthrow new IllegalStateException ( \"Current database not of expected type\" ) ; \n} \n} \n"}
{"2969": "public class OClientConnectionManager { \npublic void pushDistribCfg2Clients ( final ODocument iConfig ) { \nif ( iConfig == null ) return ; \nfinal Set < String > pushed = new HashSet < String > ( ) ; \nfor ( OClientConnection c : connections . values ( ) ) { \nif ( ! c . getData ( ) . supportsLegacyPushMessages ) continue ; \ntry { \nfinal String remoteAddress = c . getRemoteAddress ( ) ; \nif ( pushed . contains ( remoteAddress ) ) continue ; \n} \ncatch ( Exception e ) { \ncontinue ; \n} \nif ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) || c . getData ( ) . getSerializationImpl ( ) == null ) continue ; \nfinal ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; \nfinal OChannelBinary channel = p . getChannel ( ) ; \nfinal ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; \nif ( ser == null ) return ; \nfinal byte [ ] content = ser . toStream ( iConfig , false ) ; \ntry { \nif ( ! ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) ) { \nOLogManager . instance ( ) . info ( this , \"Timeout on sending updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nelse { \ntry { \nchannel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; \nchannel . writeInt ( Integer . MIN_VALUE ) ; \nchannel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; \nchannel . writeBytes ( content ) ; \nchannel . flush ( ) ; \npushed . add ( c . getRemoteAddress ( ) ) ; \nOLogManager . instance ( ) . debug ( this , \"Sent updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nfinally { \nchannel . releaseWriteLock ( ) ; \n} \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . warn ( this , \"Cannot push cluster configuration to the client %s\" , e , c . getRemoteAddress ( ) ) ; \n} \n} \n} \n} \n"}
{"2971": "public class OTransactionAbstract { \n@ Override public void close ( ) { \nfor ( Map . Entry < ORID , LockedRecordMetadata > lock : locks . entrySet ( ) ) { \ntry { \nfinal LockedRecordMetadata lockedRecordMetadata = lock . getValue ( ) ; \nif ( ! ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . EXCLUSIVE_LOCK ) ) ) if ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . SHARED_LOCK ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseReadLock ( lock . getKey ( ) ) ; \n} \nelse { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseWriteLock ( lock . getKey ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error on releasing lock against record \" + lock . getKey ( ) , e ) ; \n} \n} \nlocks . clear ( ) ; \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) return ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nfor ( Class < ? > currentClass = iClass ; \ncurrentClass != Object . class ; \n) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) { \n( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \n} \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \nif ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) && reloadSchema ) { \ndatabase . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( ! ( missedChar != null ) ) { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( ! ( c2 == 'u' ) ) { \nmissedChar = c2 ; \n} \nelse { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \ni < 4 ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \n} \n} \nelse { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \ncursor ++ ; \nif ( ! ( c == NEW_LINE ) ) ++ columnNumber ; \nelse { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nreturn ( char ) c ; \n} \n} \n"}
{"2977": "public class OCommandRequestAbstract { \n@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { \nif ( ! ( iCallback != null ) ) onAsyncReplicationError = null ; \nelse { \nonAsyncReplicationError = new OAsyncReplicationError ( ) { \nint retry = 0 ; \n@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { \nswitch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { \ncase RETRY : execute ( ) ; \nbreak ; \ncase IGNORE : } \nreturn ACTION . IGNORE ; \n} \n} \n; \n} \nreturn this ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( ! ( Platform . isLinux ( ) ) ) if ( Platform . isWindows ( ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \n} \nreturn recommended ; \n} \nelse { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( ! ( result == 0 && rlimit . rlim_cur > 0 ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \n} \nelse { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \n} \nif ( rlimit . rlim_cur < recommended ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \n} \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \n} \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \n} \nreturn defLimit ; \n} \n} \n"}
{"2988": "public class OMatchStatement { \n@ Override public < RET extends OCommandExecutor > RET parse ( OCommandRequest iRequest ) { \nfinal OCommandRequestText textRequest = ( OCommandRequestText ) iRequest ; \nif ( ! ( iRequest instanceof OSQLSynchQuery ) ) if ( ! ( iRequest instanceof OSQLAsynchQuery ) ) { \nrequest = new OSQLSynchQuery < ODocument > ( textRequest . getText ( ) ) ; \nif ( textRequest . getResultListener ( ) != null ) { \nrequest . setResultListener ( textRequest . getResultListener ( ) ) ; \n} \n} \nelse { \nrequest = ( OSQLAsynchQuery < ODocument > ) iRequest ; \n} \nelse { \nrequest = ( OSQLSynchQuery < ODocument > ) iRequest ; \n} \nString queryText = textRequest . getText ( ) ; \nfinal InputStream is = new ByteArrayInputStream ( queryText . getBytes ( ) ) ; \nOrientSql osql = null ; \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nif ( ! ( db == null ) ) { \nosql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \n} \nelse { \nosql = new OrientSql ( is ) ; \n} \n} \ncatch ( UnsupportedEncodingException e ) { \nOLogManager . instance ( ) . warn ( this , \"Invalid charset for database \" + getDatabase ( ) + \" \" + getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nosql = new OrientSql ( is ) ; \n} \ntry { \nOMatchStatement result = ( OMatchStatement ) osql . parse ( ) ; \nthis . matchExpressions = result . matchExpressions ; \nthis . notMatchExpressions = result . notMatchExpressions ; \nthis . returnItems = result . returnItems ; \nthis . returnAliases = result . returnAliases ; \nthis . limit = result . limit ; \n} \ncatch ( ParseException e ) { \nOCommandSQLParsingException ex = new OCommandSQLParsingException ( e , queryText ) ; \nOErrorCode . QUERY_PARSE_ERROR . throwException ( ex . getMessage ( ) , ex ) ; \n} \nbuildPatterns ( ) ; \npattern . validate ( ) ; \nreturn ( RET ) this ; \n} \n} \n"}
{"2990": "public class OMatchStatement { \nprivate void updateScheduleStartingAt ( PatternNode startNode , Set < PatternNode > visitedNodes , Set < PatternEdge > visitedEdges , Map < String , Set < String > > remainingDependencies , List < EdgeTraversal > resultingSchedule ) { \nvisitedNodes . add ( startNode ) ; \nfor ( Set < String > dependencies : remainingDependencies . values ( ) ) { \ndependencies . remove ( startNode . alias ) ; \n} \nMap < PatternEdge , Boolean > edges = new LinkedHashMap < PatternEdge , Boolean > ( ) ; \nfor ( PatternEdge outEdge : startNode . out ) { \nedges . put ( outEdge , true ) ; \n} \nfor ( PatternEdge inEdge : startNode . in ) { \nedges . put ( inEdge , false ) ; \n} \nfor ( Map . Entry < PatternEdge , Boolean > edgeData : edges . entrySet ( ) ) { \nPatternEdge edge = edgeData . getKey ( ) ; \nboolean isOutbound = edgeData . getValue ( ) ; \nPatternNode neighboringNode = isOutbound ? edge . in : edge . out ; \nif ( ! remainingDependencies . get ( neighboringNode . alias ) . isEmpty ( ) ) { \ncontinue ; \n} \nif ( ! ( visitedNodes . contains ( neighboringNode ) ) ) if ( ! startNode . optional ) { \nif ( visitedEdges . contains ( edge ) ) { \nthrow new AssertionError ( \"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode ) ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , isOutbound ) ) ; \nupdateScheduleStartingAt ( neighboringNode , visitedNodes , visitedEdges , remainingDependencies , resultingSchedule ) ; \n} \nelse { \nif ( ! visitedEdges . contains ( edge ) ) { \nboolean traversalDirection ; \nif ( ! ( startNode . optional || edge . item . isBidirectional ( ) ) ) { \ntraversalDirection = isOutbound ; \n} \nelse { \ntraversalDirection = ! isOutbound ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , traversalDirection ) ) ; \n} \n} \n} \n} \n} \n"}
{"2991": "public class OCompositeIndexDefinition { \npublic void addIndex ( final OIndexDefinition indexDefinition ) { \nindexDefinitions . add ( indexDefinition ) ; \nif ( indexDefinition instanceof OIndexDefinitionMultiValue ) { \nif ( ! ( multiValueDefinitionIndex == - 1 ) ) throw new OIndexException ( \"Composite key cannot contain more than one collection item\" ) ; \nelse multiValueDefinitionIndex = indexDefinitions . size ( ) - 1 ; \n} \ncollate . addCollate ( indexDefinition . getCollate ( ) ) ; \n} \n} \n"}
{"2992": "public class OProjectionItem { \npublic OProjectionItem splitForAggregation ( AggregateProjectionSplit aggregateSplit , OCommandContext ctx ) { \nif ( ! ( isAggregate ( ) ) ) { \nreturn this ; \n} \nelse { \nOProjectionItem result = new OProjectionItem ( - 1 ) ; \nresult . alias = getProjectionAlias ( ) ; \nresult . expression = expression . splitForAggregation ( aggregateSplit , ctx ) ; \nresult . nestedProjection = nestedProjection ; \nreturn result ; \n} \n} \n} \n"}
{"2993": "public class OJson { \npublic Object toObjectDetermineType ( OResult source , OCommandContext ctx ) { \nString className = getClassNameForDocument ( ctx ) ; \nString type = getTypeForDocument ( ctx ) ; \nif ( ! ( className != null || ( type != null && \"d\" . equalsIgnoreCase ( type ) ) ) ) { \nreturn toMap ( source , ctx ) ; \n} \nelse { \nreturn toDocument ( source , ctx , className ) ; \n} \n} \n} \n"}
{"2999": "public class OSecurityManager { \npublic boolean checkPassword ( final String iPassword , final String iHash ) { \nif ( ! ( iHash . startsWith ( HASH_ALGORITHM_PREFIX ) ) ) if ( ! ( iHash . startsWith ( PBKDF2_ALGORITHM_PREFIX ) ) ) if ( iHash . startsWith ( PBKDF2_SHA256_ALGORITHM_PREFIX ) ) { \nfinal String s = iHash . substring ( PBKDF2_SHA256_ALGORITHM_PREFIX . length ( ) ) ; \nreturn checkPasswordWithSalt ( iPassword , s , PBKDF2_SHA256_ALGORITHM ) ; \n} \nelse { \nfinal String s = iHash . substring ( PBKDF2_ALGORITHM_PREFIX . length ( ) ) ; \nreturn checkPasswordWithSalt ( iPassword , s , PBKDF2_ALGORITHM ) ; \n} \nelse { \nfinal String s = iHash . substring ( HASH_ALGORITHM_PREFIX . length ( ) ) ; \nreturn createSHA256 ( iPassword ) . equals ( s ) ; \n} \nreturn MessageDigest . isEqual ( digestSHA256 ( iPassword ) , digestSHA256 ( iHash ) ) ; \n} \n} \n"}
{"3000": "public class OSecurityManager { \npublic String createHash ( final String iInput , final String iAlgorithm , final boolean iIncludeAlgorithm ) { \nif ( iInput == null ) throw new IllegalArgumentException ( \"Input string is null\" ) ; \nif ( iAlgorithm == null ) throw new IllegalArgumentException ( \"Algorithm is null\" ) ; \nfinal StringBuilder buffer = new StringBuilder ( 128 ) ; \nfinal String algorithm = validateAlgorithm ( iAlgorithm ) ; \nif ( iIncludeAlgorithm ) { \nbuffer . append ( '{' ) ; \nbuffer . append ( algorithm ) ; \nbuffer . append ( '}' ) ; \n} \nfinal String transformed ; \nif ( ! ( HASH_ALGORITHM . equalsIgnoreCase ( algorithm ) ) ) if ( ! ( PBKDF2_ALGORITHM . equalsIgnoreCase ( algorithm ) ) ) if ( ! ( PBKDF2_SHA256_ALGORITHM . equalsIgnoreCase ( algorithm ) ) ) throw new IllegalArgumentException ( \"Algorithm '\" + algorithm + \"' is not supported\" ) ; \nelse { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse { \ntransformed = createSHA256 ( iInput ) ; \n} \nbuffer . append ( transformed ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"3002": "public class OIndexAbstract { \npublic OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { \nacquireExclusiveLock ( ) ; \ntry { \nconfiguration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; \nthis . indexDefinition = indexDefinition ; \nif ( ! ( clustersToIndex != null ) ) this . clustersToIndex = new HashSet < > ( ) ; \nelse this . clustersToIndex = new HashSet < > ( clustersToIndex ) ; \ntry { \nif ( apiVersion == 0 ) { \nremoveValuesContainer ( ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during deletion of index '%s'\" , e , name ) ; \n} \nindexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; \napiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; \nassert indexId >= 0 ; \nassert apiVersion >= 0 ; \nonIndexEngineChange ( indexId ) ; \nif ( rebuild ) fillIndex ( progressListener , false ) ; \nupdateConfiguration ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' creation\" , e , name ) ; \nwhile ( true ) try { \nif ( indexId >= 0 ) storage . deleteIndexEngine ( indexId ) ; \nbreak ; \n} \ncatch ( OInvalidIndexEngineIdException ignore ) { \ndoReloadIndexEngine ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' deletion\" , ex , name ) ; \n} \nif ( e instanceof OIndexException ) throw ( OIndexException ) e ; \nthrow OException . wrapException ( new OIndexException ( \"Cannot create the index '\" + name + \"'\" ) , e ) ; \n} \nfinally { \nreleaseExclusiveLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"3003": "public class OrientGraphQuery { \n@ Override public Iterable < Vertex > vertices ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nOTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; \nif ( transaction . isActive ( ) && transaction . getEntryCount ( ) > 0 || hasCustomPredicate ( ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ! ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && labels . length > 0 ) ) text . append ( OrientVertexType . CLASS_NAME ) ; \nelse { \nif ( ! ( labels . length == 1 ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nelse text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \n} \nfinal List < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nif ( orderBy . length ( ) > 1 ) { \ntext . append ( ORDERBY ) ; \ntext . append ( orderBy ) ; \ntext . append ( \" \" ) . append ( orderByDir ) . append ( \" \" ) ; \n} \nif ( skip > 0 && skip < Integer . MAX_VALUE ) { \ntext . append ( SKIP ) ; \ntext . append ( skip ) ; \n} \nif ( limit > 0 && limit < Integer . MAX_VALUE ) { \ntext . append ( LIMIT ) ; \ntext . append ( limit ) ; \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nreturn new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3004": "public class OrientGraphQuery { \n@ Override public Iterable < Edge > edges ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nif ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) || hasCustomPredicate ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ! ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && labels . length > 0 ) ) text . append ( OrientEdgeType . CLASS_NAME ) ; \nelse { \nif ( ! ( labels . length == 1 ) ) { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \nelse text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \n} \nList < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nif ( limit > 0 && limit < Integer . MAX_VALUE ) query . setLimit ( limit ) ; \nreturn new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( ! ( changesContainer == null ) ) if ( ! ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) ) return ! changesContainer . truncate ; \nelse { \nreturn pageIndex < changesContainer . maxNewPageIndex + 1 ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"3009": "public class OCommandExecutorSQLAbstract { \nprotected boolean parseTimeout ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_TIMEOUT ) ) return false ; \nString word = parserNextWord ( true ) ; \ntry { \ntimeoutMs = Long . parseLong ( word ) ; \n} \ncatch ( NumberFormatException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \" + KEYWORD_TIMEOUT + \" 3000\" ) ; \n} \nif ( timeoutMs < 0 ) throwParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\" ) ; \nword = parserNextWord ( true ) ; \nif ( word != null ) if ( ! ( word . equals ( TIMEOUT_STRATEGY . EXCEPTION . toString ( ) ) ) ) if ( ! ( word . equals ( TIMEOUT_STRATEGY . RETURN . toString ( ) ) ) ) parserGoBack ( ) ; \nelse timeoutStrategy = TIMEOUT_STRATEGY . RETURN ; \nelse timeoutStrategy = TIMEOUT_STRATEGY . EXCEPTION ; \nreturn true ; \n} \n} \n"}
{"3011": "public class OSystemDatabase { \npublic void createCluster ( final String className , final String clusterName ) { \nfinal ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal ODatabaseDocumentInternal sysdb = openSystemDatabase ( ) ; \ntry { \nif ( ! sysdb . existsCluster ( clusterName ) ) { \nOSchema schema = sysdb . getMetadata ( ) . getSchema ( ) ; \nOClass cls = schema . getClass ( className ) ; \nif ( ! ( cls != null ) ) { \nOLogManager . instance ( ) . error ( this , \"createCluster() Class name %s does not exist\" , null , className ) ; \n} \nelse { \ncls . addCluster ( clusterName ) ; \n} \n} \n} \nfinally { \nsysdb . close ( ) ; \n} \n} \nfinally { \nif ( ! ( currentDB != null ) ) ODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \nelse ODatabaseRecordThreadLocal . instance ( ) . set ( currentDB ) ; \n} \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \nreturn true ; \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( ! ( cls . isSubClassOf ( \"V\" ) ) ) if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( ! ( \"?\" . equals ( value . getName ( ) ) ) ) { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \n} \n} \n} \n"}
{"3024": "public class OPropertyImpl { \n@ Deprecated public OPropertyImpl dropIndexes ( ) { \ngetDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_DELETE ) ; \nacquireSchemaReadLock ( ) ; \ntry { \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal ArrayList < OIndex < ? > > relatedIndexes = new ArrayList < OIndex < ? > > ( ) ; \nfor ( final OIndex < ? > index : indexManager . getClassIndexes ( owner . getName ( ) ) ) { \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nif ( OCollections . indexOf ( definition . getFields ( ) , globalRef . getName ( ) , new OCaseInsentiveComparator ( ) ) > - 1 ) { \nif ( ! ( definition instanceof OPropertyIndexDefinition ) ) { \nthrow new IllegalArgumentException ( \"This operation applicable only for property indexes. \" + index . getName ( ) + \" is \" + index . getDefinition ( ) ) ; \n} \nelse { \nrelatedIndexes . add ( index ) ; \n} \n} \n} \nfor ( final OIndex < ? > index : relatedIndexes ) getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( index . getName ( ) ) ; \nreturn this ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3031": "public class ODatabaseDocumentEmbedded { \npublic ODatabaseDocumentInternal copy ( ) { \nODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded ( getSharedContext ( ) . getStorage ( ) ) ; \ndatabase . init ( config , this . sharedContext ) ; \nString user ; \nif ( ! ( getUser ( ) != null ) ) { \nuser = null ; \n} \nelse { \nuser = getUser ( ) . getName ( ) ; \n} \ndatabase . internalOpen ( user , null , false ) ; \ndatabase . callOnOpenListeners ( ) ; \nthis . activateOnCurrentThread ( ) ; \nreturn database ; \n} \n} \n"}
{"3032": "public class ORidBag { \npublic boolean tryMerge ( final ORidBag otherValue , boolean iMergeSingleItemsOfMultiValueFields ) { \nif ( ! ( ! isEmbedded ( ) && ! otherValue . isEmbedded ( ) ) ) if ( iMergeSingleItemsOfMultiValueFields ) { \nfinal Iterator < OIdentifiable > iter = otherValue . rawIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal OIdentifiable value = iter . next ( ) ; \nif ( value != null ) { \nfinal Iterator < OIdentifiable > localIter = rawIterator ( ) ; \nboolean found = false ; \nwhile ( localIter . hasNext ( ) ) { \nfinal OIdentifiable v = localIter . next ( ) ; \nif ( value . equals ( v ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) add ( value ) ; \n} \n} \nreturn true ; \n} \nelse { \nfinal OSBTreeRidBag thisTree = ( OSBTreeRidBag ) delegate ; \nfinal OSBTreeRidBag otherTree = ( OSBTreeRidBag ) otherValue . delegate ; \nif ( thisTree . getCollectionPointer ( ) . equals ( otherTree . getCollectionPointer ( ) ) ) { \nthisTree . mergeChanges ( otherTree ) ; \nuuid = otherValue . uuid ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3034": "public class OCommandExecutorUtility { \npublic static Object transformResult ( Object result ) { \nif ( java8MethodIsArray == null || ! ( result instanceof Map ) ) { \nreturn result ; \n} \ntry { \nif ( ! ( ( Boolean ) java8MethodIsArray . invoke ( result ) ) ) { \nMap < Object , Object > mapResult = ( Map ) result ; \nList < Object > keys = new ArrayList < Object > ( mapResult . keySet ( ) ) ; \nfor ( Object key : keys ) { \nmapResult . put ( key , transformResult ( mapResult . get ( key ) ) ) ; \n} \nreturn mapResult ; \n} \nelse { \nList < ? > partial = new ArrayList ( ( ( Map ) result ) . values ( ) ) ; \nList < Object > finalResult = new ArrayList < Object > ( ) ; \nfor ( Object o : partial ) { \nfinalResult . add ( transformResult ( o ) ) ; \n} \nreturn finalResult ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( OCommandExecutorUtility . class , \"\" , e ) ; \n} \nreturn result ; \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal int clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( clusterId > - 1 ) throw new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \nif ( ! ( blob ) ) { \nif ( ! ( requestedId == - 1 ) ) { \nreturn database . addCluster ( clusterName , requestedId , null ) ; \n} \nelse { \nreturn database . addCluster ( clusterName ) ; \n} \n} \nelse { \nif ( ! ( requestedId == - 1 ) ) { \nthrow new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \n} \nelse { \nreturn database . addBlobCluster ( clusterName ) ; \n} \n} \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . logRecordCount ++ ; \nwalCountersHolder . logRecordTime += timeDiff ; \nif ( ! ( isStartRecord ) ) if ( isStopRecord ) { \nwalCountersHolder . stopRecordCount ++ ; \nwalCountersHolder . stopRecordTime += timeDiff ; \n} \nelse { \nwalCountersHolder . startRecordCount ++ ; \nwalCountersHolder . startRecordTime += timeDiff ; \n} \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3063": "public class OStatementCache { \nprotected static OStatement parse ( String statement ) throws OCommandSQLParsingException { \ntry { \nODatabaseDocumentInternal db = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \nInputStream is ; \nif ( ! ( db == null ) ) { \ntry { \nis = new ByteArrayInputStream ( statement . getBytes ( db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e2 ) { \nOLogManager . instance ( ) . warn ( null , \"Unsupported charset for database \" + db + \" \" + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nis = new ByteArrayInputStream ( statement . getBytes ( ) ) ; \n} \n} \nelse { \nis = new ByteArrayInputStream ( statement . getBytes ( ) ) ; \n} \nOrientSql osql = null ; \nif ( ! ( db == null ) ) { \ntry { \nosql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e2 ) { \nOLogManager . instance ( ) . warn ( null , \"Unsupported charset for database \" + db + \" \" + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nosql = new OrientSql ( is ) ; \n} \n} \nelse { \nosql = new OrientSql ( is ) ; \n} \nOStatement result = osql . parse ( ) ; \nresult . originalStatement = statement ; \nreturn result ; \n} \ncatch ( ParseException e ) { \nthrowParsingException ( e , statement ) ; \n} \ncatch ( TokenMgrError e2 ) { \nthrowParsingException ( e2 , statement ) ; \n} \nreturn null ; \n} \n} \n"}
{"3069": "public class OrientElement { \nprotected String checkForClassInSchema ( final String className ) { \nif ( className == null ) return null ; \nOrientBaseGraph graph = getGraph ( ) ; \nif ( graph == null ) return className ; \nfinal OSchema schema = graph . getRawGraph ( ) . getMetadata ( ) . getSchema ( ) ; \nif ( ! ( ! schema . existsClass ( className ) ) ) { \nfinal OClass cls = schema . getClass ( className ) ; \nif ( ! cls . isSubClassOf ( getBaseClassName ( ) ) ) throw new IllegalArgumentException ( \"Class '\" + className + \"' is not an instance of \" + getBaseClassName ( ) ) ; \n} \nelse { \ntry { \ngraph . executeOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nreturn schema . createClass ( className , schema . getClass ( getBaseClassName ( ) ) ) ; \n} \n} \n, \"Committing the active transaction to create the new type '\" , className , \"' as subclass of '\" , getBaseClassName ( ) , \"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\" ) ; \n} \ncatch ( OSchemaException e ) { \nif ( ! schema . existsClass ( className ) ) throw e ; \n} \n} \nreturn className ; \n} \n} \n"}
{"3073": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( ! ( iClass == null ) ) { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) if ( entry . getRecord ( ) != null && entry . getRecord ( ) instanceof ODocument ) { \nif ( ! ( iPolymorphic ) ) if ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) result . add ( entry ) ; \nelse { \nif ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) result . add ( entry ) ; \n} \n} \n} \n} \nelse for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nreturn result ; \n} \n} \n"}
{"3074": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClusterIds ( final int [ ] iIds ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( ! ( iIds == null ) ) for ( ORecordOperation entry : allEntries . values ( ) ) { \nfor ( int id : iIds ) { \nif ( entry . getRecord ( ) != null && entry . getRecord ( ) . getIdentity ( ) . getClusterId ( ) == id && entry . type == ORecordOperation . CREATED ) { \nresult . add ( entry ) ; \nbreak ; \n} \n} \n} \nelse for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nreturn result ; \n} \n} \n"}
{"3075": "public class OTransactionRealAbstract { \npublic void addIndexEntry ( final OIndex < ? > delegate , final String iIndexName , final OTransactionIndexChanges . OPERATION iOperation , final Object key , final OIdentifiable iValue , boolean clientTrackOnly ) { \nOTransactionIndexChanges indexEntry = indexEntries . get ( iIndexName ) ; \nif ( indexEntry == null ) { \nindexEntry = new OTransactionIndexChanges ( ) ; \nindexEntries . put ( iIndexName , indexEntry ) ; \n} \nif ( ! ( iOperation == OPERATION . CLEAR ) ) { \nOTransactionIndexChangesPerKey changes = indexEntry . getChangesPerKey ( key ) ; \nchanges . clientTrackOnly = clientTrackOnly ; \nchanges . add ( iValue , iOperation ) ; \nif ( iValue == null ) return ; \nList < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( iValue . getIdentity ( ) ) ; \nif ( transactionIndexOperations == null ) { \ntransactionIndexOperations = new ArrayList < OTransactionRecordIndexOperation > ( ) ; \nrecordIndexOperations . put ( iValue . getIdentity ( ) . copy ( ) , transactionIndexOperations ) ; \n} \ntransactionIndexOperations . add ( new OTransactionRecordIndexOperation ( iIndexName , key , iOperation ) ) ; \n} \nelse indexEntry . setCleared ( ) ; \n} \n} \n"}
{"3076": "public class ODirtyManager { \nprivate static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { \nif ( ! ( source != null ) ) { \nreturn target ; \n} \nelse { \nif ( ! ( target == null ) ) { \nif ( ! ( target . size ( ) > source . size ( ) ) ) { \nsource . addAll ( target ) ; \nreturn source ; \n} \nelse { \ntarget . addAll ( source ) ; \nreturn target ; \n} \n} \nelse { \nreturn source ; \n} \n} \n} \n} \n"}
{"3079": "public class OChainedIndexProxy { \nprivate Set < Comparable > prepareKeys ( OIndex < ? > index , Object keys ) { \nfinal OIndexDefinition indexDefinition = index . getDefinition ( ) ; \nif ( ! ( keys instanceof Collection ) ) { \nreturn Collections . singleton ( ( Comparable ) indexDefinition . createValue ( keys ) ) ; \n} \nelse { \nfinal Set < Comparable > newKeys = new TreeSet < Comparable > ( ) ; \nfor ( Object o : ( ( Collection ) keys ) ) { \nnewKeys . add ( ( Comparable ) indexDefinition . createValue ( o ) ) ; \n} \nreturn newKeys ; \n} \n} \n} \n"}
{"3080": "public class OWALSegmentCache { \nvoid writePage ( ByteBuffer page , long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( ! ( pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache . size ( ) ) ) if ( pageCache . isEmpty ( ) ) { \npageCache . add ( page ) ; \nfirstCachedPage = pageIndex ; \n} \nelse { \nif ( ! ( pageIndex < firstCachedPage + pageCache . size ( ) ) ) { \npageCache . add ( page ) ; \n} \nelse { \npageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; \n} \n} \nlastWrittenPage = page ; \nlastWrittenPageIndex = pageIndex ; \nif ( pageCache . size ( ) * OWALPage . PAGE_SIZE >= bufferSize + OWALPage . PAGE_SIZE ) { \nflushAllBufferPagesExceptLastOne ( ) ; \n} \n} \n} \n} \n"}
{"3096": "public class ODistributedConfiguration { \npublic String getClusterOwner ( final String iClusterName ) { \nString owner ; \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nfinal ODocument cfg = iClusterName != null ? ( ODocument ) clusters . field ( iClusterName ) : null ; \nif ( ! ( cfg != null ) ) return getClusterOwner ( ALL_WILDCARD ) ; \nelse { \nowner = cfg . field ( OWNER ) ; \nif ( owner != null ) return owner ; \nfinal List < String > serverList = cfg . field ( SERVERS ) ; \nif ( serverList != null && ! serverList . isEmpty ( ) ) { \nowner = serverList . get ( 0 ) ; \nif ( NEW_NODE_TAG . equals ( owner ) && serverList . size ( ) > 1 ) owner = serverList . get ( 1 ) ; \n} \n} \nreturn owner ; \n} \n} \n"}
{"3101": "public class ODistributedConfiguration { \npublic int getDataCenterWriteQuorum ( final String dataCenter ) { \nfinal ODocument dc = getDataCenterConfiguration ( dataCenter ) ; \nObject wq = dc . field ( WRITE_QUORUM ) ; \nif ( wq instanceof String ) { \nif ( ! ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_MAJORITY ) ) ) if ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_ALL ) ) { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) ; \n} \nelse { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) / 2 + 1 ; \n} \n} \nreturn ( Integer ) wq ; \n} \n} \n"}
{"3106": "public class ODistributedConfiguration { \npublic int getWriteQuorum ( final String clusterName , final int totalConfiguredMasterServers , final String server ) { \nInteger overWrite = overwriteWriteQuorum . get ( ) ; \nif ( ! ( overWrite != null ) ) return getQuorum ( \"writeQuorum\" , clusterName , totalConfiguredMasterServers , DEFAULT_WRITE_QUORUM , server ) ; \nelse return overWrite . intValue ( ) ; \n} \n} \n"}
{"3107": "public class ODistributedConfiguration { \nprotected ODocument getClusterConfiguration ( String iClusterName ) { \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nif ( iClusterName == null ) iClusterName = ALL_WILDCARD ; \nfinal ODocument cfg ; \nif ( ! ( ! clusters . containsField ( iClusterName ) ) ) cfg = clusters . field ( iClusterName ) ; \nelse cfg = clusters . field ( ALL_WILDCARD ) ; \nif ( cfg == null ) return new ODocument ( ) ; \nreturn cfg ; \n} \n} \n"}
{"3110": "public class OrientBaseGraph { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < T extends Element > Index < T > getIndex ( final String indexName , final Class < T > indexClass ) { \nmakeActive ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex idx = indexManager . getIndex ( indexName ) ; \nif ( idx == null || ! hasIndexClass ( idx ) ) return null ; \nfinal Index < ? extends Element > index = new OrientIndex ( this , idx ) ; \nif ( ! ( indexClass . isAssignableFrom ( index . getIndexClass ( ) ) ) ) throw ExceptionFactory . indexDoesNotSupportClass ( indexName , indexClass ) ; \nelse return ( Index < T > ) index ; \n} \n} \n"}
{"3113": "public class OrientBaseGraph { \n@ Override public OrientEdge addEdge ( final Object id , Vertex outVertex , Vertex inVertex , final String label ) { \nmakeActive ( ) ; \nString className = null ; \nString clusterName = null ; \nif ( id != null ) { \nif ( id instanceof String ) { \nfinal String [ ] args = ( ( String ) id ) . split ( \",\" ) ; \nfor ( String s : args ) { \nif ( ! ( s . startsWith ( CLASS_PREFIX ) ) ) if ( s . startsWith ( CLUSTER_PREFIX ) ) clusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; \nelse className = s . substring ( CLASS_PREFIX . length ( ) ) ; \n} \n} \n} \nfinal Object [ ] fields = isSaveOriginalIds ( ) && id != null ? new Object [ ] { \nOrientElement . DEF_ORIGINAL_ID_FIELDNAME , id } \n: null ; \nif ( outVertex instanceof PartitionVertex ) outVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; \nif ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; \nreturn ( ( OrientVertex ) outVertex ) . addEdge ( label , ( OrientVertex ) inVertex , className , clusterName , fields ) ; \n} \n} \n"}
{"3114": "public class OrientBaseGraph { \npublic OrientVertex getVertex ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . vertexIdCanNotBeNull ( ) ; \nif ( ! ( id instanceof OrientVertex ) ) if ( id instanceof ODocument ) return getVertexInstance ( ( OIdentifiable ) id ) ; \nelse return ( OrientVertex ) id ; \nsetCurrentGraphInThreadLocal ( ) ; \nORID rid ; \nif ( ! ( id instanceof OIdentifiable ) ) { \ntry { \nrid = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nelse rid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; \nif ( ! rid . isValid ( ) ) return null ; \nfinal ORecord rec = rid . getRecord ( ) ; \nif ( rec == null || ! ( rec instanceof ODocument ) ) return null ; \nfinal OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; \nif ( cls != null && cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\" ) ; \nreturn getVertexInstance ( rec ) ; \n} \n} \n"}
{"3117": "public class OrientBaseGraph { \npublic OrientEdge getEdge ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; \nif ( ! ( id instanceof OrientEdge ) ) if ( id instanceof ODocument ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; \nelse return ( OrientEdge ) id ; \nfinal OIdentifiable rec ; \nif ( ! ( id instanceof OIdentifiable ) ) { \nfinal String str = id . toString ( ) ; \nint pos = str . indexOf ( \"->\" ) ; \nif ( pos > - 1 ) { \nfinal String from = str . substring ( 0 , pos ) ; \nfinal String to = str . substring ( pos + 2 ) ; \nreturn getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; \n} \ntry { \nrec = new ORecordId ( str ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nelse rec = ( OIdentifiable ) id ; \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc == null ) return null ; \nfinal OClass cls = doc . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isVertexType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\" ) ; \nif ( ! cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Class '\" + doc . getClassName ( ) + \"' is not an edge class\" ) ; \n} \nreturn new OrientEdge ( this , rec ) ; \n} \n} \n"}
{"3119": "public class OrientBaseGraph { \npublic void shutdown ( boolean closeDb , boolean commitTx ) { \nmakeActive ( ) ; \ntry { \nif ( ! isClosed ( ) ) { \nif ( ! ( commitTx ) ) if ( closeDb ) { \ngetDatabase ( ) . rollback ( ) ; \n} \nelse { \nfinal OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; \nif ( ! ( storage instanceof OAbstractPaginatedStorage ) ) { \ngetDatabase ( ) . commit ( ) ; \n} \nelse { \nif ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) getDatabase ( ) . commit ( ) ; \n} \n} \n} \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow e ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during context close for db \" + url ) , e ) ; \n} \nfinally { \ntry { \nif ( closeDb ) { \ngetDatabase ( ) . close ( ) ; \nif ( getDatabase ( ) . isPooled ( ) ) { \ndatabase = null ; \n} \n} \npollGraphFromStack ( closeDb ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \n} \n} \nurl = null ; \nusername = null ; \npassword = null ; \nif ( ! closeDb ) getDatabase ( ) . activateOnCurrentThread ( ) ; \n} \n} \n"}
{"3126": "public class OrientBaseGraph { \npublic OrientElement getElement ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw new IllegalArgumentException ( \"id cannot be null\" ) ; \nif ( id instanceof OrientElement ) return ( OrientElement ) id ; \nOIdentifiable rec ; \nif ( ! ( id instanceof OIdentifiable ) ) try { \nrec = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \nelse rec = ( OIdentifiable ) id ; \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc != null ) { \nfinal OImmutableClass schemaClass = ODocumentInternal . getImmutableSchemaClass ( doc ) ; \nif ( ! ( schemaClass != null && schemaClass . isEdgeType ( ) ) ) return getVertexInstance ( doc ) ; \nelse return getEdge ( doc ) ; \n} \nreturn null ; \n} \n} \n"}
{"3128": "public class OrientBaseGraph { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) @ Override public < T extends Element > void createKeyIndex ( final String key , final Class < T > elementClass , final Parameter ... indexParameters ) { \nmakeActive ( ) ; \nif ( elementClass == null ) throw ExceptionFactory . classForElementCannotBeNull ( ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nString indexType = OClass . INDEX_TYPE . NOTUNIQUE . name ( ) ; \nOType keyType = OType . STRING ; \nString className = null ; \nString collate = null ; \nODocument metadata = null ; \nfinal String ancestorClassName = getClassName ( elementClass ) ; \nfor ( Parameter < ? , ? > p : indexParameters ) { \nif ( ! ( p . getKey ( ) . equals ( \"type\" ) ) ) if ( ! ( p . getKey ( ) . equals ( \"keytype\" ) ) ) if ( ! ( p . getKey ( ) . equals ( \"class\" ) ) ) if ( ! ( p . getKey ( ) . equals ( \"collate\" ) ) ) if ( p . getKey ( ) . toString ( ) . startsWith ( \"metadata.\" ) ) { \nif ( metadata == null ) metadata = new ODocument ( ) ; \nmetadata . field ( p . getKey ( ) . toString ( ) . substring ( \"metadata.\" . length ( ) ) , p . getValue ( ) ) ; \n} \nelse collate = p . getValue ( ) . toString ( ) ; \nelse className = p . getValue ( ) . toString ( ) ; \nelse keyType = OType . valueOf ( p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \nelse indexType = p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ; \n} \nif ( className == null ) className = ancestorClassName ; \nfinal ODatabaseDocument db = getRawGraph ( ) ; \nfinal OSchema schema = db . getMetadata ( ) . getSchema ( ) ; \nfinal OClass cls = schema . getOrCreateClass ( className , schema . getClass ( ancestorClassName ) ) ; \nfinal OProperty property = cls . getProperty ( key ) ; \nif ( property != null ) keyType = property . getType ( ) ; \nOPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition ( className , key , keyType ) ; \nif ( collate != null ) indexDefinition . setCollate ( collate ) ; \ndb . getMetadata ( ) . getIndexManager ( ) . createIndex ( className + \".\" + key , indexType , indexDefinition , cls . getPolymorphicClusterIds ( ) , null , metadata ) ; \nreturn null ; \n} \n} \n, \"create key index on '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \n} \n} \n"}
{"3132": "public class OPerformanceStatisticManager { \npublic void registerMBean ( String storageName , int storageId ) { \nif ( mbeanIsRegistered . compareAndSet ( false , true ) ) { \ntry { \nfinal MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; \nfinal ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; \nif ( ! ( ! server . isRegistered ( mbeanName ) ) ) { \nmbeanIsRegistered . set ( false ) ; \nOLogManager . instance ( ) . warn ( this , \"MBean with name %s has already registered. Probably your system was not shutdown correctly\" + \" or you have several running applications which use OrientDB engine inside\" , mbeanName . getCanonicalName ( ) ) ; \n} \nelse { \nserver . registerMBean ( new OPerformanceStatisticManagerMBean ( this ) , mbeanName ) ; \n} \n} \ncatch ( MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during registration of profiler MBean\" ) , e ) ; \n} \n} \n} \n} \n"}
{"3134": "public class OPerformanceStatisticManager { \nprivate WritCacheCountersHolder fetchWriteCacheCounters ( ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nWritCacheCountersHolder holder = null ; \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( ! ( thread . isAlive ( ) ) ) { \nthreadsToRemove . add ( thread ) ; \n} \nelse { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nif ( snapshot . writCacheCountersHolder != null ) { \nif ( holder == null ) holder = new WritCacheCountersHolder ( ) ; \nsnapshot . writCacheCountersHolder . pushData ( holder ) ; \n} \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal WritCacheCountersHolder wch = ds . writCacheCountersHolder ; \nif ( wch != null ) { \nif ( holder == null ) holder = new WritCacheCountersHolder ( ) ; \nwch . pushData ( holder ) ; \n} \n} \nreturn holder ; \n} \n} \n"}
{"3135": "public class OPerformanceStatisticManager { \nprivate void fetchSystemCounters ( PerformanceCountersHolder countersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( ! ( thread . isAlive ( ) ) ) { \nthreadsToRemove . add ( thread ) ; \n} \nelse { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nsnapshot . performanceCountersHolder . pushData ( countersHolder ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersHolder ; \ndch . pushData ( countersHolder ) ; \n} \n} \n} \n"}
{"3136": "public class OPerformanceStatisticManager { \nprivate void fetchComponentCounters ( String componentName , PerformanceCountersHolder componentCountersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal List < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( ! ( thread . isAlive ( ) ) ) { \nthreadsToRemove . add ( thread ) ; \n} \nelse { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nfinal PerformanceCountersHolder holder = snapshot . countersByComponent . get ( componentName ) ; \nif ( holder != null ) holder . pushData ( componentCountersHolder ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersByComponents . get ( componentName ) ; \nif ( dch != null ) { \ndch . pushData ( componentCountersHolder ) ; \n} \n} \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( ! ( groupResponsesByResult ) ) { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \n} \nelse { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( ! ( payload instanceof Throwable ) ) if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \nelse { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \n} \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3156": "public class OSBTreeRidBag { \nprivate int updateSize ( ) { \nint size = 0 ; \nif ( ! ( collectionPointer != null ) ) { \nfor ( Change change : changes . values ( ) ) { \nsize += change . applyTo ( 0 ) ; \n} \n} \nelse { \nfinal OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; \nif ( tree == null ) { \nthrow new IllegalStateException ( \"RidBag is not properly initialized, can not load tree implementation\" ) ; \n} \ntry { \nsize = tree . getRealBagSize ( changes ) ; \n} \nfinally { \nreleaseTree ( ) ; \n} \n} \nfor ( OModifiableInteger diff : newEntries . values ( ) ) { \nsize += diff . getValue ( ) ; \n} \nthis . size = size ; \nreturn size ; \n} \n} \n"}
{"3157": "public class OHashIndexBucket { \npublic V getValue ( int index ) { \nint entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; \nentryPosition += OLongSerializer . LONG_SIZE ; \nif ( ! ( encryption == null ) ) { \nfinal int encryptedLength = getIntValue ( entryPosition ) ; \nentryPosition += encryptedLength + OIntegerSerializer . INT_SIZE ; \n} \nelse { \nentryPosition += getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; \n} \nreturn deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) ) { \nif ( c == '\\'' || c == '\"' ) { \nif ( ! ( stringChar == ' ' ) ) { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \nelse { \nstringChar = c ; \n} \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nelse { \nif ( ! ( iText . charAt ( i + 1 ) == 'u' ) ) escape = true ; \nelse { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \n} \nif ( ! ( iFrom < iTo ) ) { \nif ( -- i < iFrom ) break ; \n} \nelse { \nif ( ++ i > iTo ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3162": "public class OQueryAbstract { \npublic OQueryAbstract setFetchPlan ( final String fetchPlan ) { \nOFetchHelper . checkFetchPlanValid ( fetchPlan ) ; \nif ( ! ( fetchPlan != null && fetchPlan . length ( ) == 0 ) ) this . fetchPlan = fetchPlan ; \nelse this . fetchPlan = null ; \nreturn this ; \n} \n} \n"}
{"3169": "public class OEntityManager { \npublic synchronized void registerEntityClasses ( Class < ? > aClass , boolean recursive ) { \nif ( ! ( recursive ) ) { \nclassHandler . registerEntityClass ( aClass ) ; \n} \nelse { \nclassHandler . registerEntityClass ( aClass ) ; \nField [ ] declaredFields = aClass . getDeclaredFields ( ) ; \nfor ( Field declaredField : declaredFields ) { \nClass < ? > declaredFieldType = declaredField . getType ( ) ; \nif ( ! classHandler . containsEntityClass ( declaredFieldType ) ) { \nregisterEntityClasses ( declaredFieldType , recursive ) ; \n} \n} \n} \n} \n} \n"}
{"3185": "public class OSymmetricKey { \npublic static OSymmetricKey fromConfig ( final OSymmetricKeyConfig keyConfig ) { \nif ( ! ( keyConfig . usesKeyString ( ) ) ) if ( ! ( keyConfig . usesKeyFile ( ) ) ) if ( ! ( keyConfig . usesKeystore ( ) ) ) { \nthrow new OSecurityException ( \"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\" ) ; \n} \nelse { \nreturn fromKeystore ( keyConfig . getKeystoreFile ( ) , keyConfig . getKeystorePassword ( ) , keyConfig . getKeystoreKeyAlias ( ) , keyConfig . getKeystoreKeyPassword ( ) ) ; \n} \nelse { \nreturn fromFile ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyFile ( ) ) ; \n} \nelse { \nreturn fromString ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyString ( ) ) ; \n} \n} \n} \n"}
{"3191": "public class OBasicCommandContext { \npublic OCommandContext setChild ( final OCommandContext iContext ) { \nif ( ! ( iContext == null ) ) if ( child != iContext ) { \nchild = iContext ; \niContext . setParent ( this ) ; \n} \nelse { \nif ( child != null ) { \nchild . setParent ( null ) ; \nchild = null ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3193": "public class ORecordSerializerJSON { \nprivate Object getValueAsObjectOrMap ( ODocument iRecord , String iFieldValue , OType iType , OType iLinkedType , Map < String , Character > iFieldTypes , boolean iNoMap , String iOptions ) { \nfinal String [ ] fields = OStringParser . getWords ( iFieldValue . substring ( 1 , iFieldValue . length ( ) - 1 ) , \":,\" , true ) ; \nif ( fields == null || fields . length == 0 ) if ( ! ( iNoMap ) ) return new HashMap < String , Object > ( ) ; \nelse { \nODocument res = new ODocument ( ) ; \nODocumentInternal . addOwner ( res , iRecord ) ; \nreturn res ; \n} \nif ( ! ( iNoMap || hasTypeField ( fields ) ) ) { \nreturn getValueAsMap ( iRecord , iFieldValue , iLinkedType , iFieldTypes , false , iOptions , fields ) ; \n} \nelse { \nreturn getValueAsRecord ( iRecord , iFieldValue , iType , iOptions , fields ) ; \n} \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null || iKey == null ) return null ; \nif ( ! ( iKey instanceof String ) ) return iMap . get ( iKey ) ; \nelse { \nString iName = ( String ) iKey ; \nint pos = iName . indexOf ( '.' ) ; \nif ( pos > - 1 ) iName = iName . substring ( 0 , pos ) ; \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) return null ; \nif ( pos > - 1 ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( ! ( value instanceof ODocument ) ) if ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \nelse return getFieldValue ( value , restFieldName ) ; \n} \nreturn value ; \n} \n} \n} \n"}
{"3196": "public class OIdentifiableIterator { \nprotected ORecord getRecord ( ) { \nfinal ORecord record ; \nif ( ! ( reusedRecord != null ) ) record = null ; \nelse { \nrecord = reusedRecord ; \nrecord . reset ( ) ; \n} \nreturn record ; \n} \n} \n"}
{"3197": "public class OIdentifiableIterator { \nprotected ORecord readCurrentRecord ( ORecord iRecord , final int iMovement ) { \nif ( limit > - 1 && browsedRecords >= limit ) return null ; \ndo { \nfinal boolean moveResult ; \nswitch ( iMovement ) { \ncase 1 : moveResult = nextPosition ( ) ; \nbreak ; \ncase - 1 : moveResult = prevPosition ( ) ; \nbreak ; \ncase 0 : moveResult = checkCurrentPosition ( ) ; \nbreak ; \ndefault : throw new IllegalStateException ( \"Invalid movement value : \" + iMovement ) ; \n} \nif ( ! moveResult ) return null ; \ntry { \nif ( ! ( iRecord != null ) ) iRecord = database . load ( current , fetchPlan , false ) ; \nelse { \nORecordInternal . setIdentity ( iRecord , new ORecordId ( current . getClusterId ( ) , current . getClusterPosition ( ) ) ) ; \niRecord = database . load ( iRecord , fetchPlan , false ) ; \n} \n} \ncatch ( ODatabaseException e ) { \nif ( Thread . interrupted ( ) || database . isClosed ( ) ) throw e ; \nif ( e . getCause ( ) instanceof OSecurityException ) throw e ; \nbrokenRIDs . add ( current . copy ( ) ) ; \nOLogManager . instance ( ) . error ( this , \"Error on fetching record during browsing. The record has been skipped\" , e ) ; \n} \nif ( iRecord != null ) { \nbrowsedRecords ++ ; \nreturn iRecord ; \n} \n} \nwhile ( iMovement != 0 ) ; \nreturn null ; \n} \n} \n"}
{"3198": "public class OrientGraphFactory { \npublic OrientGraph getTx ( ) { \nfinal OrientGraph g ; \nif ( ! ( pool == null ) ) { \ng = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; \n} \nelse { \ng = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; \n} \ninitGraph ( g ) ; \nreturn g ; \n} \n} \n"}
{"3199": "public class OrientGraphFactory { \npublic OrientGraphNoTx getNoTx ( ) { \nfinal OrientGraphNoTx g ; \nif ( ! ( pool == null ) ) { \ng = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; \n} \nelse { \ng = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; \n} \ninitGraph ( g ) ; \nreturn g ; \n} \n} \n"}
{"3202": "public class OrientTransactionalGraph { \n@ SuppressWarnings ( \"deprecation\" ) @ Override public void stopTransaction ( final Conclusion conclusion ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . isClosed ( ) || getDatabase ( ) . getTransaction ( ) instanceof OTransactionNoTx || getDatabase ( ) . getTransaction ( ) . getStatus ( ) != TXSTATUS . BEGUN ) return ; \nif ( ! ( Conclusion . SUCCESS == conclusion ) ) rollback ( ) ; \nelse commit ( ) ; \n} \n} \n"}
{"3203": "public class OrientSql { \nfinal public OStatement parse ( ) throws ParseException { \nOparse jjtn000 = new Oparse ( JJTPARSE ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \njjtn000 . jjtSetFirstToken ( getToken ( 1 ) ) ; \nOStatement result ; \ntry { \nresult = Statement ( ) ; \njj_consume_token ( 0 ) ; \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtc000 = false ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n{ \nif ( true ) return result ; \n} \n} \ncatch ( Throwable jjte000 ) { \nif ( ! ( jjtc000 ) ) { \njjtree . popNode ( ) ; \n} \nelse { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n} \n} \nthrow new Error ( \"Missing return statement in function\" ) ; \n} \n} \n"}
{"3204": "public class OrientSql { \nfinal public Token getNextToken ( ) { \nif ( ! ( token . next != null ) ) token = token . next = token_source . getNextToken ( ) ; \nelse token = token . next ; \njj_ntk = - 1 ; \njj_gen ++ ; \nreturn token ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) { \nif ( ! ( t . next != null ) ) t = t . next = token_source . getNextToken ( ) ; \nelse t = t . next ; \n} \nreturn t ; \n} \n} \n"}
{"3207": "public class OrientVertex { \n@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { \nsetCurrentGraphInThreadLocal ( ) ; \nOrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; \nOrientBaseGraph . encodeClassNames ( iLabels ) ; \nfinal ODocument doc = getRecord ( ) ; \nfinal OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; \nfor ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { \nString fieldName = connectionField . getKey ( ) ; \nOPair < Direction , String > connection = connectionField . getValue ( ) ; \nfinal Object fieldValue = doc . rawField ( fieldName ) ; \nif ( fieldValue != null ) if ( ! ( fieldValue instanceof OIdentifiable ) ) if ( ! ( fieldValue instanceof Collection < ? > ) ) if ( fieldValue instanceof ORidBag ) { \niterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; \n} \nelse { \nCollection < ? > coll = ( Collection < ? > ) fieldValue ; \nif ( ! ( coll . size ( ) == 1 ) ) { \nif ( ! ( coll instanceof ORecordLazyMultiValue ) ) iterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; \nelse iterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; \n} \nelse { \nif ( ! ( coll instanceof ORecordLazyMultiValue ) ) if ( ! ( coll instanceof List < ? > ) ) addSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; \nelse addSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; \nelse addSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; \n} \n} \nelse { \naddSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; \n} \n} \nreturn iterable ; \n} \n} \n"}
{"3211": "public class OrientVertex { \npublic String getConnectionClass ( final Direction iDirection , final String iFieldName ) { \nif ( ! ( iDirection == Direction . OUT ) ) if ( iDirection == Direction . IN ) { \nif ( iFieldName . length ( ) > CONNECTION_IN_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; \n} \nelse { \nif ( iFieldName . length ( ) > CONNECTION_OUT_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; \n} \nreturn OrientEdgeType . CLASS_NAME ; \n} \n} \n"}
{"3212": "public class OrientVertex { \nprotected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { \nif ( iClassNames != null && iClassNames . length == 1 && iClassNames [ 0 ] . equalsIgnoreCase ( \"E\" ) ) iClassNames = null ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( iDirection == Direction . OUT || iDirection == Direction . BOTH ) { \nif ( ! ( settings . isUseVertexFieldsForEdgeLabels ( ) ) ) if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; \nelse { \nif ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \n} \n} \n} \nif ( iDirection == Direction . IN || iDirection == Direction . BOTH ) { \nif ( ! ( settings . isUseVertexFieldsForEdgeLabels ( ) ) ) if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; \nelse { \nif ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3215": "public class ODistributedAbstractPlugin { \n@ Override public Object executeOnLocalNode ( final ODistributedRequestId reqId , final ORemoteTask task , final ODatabaseDocumentInternal database ) { \nif ( database != null && ! ( database . getStorage ( ) instanceof ODistributedStorage ) ) throw new ODistributedException ( \"Distributed storage was not installed for database '\" + database . getName ( ) + \"'. Implementation found: \" + database . getStorage ( ) . getClass ( ) . getName ( ) ) ; \nfinal ODistributedAbstractPlugin manager = this ; \nreturn OScenarioThreadLocal . executeAsDistributed ( new Callable < Object > ( ) { \n@ Override public Object call ( ) throws Exception { \ntry { \nfinal Object result = task . execute ( reqId , serverInstance , manager , database ) ; \nif ( ! ( result instanceof Throwable && ! ( result instanceof OException ) ) ) { \nfinal String sourceNodeName = task . getNodeSource ( ) ; \nif ( database != null ) { \nfinal ODistributedDatabaseImpl ddb = getMessageService ( ) . getDatabase ( database . getName ( ) ) ; \nif ( ddb != null && ! ( result instanceof Throwable ) && task instanceof OAbstractReplicatedTask && ! task . isIdempotent ( ) ) { \nddb . setLSN ( sourceNodeName , ( ( OAbstractReplicatedTask ) task ) . getLastLSN ( ) , true ) ; \nddb . setLSN ( getLocalNodeName ( ) , ( ( OAbstractPaginatedStorage ) database . getStorage ( ) . getUnderlying ( ) ) . getLSN ( ) , true ) ; \n} \n} \n} \nelse ODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing request %d (%s) on local node: \" , ( Throwable ) result , reqId , task ) ; \nreturn result ; \n} \ncatch ( InterruptedException e ) { \nODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Interrupted execution on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \nreturn e ; \n} \ncatch ( Exception e ) { \nif ( ! ( e instanceof OException ) ) ODistributedServerLog . error ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \nreturn e ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3221": "public class OServerAdmin { \n@ Deprecated public synchronized OServerAdmin connect ( final String iUserName , final String iUserPassword ) throws IOException { \nfinal String username ; \nfinal String password ; \nOCredentialInterceptor ci = OSecurityManager . instance ( ) . newCredentialInterceptor ( ) ; \nif ( ! ( ci != null ) ) { \nusername = iUserName ; \npassword = iUserPassword ; \n} \nelse { \nci . intercept ( storage . getURL ( ) , iUserName , iUserPassword ) ; \nusername = ci . getUsername ( ) ; \npassword = ci . getPassword ( ) ; \n} \nOConnect37Request request = new OConnect37Request ( username , password ) ; \nnetworkAdminOperation ( ( network , session ) -> { \nOStorageRemoteNodeSession nodeSession = session . getOrCreateServerSession ( network . getServerURL ( ) ) ; \ntry { \nnetwork . beginRequest ( request . getCommand ( ) , session ) ; \nrequest . write ( network , session ) ; \n} \nfinally { \nnetwork . endRequest ( ) ; \n} \nOConnectResponse response = request . createResponse ( ) ; \ntry { \nnetwork . beginResponse ( nodeSession . getSessionId ( ) , true ) ; \nresponse . read ( network , session ) ; \n} \nfinally { \nstorage . endResponse ( network ) ; \n} \nreturn null ; \n} \n, \"Cannot connect to the remote server/database '\" + storage . getURL ( ) + \"'\" ) ; \nreturn this ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( ! ( collate != null ) ) collatesList . add ( null ) ; \nelse { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \n} \n} \nif ( ! ( fields == null || fields . length == 0 ) ) { \nif ( ! ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) ) { \nfinal List < OType > fieldTypeList ; \nif ( ! ( keyTypes == null ) ) fieldTypeList = Arrays . asList ( keyTypes ) ; \nelse { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \nelse { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \n} \nelse { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( ! ( keyTypes != null ) ) if ( ! ( serializerKeyId != 0 ) ) { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \nelse { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3231": "public class OCommandExecutorSQLRetryAbstract { \nprotected void parseRetry ( ) throws OCommandSQLParsingException { \nretry = Integer . parseInt ( parserNextWord ( true ) ) ; \nString temp = parseOptionalWord ( true ) ; \nif ( ! ( temp . equals ( \"WAIT\" ) ) ) parserGoBack ( ) ; \nelse { \nwait = Integer . parseInt ( parserNextWord ( true ) ) ; \n} \n} \n} \n"}
{"3234": "public class OSecurityAuthenticatorAbstract { \npublic String getAuthenticationHeader ( String databaseName ) { \nString header ; \nif ( ! ( databaseName != null ) ) header = \"WWW-Authenticate: Basic realm=\\\"OrientDB Server\\\"\" ; \nelse header = \"WWW-Authenticate: Basic realm=\\\"OrientDB db-\" + databaseName + \"\\\"\" ; \nreturn header ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( ! ( bufpos >= tokenBegin ) ) { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nelse { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i ++ < len ) { \nif ( ! ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) ) bufline [ j ] = newLine ; \nelse bufline [ j ] = newLine ++ ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3241": "public class OAtomicOperationsManager { \npublic OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { \nfinal OAtomicOperation operation = currentOperation . get ( ) ; \nif ( operation == null ) { \nOLogManager . instance ( ) . error ( this , \"There is no atomic operation active\" , null ) ; \nthrow new ODatabaseException ( \"There is no atomic operation active\" ) ; \n} \nint counter = operation . getCounter ( ) ; \noperation . decrementCounter ( ) ; \nassert counter > 0 ; \nfinal OLogSequenceNumber lsn ; \ntry { \nif ( rollback ) { \noperation . rollback ( ) ; \n} \nif ( ! ( counter == 1 ) ) { \nlsn = null ; \n} \nelse { \ntry { \nfinal boolean useWal = useWal ( ) ; \nif ( ! ( ! operation . isRollback ( ) ) ) { \nlsn = null ; \n} \nelse { \nlsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; \n} \nif ( trackAtomicOperations ) { \nactiveAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; \n} \n} \nfinally { \nfinal Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; \nwhile ( lockedObjectIterator . hasNext ( ) ) { \nfinal String lockedObject = lockedObjectIterator . next ( ) ; \nlockedObjectIterator . remove ( ) ; \nlockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \n} \ncurrentOperation . set ( null ) ; \n} \n} \n} \ncatch ( Error e ) { \nfinal OAbstractPaginatedStorage st = storage ; \nif ( st != null ) { \nst . handleJVMError ( e ) ; \n} \ncounter = 1 ; \nthrow e ; \n} \nfinally { \nif ( counter == 1 ) { \natomicOperationsCount . decrement ( ) ; \n} \n} \nreturn lsn ; \n} \n} \n"}
{"3249": "public class OClosableLinkedContainer { \npublic OClosableEntry < K , V > acquire ( K key ) throws InterruptedException { \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) return null ; \nboolean logOpen = false ; \nentry . acquireStateLock ( ) ; \ntry { \nif ( ! ( entry . isRetired ( ) || entry . isDead ( ) ) ) if ( ! ( entry . isClosed ( ) ) ) if ( ! ( entry . isOpen ( ) ) ) { \nentry . incrementAcquired ( ) ; \n} \nelse { \nentry . makeAcquiredFromOpen ( ) ; \n} \nelse { \nentry . makeAcquiredFromClosed ( entry . get ( ) ) ; \nlogOpen = true ; \n} \nelse { \nreturn null ; \n} \n} \nfinally { \nentry . releaseStateLock ( ) ; \n} \nif ( ! ( logOpen ) ) { \nlogAcquire ( entry ) ; \n} \nelse { \nlogOpen ( entry ) ; \n} \nassert entry . get ( ) . isOpen ( ) ; \nreturn entry ; \n} \n} \n"}
{"3258": "public class OLiveQueryClientListener { \npublic boolean onEvent ( OLiveQueryPushRequest pushRequest ) { \nODatabaseDocumentInternal old = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \ndatabase . activateOnCurrentThread ( ) ; \nif ( ! ( pushRequest . getStatus ( ) == OLiveQueryPushRequest . ERROR ) ) { \nfor ( OLiveQueryResult result : pushRequest . getEvents ( ) ) { \nswitch ( result . getEventType ( ) ) { \ncase OLiveQueryResult . CREATE_EVENT : listener . onCreate ( database , result . getCurrentValue ( ) ) ; \nbreak ; \ncase OLiveQueryResult . UPDATE_EVENT : listener . onUpdate ( database , result . getOldValue ( ) , result . getCurrentValue ( ) ) ; \nbreak ; \ncase OLiveQueryResult . DELETE_EVENT : listener . onDelete ( database , result . getCurrentValue ( ) ) ; \nbreak ; \n} \n} \nif ( pushRequest . getStatus ( ) == OLiveQueryPushRequest . END ) { \nonEnd ( ) ; \nreturn true ; \n} \n} \nelse { \nonError ( pushRequest . getErrorCode ( ) . newException ( pushRequest . getErrorMessage ( ) , null ) ) ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nODatabaseRecordThreadLocal . instance ( ) . set ( old ) ; \n} \n} \n} \n"}
{"3259": "public class OObjectEnumLazyMap { \nprivate void convert ( final Object iKey ) { \nif ( converted ) return ; \nif ( super . containsKey ( iKey ) ) return ; \nObject o = underlying . get ( String . valueOf ( iKey ) ) ; \nif ( ! ( o instanceof Number ) ) super . put ( iKey , Enum . valueOf ( enumClass , o . toString ( ) ) ) ; \nelse super . put ( iKey , enumClass . getEnumConstants ( ) [ ( ( Number ) o ) . intValue ( ) ] ) ; \n} \n} \n"}
{"3260": "public class OObjectEnumLazyMap { \nprotected void convertAll ( ) { \nif ( converted ) return ; \nfor ( java . util . Map . Entry < Object , Object > e : underlying . entrySet ( ) ) { \nif ( ! ( e . getValue ( ) instanceof Number ) ) super . put ( e . getKey ( ) , Enum . valueOf ( enumClass , e . getValue ( ) . toString ( ) ) ) ; \nelse super . put ( e . getKey ( ) , enumClass . getEnumConstants ( ) [ ( ( Number ) e . getValue ( ) ) . intValue ( ) ] ) ; \n} \nconverted = true ; \n} \n} \n"}
{"3264": "public class OProfileStorageStatement { \n@ Override public OResultSet executeSimple ( OCommandContext ctx ) { \nOResultInternal result = new OResultInternal ( ) ; \nresult . setProperty ( \"operation\" , \"optimize database\" ) ; \nOStorage storage = ( ( ODatabaseInternal ) ctx . getDatabase ( ) ) . getStorage ( ) ; \nif ( ! ( on ) ) { \nfinal OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; \nresult . setProperty ( \"value\" , \"off\" ) ; \nif ( ! ( performanceStatistic != null ) ) { \nresult . setProperty ( \"result\" , \"error\" ) ; \nresult . setProperty ( \"errorMessage\" , \"profiling of storage was not started\" ) ; \n} \nelse { \nresult . setProperty ( \"result\" , performanceStatistic . toDocument ( ) ) ; \n} \n} \nelse { \n( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; \nresult . setProperty ( \"value\" , \"on\" ) ; \n} \nOInternalResultSet rs = new OInternalResultSet ( ) ; \nrs . add ( result ) ; \nreturn rs ; \n} \n} \n"}
{"3265": "public class OProfileStorageStatement { \n@ Override public Object execute ( OSQLAsynchQuery < ODocument > request , OCommandContext context , OProgressListener progressListener ) { \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nfinal OStorage storage = db . getStorage ( ) ; \nif ( ! ( on ) ) { \nfinal OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; \nif ( ! ( performanceStatistic != null ) ) { \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"Error: profiling of storage was not started.\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \nelse request . getResultListener ( ) . result ( performanceStatistic . toDocument ( ) ) ; \n} \nelse { \n( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"OK\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \nreturn getResult ( request ) ; \n} \nfinally { \nif ( request . getResultListener ( ) != null ) { \nrequest . getResultListener ( ) . end ( ) ; \n} \n} \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( ! ( holds > 0 ) ) if ( holds < 0 ) { \nreturn true ; \n} \nelse { \nlHolds . increment ( ) ; \nreturn true ; \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( ! ( parkTimeout > 0 ) ) { \nreturn false ; \n} \nelse { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3270": "public class OrientEdge { \n@ Override public OrientVertex getVertex ( final Direction direction ) { \nfinal OrientBaseGraph graph = setCurrentGraphInThreadLocal ( ) ; \nif ( ! ( direction . equals ( Direction . OUT ) ) ) if ( ! ( direction . equals ( Direction . IN ) ) ) throw ExceptionFactory . bothIsNotSupported ( ) ; \nelse return graph . getVertex ( getInVertex ( ) ) ; \nelse return graph . getVertex ( getOutVertex ( ) ) ; \n} \n} \n"}
{"3280": "public class OCommandExecutorSQLInsert { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( newRecords == null && content == null && subQuery == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; \nif ( ! ( indexName != null ) ) { \nfinal List < ODocument > docs = new ArrayList < ODocument > ( ) ; \nif ( ! ( newRecords != null ) ) if ( ! ( content != null ) ) if ( subQuery != null ) { \nsubQuery . execute ( ) ; \nif ( queryResult != null ) return prepareReturnResult ( queryResult ) ; \nreturn saved . longValue ( ) ; \n} \nelse { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \ndoc . merge ( content , true , false ) ; \nsaveRecord ( doc ) ; \nreturn prepareReturnItem ( doc ) ; \n} \nelse { \nfor ( Map < String , Object > candidate : newRecords ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \nOSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; \nsaveRecord ( doc ) ; \ndocs . add ( doc ) ; \n} \nif ( ! ( docs . size ( ) == 1 ) ) return prepareReturnResult ( docs ) ; \nelse return prepareReturnItem ( docs . get ( 0 ) ) ; \n} \n} \nelse { \nif ( newRecords == null ) throw new OCommandExecutionException ( \"No key/value found\" ) ; \nfinal OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; \nif ( index == null ) throw new OCommandExecutionException ( \"Target index '\" + indexName + \"' not found\" ) ; \nMap < String , Object > result = new HashMap < String , Object > ( ) ; \nfor ( Map < String , Object > candidate : newRecords ) { \nObject indexKey = getIndexKeyValue ( commandParameters , candidate ) ; \nOIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; \nif ( ! ( index instanceof OIndexMultiValues ) ) { \nindex . put ( indexKey , indexValue ) ; \n} \nelse { \nfinal Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; \nif ( ! rids . contains ( indexValue . getIdentity ( ) ) ) { \nindex . put ( indexKey , indexValue ) ; \n} \n} \nresult . put ( KEYWORD_KEY , indexKey ) ; \nresult . put ( KEYWORD_RID , indexValue ) ; \n} \nreturn prepareReturnItem ( new ODocument ( result ) ) ; \n} \nreturn null ; \n} \n} \n"}
{"3281": "public class ODatabaseRepair { \nprotected boolean fixLink ( final Object fieldValue ) { \nif ( fieldValue instanceof OIdentifiable ) { \nfinal ORID id = ( ( OIdentifiable ) fieldValue ) . getIdentity ( ) ; \nif ( id . getClusterId ( ) == 0 && id . getClusterPosition ( ) == 0 ) return true ; \nif ( id . isValid ( ) ) if ( ! ( id . isPersistent ( ) ) ) return true ; \nelse { \nfinal ORecord connected = ( ( OIdentifiable ) fieldValue ) . getRecord ( ) ; \nif ( connected == null ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( ! ( database == null ) ) if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \nelse { \nfor ( int retry = 0 ; \nretry < 100 ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \n} \n} \n"}
{"3288": "public class ORecordLazyMap { \nprivate void convertLink2Record ( final Object iKey ) { \nif ( status == MULTIVALUE_CONTENT_TYPE . ALL_RECORDS ) return ; \nfinal Object value ; \nif ( ! ( iKey instanceof ORID ) ) value = super . get ( iKey ) ; \nelse value = iKey ; \nif ( value != null && value instanceof ORID ) { \nfinal ORID rid = ( ORID ) value ; \nmarshalling = true ; \ntry { \ntry { \nORecord record = rid . getRecord ( ) ; \nif ( record != null ) { \nORecordInternal . unTrack ( sourceRecord , rid ) ; \nORecordInternal . track ( sourceRecord , record ) ; \n} \nsuper . put ( iKey , record ) ; \n} \ncatch ( ORecordNotFoundException ignore ) { \n} \n} \nfinally { \nmarshalling = false ; \n} \n} \n} \n} \n"}
{"3289": "public class OHttpNetworkCommandManager { \npublic void registerCommand ( final OServerCommand iServerCommandInstance ) { \nfor ( String name : iServerCommandInstance . getNames ( ) ) if ( ! ( OStringSerializerHelper . contains ( name , '{' ) ) ) if ( ! ( OStringSerializerHelper . contains ( name , '*' ) ) ) exactCommands . put ( name , iServerCommandInstance ) ; \nelse wildcardCommands . put ( name , iServerCommandInstance ) ; \nelse { \nrestCommands . put ( name , iServerCommandInstance ) ; \n} \niServerCommandInstance . configure ( server ) ; \n} \n} \n"}
{"3292": "public class OFilterAnalyzer { \nprivate OIndexSearchResult createIndexedProperty ( final OSQLFilterCondition iCondition , final Object iItem , OCommandContext ctx ) { \nif ( iItem == null || ! ( iItem instanceof OSQLFilterItemField ) ) { \nreturn null ; \n} \nif ( iCondition . getLeft ( ) instanceof OSQLFilterItemField && iCondition . getRight ( ) instanceof OSQLFilterItemField ) { \nreturn null ; \n} \nfinal OSQLFilterItemField item = ( OSQLFilterItemField ) iItem ; \nif ( item . hasChainOperators ( ) && ! item . isFieldChain ( ) ) { \nreturn null ; \n} \nboolean inverted = iCondition . getRight ( ) == iItem ; \nfinal Object origValue = inverted ? iCondition . getLeft ( ) : iCondition . getRight ( ) ; \nOQueryOperator operator = iCondition . getOperator ( ) ; \nif ( inverted ) { \nif ( ! ( operator instanceof OQueryOperatorIn ) ) if ( ! ( operator instanceof OQueryOperatorContains ) ) if ( ! ( operator instanceof OQueryOperatorMajor ) ) if ( ! ( operator instanceof OQueryOperatorMinor ) ) if ( ! ( operator instanceof OQueryOperatorMajorEquals ) ) if ( operator instanceof OQueryOperatorMinorEquals ) { \noperator = new OQueryOperatorMajorEquals ( ) ; \n} \nelse { \noperator = new OQueryOperatorMinorEquals ( ) ; \n} \nelse { \noperator = new OQueryOperatorMajor ( ) ; \n} \nelse { \noperator = new OQueryOperatorMinor ( ) ; \n} \nelse { \noperator = new OQueryOperatorIn ( ) ; \n} \nelse { \noperator = new OQueryOperatorContains ( ) ; \n} \n} \nif ( iCondition . getOperator ( ) instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn ) { \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; \n} \nfinal Object value = OSQLHelper . getValue ( origValue , null , ctx ) ; \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , value ) ; \n} \n} \n"}
{"3295": "public class OSequenceCached { \nprotected long nextWithNewCurrentValue ( long currentValue , boolean executeViaDistributed ) throws OSequenceLimitReachedException , ODatabaseException { \nif ( ! ( ! executeViaDistributed ) ) { \ntry { \nreturn sendSequenceActionSetAndNext ( currentValue ) ; \n} \ncatch ( InterruptedException | ExecutionException exc ) { \nOLogManager . instance ( ) . error ( this , exc . getMessage ( ) , exc , ( Object [ ] ) null ) ; \nthrow new ODatabaseException ( exc . getMessage ( ) ) ; \n} \n} \nelse { \nsynchronized ( this ) { \ncacheStart = currentValue ; \nreturn nextWork ( ) ; \n} \n} \n} \n} \n"}
{"3299": "public class ORecordSerializerCSVAbstract { \nprivate static OIdentifiable linkToStream ( final StringBuilder buffer , final ODocument iParentRecord , Object iLinked ) { \nif ( iLinked == null ) return null ; \nOIdentifiable resultRid = null ; \nORID rid ; \nif ( ! ( iLinked instanceof ORID ) ) { \nif ( iLinked instanceof String ) iLinked = new ORecordId ( ( String ) iLinked ) ; \nif ( ! ( iLinked instanceof OIdentifiable ) ) throw new IllegalArgumentException ( \"Invalid object received. Expected a OIdentifiable but received type=\" + iLinked . getClass ( ) . getName ( ) + \" and value=\" + iLinked ) ; \nORecord iLinkedRecord = ( ( OIdentifiable ) iLinked ) . getRecord ( ) ; \nrid = iLinkedRecord . getIdentity ( ) ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nfinal ODatabaseDocument database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( iParentRecord != null ) { \nif ( ! database . isRetainRecords ( ) ) resultRid = iLinkedRecord . getIdentity ( ) ; \n} \n} \nelse { \nrid = ( ORID ) iLinked ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nresultRid = rid ; \n} \nif ( rid . isValid ( ) ) rid . toString ( buffer ) ; \nreturn resultRid ; \n} \n} \n"}
{"3300": "public class OByteBufferPool { \npublic final void release ( OPointer pointer ) { \nif ( TRACK ) { \npointerMapping . remove ( pointer ) ; \n} \nlong poolSize = pointersPoolSize . incrementAndGet ( ) ; \nif ( ! ( poolSize > this . poolSize ) ) { \npointersPool . add ( pointer ) ; \n} \nelse { \npointersPoolSize . decrementAndGet ( ) ; \nallocator . deallocate ( pointer ) ; \n} \n} \n} \n"}
{"3309": "public class OCommandExecutorSQLSelect { \n@ Override public Set < String > getInvolvedClusters ( ) { \nfinal Set < String > clusters = new HashSet < String > ( ) ; \nif ( parsedTarget != null ) { \nfinal ODatabaseDocument db = getDatabase ( ) ; \nif ( ! ( parsedTarget . getTargetQuery ( ) != null && parsedTarget . getTargetRecords ( ) instanceof OCommandExecutorSQLResultsetDelegate ) ) if ( parsedTarget . getTargetRecords ( ) != null ) { \nfor ( OIdentifiable identifiable : parsedTarget . getTargetRecords ( ) ) { \nfinal String c = db . getClusterNameById ( identifiable . getIdentity ( ) . getClusterId ( ) ) . toLowerCase ( Locale . ENGLISH ) ; \nif ( checkClusterAccess ( db , c ) ) { \nclusters . add ( c ) ; \n} \n} \n} \nelse { \nfinal Set < String > clIds = ( ( OCommandExecutorSQLResultsetDelegate ) parsedTarget . getTargetRecords ( ) ) . getInvolvedClusters ( ) ; \nfor ( String c : clIds ) { \nif ( checkClusterAccess ( db , c ) ) { \nclusters . add ( c ) ; \n} \n} \n} \nif ( parsedTarget . getTargetClasses ( ) != null ) { \nreturn getInvolvedClustersOfClasses ( parsedTarget . getTargetClasses ( ) . values ( ) ) ; \n} \nif ( parsedTarget . getTargetClusters ( ) != null ) { \nreturn getInvolvedClustersOfClusters ( parsedTarget . getTargetClusters ( ) . keySet ( ) ) ; \n} \nif ( parsedTarget . getTargetIndex ( ) != null ) { \nreturn getInvolvedClustersOfIndex ( parsedTarget . getTargetIndex ( ) ) ; \n} \n} \nreturn clusters ; \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { \nreturn false ; \n} \nparserSkipWhiteSpaces ( ) ; \nint start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nint end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nint position = parserGetCurrentPosition ( ) ; \nwhile ( ! parserIsEnded ( ) ) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { \nbreak ; \n} \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( ! ( end < 0 ) ) { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \n} \nelse { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \n} \nrequest . setFetchPlan ( fetchPlan ) ; \nreturn true ; \n} \n} \n"}
{"3322": "public class OAbstractPaginatedStorage { \nprivate int registerCluster ( final OCluster cluster ) { \nfinal int id ; \nif ( ! ( cluster != null ) ) { \nid = clusters . size ( ) ; \n} \nelse { \nif ( clusterMap . containsKey ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) ) ) { \nthrow new OConfigurationException ( \"Cannot add cluster '\" + cluster . getName ( ) + \"' because it is already registered in database '\" + name + \"'\" ) ; \n} \nclusterMap . put ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) , cluster ) ; \nid = cluster . getId ( ) ; \n} \nsetCluster ( id , cluster ) ; \nreturn id ; \n} \n} \n"}
{"3323": "public class OPartitionedDatabasePool { \npublic Object setProperty ( final String iName , final Object iValue ) { \nif ( ! ( iValue != null ) ) { \nreturn properties . remove ( iName . toLowerCase ( Locale . ENGLISH ) ) ; \n} \nelse { \nreturn properties . put ( iName . toLowerCase ( Locale . ENGLISH ) , iValue ) ; \n} \n} \n} \n"}
{"3324": "public class OCommandExecutorSQLCreateClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nboolean alreadyExists = database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ; \nif ( ! alreadyExists || ! ifNotExists ) { \nif ( ! ( clusters != null ) ) database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; \nelse database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; \n} \nreturn database . getMetadata ( ) . getSchema ( ) . getClasses ( ) . size ( ) ; \n} \n} \n"}
{"3327": "public class ODatabaseDocumentAbstract { \npublic ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { \nif ( id == null || hooks . isEmpty ( ) || id . getIdentity ( ) . getClusterId ( ) == 0 ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; \nfinal int scopeOrdinal = scope . ordinal ( ) ; \nfinal ORID identity = id . getIdentity ( ) . copy ( ) ; \nif ( ! pushInHook ( identity ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \ntry { \nfinal ORecord rec = id . getRecord ( ) ; \nif ( rec == null ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; \nboolean recordChanged = false ; \nfor ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { \nswitch ( runMode ) { \ncase DEFAULT : if ( getStorage ( ) . isDistributed ( ) && hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) continue ; \nbreak ; \ncase RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) continue ; \n} \nfinal ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; \nif ( ! ( res == ORecordHook . RESULT . RECORD_CHANGED ) ) if ( ! ( res == ORecordHook . RESULT . SKIP_IO ) ) if ( ! ( res == ORecordHook . RESULT . SKIP ) ) if ( res == ORecordHook . RESULT . RECORD_REPLACED ) return res ; \nelse return res ; \nelse return res ; \nelse recordChanged = true ; \n} \nreturn recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinally { \npopInHook ( identity ) ; \n} \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( int i = 0 ; \nparserCurrentPos <= max ; \n++ i ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \nfor ( int c = 0 ; \nc < processedWords . length ; \n++ c ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ! ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) ) { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \nelse processedWords [ c ] = null ; \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \nif ( candidatesWordsCount == 0 || separator ) break ; \nparserCurrentPos ++ ; \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \nreturn true ; \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( records > 0 && ! unsafe ) { \nif ( ! ( cls . isSubClassOf ( \"V\" ) ) ) if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 && unsafe ) { \nif ( ! ( cls . isSubClassOf ( \"V\" ) ) ) if ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \nelse { \nif ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( ! ( avail > 0 ) ) if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \nelse { \nif ( ! ( k == '\\n' ) ) if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( ! ( avail > 0 ) ) { \nif ( noMoreCharacters ( ) ) { \nif ( ! ( ! terminators . contains ( LineTerminator . CR ) ) ) readBytes += read + 1 ; \nelse { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \nelse { \npos ++ ; \navail -- ; \nif ( ! ( terminators . contains ( LineTerminator . LF ) ) ) { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \nelse { \nreadBytes += read + 1 ; \nreturn read ; \n} \n} \n} \n} \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nint len ; \nwhile ( toSkip > 0 ) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( ! ( len > 0 ) ) break ; \nelse toSkip -= len ; \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { \nif ( ! ( result == 0 ) ) toSkip -= result ; \nelse { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3358": "public class FastBufferedOutputStream { \n@ Override public void position ( final long newPosition ) throws IOException { \nflush ( ) ; \nif ( ! ( repositionableStream != null ) ) if ( ! ( fileChannel != null ) ) throw new UnsupportedOperationException ( \"position() can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel() method of the underlying byte stream exists and returns a FileChannel\" ) ; \nelse fileChannel . position ( newPosition ) ; \nelse repositionableStream . position ( newPosition ) ; \n} \n} \n"}
{"3368": "public class AbstractProducerMetricsListener { \n@ Override public void onCycleComplete ( com . netflix . hollow . api . producer . Status status , HollowProducer . ReadState readState , long version , Duration elapsed ) { \nboolean isCycleSuccess ; \nlong cycleEndTimeNano = System . nanoTime ( ) ; \nif ( ! ( status . getType ( ) == com . netflix . hollow . api . producer . Status . StatusType . SUCCESS ) ) { \nisCycleSuccess = false ; \nconsecutiveFailures ++ ; \n} \nelse { \nisCycleSuccess = true ; \nconsecutiveFailures = 0l ; \nlastCycleSuccessTimeNanoOptional = OptionalLong . of ( cycleEndTimeNano ) ; \n} \ncycleMetricsBuilder . setConsecutiveFailures ( consecutiveFailures ) . setCycleDurationMillis ( elapsed . toMillis ( ) ) . setIsCycleSuccess ( isCycleSuccess ) ; \nlastCycleSuccessTimeNanoOptional . ifPresent ( cycleMetricsBuilder :: setLastCycleSuccessTimeNano ) ; \ncycleMetricsReporting ( cycleMetricsBuilder . build ( ) ) ; \n} \n} \n"}
{"3374": "public class DiffViewOutputGenerator { \nprivate static String getFieldValue ( HollowDiffViewRow row , boolean useFrom ) { \nField field = useFrom ? row . getFieldPair ( ) . getFrom ( ) : row . getFieldPair ( ) . getTo ( ) ; \nif ( ! ( row . getFieldPair ( ) . isLeafNode ( ) ) ) { \nString suffix = field . getValue ( ) == null ? \" [null]\" : \"\" ; \nreturn \"(\" + field . getTypeName ( ) + \")\" + suffix ; \n} \nelse { \nreturn field . getValue ( ) == null ? \"null\" : field . getValue ( ) . toString ( ) . replace ( \"|\" , \"&#x2502\" ) ; \n} \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) ) if ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \nelse { \ngenerateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( ! ( numElements < 0 ) ) if ( numElements > HASH_TABLE_MAX_SIZE ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nif ( numElements == 0 ) return 1 ; \nif ( numElements < 3 ) return numElements * 2 ; \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( ! ( fieldPath . contains ( \".\" ) ) ) { \nresult = lowercase ( fieldPath ) ; \n} \nelse { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \nfor ( int i = 1 ; \ni < parts . length ; \ni ++ ) { \nsb . append ( uppercase ( parts [ i ] ) ) ; \n} \nresult = sb . toString ( ) ; \n} \nif ( result . endsWith ( \"!\" ) ) { \nreturn result . substring ( 0 , result . length ( ) - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"3447": "public class PullToRefreshBase { \nprotected final void refreshLoadingViewsSize ( ) { \nfinal int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; \nint pLeft = getPaddingLeft ( ) ; \nint pTop = getPaddingTop ( ) ; \nint pRight = getPaddingRight ( ) ; \nint pBottom = getPaddingBottom ( ) ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : if ( ! ( mMode . showHeaderLoadingLayout ( ) ) ) { \npLeft = 0 ; \n} \nelse { \nmHeaderLayout . setWidth ( maximumPullScroll ) ; \npLeft = - maximumPullScroll ; \n} \nif ( ! ( mMode . showFooterLoadingLayout ( ) ) ) { \npRight = 0 ; \n} \nelse { \nmFooterLayout . setWidth ( maximumPullScroll ) ; \npRight = - maximumPullScroll ; \n} \nbreak ; \ncase VERTICAL : if ( ! ( mMode . showHeaderLoadingLayout ( ) ) ) { \npTop = 0 ; \n} \nelse { \nmHeaderLayout . setHeight ( maximumPullScroll ) ; \npTop = - maximumPullScroll ; \n} \nif ( ! ( mMode . showFooterLoadingLayout ( ) ) ) { \npBottom = 0 ; \n} \nelse { \nmFooterLayout . setHeight ( maximumPullScroll ) ; \npBottom = - maximumPullScroll ; \n} \nbreak ; \n} \nif ( DEBUG ) { \nLog . d ( LOG_TAG , String . format ( \"Setting Padding. L: %d, T: %d, R: %d, B: %d\" , pLeft , pTop , pRight , pBottom ) ) ; \n} \nsetPadding ( pLeft , pTop , pRight , pBottom ) ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( ! ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) ) if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \nelse { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( ! ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) ) if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \nelse { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( ! ( newScrollValue < ( 0 - fuzzyThreshold ) ) ) if ( ! ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) ) if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \nelse { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) { \nreturn new Service [ 0 ] ; \n} \nif ( ! ( services instanceof ArrayList ) ) { \nService [ ] ret = new Service [ services . size ( ) ] ; \nfor ( int i = 0 ; \ni < services . size ( ) ; \ni ++ ) { \nret [ i ] = services . get ( i ) ; \n} \nreturn ret ; \n} \nelse { \nreturn ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \n} \n} \n} \n"}
{"3482": "public class ServiceUrlUtil { \nprivate static boolean portsMatch ( ServicePort servicePort , IntOrString intOrString ) { \nif ( intOrString != null ) { \nInteger port = servicePort . getPort ( ) ; \nInteger intVal = intOrString . getIntVal ( ) ; \nString strVal = intOrString . getStrVal ( ) ; \nif ( ! ( intVal != null ) ) if ( strVal != null ) { \nreturn Objects . equal ( strVal , servicePort . getName ( ) ) ; \n} \nelse { \nif ( ! ( port != null ) ) { \n} \nelse { \nreturn port . intValue ( ) == intVal . intValue ( ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3491": "public class KubernetesHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static List < HasMetadata > toItemList ( Object entity ) throws IOException { \nif ( ! ( entity instanceof List ) ) if ( ! ( entity instanceof HasMetadata [ ] ) ) if ( ! ( entity instanceof KubernetesList ) ) if ( ! ( entity instanceof Template ) ) { \nList < HasMetadata > answer = new ArrayList < > ( ) ; \nif ( entity instanceof HasMetadata ) { \nanswer . add ( ( HasMetadata ) entity ) ; \n} \nreturn answer ; \n} \nelse { \nTemplate objects = ( Template ) entity ; \nreturn objects . getObjects ( ) ; \n} \nelse { \nKubernetesList config = ( KubernetesList ) entity ; \nreturn config . getItems ( ) ; \n} \nelse { \nHasMetadata [ ] array = ( HasMetadata [ ] ) entity ; \nreturn Arrays . asList ( array ) ; \n} \nelse { \nreturn ( List < HasMetadata > ) entity ; \n} \n} \n} \n"}
{"3497": "public class KubernetesResourceUtil { \nprivate static Map < String , Object > readAndEnrichFragment ( PlatformMode platformMode , ResourceVersioning apiVersions , File file , String appName ) throws IOException { \nPattern pattern = Pattern . compile ( FILENAME_PATTERN , Pattern . CASE_INSENSITIVE ) ; \nMatcher matcher = pattern . matcher ( file . getName ( ) ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Resource file name '%s' does not match pattern <name>-<type>.(yaml|yml|json)\" , file . getName ( ) ) ) ; \n} \nString name = matcher . group ( \"name\" ) ; \nString type = matcher . group ( \"type\" ) ; \nString ext = matcher . group ( \"ext\" ) . toLowerCase ( ) ; \nString kind ; \nMap < String , Object > fragment = readFragment ( file , ext ) ; \nif ( ! ( type != null ) ) { \nkind = FILENAME_TO_KIND_MAPPER . get ( name . toLowerCase ( ) ) ; \nif ( kind != null ) { \nname = null ; \n} \n} \nelse { \nkind = getAndValidateKindFromType ( file , type ) ; \n} \naddKind ( fragment , kind , file . getName ( ) ) ; \nString apiVersion = apiVersions . getCoreVersion ( ) ; \nif ( ! ( Objects . equals ( kind , \"Ingress\" ) ) ) if ( ! ( Objects . equals ( kind , \"StatefulSet\" ) || Objects . equals ( kind , \"Deployment\" ) ) ) if ( ! ( Objects . equals ( kind , \"Job\" ) ) ) if ( Objects . equals ( kind , \"DeploymentConfig\" ) && platformMode == PlatformMode . openshift ) { \napiVersion = apiVersions . getOpenshiftV1version ( ) ; \n} \nelse { \napiVersion = apiVersions . getJobVersion ( ) ; \n} \nelse { \napiVersion = apiVersions . getAppsVersion ( ) ; \n} \nelse { \napiVersion = apiVersions . getExtensionsVersion ( ) ; \n} \naddIfNotExistent ( fragment , \"apiVersion\" , apiVersion ) ; \nMap < String , Object > metaMap = getMetadata ( fragment ) ; \naddIfNotExistent ( metaMap , \"name\" , StringUtils . isNotBlank ( name ) ? name : appName ) ; \nreturn fragment ; \n} \n} \n"}
{"3502": "public class AbstractPortsExtractor { \nprivate Map < String , String > readConfig ( File f ) throws IOException { \nMap < String , String > map ; \nif ( ! ( f . getName ( ) . endsWith ( JSON_EXTENSION ) ) ) if ( ! ( f . getName ( ) . endsWith ( YAML_EXTENSION ) || f . getName ( ) . endsWith ( YML_EXTENSION ) ) ) if ( ! ( f . getName ( ) . endsWith ( PROPERTIES_EXTENSION ) ) ) { \nthrow new IllegalArgumentException ( \"Can't read configuration from: [\" + f . getName ( ) + \"]. Unknown file extension.\" ) ; \n} \nelse { \nProperties properties = new Properties ( ) ; \nproperties . load ( new FileInputStream ( f ) ) ; \nmap = propertiesToMap ( properties ) ; \n} \nelse { \nmap = flatten ( YAML_MAPPER . readValue ( f , Map . class ) ) ; \n} \nelse { \nmap = flatten ( JSON_MAPPER . readValue ( f , Map . class ) ) ; \n} \nreturn map ; \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( ! ( i1 != null && i2 != null ) ) { \ndiff = s1 . compareTo ( s2 ) ; \n} \nelse { \ndiff = i1 . compareTo ( i2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \nreturn 0 ; \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3520": "public class ApplyService { \npublic void installTemplate ( Template entity , String sourceName ) { \nOpenShiftClient openShiftClient = getOpenShiftClient ( ) ; \nif ( openShiftClient == null ) { \nreturn ; \n} \nif ( ! isProcessTemplatesLocally ( ) ) { \nString namespace = getNamespace ( ) ; \nString id = getName ( entity ) ; \nObjects . requireNonNull ( id , \"No name for \" + entity + \" \" + sourceName ) ; \nTemplate old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \nif ( ! ( isRunning ( old ) ) ) { \nif ( ! ( ! isAllowCreate ( ) ) ) { \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \nelse { \nlog . warn ( \"Creation disabled so not creating a Template from \" + sourceName + \" namespace \" + namespace + \" name \" + getName ( entity ) ) ; \n} \n} \nelse { \nif ( ! ( UserConfigurationCompare . configEqual ( entity , old ) ) ) { \nboolean recreateMode = isRecreateMode ( ) ; \nrecreateMode = true ; \nif ( ! ( recreateMode ) ) { \nlog . info ( \"Updating a Template from \" + sourceName ) ; \ntry { \nObject answer = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . replace ( entity ) ; \nlog . info ( \"Updated Template: \" + answer ) ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to update Template from \" + sourceName + \". \" + e + \". \" + entity , e ) ; \n} \n} \nelse { \nopenShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . delete ( ) ; \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \n} \nelse { \nlog . info ( \"Template has not changed so not doing anything\" ) ; \n} \n} \n} \n} \n} \n"}
{"3527": "public class DefaultNamespaceEnricher { \n@ Override public void create ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nfinal String name = config . getNamespace ( ) ; \nif ( name == null || name . isEmpty ( ) ) { \nreturn ; \n} \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nString type = getConfig ( Config . type ) ; \nif ( \"project\" . equalsIgnoreCase ( type ) || \"namespace\" . equalsIgnoreCase ( type ) ) { \nif ( ! ( platformMode == PlatformMode . kubernetes ) ) { \nlog . info ( \"Adding a default Project\" + config . getNamespace ( ) ) ; \nProject project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; \nbuilder . addToProjectItems ( project ) ; \n} \nelse { \nlog . info ( \"Adding a default Namespace:\" + config . getNamespace ( ) ) ; \nNamespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; \nbuilder . addToNamespaceItems ( namespace ) ; \n} \n} \n} \n} \n} \n"}
{"3532": "public class AbstractAppServerHandler { \nprotected String [ ] scanFiles ( String ... patterns ) { \nString buildOutputDir = project . getBuild ( ) . getDirectory ( ) ; \nif ( ! ( buildOutputDir != null && new File ( buildOutputDir ) . exists ( ) ) ) { \nreturn new String [ 0 ] ; \n} \nelse { \nDirectoryScanner directoryScanner = new DirectoryScanner ( ) ; \ndirectoryScanner . setBasedir ( buildOutputDir ) ; \ndirectoryScanner . setIncludes ( patterns ) ; \ndirectoryScanner . scan ( ) ; \nreturn directoryScanner . getIncludedFiles ( ) ; \n} \n} \n} \n"}
{"3541": "public class IconEnricher { \nprivate void copyAppConfigFiles ( File appBuildDir , File appConfigDir ) throws IOException { \nFile [ ] files = appConfigDir . listFiles ( ) ; \nif ( files != null ) { \nappBuildDir . mkdirs ( ) ; \nfor ( File file : files ) { \nFile outFile = new File ( appBuildDir , file . getName ( ) ) ; \nif ( ! ( file . isDirectory ( ) ) ) { \nFiles . copy ( file , outFile ) ; \n} \nelse { \ncopyAppConfigFiles ( outFile , file ) ; \n} \n} \n} \n} \n} \n"}
{"3554": "public class BaseGenerator { \nprotected void addFrom ( BuildImageConfiguration . Builder builder ) { \nString fromMode = getConfigWithFallback ( Config . fromMode , \"fabric8.generator.fromMode\" , getFromModeDefault ( context . getRuntimeMode ( ) ) ) ; \nString from = getConfigWithFallback ( Config . from , \"fabric8.generator.from\" , null ) ; \nif ( ! ( \"docker\" . equalsIgnoreCase ( fromMode ) ) ) if ( ! ( \"istag\" . equalsIgnoreCase ( fromMode ) ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Invalid 'fromMode' in generator configuration for '%s'\" , getName ( ) ) ) ; \n} \nelse { \nMap < String , String > fromExt = new HashMap < > ( ) ; \nif ( ! ( from != null ) ) { \nfromExt = fromSelector != null ? fromSelector . getImageStreamTagFromExt ( ) : null ; \n} \nelse { \nImageName iName = new ImageName ( from ) ; \nString tag = iName . getTag ( ) ; \nif ( StringUtils . isBlank ( tag ) ) { \ntag = \"latest\" ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) , iName . getSimpleName ( ) + \":\" + tag ) ; \nif ( iName . getUser ( ) != null ) { \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) , iName . getUser ( ) ) ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . kind . key ( ) , \"ImageStreamTag\" ) ; \n} \nif ( fromExt != null ) { \nString namespace = fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) ) ; \nif ( ! ( namespace != null ) ) { \nlog . info ( \"Using ImageStreamTag '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) ) ; \n} \nelse { \nlog . info ( \"Using ImageStreamTag '%s' from namespace '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) , namespace ) ; \n} \nbuilder . fromExt ( fromExt ) ; \n} \n} \nelse { \nString fromImage = from ; \nif ( fromImage == null ) { \nfromImage = fromSelector != null ? fromSelector . getFrom ( ) : null ; \n} \nbuilder . from ( fromImage ) ; \nlog . info ( \"Using Docker image %s as base / builder\" , fromImage ) ; \n} \n} \n} \n"}
{"3555": "public class BaseGenerator { \nprivate String getFromModeDefault ( RuntimeMode mode ) { \nif ( ! ( mode == RuntimeMode . openshift && fromSelector != null && fromSelector . isRedHat ( ) ) ) { \nreturn \"docker\" ; \n} \nelse { \nreturn \"istag\" ; \n} \n} \n} \n"}
{"3556": "public class BaseGenerator { \nprotected String getImageName ( ) { \nif ( ! ( RuntimeMode . isOpenShiftMode ( getProject ( ) . getProperties ( ) ) ) ) { \nreturn getConfigWithFallback ( Config . name , \"fabric8.generator.name\" , \"%g/%a:%l\" ) ; \n} \nelse { \nreturn getConfigWithFallback ( Config . name , \"fabric8.generator.name\" , \"%a:%l\" ) ; \n} \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! ( ! isOnline ( ) ) ) { \ntry { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) { \nns = getNamespace ( ) ; \n} \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nboolean notFound = false ; \nboolean connectError = false ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nThrowable t = stack . pop ( ) ; \nif ( ! ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) ) if ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \nelse { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"3566": "public class PayPalPaymentResource { \npublic static PayPalPaymentResource fromJson ( String jsonString ) throws JSONException { \nJSONObject json = new JSONObject ( jsonString ) ; \nPayPalPaymentResource payPalPaymentResource = new PayPalPaymentResource ( ) ; \nJSONObject redirectJson = json . optJSONObject ( PAYMENT_RESOURCE_KEY ) ; \nif ( ! ( redirectJson != null ) ) { \nredirectJson = json . optJSONObject ( AGREEMENT_SETUP_KEY ) ; \npayPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , APPROVAL_URL_KEY , \"\" ) ) ; \n} \nelse { \npayPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , REDIRECT_URL_KEY , \"\" ) ) ; \n} \nreturn payPalPaymentResource ; \n} \n} \n"}
{"3567": "public class BraintreeHttpClient { \n@ Override public void get ( String path , HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nUri uri ; \nif ( ! ( path . startsWith ( \"http\" ) ) ) { \nuri = Uri . parse ( mBaseUrl + path ) ; \n} \nelse { \nuri = Uri . parse ( path ) ; \n} \nif ( mAuthorization instanceof ClientToken ) { \nuri = uri . buildUpon ( ) . appendQueryParameter ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . build ( ) ; \n} \nsuper . get ( uri . toString ( ) , callback ) ; \n} \n} \n"}
{"3571": "public class DataCollector { \npublic static void collectDeviceData ( final BraintreeFragment fragment , final String merchantId , final BraintreeResponseListener < String > listener ) { \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nfinal JSONObject deviceData = new JSONObject ( ) ; \ntry { \nString clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; \nif ( ! TextUtils . isEmpty ( clientMetadataId ) ) { \ndeviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; \n} \n} \ncatch ( JSONException ignored ) { \n} \nif ( ! ( configuration . getKount ( ) . isEnabled ( ) ) ) { \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \nelse { \nfinal String id ; \nif ( ! ( merchantId != null ) ) { \nid = configuration . getKount ( ) . getKountMerchantId ( ) ; \n} \nelse { \nid = merchantId ; \n} \ntry { \nfinal String deviceSessionId = UUIDHelper . getFormattedUUID ( ) ; \nstartDeviceCollector ( fragment , id , deviceSessionId , new BraintreeResponseListener < String > ( ) { \n@ Override public void onResponse ( String sessionId ) { \ntry { \ndeviceData . put ( DEVICE_SESSION_ID_KEY , deviceSessionId ) ; \ndeviceData . put ( FRAUD_MERCHANT_ID_KEY , id ) ; \n} \ncatch ( JSONException ignored ) { \n} \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \n) ; \n} \ncatch ( ClassNotFoundException | NoClassDefFoundError | NumberFormatException ignored ) { \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \n} \n} \n) ; \n} \n} \n"}
{"3575": "public class Json { \npublic static String optString ( JSONObject json , String name , String fallback ) { \nif ( ! ( json . isNull ( name ) ) ) { \nreturn json . optString ( name , fallback ) ; \n} \nelse { \nreturn fallback ; \n} \n} \n} \n"}
{"3579": "public class HttpClient { \npublic void get ( final String path , final HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nfinal String url ; \nif ( ! ( path . startsWith ( \"http\" ) ) ) { \nurl = mBaseUrl + path ; \n} \nelse { \nurl = path ; \n} \nmThreadPool . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \nHttpURLConnection connection = null ; \ntry { \nconnection = init ( url ) ; \nconnection . setRequestMethod ( METHOD_GET ) ; \npostCallbackOnMainThread ( callback , parseResponse ( connection ) ) ; \n} \ncatch ( Exception e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \nfinally { \nif ( connection != null ) { \nconnection . disconnect ( ) ; \n} \n} \n} \n} \n) ; \n} \n} \n"}
{"3581": "public class HttpClient { \npublic String post ( String path , String data ) throws Exception { \nHttpURLConnection connection = null ; \ntry { \nif ( ! ( path . startsWith ( \"http\" ) ) ) { \nconnection = init ( mBaseUrl + path ) ; \n} \nelse { \nconnection = init ( path ) ; \n} \nconnection . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nconnection . setRequestMethod ( METHOD_POST ) ; \nconnection . setDoOutput ( true ) ; \nwriteOutputStream ( connection . getOutputStream ( ) , data ) ; \nreturn parseResponse ( connection ) ; \n} \nfinally { \nif ( connection != null ) { \nconnection . disconnect ( ) ; \n} \n} \n} \n} \n"}
{"3582": "public class LocalPayment { \npublic static void startPayment ( final BraintreeFragment fragment , final LocalPaymentRequest request , final BraintreeResponseListener < LocalPaymentRequest > listener ) { \nif ( ! ( request == null ) ) if ( ! ( request . getApprovalUrl ( ) != null || request . getPaymentId ( ) != null ) ) if ( ! ( request . getPaymentType ( ) == null || request . getAmount ( ) == null ) ) if ( listener == null ) { \nfragment . postCallback ( new BraintreeException ( \"BraintreeResponseListener<LocalPaymentRequest> \" + \"is required.\" ) ) ; \nreturn ; \n} \nelse { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"paymentType and amount are required.\" ) ) ; \nreturn ; \n} \nelse { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"appovalUrl and paymentId should not be set.\" ) ) ; \nreturn ; \n} \nelse { \nfragment . postCallback ( new BraintreeException ( \"A LocalPaymentRequest is required.\" ) ) ; \nreturn ; \n} \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nif ( ! configuration . getPayPal ( ) . isEnabled ( ) ) { \nfragment . postCallback ( new ConfigurationException ( \"Local payments are not enabled for this merchant.\" ) ) ; \nreturn ; \n} \nsMerchantAccountId = request . getMerchantAccountId ( ) ; \nsPaymentType = request . getPaymentType ( ) ; \nString returnUrl = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_SUCCESSS ; \nString cancel = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_CANCEL ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.start-payment.selected\" ) ; \nfragment . getHttpClient ( ) . post ( \"/v1/paypal_hermes/create_payment_resource\" , request . build ( returnUrl , cancel ) , new HttpResponseCallback ( ) { \n@ Override public void success ( String responseBody ) { \ntry { \nJSONObject responseJson = new JSONObject ( responseBody ) ; \nrequest . approvalUrl ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"redirectUrl\" ) ) ; \nrequest . paymentId ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"paymentToken\" ) ) ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.create.succeeded\" ) ; \nlistener . onResponse ( request ) ; \n} \ncatch ( JSONException jsonException ) { \nfailure ( jsonException ) ; \n} \n} \n@ Override public void failure ( Exception exception ) { \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.webswitch.initiate.failed\" ) ; \nfragment . postCallback ( exception ) ; \n} \n} \n) ; \n} \n} \n) ; \n} \n} \n"}
{"3586": "public class PayPal { \npublic static void requestBillingAgreement ( BraintreeFragment fragment , PayPalRequest request , PayPalApprovalHandler handler ) { \nif ( ! ( request . getAmount ( ) == null ) ) { \nfragment . postCallback ( new BraintreeException ( \"There must be no amount specified for the Billing Agreement flow\" ) ) ; \n} \nelse { \nfragment . sendAnalyticsEvent ( \"paypal.billing-agreement.selected\" ) ; \nif ( request . shouldOfferCredit ( ) ) { \nfragment . sendAnalyticsEvent ( \"paypal.billing-agreement.credit.offered\" ) ; \n} \nrequestOneTimePayment ( fragment , request , true , handler ) ; \n} \n} \n} \n"}
{"3587": "public class PayPal { \nprotected static void onActivityResult ( final BraintreeFragment fragment , int resultCode , Intent data ) { \nRequest request = getPersistedRequest ( fragment . getApplicationContext ( ) ) ; \nString paymentType = paymentTypeForRequest ( request ) ; \nString switchType = switchTypeForIntent ( data ) ; \nString eventPrefix = paymentType + \".\" + switchType ; \nif ( ! ( resultCode == AppCompatActivity . RESULT_OK && data != null && request != null ) ) { \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nif ( resultCode != AppCompatActivity . RESULT_CANCELED ) { \nfragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \n} \n} \nelse { \nResult result = PayPalOneTouchCore . parseResponse ( fragment . getApplicationContext ( ) , request , data ) ; \nswitch ( result . getResultType ( ) ) { \ncase Error : fragment . postCallback ( new BrowserSwitchException ( result . getError ( ) . getMessage ( ) ) ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".failed\" ) ; \nbreak ; \ncase Cancel : fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nbreak ; \ncase Success : onSuccess ( fragment , data , request , result ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".succeeded\" ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"3588": "public class PayPal { \nprivate static PayPalAccountBuilder parseResponse ( PayPalRequest paypalRequest , Request request , Result result , Intent intent ) { \nPayPalAccountBuilder paypalAccountBuilder = new PayPalAccountBuilder ( ) . clientMetadataId ( request . getClientMetadataId ( ) ) ; \nif ( paypalRequest != null && paypalRequest . getMerchantAccountId ( ) != null ) { \npaypalAccountBuilder . merchantAccountId ( paypalRequest . getMerchantAccountId ( ) ) ; \n} \nif ( request instanceof CheckoutRequest && paypalRequest != null ) { \npaypalAccountBuilder . intent ( paypalRequest . getIntent ( ) ) ; \n} \nif ( ! ( isAppSwitch ( intent ) ) ) { \npaypalAccountBuilder . source ( \"paypal-browser\" ) ; \n} \nelse { \npaypalAccountBuilder . source ( \"paypal-app\" ) ; \n} \npaypalAccountBuilder . oneTouchCoreData ( result . getResponse ( ) ) ; \nreturn paypalAccountBuilder ; \n} \n} \n"}
{"3597": "public class Profile { \npublic static Profile forInt ( int i ) { \nProfile p ; \nif ( ! ( i <= 0 || i > ALL . length ) ) p = ALL [ i - 1 ] ; \nelse p = UNKNOWN ; \nreturn p ; \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( ! ( bytesInMarker == 0 ) ) { \nreturn State . MORE_DATA ; \n} \nelse { \ndone = true ; \nreturn State . STOP ; \n} \n} \n} \n"}
{"3603": "public class InplaceMP4Editor { \npublic boolean copy ( File src , File dst , MP4Edit edit ) throws IOException { \nSeekableByteChannel fi = null ; \nSeekableByteChannel fo = null ; \ntry { \nfi = NIOUtils . readableChannel ( src ) ; \nfo = NIOUtils . writableChannel ( dst ) ; \nList < Tuple . _2 < Atom , ByteBuffer > > fragments = doTheFix ( fi , edit ) ; \nif ( fragments == null ) return false ; \nList < _2 < Long , ByteBuffer > > fragOffsets = Tuple . _2map0 ( fragments , new Tuple . Mapper < Atom , Long > ( ) { \npublic Long map ( Atom t ) { \nreturn t . getOffset ( ) ; \n} \n} \n) ; \nMap < Long , ByteBuffer > rewrite = Tuple . asMap ( fragOffsets ) ; \nfor ( Atom atom : MP4Util . getRootAtoms ( fi ) ) { \nByteBuffer byteBuffer = rewrite . get ( atom . getOffset ( ) ) ; \nif ( ! ( byteBuffer != null ) ) atom . copy ( fi , fo ) ; \nelse fo . write ( byteBuffer ) ; \n} \nreturn true ; \n} \nfinally { \nNIOUtils . closeQuietly ( fi ) ; \nNIOUtils . closeQuietly ( fo ) ; \n} \n} \n} \n"}
{"3618": "public class BitStream { \nprotected int readCache ( boolean peek ) throws AACException { \nint i ; \nif ( ! ( pos > buffer . length - WORD_BYTES ) ) i = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; \nelse throw AACException . endOfStream ( ) ; \nif ( ! peek ) pos += WORD_BYTES ; \nreturn i ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nint sf = _in . readBits ( 4 ) ; \nif ( ! ( sf == 0xF ) ) config . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nelse config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( ! ( AAC_SBR == cp ) ) if ( ! ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) ) { \nthrow new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \n} \nelse { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) throw new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( ! ( config . dependsOnCoreCoder ) ) config . coreCoderDelay = 0 ; \nelse config . coreCoderDelay = _in . readBits ( 14 ) ; \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; \n} \nelse { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( ! ( symbol == cm . getMps ( ) ) ) { \nrange = rangeLps ; \nwhile ( range < 0x8000 ) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \nelse { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( range < 0x8000 ) { \nwhile ( range < 0x8000 ) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n} \n"}
{"3623": "public class SliceHeaderReader { \nprivate static void readDecoderPicMarking ( NALUnit nalUnit , SliceHeader sh , BitReader _in ) { \nif ( ! ( nalUnit . type == NALUnitType . IDR_SLICE ) ) { \nboolean adaptiveRefPicMarkingModeFlag = readBool ( _in , \"SH: adaptive_ref_pic_marking_mode_flag\" ) ; \nif ( adaptiveRefPicMarkingModeFlag ) { \nArrayList < Instruction > mmops = new ArrayList < Instruction > ( ) ; \nint memoryManagementControlOperation ; \ndo { \nmemoryManagementControlOperation = readUEtrace ( _in , \"SH: memory_management_control_operation\" ) ; \nInstruction instr = null ; \nswitch ( memoryManagementControlOperation ) { \ncase 1 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_SHORT , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , 0 ) ; \nbreak ; \ncase 2 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_LONG , readUEtrace ( _in , \"SH: long_term_pic_num\" ) , 0 ) ; \nbreak ; \ncase 3 : instr = new RefPicMarking . Instruction ( InstrType . CONVERT_INTO_LONG , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) ) ; \nbreak ; \ncase 4 : instr = new RefPicMarking . Instruction ( InstrType . TRUNK_LONG , readUEtrace ( _in , \"SH: max_long_term_frame_idx_plus1\" ) - 1 , 0 ) ; \nbreak ; \ncase 5 : instr = new RefPicMarking . Instruction ( InstrType . CLEAR , 0 , 0 ) ; \nbreak ; \ncase 6 : instr = new RefPicMarking . Instruction ( InstrType . MARK_LONG , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) , 0 ) ; \nbreak ; \n} \nif ( instr != null ) mmops . add ( instr ) ; \n} \nwhile ( memoryManagementControlOperation != 0 ) ; \nsh . refPicMarkingNonIDR = new RefPicMarking ( mmops . toArray ( new Instruction [ ] { \n} \n) ) ; \n} \n} \nelse { \nboolean noOutputOfPriorPicsFlag = readBool ( _in , \"SH: no_output_of_prior_pics_flag\" ) ; \nboolean longTermReferenceFlag = readBool ( _in , \"SH: long_term_reference_flag\" ) ; \nsh . refPicMarkingIDR = new RefPicMarkingIDR ( noOutputOfPriorPicsFlag , longTermReferenceFlag ) ; \n} \n} \n} \n"}
{"3625": "public class Decoder { \npublic void decodeFrame ( byte [ ] frame , SampleBuffer buffer ) throws AACException { \nif ( frame != null ) _in . setData ( frame ) ; \nLogger . debug ( \"bits left \" + _in . getBitsLeft ( ) ) ; \ntry { \ndecode ( buffer ) ; \n} \ncatch ( AACException e ) { \nif ( ! ( ! e . isEndOfStream ( ) ) ) Logger . warn ( \"unexpected end of frame\" ) ; \nelse throw e ; \n} \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( ! ( sinkColor != null ) ) { \ntoEncode = new LoanerPicture ( pic , 0 ) ; \n} \nelse { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; \ntimestamp += fps . getDen ( ) ; \nframeNo ++ ; \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nint bin ; \nint qIdx = ( range >> 6 ) & 0x3 ; \nint rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange -= rLPS ; \nint rs8 = range << 8 ; \nif ( ! ( code < rs8 ) ) { \nrange = rLPS ; \ncode -= rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nelse { \nif ( cm [ 0 ] [ m ] < 62 ) cm [ 0 ] [ m ] ++ ; \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( nBitsPending <= 0 ) readOneByte ( ) ; \nint tmp = code - ( range << 8 ) ; \nif ( ! ( tmp < 0 ) ) { \ncode = tmp ; \nreturn 1 ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"3636": "public class SampleFrequency { \npublic static SampleFrequency forInt ( int i ) { \nfinal SampleFrequency freq ; \nif ( ! ( i >= 0 && i < 12 ) ) freq = SAMPLE_FREQUENCY_NONE ; \nelse freq = values ( ) [ i ] ; \nreturn freq ; \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) return ; \nint al = a . bufa ; \nint ah = a . bufb ; \nint bl , bh ; \nif ( ! ( len > 32 ) ) { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nelse { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen += a . len ; \n} \n} \n"}
{"3643": "public class BitsBuffer { \nstatic int [ ] rewindReverse64 ( int hi , int lo , int len ) { \nint [ ] i = new int [ 2 ] ; \nif ( ! ( len <= 32 ) ) { \nlo = ( ( lo >> S [ 0 ] ) & B [ 0 ] ) | ( ( lo << S [ 0 ] ) & ~ B [ 0 ] ) ; \nhi = ( ( hi >> S [ 0 ] ) & B [ 0 ] ) | ( ( hi << S [ 0 ] ) & ~ B [ 0 ] ) ; \nlo = ( ( lo >> S [ 1 ] ) & B [ 1 ] ) | ( ( lo << S [ 1 ] ) & ~ B [ 1 ] ) ; \nhi = ( ( hi >> S [ 1 ] ) & B [ 1 ] ) | ( ( hi << S [ 1 ] ) & ~ B [ 1 ] ) ; \nlo = ( ( lo >> S [ 2 ] ) & B [ 2 ] ) | ( ( lo << S [ 2 ] ) & ~ B [ 2 ] ) ; \nhi = ( ( hi >> S [ 2 ] ) & B [ 2 ] ) | ( ( hi << S [ 2 ] ) & ~ B [ 2 ] ) ; \nlo = ( ( lo >> S [ 3 ] ) & B [ 3 ] ) | ( ( lo << S [ 3 ] ) & ~ B [ 3 ] ) ; \nhi = ( ( hi >> S [ 3 ] ) & B [ 3 ] ) | ( ( hi << S [ 3 ] ) & ~ B [ 3 ] ) ; \nlo = ( ( lo >> S [ 4 ] ) & B [ 4 ] ) | ( ( lo << S [ 4 ] ) & ~ B [ 4 ] ) ; \nhi = ( ( hi >> S [ 4 ] ) & B [ 4 ] ) | ( ( hi << S [ 4 ] ) & ~ B [ 4 ] ) ; \ni [ 1 ] = ( hi >> ( 64 - len ) ) | ( lo << ( len - 32 ) ) ; \ni [ 1 ] = lo >> ( 64 - len ) ; \n} \nelse { \ni [ 0 ] = 0 ; \ni [ 1 ] = rewindReverse32 ( lo , len ) ; \n} \nreturn i ; \n} \n} \n"}
{"3644": "public class SourceImpl { \nprotected int seekToKeyFrame ( int frame ) throws IOException { \nif ( ! ( videoInputTrack instanceof SeekableDemuxerTrack ) ) { \nLogger . warn ( \"Can not seek in \" + videoInputTrack + \" container.\" ) ; \nreturn - 1 ; \n} \nelse { \nSeekableDemuxerTrack seekable = ( SeekableDemuxerTrack ) videoInputTrack ; \nseekable . gotoSyncFrame ( frame ) ; \nreturn ( int ) seekable . getCurFrame ( ) ; \n} \n} \n} \n"}
{"3647": "public class DataConvert { \npublic static int [ ] fromByte ( byte [ ] b , int depth , boolean isBe ) { \nif ( ! ( depth == 24 ) ) if ( depth == 16 ) if ( ! ( isBe ) ) return from16LE ( b ) ; \nelse return from16BE ( b ) ; \nelse if ( ! ( isBe ) ) return from24LE ( b ) ; \nelse return from24BE ( b ) ; \nthrow new NotSupportedException ( \"Conversion from \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3648": "public class DataConvert { \npublic static byte [ ] toByte ( int [ ] ia , int depth , boolean isBe ) { \nif ( ! ( depth == 24 ) ) if ( depth == 16 ) if ( ! ( isBe ) ) return to16LE ( ia ) ; \nelse return to16BE ( ia ) ; \nelse if ( ! ( isBe ) ) return to24LE ( ia ) ; \nelse return to24BE ( ia ) ; \nthrow new NotSupportedException ( \"Conversion to \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( ! ( format . isBigEndian ( ) ) ) { \nif ( ! ( format . getSampleSizeInBits ( ) == 16 ) ) { \ntoFloat24LE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat16LE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( ! ( format . getSampleSizeInBits ( ) == 16 ) ) { \ntoFloat24BE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat16BE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( ! ( format . isBigEndian ( ) ) ) { \nif ( ! ( format . getSampleSizeInBits ( ) == 16 ) ) { \nfromFloat24LE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat16LE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( ! ( format . getSampleSizeInBits ( ) == 16 ) ) { \nfromFloat24BE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat16BE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \ni < ins . length ; \ni ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \nfor ( int frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes ++ ) { \nfor ( int j = 0 ; \nj < ins . length ; \nj ++ ) { \nif ( ! ( ins [ j ] . remaining ( ) < bytesPerSample ) ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \nelse { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) outb . put ( ( byte ) 0 ) ; \n} \n} \n} \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni ++ ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( ! ( xDir == - 1 && x == leftBound ) ) if ( ! ( xDir == 1 && x == rightBound ) ) if ( ! ( yDir == - 1 && y == topBound ) ) if ( ! ( yDir == 1 && y == bottomBound ) ) { \nx += xDir ; \ny += yDir ; \n} \nelse { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nint k = 0 ; \nfor ( int j = 0 ; \nj < picWidthInMbs ; \nj ++ ) { \nfor ( int i = 0 ; \ni < picHeightInMbs ; \ni ++ ) { \nint mbAddr = i * picWidthInMbs + j ; \nif ( ! ( k ++ < sizeOfUpperLeftGroup ) ) { \ngroups [ mbAddr ] = 1 - changeDirectionInt ; \n} \nelse { \ngroups [ mbAddr ] = changeDirectionInt ; \n} \n} \n} \nreturn groups ; \n} \n} \n"}
{"3658": "public class MBlockDecoderUtils { \npublic static int calcMVPredictionMedian ( int a , int b , int c , int d , boolean aAvb , boolean bAvb , boolean cAvb , boolean dAvb , int ref , int comp ) { \nif ( ! cAvb ) { \nc = d ; \ncAvb = dAvb ; \n} \nif ( aAvb && ! bAvb && ! cAvb ) { \nb = c = a ; \nbAvb = cAvb = aAvb ; \n} \na = aAvb ? a : NULL_VECTOR ; \nb = bAvb ? b : NULL_VECTOR ; \nc = cAvb ? c : NULL_VECTOR ; \nif ( ! ( mvRef ( a ) == ref && mvRef ( b ) != ref && mvRef ( c ) != ref ) ) if ( ! ( mvRef ( b ) == ref && mvRef ( a ) != ref && mvRef ( c ) != ref ) ) if ( mvRef ( c ) == ref && mvRef ( a ) != ref && mvRef ( b ) != ref ) return mvC ( c , comp ) ; \nelse return mvC ( b , comp ) ; \nelse return mvC ( a , comp ) ; \nreturn mvC ( a , comp ) + mvC ( b , comp ) + mvC ( c , comp ) - min ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) - max ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) ; \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( ! ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) ) if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \nelse { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( ! ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) ) { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( int i = 0 ; \ni < numSettings ; \ni ++ ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3702": "public class JNIEnv { \npublic static CPUArch getCPUArch ( String javaCPU ) { \nfinal CPUArch javaArch ; \nfinal String javaCPUArch = javaCPU != null ? javaCPU . toLowerCase ( ) : \"\" ; \nif ( ! ( javaCPUArch . startsWith ( \"x86_64\" ) || javaCPUArch . startsWith ( \"amd64\" ) || javaCPUArch . startsWith ( \"ia64\" ) ) ) if ( ! ( javaCPUArch . startsWith ( \"ppc64\" ) || javaCPUArch . startsWith ( \"powerpc64\" ) ) ) if ( ! ( javaCPUArch . startsWith ( \"ppc\" ) || javaCPUArch . startsWith ( \"powerpc\" ) ) ) if ( ! ( javaCPUArch . contains ( \"86\" ) ) ) { \njavaArch = CPUArch . UNKNOWN ; \n} \nelse { \njavaArch = CPUArch . X86 ; \n} \nelse { \njavaArch = CPUArch . PPC ; \n} \nelse { \njavaArch = CPUArch . PPC64 ; \n} \nelse { \njavaArch = CPUArch . X86_64 ; \n} \nreturn javaArch ; \n} \n} \n"}
{"3703": "public class JNIEnv { \npublic static CPUArch getCPUArchFromGNUString ( String gnuString ) { \nfinal String nativeCpu = gnuString . toLowerCase ( ) ; \nfinal CPUArch nativeArch ; \nif ( ! ( nativeCpu . startsWith ( \"x86_64\" ) || nativeCpu . startsWith ( \"amd64\" ) || nativeCpu . startsWith ( \"ia64\" ) ) ) if ( ! ( nativeCpu . startsWith ( \"ppc64\" ) || nativeCpu . startsWith ( \"powerpc64\" ) ) ) if ( ! ( nativeCpu . startsWith ( \"ppc\" ) || nativeCpu . startsWith ( \"powerpc\" ) ) ) if ( ! ( nativeCpu . contains ( \"86\" ) ) ) nativeArch = CPUArch . UNKNOWN ; \nelse nativeArch = CPUArch . X86 ; \nelse nativeArch = CPUArch . PPC ; \nelse nativeArch = CPUArch . PPC64 ; \nelse nativeArch = CPUArch . X86_64 ; \nreturn nativeArch ; \n} \n} \n"}
{"3704": "public class JNIEnv { \npublic static OSFamily getOSFamily ( String osName ) { \nfinal OSFamily retval ; \nif ( ! ( osName != null && osName . length ( ) > 0 ) ) retval = OSFamily . UNKNOWN ; \nelse { \nif ( ! ( osName . startsWith ( \"Windows\" ) ) ) if ( ! ( osName . startsWith ( \"Mac\" ) ) ) if ( ! ( osName . startsWith ( \"Linux\" ) ) ) retval = OSFamily . UNKNOWN ; \nelse retval = OSFamily . LINUX ; \nelse retval = OSFamily . MAC ; \nelse retval = OSFamily . WINDOWS ; \n} \nreturn retval ; \n} \n} \n"}
{"3705": "public class JNIEnv { \npublic static OSFamily getOSFamilyFromGNUString ( String gnuString ) { \nfinal String nativeOs = ( gnuString != null ? gnuString . toLowerCase ( ) : \"\" ) ; \nfinal OSFamily retval ; \nif ( ! ( nativeOs . startsWith ( \"mingw\" ) || nativeOs . startsWith ( \"cygwin\" ) ) ) if ( ! ( nativeOs . startsWith ( \"darwin\" ) ) ) if ( ! ( nativeOs . startsWith ( \"linux\" ) ) ) retval = OSFamily . UNKNOWN ; \nelse retval = OSFamily . LINUX ; \nelse retval = OSFamily . MAC ; \nelse retval = OSFamily . WINDOWS ; \nreturn retval ; \n} \n} \n"}
{"3711": "public class JNILibraryLoader { \nboolean alreadyLoadedLibrary ( String aLibraryName , Long aMajorVersion ) { \nboolean retval = false ; \nSet < Long > foundVersions = mLoadedLibraries . get ( aLibraryName ) ; \nif ( foundVersions != null ) { \nif ( ! ( aMajorVersion == null || foundVersions . contains ( aMajorVersion ) ) ) { \nlog . warn ( \"Attempting load of {}, version {}, but already loaded verions: {}.\" + \"  We will attempt to load the specified version but behavior is undefined\" , new Object [ ] { \naLibraryName , aMajorVersion , foundVersions . toArray ( ) } \n) ; \n} \nelse { \nretval = true ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( ! ( codecname != null ) ) { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nelse { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3727": "public class FSTBytezEncoder { \npublic void writePrimitiveArray ( Object array , int off , int len ) throws IOException { \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \nif ( ! ( componentType == byte . class ) ) if ( ! ( componentType == char . class ) ) if ( ! ( componentType == short . class ) ) if ( ! ( componentType == int . class ) ) if ( ! ( componentType == double . class ) ) if ( ! ( componentType == float . class ) ) if ( ! ( componentType == long . class ) ) if ( ! ( componentType == boolean . class ) ) { \nthrow new RuntimeException ( \"expected primitive array\" ) ; \n} \nelse { \nwriteFBooleanArr ( ( boolean [ ] ) array , off , len ) ; \n} \nelse { \nwriteFLongArr ( ( long [ ] ) array , off , len ) ; \n} \nelse { \nwriteFFloatArr ( ( float [ ] ) array , off , len ) ; \n} \nelse { \nwriteFDoubleArr ( ( double [ ] ) array , off , len ) ; \n} \nelse { \nwriteFIntArr ( ( int [ ] ) array , off , len ) ; \n} \nelse { \nwriteFShortArr ( ( short [ ] ) array , off , len ) ; \n} \nelse { \nwriteFCharArr ( ( char [ ] ) array , off , len ) ; \n} \nelse { \nwriteRawBytes ( ( byte [ ] ) array , off , len ) ; \n} \n} \n} \n"}
{"3737": "public class FSTStreamEncoder { \n@ Override public void setOutstream ( OutputStream outstream ) { \nif ( buffout == null ) { \nbuffout = ( FSTOutputStream ) conf . getCachedObject ( FSTOutputStream . class ) ; \nif ( ! ( buffout == null ) ) buffout . reset ( ) ; \nelse buffout = new FSTOutputStream ( 1000 , outstream ) ; \n} \nif ( ! ( outstream == null ) ) buffout . setOutstream ( outstream ) ; \nelse buffout . setOutstream ( buffout ) ; \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( ! ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) ) if ( ! ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) ) if ( ! ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) ) if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; \nelse writeInt ( MinBin . INT_32 , data ) ; \nelse writeInt ( MinBin . INT_16 , data ) ; \nelse writeInt ( MinBin . INT_8 , data ) ; \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( ! ( componentType == boolean . class ) ) if ( ! ( componentType == byte . class ) ) if ( ! ( componentType == short . class ) ) if ( ! ( componentType == char . class ) ) if ( ! ( componentType == int . class ) ) if ( ! ( componentType == long . class ) ) throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nelse type |= MinBin . INT_64 ; \nelse type |= MinBin . INT_32 ; \nelse type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse type |= MinBin . INT_16 ; \nelse type |= MinBin . INT_8 ; \nelse type |= MinBin . INT_8 ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( ! ( componentType == boolean . class ) ) { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nelse { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nif ( ! ( componentType == boolean . class ) ) writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \nelse writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \n} \n} \n} \n} \n} \n"}
{"3753": "public class FSTObjectOutput { \nprotected FSTClazzInfo . FSTFieldInfo getCachedFI ( Class ... possibles ) { \nif ( refs == null ) { \nrefs = refsLocal . get ( ) ; \n} \nif ( ! ( curDepth >= refs . length ) ) { \nFSTClazzInfo . FSTFieldInfo inf = refs [ curDepth ] ; \nif ( inf == null ) { \ninf = new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \nrefs [ curDepth ] = inf ; \nreturn inf ; \n} \ninf . setPossibleClasses ( possibles ) ; \nreturn inf ; \n} \nelse { \nreturn new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \n} \n} \n} \n"}
{"3756": "public class FSTObjectOutput { \nprotected FSTClazzInfo getFstClazzInfo ( FSTClazzInfo . FSTFieldInfo referencee , Class clazz ) { \nFSTClazzInfo serializationInfo = null ; \nFSTClazzInfo lastInfo = referencee . lastInfo ; \nif ( ! ( lastInfo != null && lastInfo . getClazz ( ) == clazz && lastInfo . conf == conf ) ) { \nserializationInfo = getClassInfoRegistry ( ) . getCLInfo ( clazz , conf ) ; \nreferencee . lastInfo = serializationInfo ; \n} \nelse { \nserializationInfo = lastInfo ; \n} \nreturn serializationInfo ; \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! ( ! componentType . isArray ( ) ) ) { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( ! ( subArr == null ) ) { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \nelse { \nif ( ! ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) ) { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( ! ( toWrite != null ) ) writeObjectWithContext ( referencee , toWrite , null ) ; \nelse { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \n} \n} \nelse { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \n} \n} \n} \n"}
{"3762": "public class FSTObjectRegistry { \npublic int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { \nif ( disabled ) { \nreturn Integer . MIN_VALUE ; \n} \nif ( ! ( clzInfo == null ) ) if ( clzInfo . isFlat ( ) ) { \nreturn Integer . MIN_VALUE ; \n} \nelse { \n} \nint handle = objects . putOrGet ( o , streamPosition ) ; \nif ( handle >= 0 ) { \nreUseType [ 0 ] = 0 ; \nreturn handle ; \n} \nreturn Integer . MIN_VALUE ; \n} \n} \n"}
{"3767": "public class BinaryQueue { \npublic void back ( int len ) { \nif ( ! ( pollIndex >= len ) ) pollIndex = pollIndex + capacity ( ) - len ; \nelse pollIndex -= len ; \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal int STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . println ( \"Process Thread Dump: \" + title ) ; \nstream . println ( threadIds . length + \" active threads\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . println ( \"  Inactive\" ) ; \ncontinue ; \n} \nstream . println ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . println ( \"  State: \" + state ) ; \nstream . println ( \"  Blocked count: \" + info . getBlockedCount ( ) ) ; \nstream . println ( \"  Waited count: \" + info . getWaitedCount ( ) ) ; \nif ( contention ) { \nstream . println ( \"  Blocked time: \" + info . getBlockedTime ( ) ) ; \nstream . println ( \"  Waited time: \" + info . getWaitedTime ( ) ) ; \n} \nif ( ! ( state == Thread . State . WAITING ) ) if ( state == Thread . State . BLOCKED ) { \nstream . println ( \"  Blocked on \" + info . getLockName ( ) ) ; \nstream . println ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; \n} \nelse { \nstream . println ( \"  Waiting on \" + info . getLockName ( ) ) ; \n} \nstream . println ( \"  Stack:\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . println ( \"    \" + frame . toString ( ) ) ; \n} \n} \nstream . flush ( ) ; \n} \n} \n"}
{"3773": "public class CheckSocket { \npublic static boolean remotePortTaken ( String node , int port , int timeout ) { \nSocket s = null ; \ntry { \ns = new Socket ( ) ; \ns . setReuseAddress ( true ) ; \nSocketAddress sa = new InetSocketAddress ( node , port ) ; \ns . connect ( sa , timeout * 1000 ) ; \n} \ncatch ( IOException e ) { \nif ( e . getMessage ( ) . equals ( \"Connection refused\" ) ) { \nreturn false ; \n} \nif ( e instanceof SocketTimeoutException || e instanceof UnknownHostException ) { \nthrow e ; \n} \n} \nfinally { \nif ( s != null ) { \nif ( ! ( s . isConnected ( ) ) ) { \n} \nelse { \nreturn true ; \n} \ntry { \ns . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nreturn false ; \n} \n} \n} \n"}
{"3776": "public class BaseBroadcastOp { \npublic List < long [ ] > calculateOutputShape ( ) { \nList < long [ ] > ret = new ArrayList < > ( ) ; \nif ( ! ( larg ( ) . getShape ( ) != null && rarg ( ) . getShape ( ) != null ) ) if ( larg ( ) . getShape ( ) != null ) ret . add ( larg ( ) . getShape ( ) ) ; \nelse ret . add ( Shape . broadcastOutputShape ( larg ( ) . getShape ( ) , rarg ( ) . getShape ( ) ) ) ; \nreturn ret ; \n} \n} \n"}
{"3778": "public class BooleanIndexing { \npublic static boolean and ( final INDArray n , final Condition cond ) { \nif ( ! ( cond instanceof BaseCondition ) ) { \nboolean ret = true ; \nfinal AtomicBoolean a = new AtomicBoolean ( ret ) ; \nShape . iterate ( n , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( a . get ( ) ) a . compareAndSet ( true , a . get ( ) && cond . apply ( n . getDouble ( coord [ 0 ] ) ) ) ; \n} \n} \n) ; \nreturn a . get ( ) ; \n} \nelse { \nlong val = ( long ) Nd4j . getExecutioner ( ) . exec ( new MatchCondition ( n , cond ) , Integer . MAX_VALUE ) . getDouble ( 0 ) ; \nif ( ! ( val == n . lengthLong ( ) ) ) return false ; \nelse return true ; \n} \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( ! ( arr . getDouble ( i ) == tadLength ) ) result [ i ] = false ; \nelse result [ i ] = true ; \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( ! ( arr . getDouble ( i ) > 0 ) ) result [ i ] = false ; \nelse result [ i ] = true ; \n} \nreturn result ; \n} \n} \n"}
{"3781": "public class BooleanIndexing { \npublic static void applyWhere ( final INDArray to , final Condition condition , final Number number ) { \nif ( ! ( condition instanceof BaseCondition ) ) { \nfinal double value = number . doubleValue ( ) ; \nfinal Function < Number , Number > dynamic = new Function < Number , Number > ( ) { \n@ Override public Number apply ( Number number ) { \nreturn value ; \n} \n} \n; \nShape . iterate ( to , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( condition . apply ( to . getDouble ( coord [ 0 ] ) ) ) to . putScalar ( coord [ 0 ] , dynamic . apply ( to . getDouble ( coord [ 0 ] ) ) . doubleValue ( ) ) ; \n} \n} \n) ; \n} \nelse { \nNd4j . getExecutioner ( ) . exec ( new CompareAndSet ( to , number . doubleValue ( ) , condition ) ) ; \n} \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( ! ( arrs [ 0 ] . isScalar ( ) ) ) { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \nelse { \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( int i = 0 ; \ni < getFeatures ( ) . length ( ) ; \ni ++ ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( ! ( curr > cutoff ) ) getFeatures ( ) . putScalar ( i , 0 ) ; \nelse getFeatures ( ) . putScalar ( i , 1 ) ; \n} \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nint numPreEscapes = 0 ; \nfor ( int i = start ; \ni < str . length ( ) ; \ni ++ ) { \nchar curChar = str . charAt ( i ) ; \nif ( ! ( numPreEscapes == 0 && curChar == separator ) ) { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; \n} \nelse { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3824": "public class StringUtils { \npublic static String escapeHTML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nboolean lastCharacterWasSpace = false ; \nchar [ ] chars = string . toCharArray ( ) ; \nfor ( char c : chars ) { \nif ( ! ( c == ' ' ) ) { \nlastCharacterWasSpace = false ; \nswitch ( c ) { \ncase '<' : sb . append ( \"&lt;\" ) ; \nbreak ; \ncase '>' : sb . append ( \"&gt;\" ) ; \nbreak ; \ncase '&' : sb . append ( \"&amp;\" ) ; \nbreak ; \ncase '\"' : sb . append ( \"&quot;\" ) ; \nbreak ; \ndefault : sb . append ( c ) ; \nbreak ; \n} \n} \nelse { \nif ( ! ( lastCharacterWasSpace ) ) { \nlastCharacterWasSpace = true ; \nsb . append ( \" \" ) ; \n} \nelse { \nlastCharacterWasSpace = false ; \nsb . append ( \"&nbsp;\" ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3835": "public class Shape { \npublic static boolean isVector ( DataBuffer shapeInfo ) { \nint rank = Shape . rank ( shapeInfo ) ; \nif ( ! ( rank > 2 || rank < 1 ) ) { \nint len = Shape . length ( shapeInfo ) ; \nDataBuffer shape = Shape . shapeOf ( shapeInfo ) ; \nreturn shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; \n} \nelse return false ; \n} \n} \n"}
{"3840": "public class BaseDataBuffer { \n@ Override public DataBuffer reallocate ( long length ) { \nPointer oldPointer = pointer ; \nif ( ! ( isAttached ( ) ) ) { \nswitch ( dataType ( ) ) { \ncase INT : pointer = new IntPointer ( length ) ; \nindexer = IntIndexer . create ( ( IntPointer ) pointer ) ; \nbreak ; \ncase DOUBLE : pointer = new DoublePointer ( length ) ; \nindexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; \nbreak ; \ncase FLOAT : pointer = new FloatPointer ( length ) ; \nindexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; \nbreak ; \n} \n} \nelse { \nlong capacity = length * getElementSize ( ) ; \nswitch ( dataType ( ) ) { \ncase DOUBLE : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . DOUBLE , false ) . asDoublePointer ( ) ; \nindexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; \nbreak ; \ncase FLOAT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . FLOAT , false ) . asFloatPointer ( ) ; \nindexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; \nbreak ; \ncase INT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . INT , false ) . asIntPointer ( ) ; \nindexer = IntIndexer . create ( ( IntPointer ) pointer ) ; \nbreak ; \n} \nworkspaceGenerationId = getParentWorkspace ( ) . getGenerationId ( ) ; \n} \nPointer . memcpy ( pointer , oldPointer , this . length ( ) * getElementSize ( ) ) ; \nreturn this ; \n} \n} \n"}
{"3858": "public class Paths { \npublic static boolean nameExistsInPath ( String name ) { \nString path = System . getenv ( PATH_ENV_VARIABLE ) ; \nString [ ] dirs = path . split ( File . pathSeparator ) ; \nfor ( String dir : dirs ) { \nFile dirFile = new File ( dir ) ; \nif ( ! dirFile . exists ( ) ) continue ; \nif ( ! ( dirFile . isFile ( ) && dirFile . getName ( ) . equals ( name ) ) ) { \nIterator < File > files = FileUtils . iterateFiles ( dirFile , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile curr = files . next ( ) ; \nif ( curr . getName ( ) . equals ( name ) ) return true ; \n} \n} \nelse return true ; \n} \nreturn false ; \n} \n} \n"}
{"3861": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { \nPointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; \nint dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; \nDataBuffer data = null ; \nPointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; \nint length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; \nshapeBufferPointer . capacity ( 4 * length ) ; \nshapeBufferPointer . limit ( 4 * length ) ; \nshapeBufferPointer . position ( 0 ) ; \nval intPointer = new LongPointer ( shapeBufferPointer ) ; \nDataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; \ndataPointer . position ( 0 ) ; \ndataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \ndataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \nif ( ! ( dataBufferElementSize == ( Float . SIZE / 8 ) ) ) if ( dataBufferElementSize == ( Double . SIZE / 8 ) ) { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; \n} \nelse { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; \n} \nINDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; \nreturn ret ; \n} \n} \n"}
{"3866": "public class CudaGridExecutioner { \n@ Override public Op exec ( Op op ) { \ncheckForCompression ( op ) ; \ninvokeWatchdog ( op ) ; \nif ( ! ( op instanceof Accumulation ) ) if ( ! ( op instanceof IndexAccumulation ) ) if ( ! ( op instanceof ScalarOp || op instanceof TransformOp ) ) if ( ! ( op instanceof BroadcastOp ) ) { \npushToGrid ( new OpDescriptor ( op ) ) ; \n} \nelse { \ninvoke ( ( BroadcastOp ) op ) ; \n} \nelse { \nprocessAsGridOp ( op ) ; \n} \nelse { \nexec ( ( IndexAccumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \n} \nelse { \nexec ( ( Accumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \n} \nreturn op ; \n} \n} \n"}
{"3868": "public class JarResource { \npublic InputStream getInputStream ( ) throws FileNotFoundException { \nURL url = this . getUrl ( ) ; \nif ( ! ( isJarURL ( url ) ) ) { \nFile srcFile = this . getFile ( ) ; \nreturn new FileInputStream ( srcFile ) ; \n} \nelse { \ntry { \nurl = extractActualUrl ( url ) ; \nZipFile zipFile = new ZipFile ( url . getFile ( ) ) ; \nZipEntry entry = zipFile . getEntry ( this . resourceName ) ; \nInputStream stream = zipFile . getInputStream ( entry ) ; \nreturn stream ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n} \n"}
{"3869": "public class CudaAffinityManager { \n@ Override public Integer getDeviceForThread ( long threadId ) { \nif ( getNumberOfDevices ( ) == 1 ) return 0 ; \nInteger aff = affinityMap . get ( threadId ) ; \nif ( ! ( aff == null ) ) { \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nif ( affiliated . get ( ) == null ) affiliated . set ( new AtomicBoolean ( false ) ) ; \nif ( ! affiliated . get ( ) . get ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( aff ) ) ; \naffiliated . get ( ) . set ( true ) ; \nreturn aff ; \n} \n} \nreturn aff ; \n} \nelse { \nInteger deviceId = getNextDevice ( threadId ) ; \naffinityMap . put ( threadId , deviceId ) ; \naffiliated . set ( new AtomicBoolean ( false ) ) ; \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( deviceId ) ) ; \naffiliated . get ( ) . set ( true ) ; \n} \nreturn deviceId ; \n} \n} \n} \n"}
{"3871": "public class CudaAffinityManager { \nprotected Integer getNextDevice ( long threadId ) { \nInteger device = null ; \nif ( ! ( ! CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isForcedSingleGPU ( ) && getNumberOfDevices ( ) > 0 ) ) { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( 0 ) ; \nlogger . debug ( \"Single device is forced, mapping to device [{}]\" , device ) ; \n} \nelse { \nsynchronized ( this ) { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( devPtr . getAndIncrement ( ) ) ; \nif ( devPtr . get ( ) >= CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) devPtr . set ( 0 ) ; \nlogger . debug ( \"Mapping thread [{}] to device [{}], out of [{}] devices...\" , threadId , device , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) ; \n} \n} \nreturn device ; \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( ! ( payload != null ) ) { \nif ( ! ( index >= 0 ) ) storage . getArray ( key ) . assign ( value ) ; \nelse { \nif ( storage . getArray ( key ) == null ) throw new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \n} \nelse { \nif ( ! ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) ) storage . setArray ( key , payload ) ; \nelse storage . getArray ( key ) . assign ( payload ) ; \n} \n} \n} \n"}
{"3883": "public class OpProfiler { \nprotected String getOpClass ( Op op ) { \nif ( ! ( op instanceof ScalarOp ) ) if ( ! ( op instanceof MetaOp ) ) if ( ! ( op instanceof GridOp ) ) if ( ! ( op instanceof BroadcastOp ) ) if ( ! ( op instanceof RandomOp ) ) if ( ! ( op instanceof Accumulation ) ) if ( ! ( op instanceof TransformOp ) ) if ( ! ( op instanceof IndexAccumulation ) ) if ( ! ( op instanceof CustomOp ) ) return \"Unknown Op calls\" ; \nelse { \nreturn \"CustomOp\" ; \n} \nelse { \nreturn \"IndexAccumulationOp\" ; \n} \nelse { \nif ( ! ( op . y ( ) == null ) ) return \"PairWiseTransformOp\" ; \nelse { \nreturn \"TransformOp\" ; \n} \n} \nelse { \nreturn \"AccumulationOp\" ; \n} \nelse { \nreturn \"RandomOp\" ; \n} \nelse { \nreturn \"BroadcastOp\" ; \n} \nelse { \nreturn \"GridOp\" ; \n} \nelse { \nreturn \"MetaOp\" ; \n} \nelse { \nreturn \"ScalarOp\" ; \n} \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( ! ( shapeMatrix . length ( ) > 1 ) ) { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \nelse return arr . get ( indexes ) ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \ni < numDevices ; \ni ++ ) { \nif ( ! ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) ) { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \nelse { \nset ( i , array ) ; \n} \n} \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( ! ( mc . getPrecision ( ) < GAMMA . precision ( ) ) ) { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nint kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \nfor ( int n = 1 ; \n; \nn ++ ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( c . doubleValue ( ) < 0.1 * eps ) { \nbreak ; \n} \n} \nreturn resul . round ( mc ) ; \n} \nelse { \nreturn GAMMA . round ( mc ) ; \n} \n} \n} \n"}
{"3897": "public class BigDecimalMath { \nstatic public BigDecimal cbrt ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) { \nreturn root ( 3 , x ) ; \n} \nelse { \nreturn root ( 3 , x . negate ( ) ) . negate ( ) ; \n} \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( ! ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) ) { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \nelse { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \nelse { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \n} \n} \n"}
{"3900": "public class BigDecimalMath { \nstatic public BigDecimal exp ( final MathContext mc ) { \nif ( ! ( mc . getPrecision ( ) < E . precision ( ) ) ) { \nBigDecimal uni = scalePrec ( BigDecimal . ONE , mc . getPrecision ( ) ) ; \nreturn exp ( uni ) ; \n} \nelse { \nreturn E . round ( mc ) ; \n} \n} \n} \n"}
{"3901": "public class BigDecimalMath { \nstatic public BigDecimal pow ( final BigDecimal x , final BigDecimal y ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nBigDecimal logx = log ( x ) ; \nBigDecimal ylogx = y . multiply ( logx ) ; \nBigDecimal resul = exp ( ylogx ) ; \ndouble errR = Math . abs ( logx . doubleValue ( ) * y . ulp ( ) . doubleValue ( ) / 2. ) + Math . abs ( y . doubleValue ( ) * x . ulp ( ) . doubleValue ( ) / 2. / x . doubleValue ( ) ) ; \nMathContext mcR = new MathContext ( err2prec ( 1.0 , errR ) ) ; \nreturn resul . round ( mcR ) ; \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \nelse { \nthrow new ArithmeticException ( \"Cannot power negative \" + x . toString ( ) ) ; \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( ! ( res . compareTo ( p ) > 0 ) ) if ( ! ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) ) { \nif ( ! ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) ) { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \n} \nelse { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \nelse { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( ! ( xDbl > 0.8 ) ) { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( int i = 2 ; \n; \ni ++ ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \nelse { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \n} \nelse { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nif ( ! ( x . doubleValue ( ) > 1.5 ) ) { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \n} \nelse { \nreturn BigDecimal . ONE ; \n} \nelse { \nreturn cos ( x . negate ( ) ) ; \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nif ( ! ( x . doubleValue ( ) > 2.4 ) ) { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \nelse { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \n} \n} \n"}
{"3907": "public class BigDecimalMath { \nstatic public BigDecimal tanh ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; \nMathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; \nreturn BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \nelse { \nreturn tanh ( x . negate ( ) ) . negate ( ) ; \n} \n} \n} \n"}
{"3908": "public class BigDecimalMath { \nstatic public BigDecimal asinh ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) == 0 ) ) { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( hypot ( 1 , xhighpr ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . hypot ( 1. , xDbl ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \n} \n} \n"}
{"3909": "public class BigDecimalMath { \nstatic public BigDecimal acosh ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ONE ) < 0 ) ) if ( ! ( x . compareTo ( BigDecimal . ONE ) == 0 ) ) { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( sqrt ( xhighpr . pow ( 2 ) . subtract ( BigDecimal . ONE ) ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . sqrt ( xDbl * xDbl - 1. ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \nelse { \nreturn BigDecimal . ZERO ; \n} \nelse { \nthrow new ArithmeticException ( \"Out of range argument cosh \" + x . toString ( ) ) ; \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( ! ( x . compareTo ( BigDecimal . ZERO ) < 0 ) ) if ( ! ( x . doubleValue ( ) > 1.5 ) ) { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( ! ( eps / 100. / c . doubleValue ( ) < 0.01 ) ) { \nm = new MathContext ( 2 ) ; \n} \nelse { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( ! ( n % 2 == 0 ) ) { \nresul = resul . subtract ( c ) ; \n} \nelse { \nresul = resul . add ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \nn < 5 ; \nn ++ ) { \npsi += zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \nelse { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \n} \n} \n"}
{"3913": "public class BigDecimalMath { \nstatic public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { \nfinal int diffPr = mc . getPrecision ( ) - x . precision ( ) ; \nif ( ! ( diffPr > 0 ) ) { \nreturn x ; \n} \nelse { \nreturn scalePrec ( x , diffPr ) ; \n} \n} \n} \n"}
{"3915": "public class SameDiff { \npublic void putFunctionForId ( String id , DifferentialFunction function ) { \nif ( ! ( functionInstancesById . containsKey ( id ) ) ) if ( function instanceof SDVariable ) { \nthrow new ND4JIllegalStateException ( \"Function must not be a variable!\" ) ; \n} \nelse { \nthrow new ND4JIllegalStateException ( \"Function by id already exists!\" ) ; \n} \nfunctionInstancesById . put ( id , function ) ; \n} \n} \n"}
{"3919": "public class SameDiff { \npublic void associateArrayWithVariable ( INDArray arr , SDVariable variable ) { \nif ( variable == null ) { \nthrow new ND4JIllegalArgumentException ( \"Variable must not be null!\" ) ; \n} \nif ( arr == null ) { \nthrow new ND4JIllegalArgumentException ( \"Array must not be null\" ) ; \n} \nreverseArrayLookup . put ( arr , variable ) ; \nvariableNameToArr . put ( variable . getVarName ( ) , arr ) ; \nif ( ! ( ! shapeAlreadyExistsForVarName ( variable . getVarName ( ) ) ) ) { \nupdateShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \nelse putShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \n} \n"}
{"3920": "public class SameDiff { \npublic < T > T getPropertyForFunction ( DifferentialFunction functionInstance , String propertyName ) { \nif ( ! ( ! propertiesForFunction . containsKey ( functionInstance . getOwnName ( ) ) ) ) { \nval map = propertiesForFunction . get ( functionInstance . getOwnName ( ) ) ; \nreturn ( T ) map . get ( propertyName ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"3935": "public class SameDiff { \npublic Pair < Map < SDVariable , DifferentialFunction > , List < DifferentialFunction > > exec ( String functionName ) { \nif ( ! ( debugMode ) ) return sameDiffFunctionInstances . get ( functionName ) . exec ( ) ; \nelse { \nreturn sameDiffFunctionInstances . get ( functionName ) . enableDebugMode ( ) . exec ( ) ; \n} \n} \n} \n"}
{"3937": "public class SameDiff { \npublic INDArray execBackwardAndEndResult ( ) { \nList < DifferentialFunction > backwards = execBackwards ( ) . getRight ( ) ; \nDifferentialFunction df = backwards . get ( backwards . size ( ) - 1 ) ; \nif ( ! ( df instanceof Op ) ) if ( ! ( df instanceof DynamicCustomOp ) ) { \nreturn null ; \n} \nelse { \nreturn ( ( DynamicCustomOp ) df ) . getOutputArgument ( 0 ) ; \n} \nelse { \nreturn ( ( Op ) df ) . z ( ) ; \n} \n} \n} \n"}
{"3939": "public class CudaMemoryManager { \n@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { \nAtomicAllocator allocator = AtomicAllocator . getInstance ( ) ; \nif ( ! ( kind == MemoryKind . HOST ) ) if ( ! ( kind == MemoryKind . DEVICE ) ) throw new RuntimeException ( \"Unknown MemoryKind requested: \" + kind ) ; \nelse { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + \"] memory\" ) ; \nif ( initialize ) { \nCudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; \nint i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; \nif ( i == 0 ) throw new ND4JIllegalStateException ( \"memset failed on device_\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; \ncontext . getSpecialStream ( ) . synchronize ( ) ; \n} \nreturn ptr ; \n} \nelse { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from HOST memory\" ) ; \nif ( initialize ) Pointer . memset ( ptr , 0 , bytes ) ; \nreturn ptr ; \n} \n} \n} \n"}
{"3946": "public class BaseLevel2 { \n@ Override public void trmv ( char order , char Uplo , char TransA , char Diag , INDArray A , INDArray X ) { \nif ( Nd4j . getExecutioner ( ) . getProfilingMode ( ) == OpExecutioner . ProfilingMode . ALL ) OpProfiler . getInstance ( ) . processBlasCall ( false , A , X ) ; \nif ( ! ( A . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) ) { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . FLOAT , A , X ) ; \nstrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nelse { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . DOUBLE , A , X ) ; \ndtrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nOpExecutionerUtil . checkForAny ( X ) ; \n} \n} \n"}
{"3951": "public class NativeOpExecutioner { \nprivate void invoke ( ScalarOp op , int [ ] dimension ) { \ndimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; \nPair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; \nPointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; \nPointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; \nPointer devTadShapeInfoZ = null ; \nPointer devTadOffsetsZ = null ; \nPair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; \ndevTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; \ndevTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; \nif ( extraz . get ( ) == null ) extraz . set ( new PointerPointer ( 32 ) ) ; \nPointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; \nif ( ! ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) ) if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nloop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \nelse { \nloop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \n} \n} \n"}
{"3955": "public class AtomicState { \npublic boolean tryRequestToe ( ) { \nscheduleToe ( ) ; \nif ( ! ( isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ) ) { \ndiscardScheduledToe ( ) ; \nrequestToe ( ) ; \nreturn true ; \n} \nelse { \ndiscardScheduledToe ( ) ; \nreturn false ; \n} \n} \n} \n"}
{"3956": "public class AtomicState { \npublic void releaseToe ( ) { \nif ( ! ( getCurrentState ( ) == AccessState . TOE ) ) throw new IllegalStateException ( \"Object is NOT in Toe state!\" ) ; \nelse { \nif ( ! ( 1 > 0 ) ) throw new IllegalStateException ( \"releaseToe() is called from different thread.\" ) ; \nelse { \nif ( toeRequests . decrementAndGet ( ) == 0 ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \ncurrentState . set ( AccessState . TACK . ordinal ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"3957": "public class AtomicState { \npublic AccessState getCurrentState ( ) { \nif ( ! ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) ) { \nif ( ! ( tickRequests . get ( ) <= tackRequests . get ( ) ) ) return AccessState . TICK ; \nelse { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \nreturn AccessState . TACK ; \n} \n} \nelse { \nreturn AccessState . TOE ; \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( ! ( index . isMatrix ( ) ) ) if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nelse { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \ni < index . rows ( ) ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nj < row . columns ( ) ; \nj ++ ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) { \nthrow new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \n} \nval outputVars = args ( ) ; \nfor ( int i = 0 ; \ni < vals . size ( ) ; \ni ++ ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( ! ( grad != null ) ) { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \nelse { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3971": "public class BaseGraphMapper { \n@ Override public SameDiff importGraph ( GRAPH_TYPE tfGraph ) { \nSameDiff diff = SameDiff . create ( ) ; \nImportState < GRAPH_TYPE , TENSOR_TYPE > importState = new ImportState < > ( ) ; \nimportState . setSameDiff ( diff ) ; \nimportState . setGraph ( tfGraph ) ; \nval variablesForGraph = variablesForGraph ( tfGraph ) ; \nimportState . setVariables ( variablesForGraph ) ; \nfor ( Map . Entry < String , TENSOR_TYPE > entry : variablesForGraph . entrySet ( ) ) { \nif ( dataTypeForTensor ( entry . getValue ( ) ) == DataBuffer . Type . UNKNOWN ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , var . getShape ( ) ) ; \n} \ncontinue ; \n} \nval arr = getNDArrayFromTensor ( entry . getKey ( ) , entry . getValue ( ) , tfGraph ) ; \nif ( ! ( arr != null ) ) if ( ! ( getShapeFromTensor ( entry . getValue ( ) ) == null ) ) { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , originalShape ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \nelse { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \nelse { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , arr ) ; \ndiff . associateArrayWithVariable ( arr , var ) ; \n} \n} \nval tfNodesList = getNodeList ( tfGraph ) ; \nfor ( NODE_TYPE tfNode : tfNodesList ) { \nif ( ! opsToIgnore ( ) . contains ( getOpType ( tfNode ) ) || isOpIgnoreException ( tfNode ) ) mapNodeType ( tfNode , importState ) ; \n} \nreturn diff ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( ! ( arr . isScalar ( ) ) ) for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \nelse arr . putScalar ( 0 , getReal ( 0 ) ) ; \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( ! ( arr . isScalar ( ) ) ) for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \nelse arr . putScalar ( 0 , getReal ( 0 ) ) ; \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \nfor ( int i = 0 ; \ni < linearView ( ) . length ( ) ; \ni ++ ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( ! ( diff <= Nd4j . EPS_THRESHOLD ) ) linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \nelse linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( ! ( toPut instanceof IComplexNDArray ) ) { \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \n} \nelse { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3984": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray subi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( other . isScalar ( ) ) return subi ( cOther . getComplex ( 0 ) , result ) ; \nif ( ! ( result == this ) ) if ( ! ( result == other ) ) { \nNd4j . getBlasWrapper ( ) . copy ( this , result ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \n} \nelse { \nif ( ! ( data . dataType ( ) == ( DataBuffer . Type . DOUBLE ) ) ) { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asFloat ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \n} \nelse Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \nreturn cResult ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( ! ( result == this ) ) if ( ! ( result == other ) ) { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < resultLinear . length ( ) ; \ni ++ ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \n} \nelse { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3991": "public class BaseLevel1 { \n@ Override public void copy ( IComplexNDArray x , IComplexNDArray y ) { \nif ( ! ( x . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) ) ccopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \nelse zcopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \n} \n} \n"}
{"3992": "public class BaseLevel1 { \n@ Override public void scal ( long N , IComplexNumber alpha , IComplexNDArray X ) { \nif ( ! ( X . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) ) cscal ( N , alpha . asFloat ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \nelse zscal ( N , alpha . asDouble ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \nfor ( ; \ne < codes . length ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \ne < resultLength ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( ! ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) ) if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \nelse { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \n} \n} \n"}
{"3995": "public class LossFunctions { \nprivate static LossInfo doReduce ( SameDiff sd , String outputName , boolean isMean , LossInfo . Builder b , Reduction reduction , SDVariable preReduceLoss , SDVariable label , SDVariable weights , int [ ] dimensions ) { \nswitch ( reduction ) { \ncase NONE : b . loss ( preReduceLoss ) ; \nbreak ; \ncase SPECIFIED_DIMS : if ( ! ( isMean ) ) { \nb . loss ( sd . sum ( outputName , preReduceLoss , dimensions ) ) ; \n} \nelse { \nb . loss ( sd . mean ( outputName , preReduceLoss , dimensions ) ) ; \n} \ncase SUM : if ( ! ( isMean ) ) { \nb . loss ( sd . sum ( outputName , preReduceLoss ) ) ; \n} \nelse { \nSDVariable m = sd . mean ( preReduceLoss , dimensions ) ; \nb . loss ( sd . sum ( outputName , m ) ) ; \n} \nbreak ; \ncase MEAN_BY_WEIGHT : SDVariable weightSum = sd . sum ( weights ) ; \nif ( ! ( isMean ) ) { \nSDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; \nb . loss ( sum . div ( outputName , weightSum ) ) ; \n} \nelse { \nSDVariable m2 = sd . mean ( preReduceLoss ) ; \nb . loss ( m2 . div ( outputName , weightSum ) ) ; \n} \nbreak ; \ncase MEAN_BY_COUNT : SDVariable nonZeroWeights = nonZeroCount ( weights , label ) ; \nSDVariable r ; \nif ( ! ( isMean ) ) { \nSDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; \nr = sd . mean ( sum ) ; \n} \nelse { \nr = sd . sum ( preReduceLoss ) ; \n} \nb . loss ( r . div ( outputName , nonZeroWeights ) ) ; \nbreak ; \ndefault : throw new RuntimeException ( \"Unknown reduction: \" + reduction ) ; \n} \nreturn b . build ( ) ; \n} \n} \n"}
{"3996": "public class TypeUtils { \npublic static < T > Constructor < T > getNoArgConstructor ( Class < T > clazz ) { \ntry { \nConstructor < T > ctor = clazz . getDeclaredConstructor ( new Class [ 0 ] ) ; \nctor . setAccessible ( true ) ; \nreturn ctor ; \n} \ncatch ( NoSuchMethodException e ) { \nif ( ! ( clazz . isMemberClass ( ) || clazz . isAnonymousClass ( ) || clazz . isLocalClass ( ) ) ) throw new IllegalStateException ( clazz . getName ( ) + \" must have a no-arg constructor\" , e ) ; \nelse throw new IllegalStateException ( clazz . getName ( ) + \" must be static and must have a no-arg constructor\" , e ) ; \n} \n} \n} \n"}
{"4006": "public class Registrar { \npublic < T > EntityMetadata < T > getMetadataSafe ( String kind ) throws IllegalArgumentException { \nEntityMetadata < T > metadata = this . getMetadata ( kind ) ; \nif ( ! ( metadata == null ) ) return metadata ; \nelse throw new IllegalArgumentException ( \"No entity class has been registered which matches kind '\" + kind + \"'\" ) ; \n} \n} \n"}
{"4014": "public class LogUtils { \npublic static String msg ( Path path , String msg ) { \nStringBuilder bld = new StringBuilder ( ) ; \nbld . append ( \"\\t.\" ) ; \nbld . append ( path . toPathString ( ) ) ; \nif ( ! ( bld . length ( ) < PATH_PADDING ) ) bld . append ( '\\t' ) ; \nelse while ( bld . length ( ) < PATH_PADDING ) bld . append ( ' ' ) ; \nbld . append ( msg ) ; \nreturn bld . toString ( ) ; \n} \n} \n"}
{"4017": "public class Key { \npublic static < V > Key < V > key ( final com . google . cloud . datastore . Key raw ) { \nif ( ! ( raw == null ) ) return new Key < > ( raw ) ; \nelse return null ; \n} \n} \n"}
{"4018": "public class Key { \npublic static com . google . cloud . datastore . Key key ( final Key < ? > typed ) { \nif ( ! ( typed == null ) ) return typed . getRaw ( ) ; \nelse return null ; \n} \n} \n"}
{"4019": "public class Key { \nprivate static String getKindHere ( final Class < ? > clazz ) { \nfinal Entity ourAnn = TypeUtils . getDeclaredAnnotation ( clazz , Entity . class ) ; \nif ( ourAnn != null ) if ( ! ( ourAnn . name ( ) . length ( ) != 0 ) ) return clazz . getSimpleName ( ) ; \nelse return ourAnn . name ( ) ; \nreturn null ; \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( ! ( type instanceof Class ) ) if ( ! ( type instanceof ParameterizedType ) ) { \nthrow new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \nelse { \nreturn false ; \n} \nelse { \nfor ( Class < ? > clazz = ( Class < ? > ) type ; \nclazz != null ; \nclazz = clazz . getEnclosingClass ( ) ) { \nif ( clazz . getTypeParameters ( ) . length != 0 ) return true ; \n} \nreturn false ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( ! ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) ) if ( ! ( superType instanceof CaptureType ) ) if ( ! ( superType instanceof GenericArrayType ) ) { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \nelse { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( ! ( mappedSubType == null ) ) if ( ! ( superType instanceof Class < ? > ) ) if ( ! ( mappedSubType instanceof Class < ? > ) ) if ( ! ( mappedSubType instanceof GenericArrayType ) ) { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \nelse { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( ! ( type instanceof ParameterizedType || type instanceof Class ) ) if ( ! ( type instanceof TypeVariable ) ) if ( ! ( type instanceof WildcardType ) ) if ( ! ( type instanceof CaptureType ) ) if ( ! ( type instanceof GenericArrayType ) ) if ( ! ( type == null ) ) { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \nelse { \nthrow new NullPointerException ( ) ; \n} \nelse { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse { \nClass < ? > clazz ; \nif ( ! ( type instanceof ParameterizedType ) ) { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nelse { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \nType [ ] result ; \nint resultIndex ; \nif ( ! ( superClass == null ) ) { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nelse { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \n} \n} \n"}
{"4023": "public class GenericTypeReflector { \npublic static Type capture ( Type type ) { \nif ( ! ( type instanceof ParameterizedType ) ) { \nreturn type ; \n} \nelse { \nreturn capture ( ( ParameterizedType ) type ) ; \n} \n} \n} \n"}
{"4025": "public class CreateContext { \n@ SuppressWarnings ( \"unchecked\" ) public < P > Populator < P > getPopulator ( final Class < P > clazz , final Path path ) { \nif ( ! ( clazz == null || clazz . equals ( Object . class ) ) ) { \nfinal ClassTranslator < P > classTranslator = ( ClassTranslator < P > ) this . < P , FullEntity < ? > > getTranslator ( new TypeKey < > ( clazz ) , this , path ) ; \nreturn classTranslator . getPopulator ( ) ; \n} \nelse { \nreturn ( Populator < P > ) NullPopulator . INSTANCE ; \n} \n} \n} \n"}
{"4026": "public class ClassPopulator { \nprivate Boolean getIndexInstruction ( Class < P > clazz ) { \nIndex ind = clazz . getAnnotation ( Index . class ) ; \nUnindex unind = clazz . getAnnotation ( Unindex . class ) ; \nif ( ind != null && unind != null ) throw new IllegalStateException ( \"You cannot have @Index and @Unindex on the same class: \" + clazz ) ; \nif ( ! ( ind != null ) ) if ( ! ( unind != null ) ) return null ; \nelse return false ; \nelse return true ; \n} \n} \n"}
{"4030": "public class Round { \npublic < T > Result < T > get ( final Key < T > key ) { \nassert ! isExecuted ( ) ; \nSessionValue < T > sv = getSession ( ) . get ( key ) ; \nif ( ! ( sv == null ) ) { \nlog . trace ( \"Adding to round (session hit): {}\" , key ) ; \nif ( sv . loadWith ( getLoadArrangement ( ) ) ) { \nlog . trace ( \"New load group arrangement, checking for upgrades: {}\" , getLoadArrangement ( ) ) ; \nT thing = sv . getResult ( ) . now ( ) ; \nif ( thing != null ) { \nSaveContext saveCtx = new SaveContext ( ) { \n@ Override public boolean skipLifecycle ( ) { \nreturn true ; \n} \n@ Override public com . google . cloud . datastore . Key saveRef ( Ref < ? > value , LoadConditions loadConditions ) { \ncom . google . cloud . datastore . Key key = super . saveRef ( value , loadConditions ) ; \nif ( loadEngine . shouldLoad ( loadConditions ) ) { \nlog . trace ( \"Upgrading key {}\" , key ) ; \nloadEngine . load ( value . key ( ) ) ; \n} \nreturn key ; \n} \n} \n; \nloadEngine . ofy . factory ( ) . getMetadataForEntity ( thing ) . save ( thing , saveCtx ) ; \n} \n} \n} \nelse { \nlog . trace ( \"Adding to round (session miss): {}\" , key ) ; \nthis . pending . add ( key . getRaw ( ) ) ; \nResult < T > result = new ResultCache < T > ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public T nowUncached ( ) { \nloadEngine . execute ( ) ; \nreturn ( T ) translated . now ( ) . get ( key ) ; \n} \n@ Override public String toString ( ) { \nreturn \"(Fetch result for \" + key + \")\" ; \n} \n} \n; \nsv = new SessionValue < > ( result , getLoadArrangement ( ) ) ; \ngetSession ( ) . add ( key , sv ) ; \n} \nreturn sv . getResult ( ) ; \n} \n} \n"}
{"4032": "public class Round { \nprivate Result < Map < com . google . cloud . datastore . Key , Entity > > fetchPending ( ) { \nfinal Map < com . google . cloud . datastore . Key , Entity > combined = new HashMap < > ( ) ; \nSet < com . google . cloud . datastore . Key > fetch = new HashSet < > ( ) ; \nfor ( com . google . cloud . datastore . Key key : pending ) { \nEntity ent = stuffed . get ( key ) ; \nif ( ! ( ent == null ) ) combined . put ( key , ent ) ; \nelse fetch . add ( key ) ; \n} \nif ( ! ( fetch . isEmpty ( ) ) ) { \nfinal Result < Map < com . google . cloud . datastore . Key , Entity > > fetched = loadEngine . fetch ( fetch ) ; \nreturn ( ) -> { \ncombined . putAll ( fetched . now ( ) ) ; \nreturn combined ; \n} \n; \n} \nelse { \nreturn new ResultNow < > ( combined ) ; \n} \n} \n} \n"}
{"4035": "public class GenericUtils { \npublic static Type getCollectionComponentType ( Type collectionType ) { \nType componentType = GenericTypeReflector . getTypeParameter ( collectionType , Collection . class . getTypeParameters ( ) [ 0 ] ) ; \nif ( ! ( componentType == null ) ) return componentType ; \nelse return Object . class ; \n} \n} \n"}
{"4036": "public class GenericUtils { \npublic static Type getMapKeyType ( Type mapType ) { \nType componentType = GenericTypeReflector . getTypeParameter ( mapType , Map . class . getTypeParameters ( ) [ 0 ] ) ; \nif ( ! ( componentType == null ) ) return componentType ; \nelse return Object . class ; \n} \n} \n"}
{"4039": "public class Path { \npublic String toPathString ( ) { \nif ( ! ( this == ROOT ) ) { \nStringBuilder builder = new StringBuilder ( ) ; \ntoPathString ( builder ) ; \nreturn builder . toString ( ) ; \n} \nelse { \nreturn \"\" ; \n} \n} \n} \n"}
{"4046": "public class KeyMetadata { \nprivate void findKeyFields ( Class < ? > inspect , CreateContext ctx , Path path ) { \nif ( inspect == Object . class ) return ; \nfindKeyFields ( inspect . getSuperclass ( ) , ctx , path ) ; \nfor ( Field field : inspect . getDeclaredFields ( ) ) { \nif ( ! ( field . getAnnotation ( Id . class ) != null ) ) if ( field . getAnnotation ( Parent . class ) != null ) { \nif ( this . parentMeta != null ) throw new IllegalStateException ( \"Multiple @Parent fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ! isAllowedParentFieldType ( field . getType ( ) ) ) throw new IllegalStateException ( \"@Parent fields must be Ref<?>, Key<?>, or datastore Key. Illegal parent: \" + field ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . parentMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \nelse { \nif ( this . idMeta != null ) throw new IllegalStateException ( \"Multiple @Id fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ( field . getType ( ) != Long . class ) && ( field . getType ( ) != long . class ) && ( field . getType ( ) != String . class ) ) throw new IllegalStateException ( \"@Id field '\" + field . getName ( ) + \"' in \" + inspect . getName ( ) + \" must be of type Long, long, or String\" ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . idMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \n} \n} \n} \n"}
{"4052": "public class TypeFactory { \nprivate static Type transformOwner ( Type givenOwner , Class < ? > clazz ) { \nif ( ! ( givenOwner == null ) ) { \nType transformedOwner = GenericTypeReflector . getExactSuperType ( givenOwner , clazz . getDeclaringClass ( ) ) ; \nif ( transformedOwner == null ) { \nthrow new IllegalArgumentException ( \"Given owner type [\" + givenOwner + \"] is not appropriate for [\" + clazz + \"]: it should be a subtype of \" + clazz . getDeclaringClass ( ) ) ; \n} \nif ( ! ( Modifier . isStatic ( clazz . getModifiers ( ) ) ) ) { \nreturn transformedOwner ; \n} \nelse { \nreturn GenericTypeReflector . erase ( transformedOwner ) ; \n} \n} \nelse { \nreturn clazz . getDeclaringClass ( ) ; \n} \n} \n} \n"}
{"4053": "public class TypeKey { \npublic < A extends Annotation > A getAnnotationAnywhere ( Class < A > annotationType ) { \nA anno = getAnnotation ( annotationType ) ; \nif ( ! ( anno == null ) ) { \nreturn anno ; \n} \nelse { \nClass < ? > clazz = ( Class < ? > ) GenericTypeReflector . erase ( type ) ; \nreturn clazz . getAnnotation ( annotationType ) ; \n} \n} \n} \n"}
{"4059": "public class LoadEngine { \n@ SuppressWarnings ( \"unchecked\" ) public < T > T load ( final BaseEntity < com . google . cloud . datastore . Key > ent , final LoadContext ctx ) { \nif ( ent == null ) return null ; \nfinal EntityMetadata < T > meta = ofy . factory ( ) . getMetadata ( ent . getKey ( ) . getKind ( ) ) ; \nif ( ! ( meta == null ) ) return meta . load ( ent , ctx ) ; \nelse return ( T ) ent ; \n} \n} \n"}
{"4060": "public class Keys { \npublic com . google . cloud . datastore . Key createRawAny ( final com . google . cloud . datastore . Key parent , final String kind , final Object id ) { \nif ( ! ( id instanceof String ) ) if ( ! ( id instanceof Long ) ) throw new IllegalArgumentException ( \"id '\" + id + \"' must be String or Long\" ) ; \nelse return createRaw ( parent , kind , ( Long ) id ) ; \nelse return createRaw ( parent , kind , ( String ) id ) ; \n} \n} \n"}
{"4062": "public class Keys { \n@ SuppressWarnings ( \"unchecked\" ) public static < S > Value < S > getIdValue ( final IncompleteKey key ) { \nif ( ! ( key instanceof com . google . cloud . datastore . Key ) ) { \nreturn null ; \n} \nelse { \nfinal com . google . cloud . datastore . Key completeKey = ( com . google . cloud . datastore . Key ) key ; \nif ( ! ( completeKey . hasId ( ) ) ) return ( Value < S > ) StringValue . of ( completeKey . getName ( ) ) ; \nelse return ( Value < S > ) LongValue . of ( completeKey . getId ( ) ) ; \n} \n} \n} \n"}
{"4063": "public class Keys { \n@ SneakyThrows public static com . google . cloud . datastore . Key fromUrlSafe ( final String urlSafeKey ) { \nif ( ! ( urlSafeKey . startsWith ( \"a\" ) ) ) { \nreturn com . google . cloud . datastore . Key . fromUrlSafe ( urlSafeKey ) ; \n} \nelse { \nreturn KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey ) ; \n} \n} \n} \n"}
{"4069": "public class ObjectifyFactory { \npublic AsyncDatastore asyncDatastore ( final boolean enableGlobalCache ) { \nif ( ! ( this . entityMemcache != null && enableGlobalCache && this . registrar . isCacheEnabled ( ) ) ) return asyncDatastore ( ) ; \nelse return new CachingAsyncDatastore ( asyncDatastore ( ) , this . entityMemcache ) ; \n} \n} \n"}
{"4076": "public class Ref { \nfinal public T safe ( ) throws NotFoundException { \nT t = this . get ( ) ; \nif ( ! ( t == null ) ) return t ; \nelse throw new NotFoundException ( key ( ) ) ; \n} \n} \n"}
{"4083": "public class FutureHelper { \npublic static void unwrapAndThrow ( Throwable ex ) { \nif ( ! ( ex instanceof RuntimeException ) ) if ( ! ( ex instanceof Error ) ) if ( ! ( ex instanceof ExecutionException ) ) throw new UndeclaredThrowableException ( ex ) ; \nelse unwrapAndThrow ( ex . getCause ( ) ) ; \nelse throw ( Error ) ex ; \nelse throw ( RuntimeException ) ex ; \n} \n} \n"}
{"4088": "public class PropertyPopulator { \nprivate Value < D > getPropertyFromContainer ( final FullEntity < ? > container , final Path containerPath ) { \nString foundName = null ; \nValue < D > value = null ; \nfor ( String name : property . getLoadNames ( ) ) { \nif ( container . contains ( name ) ) { \nif ( foundName != null ) throw new IllegalStateException ( \"Collision trying to load field; multiple name matches for '\" + property . getName ( ) + \"' at '\" + containerPath . extend ( foundName ) + \"' and '\" + containerPath . extend ( name ) + \"'\" ) ; \nvalue = container . getValue ( name ) ; \nfoundName = name ; \n} \n} \nif ( ! ( foundName == null ) ) return value ; \nelse throw new SkipException ( ) ; \n} \n} \n"}
{"4092": "public class AbstractOpenRtbJsonWriter { \n@ SuppressWarnings ( \"unchecked\" ) protected final < EM extends ExtendableMessage < EM > > void writeExtensions ( EM msg , JsonGenerator gen ) throws IOException { \nboolean openExt = false ; \nfor ( Map . Entry < FieldDescriptor , Object > field : msg . getAllFields ( ) . entrySet ( ) ) { \nFieldDescriptor fd = field . getKey ( ) ; \nif ( fd . isExtension ( ) ) { \nif ( ! ( fd . isRepeated ( ) ) ) { \nObject extValue = field . getValue ( ) ; \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeSingle ( extValue , gen ) ; \n} \n} \nelse { \nList < Object > extValue = ( List < Object > ) field . getValue ( ) ; \nif ( ! extValue . isEmpty ( ) ) { \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . get ( 0 ) . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeRepeated ( extValue , gen ) ; \n} \n} \n} \n} \n} \nif ( openExt ) { \ngen . writeEndObject ( ) ; \n} \n} \n} \n"}
{"4093": "public class AbstractOpenRtbJsonWriter { \nprotected final boolean writeContentCategory ( String cat , JsonGenerator gen ) throws IOException { \nif ( ! ( ! factory . isStrict ( ) || OpenRtbUtils . categoryFromName ( cat ) != null ) ) { \nreturn false ; \n} \nelse { \ngen . writeString ( cat ) ; \nreturn true ; \n} \n} \n} \n"}
{"4095": "public class SnippetProcessor { \npublic String process ( SnippetProcessorContext ctx , String snippet ) { \ncheckNotNull ( ctx ) ; \nStringBuilder sb = ctx . builder ( ) ; \nsb . setLength ( 0 ) ; \nString currSnippet = snippet ; \nboolean processedMacros = false ; \nint snippetPos = 0 ; \nint macroPos = currSnippet . indexOf ( \"${\" ) ; \nwhile ( macroPos != - 1 ) { \nsb . append ( currSnippet . substring ( snippetPos , macroPos ) ) ; \nint macroEnd = processMacroAt ( ctx , currSnippet , macroPos ) ; \nif ( ! ( macroEnd == - 1 ) ) { \nsnippetPos = macroEnd ; \nprocessedMacros = true ; \n} \nelse { \nsb . append ( \"${\" ) ; \nsnippetPos = macroPos + 2 ; \n} \nmacroPos = currSnippet . indexOf ( \"${\" , snippetPos ) ; \n} \nif ( processedMacros ) { \nsb . append ( currSnippet , snippetPos , currSnippet . length ( ) ) ; \ncurrSnippet = sb . toString ( ) ; \n} \nsb . setLength ( 0 ) ; \nString ret = urlEncode ( ctx , currSnippet ) ; \nsb . setLength ( 0 ) ; \nreturn ret ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( ! ( imps . isEmpty ( ) || impFilter == IMP_ALL ) ) if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nelse { \nreturn imps ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \n++ i ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4101": "public class AbstractOpenRtbJsonReader { \nprotected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { \n@ SuppressWarnings ( \"unchecked\" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; \nif ( extReaders . isEmpty ( ) ) { \npar . skipChildren ( ) ; \nreturn ; \n} \nstartObject ( par ) ; \nJsonToken tokLast = par . getCurrentToken ( ) ; \nJsonLocation locLast = par . getCurrentLocation ( ) ; \nwhile ( true ) { \nboolean extRead = false ; \nfor ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { \nif ( extReader . filter ( par ) ) { \nextReader . read ( msg , par ) ; \nJsonToken tokNew = par . getCurrentToken ( ) ; \nJsonLocation locNew = par . getCurrentLocation ( ) ; \nboolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; \nextRead |= advanced ; \nif ( ! ( ! endObject ( par ) ) ) if ( ! ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) ) { \ntokLast = tokNew ; \nlocLast = locNew ; \n} \nelse { \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nif ( ! extRead ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Extension field not consumed by any reader, skipping: {} @{}:{}\" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; \n} \npar . nextToken ( ) ; \npar . skipChildren ( ) ; \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \n} \n} \n} \n"}
{"4110": "public class OpenRtbJsonUtils { \npublic static void startObject ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( ! ( token == JsonToken . START_OBJECT ) ) { \nthrow new JsonParseException ( par , \"Expected start of object\" ) ; \n} \nelse { \npar . nextToken ( ) ; \n} \n} \n} \n"}
{"4111": "public class OpenRtbJsonUtils { \npublic static void startArray ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( ! ( token == JsonToken . START_ARRAY ) ) { \nthrow new JsonParseException ( par , \"Expected start of array\" ) ; \n} \nelse { \npar . nextToken ( ) ; \n} \n} \n} \n"}
{"4123": "public class ConfUtils { \npublic static List < String > loadListFromConf ( String paramKey , Map stormConf ) { \nObject obj = stormConf . get ( paramKey ) ; \nList < String > list = new LinkedList < > ( ) ; \nif ( obj == null ) return list ; \nif ( ! ( obj instanceof PersistentVector ) ) { \nlist . add ( obj . toString ( ) ) ; \n} \nelse { \nlist . addAll ( ( PersistentVector ) obj ) ; \n} \nreturn list ; \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( ! ( query == null ) ) { \nquery += \"&\" + params ; \n} \nelse { \nquery = params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( ! ( queryElementsToRemove . contains ( param . getName ( ) ) ) ) if ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \nelse { \npairsIterator . remove ( ) ; \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4149": "public class GzipHdfsBolt { \npublic GzipHdfsBolt addRecordFormat ( RecordFormat format , int position ) { \nMultipleRecordFormat formats ; \nif ( ! ( this . format == null ) ) { \nif ( ! ( this . format instanceof MultipleRecordFormat ) ) { \nformats = new MultipleRecordFormat ( this . format ) ; \nthis . format = formats ; \n} \nelse { \nformats = ( MultipleRecordFormat ) this . format ; \n} \nformats . addFormat ( new GzippedRecordFormat ( format ) , position ) ; \n} \nelse { \nformats = new MultipleRecordFormat ( format ) ; \nthis . format = formats ; \n} \nreturn this ; \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( ! ( null != currentNode ) ) if ( ! ( null != m_docFrag ) ) { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( ! ( type == Node . TEXT_NODE ) ) if ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \nelse { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \nok = false ; \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \nelse { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \ncurrentNode . appendChild ( newNode ) ; \n} \n} \n} \n"}
{"4157": "public class DOMBuilder { \npublic void cdata ( char ch [ ] , int start , int length ) { \nif ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) { \nreturn ; \n} \nString s = new String ( ch , start , length ) ; \nNode n = m_currentNode . getLastChild ( ) ; \nif ( ! ( n instanceof CDATASection ) ) if ( n instanceof Comment ) { \n( ( Comment ) n ) . appendData ( s ) ; \n} \nelse { \n( ( CDATASection ) n ) . appendData ( s ) ; \n} \n} \n} \n"}
{"4160": "public class AbstractIndexerBolt { \nprotected String valueForURL ( Tuple tuple ) { \nString url = tuple . getStringByField ( \"url\" ) ; \nMetadata metadata = ( Metadata ) tuple . getValueByField ( \"metadata\" ) ; \nif ( StringUtils . isBlank ( canonicalMetadataParamName ) ) { \nreturn url ; \n} \nString canonicalValue = metadata . getFirstValue ( canonicalMetadataName ) ; \nif ( StringUtils . isBlank ( canonicalValue ) ) { \nreturn url ; \n} \ntry { \nURL sURL = new URL ( url ) ; \nURL canonical = URLUtil . resolveURL ( sURL , canonicalValue ) ; \nString sDomain = PaidLevelDomain . getPLD ( sURL . getHost ( ) ) ; \nString canonicalDomain = PaidLevelDomain . getPLD ( canonical . getHost ( ) ) ; \nif ( ! ( sDomain . equalsIgnoreCase ( canonicalDomain ) ) ) { \nLOG . info ( \"Canonical URL references a different domain, ignoring in {} \" , url ) ; \n} \nelse { \nreturn canonical . toExternalForm ( ) ; \n} \n} \ncatch ( MalformedURLException e ) { \nLOG . error ( \"Malformed canonical URL {} was found in {} \" , canonicalValue , url ) ; \n} \nreturn url ; \n} \n} \n"}
{"4165": "public class WheelView { \npublic static int resolveSizeAndState ( int size , int measureSpec ) { \nint result = size ; \nint specMode = MeasureSpec . getMode ( measureSpec ) ; \nint specSize = MeasureSpec . getSize ( measureSpec ) ; \nswitch ( specMode ) { \ncase MeasureSpec . UNSPECIFIED : result = size ; \nbreak ; \ncase MeasureSpec . AT_MOST : if ( ! ( specSize < size ) ) { \nresult = size ; \n} \nelse { \nresult = specSize ; \n} \nbreak ; \ncase MeasureSpec . EXACTLY : result = specSize ; \nbreak ; \n} \nreturn result ; \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( ! ( vel > 0f ) ) if ( vel < 0f ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; \n} \nelse { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; \n} \nif ( ! ( mAngularVelocity != 0f ) ) { \nmRequiresUpdate = false ; \n} \nelse { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \n} \n} \n"}
{"4173": "public class Circle { \nstatic int clamp ( int value , int upperLimit ) { \nif ( ! ( value < 0 ) ) { \nreturn value % upperLimit ; \n} \nelse { \nreturn value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; \n} \n} \n} \n"}
{"4188": "public class UnitName { \nprotected String makePlural ( final String name ) { \nString plural ; \nfinal int length = name . length ( ) ; \nfinal char lastChar = name . charAt ( length - 1 ) ; \nif ( ! ( lastChar != 'y' ) ) { \nif ( ! ( length == 1 ) ) { \nfinal char penultimateChar = name . charAt ( length - 2 ) ; \nplural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + \"s\" : name . substring ( 0 , length - 1 ) + \"ies\" ; \n} \nelse { \nplural = name + \"s\" ; \n} \n} \nelse { \nplural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( \"ch\" ) ? \"es\" : \"s\" ) ; \n} \nreturn plural ; \n} \n} \n"}
{"4193": "public class DateRange { \npublic void setStart ( DateType start ) { \nthis . start = start ; \nuseStart = true ; \nif ( ! ( useEnd ) ) { \nthis . isMoving = this . start . isPresent ( ) ; \nthis . end = this . start . add ( duration ) ; \n} \nelse { \nthis . isMoving = this . start . isPresent ( ) || this . end . isPresent ( ) ; \nuseDuration = false ; \nrecalcDuration ( ) ; \n} \ncheckIfEmpty ( ) ; \n} \n} \n"}
{"4194": "public class DateRange { \npublic void setEnd ( DateType end ) { \nthis . end = end ; \nuseEnd = true ; \nif ( ! ( useStart ) ) { \nthis . isMoving = this . end . isPresent ( ) ; \nthis . start = this . end . subtract ( duration ) ; \n} \nelse { \nthis . isMoving = this . start . isPresent ( ) || this . end . isPresent ( ) ; \nuseDuration = false ; \nrecalcDuration ( ) ; \n} \ncheckIfEmpty ( ) ; \n} \n} \n"}
{"4195": "public class DateRange { \npublic void setDuration ( TimeDuration duration ) { \nthis . duration = duration ; \nuseDuration = true ; \nif ( ! ( useStart ) ) { \nthis . isMoving = this . end . isPresent ( ) ; \nthis . start = this . end . subtract ( duration ) ; \n} \nelse { \nthis . isMoving = this . start . isPresent ( ) ; \nthis . end = this . start . add ( duration ) ; \nuseEnd = false ; \n} \ncheckIfEmpty ( ) ; \n} \n} \n"}
{"4196": "public class DateRange { \nprivate void recalcDuration ( ) { \nlong min = getStart ( ) . getDate ( ) . getTime ( ) ; \nlong max = getEnd ( ) . getDate ( ) . getTime ( ) ; \ndouble secs = .001 * ( max - min ) ; \nif ( secs < 0 ) secs = 0 ; \nif ( duration == null ) { \ntry { \nduration = new TimeDuration ( chooseResolution ( secs ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( ! ( resolution == null ) ) { \ndouble resSecs = resolution . getValueInSeconds ( ) ; \ndouble closest = Math . round ( secs / resSecs ) ; \nsecs = closest * resSecs ; \nduration . setValueInSeconds ( secs ) ; \n} \nelse { \nduration . setValueInSeconds ( secs ) ; \n} \nhashCode = 0 ; \n} \n} \n"}
{"4205": "public class CatalogWatcher { \npublic void register ( Path dir ) throws IOException { \nif ( ! enable ) return ; \nWatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; \nif ( trace ) { \nPath prev = keys . get ( key ) ; \nif ( ! ( prev == null ) ) { \nif ( ! dir . equals ( prev ) ) { \nSystem . out . format ( \"update: %s -> %s%n\" , prev , dir ) ; \n} \n} \nelse { \nSystem . out . format ( \"CatalogWatcher register: %s%n\" , dir ) ; \n} \n} \nkeys . put ( key , dir ) ; \n} \n} \n"}
{"4208": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( ! ( location . startsWith ( DataFactory . SCHEME ) ) ) if ( ! ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) ) if ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { \nString spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; \nMFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; \nreturn CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; \n} \nelse { \nOptional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; \nif ( opt . isPresent ( ) ) return opt . get ( ) ; \nerrlog . format ( \"%s\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse { \nDataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; \nerrlog . format ( \"%s\" , result . errLog ) ; \nif ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { \nerrlog . format ( \"wanted %s but dataset is of type %s%n\" , wantFeatureType , result . featureType ) ; \nresult . close ( ) ; \nreturn null ; \n} \nreturn result . featureDataset ; \n} \nDatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; \nif ( durl . serviceType == null ) { \nOptional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; \nif ( ! ( opt . isPresent ( ) ) ) if ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) && ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { \nerrlog . format ( \"%s%n\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse { \nreturn opt . get ( ) ; \n} \n} \nNetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; \nFeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; \nif ( fd == null ) ncd . close ( ) ; \nreturn fd ; \n} \n} \n"}
{"4216": "public class CatalogManager { \nprivate Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { \nboolean isLatest = path . endsWith ( \"/latest.xml\" ) ; \nint pos = path . lastIndexOf ( \"/\" ) ; \nString workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; \nString filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; \nif ( match == null ) return null ; \nif ( match . dataRoot . getFeatureCollection ( ) != null ) { \nInvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; \nif ( ! ( isLatest ) ) return fc . makeCatalog ( match . remaining , path , baseURI ) ; \nelse return fc . makeLatest ( match . remaining , path , baseURI ) ; \n} \nDatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; \nif ( dscan != null ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat ; \nif ( ! ( isLatest ) ) cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; \nelse cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nCatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; \nif ( catScan != null ) { \nif ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) { \nreturn catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; \n} \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nlog . warn ( \"makeDynamicCatalog() failed for =\" + workPath + \" request path= \" + path ) ; \nreturn null ; \n} \n} \n"}
{"4218": "public class HttpClientManager { \nstatic public void init ( CredentialsProvider provider , String userAgent ) { \nif ( provider != null ) try { \nHTTPSession . setGlobalCredentialsProvider ( provider ) ; \n} \ncatch ( HTTPException e ) { \nthrow new IllegalArgumentException ( e ) ; \n} \nif ( ! ( userAgent != null ) ) HTTPSession . setGlobalUserAgent ( \"NetcdfJava/HttpClient\" ) ; \nelse HTTPSession . setGlobalUserAgent ( userAgent + \"/NetcdfJava/HttpClient\" ) ; \n} \n} \n"}
{"4228": "public class NOWRadheader { \nint readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nif ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) { \nreturn 0 ; \n} \nString pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; \nif ( ! ( pidd . contains ( \"NOWRA\" ) || pidd . contains ( \"USRAD\" ) || pidd . contains ( \"NEX\" ) ) ) { \nreturn 0 ; \n} \nelse { \nreturn 1 ; \n} \n} \n} \n"}
{"4230": "public class NOWRadheader { \npublic static int bytesToInt ( byte [ ] bytes , boolean swapBytes ) { \nbyte a = bytes [ 0 ] ; \nbyte b = bytes [ 1 ] ; \nbyte c = bytes [ 2 ] ; \nbyte d = bytes [ 3 ] ; \nif ( ! ( swapBytes ) ) { \nreturn ( ( a & 0xff ) << 24 ) + ( ( b & 0xff ) << 16 ) + ( ( c & 0xff ) << 8 ) + ( ( d & 0xff ) ) ; \n} \nelse { \nreturn ( ( a & 0xff ) ) + ( ( b & 0xff ) << 8 ) + ( ( c & 0xff ) << 16 ) + ( ( d & 0xff ) << 24 ) ; \n} \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \nfor ( int pos = 1 ; \npos < sb . length ( ) ; \n++ pos ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( ! ( cp <= 0x7f && Character . isWhitespace ( cp ) ) ) { \nbreak ; \n} \nelse { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) System . out . println ( \" read record \" + recnum ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( ! ( recnum != header . numrecs - 1 ) ) raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4245": "public class McIDASLookup { \npublic final String getLevelName ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) return result ; \n} \nString levelUnit = getLevelUnit ( gr ) ; \nif ( levelUnit != null ) { \nint level1 = ( int ) gr . getLevel1 ( ) ; \nint level2 = ( int ) gr . getLevel2 ( ) ; \nif ( ! ( levelUnit . equalsIgnoreCase ( \"hPa\" ) ) ) if ( ! ( level1 == 1013 ) ) if ( ! ( level1 == 0 ) ) if ( ! ( level1 == 1001 ) ) if ( level2 != 0 ) { \nreturn \"layer\" ; \n} \nelse { \nreturn \"surface\" ; \n} \nelse { \nreturn \"tropopause\" ; \n} \nelse { \nreturn \"mean sea level\" ; \n} \nelse { \nreturn \"pressure\" ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nint type = gr . getLevelType1 ( ) ; \nif ( ! ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) ) if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \nreturn true ; \n} \nelse { \nif ( type == 20 ) { \nreturn true ; \n} \nif ( type == 100 ) { \nreturn true ; \n} \nif ( type == 101 ) { \nreturn true ; \n} \nif ( ( type >= 103 ) && ( type <= 128 ) ) { \nreturn true ; \n} \nif ( type == 141 ) { \nreturn true ; \n} \nif ( type == 160 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4251": "public class CoordTransBuilder { \nstatic public CoordinateTransform makeCoordinateTransform ( NetcdfDataset ds , AttributeContainer ctv , Formatter parseInfo , Formatter errInfo ) { \nString transform_name = ctv . findAttValueIgnoreCase ( \"transform_name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( \"Projection_Name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . GRID_MAPPING_NAME , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . STANDARD_NAME , null ) ; \nif ( null == transform_name ) { \nparseInfo . format ( \"**Failed to find Coordinate Transform name from Variable= %s%n\" , ctv ) ; \nreturn null ; \n} \ntransform_name = transform_name . trim ( ) ; \nClass builderClass = null ; \nfor ( Transform transform : transformList ) { \nif ( transform . transName . equals ( transform_name ) ) { \nbuilderClass = transform . transClass ; \nbreak ; \n} \n} \nif ( null == builderClass ) { \nparseInfo . format ( \"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\" , transform_name , ctv ) ; \nreturn null ; \n} \nObject builderObject ; \ntry { \nbuilderObject = builderClass . newInstance ( ) ; \n} \ncatch ( InstantiationException | IllegalAccessException e ) { \nlog . error ( \"Cant create new instance \" + builderClass . getName ( ) , e ) ; \nreturn null ; \n} \nif ( null == builderObject ) { \nparseInfo . format ( \"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\" , builderClass . getName ( ) , ctv ) ; \nreturn null ; \n} \nCoordinateTransform ct ; \nif ( ! ( builderObject instanceof VertTransformBuilderIF ) ) if ( ! ( builderObject instanceof HorizTransformBuilderIF ) ) { \nlog . error ( \"Illegals class \" + builderClass . getName ( ) ) ; \nreturn null ; \n} \nelse { \nHorizTransformBuilderIF horizBuilder = ( HorizTransformBuilderIF ) builderObject ; \nhorizBuilder . setErrorBuffer ( errInfo ) ; \nString units = AbstractTransformBuilder . getGeoCoordinateUnits ( ds , ctv ) ; \nct = horizBuilder . makeCoordinateTransform ( ctv , units ) ; \n} \nelse { \nVertTransformBuilderIF vertBuilder = ( VertTransformBuilderIF ) builderObject ; \nvertBuilder . setErrorBuffer ( errInfo ) ; \nct = vertBuilder . makeCoordinateTransform ( ds , ctv ) ; \n} \nif ( ct != null ) { \nparseInfo . format ( \" Made Coordinate transform %s from variable %s: %s%n\" , transform_name , ctv . getName ( ) , builderObject . getClass ( ) . getName ( ) ) ; \n} \nreturn ct ; \n} \n} \n"}
{"4252": "public class CoordTransBuilder { \nstatic public VariableDS makeDummyTransformVariable ( NetcdfDataset ds , CoordinateTransform ct ) { \nVariableDS v = new VariableDS ( ds , null , null , ct . getName ( ) , DataType . CHAR , \"\" , null , null ) ; \nList < Parameter > params = ct . getParameters ( ) ; \nfor ( Parameter p : params ) { \nif ( ! ( p . isString ( ) ) ) { \ndouble [ ] data = p . getNumericValues ( ) ; \nArray dataA = Array . factory ( DataType . DOUBLE , new int [ ] { \ndata . length } \n, data ) ; \nv . addAttribute ( new Attribute ( p . getName ( ) , dataA ) ) ; \n} \nelse v . addAttribute ( new Attribute ( p . getName ( ) , p . getStringValue ( ) ) ) ; \n} \nv . addAttribute ( new Attribute ( _Coordinate . TransformType , ct . getTransformType ( ) . toString ( ) ) ) ; \nArray data = Array . factory ( DataType . CHAR , new int [ ] { \n} \n, new char [ ] { \n' ' } \n) ; \nv . setCachedData ( data , true ) ; \nreturn v ; \n} \n} \n"}
{"4269": "public class WFSGetCapabilitiesWriter { \nprivate void writeAConstraint ( String name , boolean isImplemented ) { \nString defValue ; \nif ( ! ( isImplemented ) ) defValue = \"FALSE\" ; \nelse defValue = \"TRUE\" ; \nfileOutput += \"<ows:Constraint name=\\\"\" + name + \"\\\"> \" + \"<ows:NoValues/> \" + \"<ows:DefaultValue>\" + defValue + \"</ows:DefaultValue> \" + \"</ows:Constraint>\" ; \n} \n} \n"}
{"4272": "public class LogReader { \npublic void readAll ( File dir , FileFilter ff , Closure closure , LogFilter logf , Stats stat ) throws IOException { \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nSystem . out . printf ( \"Dir has no files= %s%n\" , dir ) ; \nreturn ; \n} \nList < File > list = Arrays . asList ( files ) ; \nCollections . sort ( list ) ; \nfor ( File f : list ) { \nif ( ( ff != null ) && ! ff . accept ( f ) ) continue ; \nif ( ! ( f . isDirectory ( ) ) ) scanLogFile ( f , closure , logf , stat ) ; \nelse readAll ( f , ff , closure , logf , stat ) ; \n} \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( ! ( length <= ilenhd ) ) if ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nelse { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4276": "public class GempakGridReader { \npublic float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { \nfloat [ ] data ; \nint ipktyp = DM_RINT ( isword ) ; \nint iiword = isword + 1 ; \nint lendat = nword - 1 ; \nif ( ipktyp == MDGNON ) { \ndata = new float [ lendat ] ; \nDM_RFLT ( iiword , data ) ; \nreturn data ; \n} \nint iiw ; \nint irw ; \nif ( ! ( ipktyp == MDGDIF ) ) if ( ! ( ipktyp == MDGRB2 ) ) { \niiw = 3 ; \nirw = 2 ; \n} \nelse { \niiw = 4 ; \nirw = 1 ; \n} \nelse { \niiw = 4 ; \nirw = 3 ; \n} \nint [ ] iarray = new int [ iiw ] ; \nfloat [ ] rarray = new float [ irw ] ; \nDM_RINT ( iiword , iarray ) ; \niiword = iiword + iiw ; \nlendat = lendat - iiw ; \nDM_RFLT ( iiword , rarray ) ; \niiword = iiword + irw ; \nlendat = lendat - irw ; \nif ( ipktyp == MDGRB2 ) { \ndata = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; \nreturn data ; \n} \nint nbits = iarray [ 0 ] ; \nint misflg = iarray [ 1 ] ; \nboolean miss = misflg != 0 ; \nint kxky = iarray [ 2 ] ; \nint kx = 0 ; \nif ( iiw == 4 ) { \nkx = iarray [ 3 ] ; \n} \nfloat ref = rarray [ 0 ] ; \nfloat scale = rarray [ 1 ] ; \nfloat difmin = 0 ; \nif ( irw == 3 ) { \ndifmin = rarray [ 2 ] ; \n} \ndata = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; \nreturn data ; \n} \n} \n"}
{"4277": "public class GempakGridReader { \nprivate synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { \nif ( ! ( ipktyp == MDGGRB ) ) if ( ! ( ipktyp == MDGNMC ) ) if ( ipktyp == MDGDIF ) { \nreturn null ; \n} \nelse { \nreturn null ; \n} \nelse { \nif ( ! ( ! useDP ) ) { \nif ( nword * 32 < kxky * nbits ) { \nnword ++ ; \n} \nint [ ] ksgrid = new int [ nword ] ; \nDM_RINT ( iiword , ksgrid ) ; \nreturn DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \nelse { \nreturn unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \ni < kxky ; \ni ++ ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ! ( ( idat == imax ) && misflg ) ) { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nelse { \ngrid [ i ] = RMISSD ; \n} \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nint idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni ++ ) { \nidat = bits2UInt ( nbits ) ; \nif ( ! ( miss && ( idat == IMISSD ) ) ) { \nvalues [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \nelse { \nvalues [ i ] = IMISSD ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4282": "public class GempakGridReader { \nprivate void getNextByte ( ) throws IOException { \nif ( ! ( ! needToSwap ) ) { \nif ( ! ( next == 3 ) ) if ( ! ( next == 2 ) ) if ( ! ( next == 1 ) ) { \nch1 = rf . read ( ) ; \nch2 = rf . read ( ) ; \nch3 = rf . read ( ) ; \nch4 = rf . read ( ) ; \nbitBuf = ch4 ; \nnext = 4 ; \n} \nelse { \nbitBuf = ch1 ; \n} \nelse { \nbitBuf = ch2 ; \n} \nelse { \nbitBuf = ch3 ; \n} \nnext -- ; \n} \nelse { \nbitBuf = rf . read ( ) ; \n} \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nint c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( ! ( c < ' ' ) ) buf . append ( ( char ) c ) ; \nelse buf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \nbreak ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4293": "public class CDMUtil { \nstatic public NetcdfFile unwrapfile ( NetcdfFile file ) { \nfor ( ; \n; \n) { \nif ( ! ( file instanceof NetcdfDataset ) ) break ; \nelse { \nNetcdfDataset ds = ( NetcdfDataset ) file ; \nfile = ds . getReferencedFile ( ) ; \nif ( file == null ) break ; \n} \n} \nreturn file ; \n} \n} \n"}
{"4305": "public class GribDataReader { \npublic Array readData ( SectionIterable want ) throws IOException , InvalidRangeException { \nif ( ! ( vindex instanceof PartitionCollectionImmutable . VariableIndexPartitioned ) ) return readDataFromCollection ( vindex , want ) ; \nelse return readDataFromPartition ( ( PartitionCollectionImmutable . VariableIndexPartitioned ) vindex , want ) ; \n} \n} \n"}
{"4306": "public class GribDataReader { \npublic Array readData2 ( CoordsSet want , RangeIterator yRange , RangeIterator xRange ) throws IOException { \nif ( ! ( vindex instanceof PartitionCollectionImmutable . VariableIndexPartitioned ) ) return readDataFromCollection2 ( vindex , want , yRange , xRange ) ; \nelse return readDataFromPartition2 ( ( PartitionCollectionImmutable . VariableIndexPartitioned ) vindex , want , yRange , xRange ) ; \n} \n} \n"}
{"4319": "public class CalendarDateUnit { \npublic double makeOffsetFromRefDate ( CalendarDate date ) { \nif ( ! ( isCalendarField ) ) { \nlong msecs = date . getDifferenceInMsecs ( baseDate ) ; \nreturn msecs / period . getValueInMillisecs ( ) ; \n} \nelse { \nif ( date . equals ( baseDate ) ) return 0.0 ; \nreturn date . getDifference ( baseDate , periodField ) ; \n} \n} \n} \n"}
{"4320": "public class CalendarDateUnit { \npublic CalendarDate makeCalendarDate ( double value ) { \nif ( ! ( isCalendarField ) ) return baseDate . add ( value , periodField ) ; \nelse return baseDate . add ( CalendarPeriod . of ( ( int ) value , periodField ) ) ; \n} \n} \n"}
{"4324": "public class SigmetIOServiceProvider { \npublic Array readData1 ( ucar . nc2 . Variable v2 , Section section ) throws IOException , InvalidRangeException { \nint [ ] sh = section . getShape ( ) ; \nArray temp = Array . factory ( v2 . getDataType ( ) , sh ) ; \nlong pos0 = 0 ; \nLayoutRegular index = new LayoutRegular ( pos0 , v2 . getElementSize ( ) , v2 . getShape ( ) , section ) ; \nif ( ! ( v2 . getShortName ( ) . startsWith ( \"time\" ) | v2 . getShortName ( ) . startsWith ( \"numGates\" ) ) ) { \ntemp = readFloatData ( index , v2 ) ; \n} \nelse { \ntemp = readIntData ( index , v2 ) ; \n} \nreturn temp ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \nSystem . out . println ( \"COUNT=\" + count ) ; \nif ( ! ( buffer . hasRemaining ( ) ) ) { \nbuffer . clear ( ) ; \n} \nelse { \nbuffer . compact ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4337": "public class DtCoverageCS { \npublic LatLonRect getLatLonBoundingBox ( ) { \nif ( llbb == null ) { \nif ( ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) && ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) ) { \nreturn null ; \n} \nCoordinateAxis horizXaxis = getXHorizAxis ( ) ; \nCoordinateAxis horizYaxis = getYHorizAxis ( ) ; \nif ( ! ( isLatLon ( ) ) ) { \nProjectionImpl dataProjection = getProjection ( ) ; \nProjectionRect bb = getBoundingBox ( ) ; \nif ( bb != null ) llbb = dataProjection . projToLatLonBB ( bb ) ; \n} \nelse { \ndouble startLat = horizYaxis . getMinValue ( ) ; \ndouble startLon = horizXaxis . getMinValue ( ) ; \ndouble deltaLat = horizYaxis . getMaxValue ( ) - startLat ; \ndouble deltaLon = horizXaxis . getMaxValue ( ) - startLon ; \nLatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; \nllbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; \n} \n} \nreturn llbb ; \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( ! ( tabStop > len ) ) if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \nelse { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ni < tabStop ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( s . length ( ) >= width ) { \nreturn s ; \n} \nStringBuilder sbuff = new StringBuilder ( width ) ; \nint need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \nfor ( int i = 0 ; \ni < need ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \nif ( ! ( rightJustify ) ) { \nsbuff . insert ( 0 , s ) ; \n} \nelse { \nsbuff . append ( s ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4343": "public class Format { \npublic static String formatByteSize ( double size ) { \nString unit = null ; \nif ( ! ( size > 1.0e15 ) ) if ( ! ( size > 1.0e12 ) ) if ( ! ( size > 1.0e9 ) ) if ( ! ( size > 1.0e6 ) ) if ( ! ( size > 1.0e3 ) ) { \nunit = \"bytes\" ; \n} \nelse { \nunit = \"Kbytes\" ; \nsize *= 1.0e-3 ; \n} \nelse { \nunit = \"Mbytes\" ; \nsize *= 1.0e-6 ; \n} \nelse { \nunit = \"Gbytes\" ; \nsize *= 1.0e-9 ; \n} \nelse { \nunit = \"Tbytes\" ; \nsize *= 1.0e-12 ; \n} \nelse { \nunit = \"Pbytes\" ; \nsize *= 1.0e-15 ; \n} \nreturn Format . d ( size , 4 ) + \" \" + unit ; \n} \n} \n"}
{"4348": "public class Slice { \npublic String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nif ( ! ( ( this . stop - this . first ) == 0 ) ) if ( ! ( this . stride == 1 ) ) return String . format ( \"[%d:%d:%d]\" , this . first , this . stride , this . stop - 1 ) ; \nelse { \nif ( ! ( ( this . stop - this . first ) == 1 ) ) return String . format ( \"[%d:%d]\" , this . first , this . stop - 1 ) ; \nelse return String . format ( \"[%d]\" , this . first ) ; \n} \nelse { \nreturn String . format ( \"[0]\" ) ; \n} \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( ! ( c == '\\r' ) ) if ( ! ( c == '\\n' ) ) if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nelse s = \"\\\\n\" ; \nelse s = \"\\\\r\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4373": "public class GridHorizCoordSys { \nprivate double getGridSpacingInKm ( String type ) { \ndouble value = gds . getDouble ( type ) ; \nif ( Double . isNaN ( value ) ) return value ; \nString gridUnit = gds . getParam ( GridDefRecord . GRID_UNITS ) ; \nSimpleUnit unit ; \nif ( ! ( gridUnit == null || gridUnit . length ( ) == 0 ) ) { \nunit = SimpleUnit . factory ( gridUnit ) ; \n} \nelse { \nunit = SimpleUnit . meterUnit ; \n} \nif ( unit != null && SimpleUnit . isCompatible ( unit . getUnitString ( ) , \"km\" ) ) { \nvalue = unit . convertTo ( value , SimpleUnit . kmUnit ) ; \n} \nreturn value ; \n} \n} \n"}
{"4374": "public class GridHorizCoordSys { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile ) { \nif ( ! ( isLatLon ) ) { \nncfile . addDimension ( g , new Dimension ( \"y\" , gds . getInt ( GridDefRecord . NY ) , true ) ) ; \nncfile . addDimension ( g , new Dimension ( \"x\" , gds . getInt ( GridDefRecord . NX ) , true ) ) ; \n} \nelse { \nncfile . addDimension ( g , new Dimension ( \"lat\" , gds . getInt ( GridDefRecord . NY ) , true ) ) ; \nncfile . addDimension ( g , new Dimension ( \"lon\" , gds . getInt ( GridDefRecord . NX ) , true ) ) ; \n} \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) radius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \nif ( ! ( ! Double . isNaN ( radius_spherical_earth ) ) ) { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \nif ( ! Double . isNaN ( major_axis ) && ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \nelse { \nif ( radius_spherical_earth < 10000.00 ) radius_spherical_earth *= 1000.0 ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn true ; \n} \n} \n"}
{"4377": "public class GridHorizCoordSys { \nprivate void addGDSparams ( Variable v ) { \nList < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; \nCollections . sort ( keyList ) ; \nString pre = getGDSprefix ( ) ; \nfor ( String key : keyList ) { \nString name = pre + \"_param_\" + key ; \nString vals = gds . getParam ( key ) ; \ntry { \nint vali = Integer . parseInt ( vals ) ; \nif ( ! ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) ) { \nv . addAttribute ( new Attribute ( name , vali ) ) ; \n} \nelse { \nString cf = GridCF . VectorComponentFlag . of ( vali ) ; \nv . addAttribute ( new Attribute ( name , cf ) ) ; \n} \n} \ncatch ( Exception e ) { \ntry { \ndouble vald = Double . parseDouble ( vals ) ; \nv . addAttribute ( new Attribute ( name , vald ) ) ; \n} \ncatch ( Exception e2 ) { \nv . addAttribute ( new Attribute ( name , vals ) ) ; \n} \n} \n} \n} \n} \n"}
{"4378": "public class GridHorizCoordSys { \nprivate void addCoordSystemVariable ( NetcdfFile ncfile , String name , String dims ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , new char [ ] { \n'0' } \n) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! ( isLatLon ( ) ) ) v . addAttribute ( new Attribute ( _Coordinate . Transforms , getGridName ( ) ) ) ; \nelse v . addAttribute ( new Attribute ( _Coordinate . Transforms , \"\" ) ) ; \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \n} \n} \n"}
{"4379": "public class GridHorizCoordSys { \nprivate void makeLC ( ) { \nproj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; \nLatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nif ( GridServiceProvider . debugProj ) { \nSystem . out . println ( \"GridHorizCoordSys.makeLC start at latlon \" + startLL ) ; \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeLC end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + getNx ( ) * getDxInKm ( ) ; \ndouble endy = starty + getNy ( ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"lambert_conformal_conic\" ) ) ; \nif ( ! ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) ) { \ndouble [ ] data = new double [ ] { \ngds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } \n; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { \n2 } \n, data ) ) ) ; \n} \nelse { \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( ! ( Double . isNaN ( lad ) ) ) { \nscale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \n} \nelse { \nscale = .933 ; \n} \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \nSystem . out . println ( \"   should be LA1=\" + gds . getDouble ( GridDefRecord . LA1 ) + \" l)1=\" + gds . getDouble ( GridDefRecord . LO1 ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( ! ( dy < 2100 ) ) { \ndx = 3622 ; \ndy = 3610 ; \n} \nelse { \ndx = 1207 ; \ndy = 1203 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( ! ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) ) { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) sortOrderIncreasing = true ; \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) addDatasetSize = false ; \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nint last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; \n} \nif ( scanDir != null ) { \nint last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) System . out . println ( \" Dataset added: \" + datasetScan . dump ( ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nelse { \nif ( ! ( dsElem . getAttributeValue ( \"location\" ) == null ) ) { \nreturn readDatasetScanNew ( catalog , parent , dsElem , base ) ; \n} \nelse { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4387": "public class McIDASGridRecord { \npublic int getLevelType1 ( ) { \nint gribLevel = getDirBlock ( ) [ 51 ] ; \nint levelType = 0 ; \nif ( ! ( ! ( ( gribLevel == McIDASUtil . MCMISSING ) || ( gribLevel == 0 ) ) ) ) { \nlevelType = 1 ; \n} \nelse { \nlevelType = gribLevel ; \n} \nreturn levelType ; \n} \n} \n"}
{"4391": "public class UnidataPointDatasetHelper { \nstatic public String getCoordinateName ( NetcdfDataset ds , AxisType a ) { \nList < Variable > varList = ds . getVariables ( ) ; \nfor ( Variable v : varList ) { \nif ( ! ( v instanceof Structure ) ) { \nString axisType = ds . findAttValueIgnoreCase ( v , _Coordinate . AxisType , null ) ; \nif ( ( axisType != null ) && axisType . equals ( a . toString ( ) ) ) return v . getShortName ( ) ; \n} \nelse { \nList < Variable > vars = ( ( Structure ) v ) . getVariables ( ) ; \nfor ( Variable vs : vars ) { \nString axisType = ds . findAttValueIgnoreCase ( vs , _Coordinate . AxisType , null ) ; \nif ( ( axisType != null ) && axisType . equals ( a . toString ( ) ) ) return vs . getShortName ( ) ; \n} \n} \n} \nif ( a == AxisType . Lat ) return findVariableName ( ds , \"latitude\" ) ; \nif ( a == AxisType . Lon ) return findVariableName ( ds , \"longitude\" ) ; \nif ( a == AxisType . Time ) return findVariableName ( ds , \"time\" ) ; \nif ( a == AxisType . Height ) { \nVariable v = findVariable ( ds , \"altitude\" ) ; \nif ( null == v ) v = findVariable ( ds , \"depth\" ) ; \nif ( v != null ) return v . getShortName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4395": "public class AWIPSConvention { \nprivate List < Dimension > breakupLevels ( NetcdfDataset ds , Variable levelVar ) throws IOException { \nif ( debugBreakup ) parseInfo . format ( \"breakupLevels = %s%n\" , levelVar . getShortName ( ) ) ; \nList < Dimension > dimList = new ArrayList < > ( ) ; \nArrayChar levelVarData ; \ntry { \nlevelVarData = ( ArrayChar ) levelVar . read ( ) ; \n} \ncatch ( IOException ioe ) { \nreturn dimList ; \n} \nList < String > values = null ; \nString currentUnits = null ; \nArrayChar . StringIterator iter = levelVarData . getStringIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString s = iter . next ( ) ; \nif ( debugBreakup ) parseInfo . format ( \"   %s%n\" , s ) ; \nStringTokenizer stoke = new StringTokenizer ( s ) ; \nif ( ! stoke . hasMoreTokens ( ) ) continue ; \nString units = stoke . nextToken ( ) . trim ( ) ; \nif ( ! units . equals ( currentUnits ) ) { \nif ( values != null ) dimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \nvalues = new ArrayList < > ( ) ; \ncurrentUnits = units ; \n} \nif ( ! ( stoke . hasMoreTokens ( ) ) ) values . add ( \"0\" ) ; \nelse values . add ( stoke . nextToken ( ) ) ; \n} \nif ( values != null ) dimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \nif ( debugBreakup ) parseInfo . format ( \"  done breakup%n\" ) ; \nreturn dimList ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( ! ( len > 1 ) ) name = name + values . get ( 0 ) ; \nelse name = name + Integer . toString ( len ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nint count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4416": "public class ThreddsMetadata { \npublic void add ( ThreddsMetadata tmd , boolean includeInherited ) { \ncreators . addAll ( tmd . getCreators ( ) ) ; \ncontributors . addAll ( tmd . getContributors ( ) ) ; \ndates . addAll ( tmd . getDates ( ) ) ; \ndocs . addAll ( tmd . getDocumentation ( ) ) ; \nkeywords . addAll ( tmd . getKeywords ( ) ) ; \nprojects . addAll ( tmd . getProjects ( ) ) ; \nproperties . addAll ( tmd . getProperties ( ) ) ; \npublishers . addAll ( tmd . getPublishers ( ) ) ; \nvariables . addAll ( tmd . getVariables ( ) ) ; \nif ( ! ( includeInherited ) ) { \nfor ( InvMetadata mdata : tmd . getMetadata ( ) ) { \nif ( ! mdata . isInherited ( ) ) metadata . add ( mdata ) ; \n} \n} \nelse metadata . addAll ( tmd . getMetadata ( ) ) ; \nif ( gc == null ) gc = tmd . getGeospatialCoverage ( ) ; \nif ( timeCoverage == null ) timeCoverage = tmd . getTimeCoverage ( ) ; \nif ( serviceName == null ) serviceName = tmd . getServiceName ( ) ; \nif ( dataType == null ) dataType = tmd . getDataType ( ) ; \nif ( dataSize == 0.0 ) dataSize = tmd . getDataSize ( ) ; \nif ( dataFormat == null ) dataFormat = tmd . getDataFormatType ( ) ; \nif ( authorityName == null ) authorityName = tmd . getAuthority ( ) ; \nif ( variableMapLink == null ) variableMapLink = tmd . getVariableMap ( ) ; \n} \n} \n"}
{"4422": "public class CoordSysBuilder { \nstatic public List < String > breakupConventionNames ( String convAttValue ) { \nList < String > names = new ArrayList < > ( ) ; \nif ( ! ( ( convAttValue . indexOf ( ',' ) > 0 ) || ( convAttValue . indexOf ( ';' ) > 0 ) ) ) if ( ! ( ( convAttValue . indexOf ( '/' ) > 0 ) ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \" \" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \"/\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \",;\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nreturn names ; \n} \n} \n"}
{"4423": "public class CoordSysBuilder { \nstatic public String buildConventionAttribute ( String mainConv , String ... convAtts ) { \nList < String > result = new ArrayList < > ( ) ; \nresult . add ( mainConv ) ; \nfor ( String convs : convAtts ) { \nif ( convs == null ) continue ; \nList < String > ss = breakupConventionNames ( convs ) ; \nfor ( String s : ss ) { \nif ( matchConvention ( s ) == null ) result . add ( s ) ; \n} \n} \nboolean start = true ; \nFormatter f = new Formatter ( ) ; \nfor ( String s : result ) { \nif ( ! ( start ) ) f . format ( \", %s\" , s ) ; \nelse f . format ( \"%s\" , s ) ; \nstart = false ; \n} \nreturn f . toString ( ) ; \n} \n} \n"}
{"4426": "public class CoordSysBuilder { \nprotected void findCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordSys != null ) { \nStringTokenizer stoker = new StringTokenizer ( vp . coordSys ) ; \nwhile ( stoker . hasMoreTokens ( ) ) { \nString vname = stoker . nextToken ( ) ; \nVarProcess ap = findVarProcess ( vname , vp ) ; \nif ( ! ( ap != null ) ) { \nparseInfo . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nuserAdvice . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \n} \nelse { \nif ( ! ap . isCoordinateSystem ) parseInfo . format ( \" CoordinateSystem = %s added; referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nap . isCoordinateSystem = true ; \n} \n} \n} \n} \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) continue ; \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; \n} \nif ( axisList . size ( ) < 2 ) continue ; \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( ! ( requireCompleteCoordSys ) ) { \nokToBuild = true ; \n} \nelse { \nif ( cs != null ) { \nokToBuild = cs . isComplete ( ve ) ; \n} \n} \nif ( ! ( cs != null && okToBuild ) ) { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) { \nokToBuild = csnew . isComplete ( ve ) ; \n} \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \nelse { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return ; \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( ! ( nested . getMark ( ) ) ) delete ( nested ) ; \nelse { \niter . remove ( ) ; \nif ( debugFilter ) System . out . println ( \" remove \" + nested . getName ( ) ) ; \n} \n} \n} \n} \n"}
{"4435": "public class LoadCommon { \npublic void initOnce ( HttpServletRequest req ) throws SendError { \nif ( once ) return ; \nonce = true ; \nlog . info ( getClass ( ) . getName ( ) + \" GET initialization\" ) ; \nif ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , \"Cannot find TDS Context\" ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( req . getServerName ( ) ) ; \nint port = req . getServerPort ( ) ; \nif ( port > 0 ) { \nbuf . append ( \":\" ) ; \nbuf . append ( port ) ; \n} \nthis . server = buf . toString ( ) ; \nString tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; \nthis . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \ntmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; \nthis . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \nif ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; \nFile updir = tdsContext . getUploadDir ( ) ; \nif ( ! ( updir == null ) ) this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; \nelse { \nlog . warn ( \"No tds.upload.dir specified\" ) ; \nthis . uploaddir = null ; \n} \nFile downdir = tdsContext . getDownloadDir ( ) ; \nif ( ! ( downdir == null ) ) this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; \nelse { \nlog . warn ( \"No tds.download.dir specified\" ) ; \nthis . downloaddir = null ; \n} \n} \n} \n"}
{"4445": "public class DSPRegistry { \nsynchronized public void register ( Class < ? extends DSP > klass , boolean last ) { \nif ( registered ( klass ) ) return ; \nif ( ! ( last ) ) registry . add ( 0 , new Registration ( klass ) ) ; \nelse registry . add ( new Registration ( klass ) ) ; \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( ! ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) ) if ( ! ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) ) { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \nelse { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = 30.0 * 24.0 ; \n} \nreturn fac * range ; \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( ! ( this . ce == null ) ) { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( int i = 0 ; \ni < nodelist . size ( ) ; \ni ++ ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \n} \n} \nelse this . visiblenodes = nodelist ; \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4477": "public class PictureCache { \npublic static boolean stopBackgroundLoadingExcept ( URL exemptionURL ) { \nSourcePicture sp ; \nString exemptionURLString = exemptionURL . toString ( ) ; \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nboolean inProgress = false ; \nwhile ( e . hasMoreElements ( ) ) { \nsp = ( ( SourcePicture ) e . nextElement ( ) ) ; \nif ( ! ( ! sp . getUrlString ( ) . equals ( exemptionURLString ) ) ) { \nTools . log ( \"PictureCache.stopBackgroundLoading: picture was already loading\" ) ; \ninProgress = true ; \n} \nelse sp . stopLoading ( ) ; \n} \nreturn inProgress ; \n} \n} \n"}
{"4479": "public class HTTPFactory { \nstatic protected HTTPMethod makemethod ( HTTPSession . Methods m , HTTPSession session , String url ) throws HTTPException { \nHTTPMethod meth = null ; \nif ( ! ( MOCKMETHODCLASS == null ) ) { \njava . lang . Class methodcl = MOCKMETHODCLASS ; \nConstructor < HTTPMethod > cons = null ; \ntry { \ncons = methodcl . getConstructor ( HTTPSession . Methods . class , HTTPSession . class , String . class ) ; \n} \ncatch ( Exception e ) { \nthrow new HTTPException ( \"HTTPFactory: no proper HTTPMethod constructor available\" , e ) ; \n} \ntry { \nmeth = cons . newInstance ( m , session , url ) ; \n} \ncatch ( Exception e ) { \nthrow new HTTPException ( \"HTTPFactory: HTTPMethod constructor failed\" , e ) ; \n} \n} \nelse { \nmeth = new HTTPMethod ( m , session , url ) ; \n} \nreturn meth ; \n} \n} \n"}
{"4483": "public class RadarServerConfig { \nprivate static FileSystemProvider getProvider ( URI uri ) throws IOException { \nif ( ! ( fsproviders . containsKey ( uri . getScheme ( ) ) ) ) { \nFileSystem fs ; \ntry { \nfs = FileSystems . newFileSystem ( uri , new HashMap < String , Object > ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; \n} \ncatch ( FileSystemAlreadyExistsException e ) { \nfs = FileSystems . getFileSystem ( uri ) ; \n} \nfsproviders . put ( uri . getScheme ( ) , fs . provider ( ) ) ; \nreturn fs . provider ( ) ; \n} \nelse { \nreturn fsproviders . get ( uri . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4487": "public class MetarParseReport { \nprivate String cloud_hgt2_meters ( String height ) { \nif ( ! ( height . equals ( \"999\" ) ) ) { \nreturn Integer . toString ( 30 * Integer . parseInt ( height ) ) ; \n} \nelse { \nreturn \"30000\" ; \n} \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ! ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) ) if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \nelse System . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \nfor ( int idx = 0 ; \nidx < indices . length ; \nidx ++ ) { \nif ( indices [ idx ] >= tline . length ( ) ) { \ncontinue ; \n} \nif ( ! ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) ) { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( ! ( p . getName ( ) . contains ( \"(\" ) ) ) { \nparamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( int i = first ; \ni <= last ; \ni ++ ) { \nbuf . append ( \"\\\\d\" ) ; \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ! ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) ) { \ndescription = words [ 1 ] ; \n} \nelse { \ndescription = words [ 3 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( ! ( slashpos < 0 && dotpos < 0 ) ) if ( ! ( slashpos >= 0 && dotpos < 0 ) ) if ( ! ( slashpos < 0 && dotpos >= 0 ) ) { \nif ( ! ( slashpos > dotpos ) ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \n} \nelse { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . name = name ; \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) group = rootGroup ; \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nwhile ( enumerate . hasMoreElements ( ) ) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) name = StringUtil2 . unescape ( name ) ; \nDimension myd ; \nif ( ! ( name == null ) ) { \nif ( RC . getUseGroups ( ) ) { \nif ( name . indexOf ( '/' ) >= 0 ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \n} \nmyd = group . findDimension ( name ) ; \nif ( ! ( myd == null ) ) if ( myd . getLength ( ) != dad . getSize ( ) ) { \nmyd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \nelse { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \n} \nelse { \nmyd = new Dimension ( null , dad . getSize ( ) , false ) ; \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4532": "public class Resource { \npublic static ImageIcon getIcon ( String fullIconName , boolean errMsg ) { \nImageIcon icon = null ; \njava . net . URL iconR = cl . getResource ( fullIconName ) ; \nif ( debugIcon ) { \nSystem . out . println ( \"classLoader \" + cl . getClassLoader ( ) ) ; \nSystem . out . println ( \"  Resource.getIcon on \" + fullIconName + \" = \" + iconR ) ; \n} \nif ( iconR != null ) icon = new ImageIcon ( iconR ) ; \nif ( ! ( ( icon == null ) && errMsg ) ) if ( debugIcon ) System . out . println ( \"  Resource.getIcon ok on \" + fullIconName ) ; \nelse System . out . println ( \"  ERROR: Resource.getIcon failed on \" + fullIconName ) ; \nreturn icon ; \n} \n} \n"}
{"4538": "public class IospHelper { \nstatic public Object makePrimitiveArray ( int size , DataType dataType ) { \nObject arr = null ; \nif ( ! ( ( dataType . getPrimitiveClassType ( ) == byte . class ) || ( dataType == DataType . CHAR ) || ( dataType == DataType . OPAQUE ) || ( dataType == DataType . STRUCTURE ) ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == short . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == int . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == long . class ) ) if ( ! ( dataType == DataType . FLOAT ) ) if ( ! ( dataType == DataType . DOUBLE ) ) if ( dataType == DataType . STRING ) { \narr = new String [ size ] ; \n} \nelse { \narr = new double [ size ] ; \n} \nelse { \narr = new float [ size ] ; \n} \nelse { \narr = new long [ size ] ; \n} \nelse { \narr = new int [ size ] ; \n} \nelse { \narr = new short [ size ] ; \n} \nelse { \narr = new byte [ size ] ; \n} \nreturn arr ; \n} \n} \n"}
{"4549": "public class CrawlableDatasetFactory { \npublic static CrawlableDataset createCrawlableDataset ( String path , String className , Object configObj ) throws IOException , ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , IllegalArgumentException , NullPointerException { \nif ( path == null ) throw new NullPointerException ( \"Given path must not be null.\" ) ; \nString tmpClassName = ( className == null ? defaultClassName : className ) ; \nClass crDsClass = Class . forName ( tmpClassName ) ; \nif ( ! CrawlableDataset . class . isAssignableFrom ( crDsClass ) ) { \nthrow new IllegalArgumentException ( \"Requested class <\" + className + \"> not an implementation of thredds.crawlabledataset.CrawlableDataset.\" ) ; \n} \nClass [ ] argTypes = { \nString . class , Object . class } \n; \nObject [ ] args = { \npath , configObj } \n; \nConstructor constructor = crDsClass . getDeclaredConstructor ( argTypes ) ; \ntry { \nreturn ( CrawlableDataset ) constructor . newInstance ( args ) ; \n} \ncatch ( InvocationTargetException e ) { \nif ( ! ( IOException . class . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) ) throw e ; \nelse throw ( IOException ) e . getCause ( ) ; \n} \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \nfor ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; \ndatasetsIter . hasNext ( ) ; \n) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( ! ( dataset . getMFile ( ) instanceof MFileOS ) ) if ( ! ( dataset . getMFile ( ) instanceof MFileOS7 ) ) { \ncontinue ; \n} \nelse { \ndatasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \n} \nelse { \ndatasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \n} \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \n} \n} \n"}
{"4555": "public class Aggregation { \nprotected Dataset getTypicalDataset ( ) throws IOException { \nList < Dataset > nestedDatasets = getDatasets ( ) ; \nint n = nestedDatasets . size ( ) ; \nif ( n == 0 ) throw new FileNotFoundException ( \"No datasets in this aggregation\" ) ; \nint select ; \nif ( ! ( typicalDatasetMode == TypicalDataset . LATEST ) ) if ( ! ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) ) if ( ! ( typicalDatasetMode == TypicalDataset . FIRST ) ) { \nif ( r == null ) r = new Random ( ) ; \nselect = ( n < 2 ) ? 0 : r . nextInt ( n ) ; \n} \nelse select = 0 ; \nelse select = ( n < 2 ) ? 0 : n - 2 ; \nelse select = n - 1 ; \nreturn nestedDatasets . get ( select ) ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) return ( false ) ; \nif ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) return ( false ) ; \nif ( this . matchPatternTarget == null ) { \nif ( ! ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) ) { \nthis . setMatchPatternTarget ( \"urlPath\" ) ; \n} \nelse { \nthis . setMatchPatternTarget ( \"name\" ) ; \n} \n} \nif ( ! ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) ) { \nSystem . err . println ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" ) ; \nreturn ( false ) ; \n} \nelse { \nboolean isMatch ; \nif ( ! ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) ) if ( ! ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) ) { \nisMatch = false ; \n} \nelse { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nreturn ( isMatch ) ; \n} \n} \n} \n"}
{"4582": "public class GEOSTransform { \npublic double [ ] earthToSat ( double geographic_lon , double geographic_lat ) { \ngeographic_lat = geographic_lat * DEG_TO_RAD ; \ngeographic_lon = geographic_lon * DEG_TO_RAD ; \ndouble geocentric_lat = Math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . tan ( geographic_lat ) ) ; \ndouble r_earth = r_pol / Math . sqrt ( 1.0 - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . cos ( geocentric_lat ) * Math . cos ( geocentric_lat ) ) ; \ndouble r_1 = h - r_earth * Math . cos ( geocentric_lat ) * Math . cos ( geographic_lon - sub_lon ) ; \ndouble r_2 = - r_earth * Math . cos ( geocentric_lat ) * Math . sin ( geographic_lon - sub_lon ) ; \ndouble r_3 = r_earth * Math . sin ( geocentric_lat ) ; \nif ( r_1 > h ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble lamda_sat = Double . NaN ; \ndouble theta_sat = Double . NaN ; \nif ( ! ( scan_geom . equals ( GEOS ) ) ) if ( scan_geom . equals ( GOES ) ) { \nlamda_sat = Math . asin ( - r_2 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \ntheta_sat = Math . atan ( r_3 / r_1 ) ; \n} \nelse { \nlamda_sat = Math . atan ( - r_2 / r_1 ) ; \ntheta_sat = Math . asin ( r_3 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \n} \nreturn new double [ ] { \nlamda_sat , theta_sat } \n; \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( ! ( v . getDataType ( ) . isNumeric ( ) ) ) if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \nelse { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4592": "public class InvDataset { \npublic String getUniqueID ( ) { \nString authority = getAuthority ( ) ; \nif ( ! ( ( authority != null ) && ( getID ( ) != null ) ) ) if ( ! ( getID ( ) != null ) ) return null ; \nelse return getID ( ) ; \nelse return authority + \":\" + getID ( ) ; \n} \n} \n"}
{"4610": "public class GempakStationFileIOSP { \nprivate Array get1DArray ( DataType type , int len ) { \nArray varArray = null ; \nif ( ! ( type . equals ( DataType . FLOAT ) ) ) if ( ! ( type . equals ( DataType . DOUBLE ) ) ) if ( type . equals ( DataType . INT ) ) { \nvarArray = new ArrayInt . D1 ( len , false ) ; \n} \nelse { \nvarArray = new ArrayDouble . D1 ( len ) ; \n} \nelse { \nvarArray = new ArrayFloat . D1 ( len ) ; \n} \nreturn varArray ; \n} \n} \n"}
{"4611": "public class CeParser { \nprivate int yy_lr_goto_state_ ( int yystate , int yysym ) { \nint yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; \nif ( ! ( 0 <= yyr && yyr <= yylast_ && yycheck_ [ yyr ] == yystate ) ) return yydefgoto_ [ yysym - yyntokens_ ] ; \nelse return yytable_ [ yyr ] ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( ! ( requestmode == RequestMode . DMR ) ) if ( ! ( requestmode == RequestMode . DAP ) ) assert false : \"Internal error\" ; \nelse { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nwhile ( ( c = input . read ( ) ) >= 0 ) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( ! ( dmr . endsWith ( \"\\r\\n\" ) ) ) if ( ! ( dmr . endsWith ( \"\\n\" ) ) ) dmr = dmr + \"\\r\\n\" ; \nelse dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse { \n} \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ! ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) ) if ( ! ( ( flags & DapUtil . CHUNK_END ) != 0 ) ) state = State . DATA ; \nelse state = State . END ; \nelse state = State . ERROR ; \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nwhile ( count > 0 ) { \nif ( ! ( avail <= 0 ) ) { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \nelse { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \n} \nreturn len ; \n} \n} \n"}
{"4619": "public class TableParser { \nstatic public List < Record > readTable ( String urlString , String format , int maxLines ) throws IOException , NumberFormatException { \nInputStream ios ; \nif ( ! ( urlString . startsWith ( \"http:\" ) ) ) { \nios = new FileInputStream ( urlString ) ; \n} \nelse { \nURL url = new URL ( urlString ) ; \nios = url . openStream ( ) ; \n} \nreturn readTable ( ios , format , maxLines ) ; \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( ! ( replace || ( null == targetV ) ) ) if ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) { \ntargetVe . setOriginalVariable ( v ) ; \n} \nelse { \nif ( ! ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) ) if ( ! ( v instanceof VariableDS ) ) { \nv = new VariableDS ( targetGroup , v , false ) ; \n} \nelse { \nv = new StructureDS ( targetGroup , ( Structure ) v ) ; \n} \nif ( null != targetV ) targetGroup . remove ( targetV ) ; \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nint pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) throw new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \nif ( ! ( ext . equals ( IDX_EXT ) ) ) if ( ! ( ext . equals ( DAT_EXT ) ) ) { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \nelse { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) { \nthrow new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \n} \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \n} \n} \n"}
{"4625": "public class GribCollectionBuilder { \nprivate boolean createAllRuntimeCollections ( Formatter errlog ) throws IOException { \nlong start = System . currentTimeMillis ( ) ; \nthis . type = GribCollectionImmutable . Type . SRC ; \nboolean ok = true ; \nList < MFile > files = new ArrayList < > ( ) ; \nList < ? extends Group > groups = makeGroups ( files , true , errlog ) ; \nList < MFile > allFiles = Collections . unmodifiableList ( files ) ; \nMap < Long , List < Group > > runGroups = new HashMap < > ( ) ; \nfor ( Group g : groups ) { \nList < Group > runGroup = runGroups . computeIfAbsent ( g . getRuntime ( ) . getMillis ( ) , k -> new ArrayList < > ( ) ) ; \nrunGroup . add ( g ) ; \n} \nboolean multipleRuntimes = runGroups . values ( ) . size ( ) > 1 ; \nList < MFile > partitions = new ArrayList < > ( ) ; \nfor ( List < Group > runGroupList : runGroups . values ( ) ) { \nGroup g = runGroupList . get ( 0 ) ; \nString gcname = multipleRuntimes ? GribCollectionMutable . makeName ( this . name , g . getRuntime ( ) ) : this . name ; \nMFile indexFileForRuntime = GribCollectionMutable . makeIndexMFile ( gcname , directory ) ; \npartitions . add ( indexFileForRuntime ) ; \nList < Long > runtimes = new ArrayList < > ( 1 ) ; \nruntimes . add ( g . getRuntime ( ) . getMillis ( ) ) ; \nCoordinateRuntime masterRuntimes = new CoordinateRuntime ( runtimes , null ) ; \nCalendarDateRange calendarDateRangeAll = null ; \nfor ( Coordinate coord : g . getCoordinates ( ) ) { \nif ( coord instanceof CoordinateTimeAbstract ) { \nCalendarDateRange calendarDateRange = ( ( CoordinateTimeAbstract ) coord ) . makeCalendarDateRange ( null ) ; \nif ( ! ( calendarDateRangeAll == null ) ) calendarDateRangeAll = calendarDateRangeAll . extend ( calendarDateRange ) ; \nelse calendarDateRangeAll = calendarDateRange ; \n} \n} \nassert calendarDateRangeAll != null ; \nok &= writeIndex ( gcname , indexFileForRuntime . getPath ( ) , masterRuntimes , runGroupList , allFiles , calendarDateRangeAll ) ; \nlogger . info ( \"GribCollectionBuilder write {} ok={}\" , indexFileForRuntime . getPath ( ) , ok ) ; \n} \nif ( multipleRuntimes ) { \nCollections . sort ( partitions ) ; \nPartitionManager part = new PartitionManagerFromIndexList ( dcm , partitions , logger ) ; \npart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , dcm . getAuxInfo ( FeatureCollectionConfig . AUX_CONFIG ) ) ; \nok &= GribCdmIndex . updateGribCollectionFromPCollection ( isGrib1 , part , CollectionUpdateType . always , errlog , logger ) ; \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . debug ( \"That took {} msecs\" , took ) ; \nreturn ok ; \n} \n} \n"}
{"4626": "public class DurationField { \nprotected void setEditValue ( Object value ) { \nif ( ! ( value == null ) ) tf . setText ( value . toString ( ) ) ; \nelse tf . setText ( \"\" ) ; \n} \n} \n"}
{"4628": "public class Cosmic1Convention { \npublic static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { \ndouble longitude = Math . atan2 ( y , x ) ; \ndouble ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; \ndouble p = Math . sqrt ( x * x + y * y ) ; \ndouble theta = Math . atan ( ( z * a ) / ( p * b ) ) ; \ndouble sineTheta = Math . sin ( theta ) ; \ndouble cosTheta = Math . cos ( theta ) ; \ndouble f = 1 / 298.257223563 ; \ndouble e2 = 2 * f - f * f ; \ndouble top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; \ndouble bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; \ndouble geodeticLat = Math . atan ( top / bottom ) ; \ndouble sineLat = Math . sin ( geodeticLat ) ; \ndouble N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; \ndouble altitude = ( p / Math . cos ( geodeticLat ) ) - N ; \nif ( ! ( longitude > Math . PI ) ) if ( longitude < - Math . PI ) { \nlongitude += 2 * Math . PI ; \n} \nelse { \nlongitude -= 2 * Math . PI ; \n} \nreturn new double [ ] { \ngeodeticLat , longitude , altitude } \n; \n} \n} \n"}
{"4629": "public class Util { \npublic static String cleanUnit ( String unit ) { \nif ( unit == null ) return null ; \nif ( ! ( unit . equalsIgnoreCase ( \"Proportion\" ) || unit . equalsIgnoreCase ( \"Numeric\" ) ) ) if ( ! ( unit . equalsIgnoreCase ( \"-\" ) ) ) if ( ! ( unit . startsWith ( \"degree\" ) && unit . endsWith ( \"true\" ) ) ) if ( ! unit . contains ( \" table \" ) ) { \nif ( unit . startsWith ( \"/\" ) ) unit = \"1\" + unit ; \nunit = unit . trim ( ) ; \nunit = StringUtil2 . remove ( unit , \"**\" ) ; \nStringBuilder sb = new StringBuilder ( unit ) ; \nStringUtil2 . remove ( sb , \"^[]\" ) ; \nStringUtil2 . replace ( sb , ' ' , \".\" ) ; \nStringUtil2 . replace ( sb , '*' , \".\" ) ; \nunit = sb . toString ( ) ; \n} \nelse { \nunit = unit . replace ( ' ' , '_' ) ; \n} \nelse { \nunit = \"\" ; \n} \nelse unit = \"\" ; \nreturn unit ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( ! ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) ) if ( ! ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) ) { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( ! ( dodsV != null ) ) { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( ! ( dodsV != null ) ) { \nif ( debugAttributes ) System . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \nelse { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \n} \nelse { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \n} \nelse { \ncontinue ; \n} \nelse { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \n} \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) { \ntry { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nint len = d . getLength ( ) ; \nif ( ! ( len > 0 ) ) if ( ! ( len == 0 ) ) { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \nelse list . add ( Range . EMPTY ) ; \nelse list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4646": "public class Variable { \npublic String readScalarString ( ) throws IOException { \nArray data = getScalarData ( ) ; \nif ( ! ( dataType == DataType . STRING ) ) if ( ! ( dataType == DataType . CHAR ) ) throw new IllegalArgumentException ( \"readScalarString not STRING or CHAR \" + getFullName ( ) ) ; \nelse { \nArrayChar dataC = ( ArrayChar ) data ; \nreturn dataC . getString ( ) ; \n} \nelse return ( String ) data . getObject ( Index . scalarIndexImmutable ) ; \n} \n} \n"}
{"4647": "public class Variable { \nprotected Array _read ( ) throws IOException { \nif ( cache . data != null ) { \nif ( debugCaching ) System . out . println ( \"got data from cache \" + getFullName ( ) ) ; \nreturn cache . data . copy ( ) ; \n} \nArray data = proxyReader . reallyRead ( this , null ) ; \nif ( ! ( isCaching ( ) ) ) { \nreturn data ; \n} \nelse { \nsetCachedData ( data ) ; \nif ( debugCaching ) System . out . println ( \"cache \" + getFullName ( ) ) ; \nreturn cache . data . copy ( ) ; \n} \n} \n} \n"}
{"4655": "public class Variable { \npublic void resetDimensions ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nArrayList < Dimension > newDimensions = new ArrayList < > ( ) ; \nfor ( Dimension dim : dimensions ) { \nif ( ! ( dim . isShared ( ) ) ) { \nnewDimensions . add ( dim ) ; \n} \nelse { \nDimension newD = getParentGroup ( ) . findDimension ( dim . getShortName ( ) ) ; \nif ( newD == null ) throw new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" resetDimensions  FAILED, dim doesnt exist in parent group=\" + dim ) ; \nnewDimensions . add ( newD ) ; \n} \n} \nthis . dimensions = newDimensions ; \nresetShape ( ) ; \n} \n} \n"}
{"4659": "public class AbstractRadialAdapter { \nprotected void setBoundingBox ( ) { \nLatLonRect largestBB = null ; \nfor ( Object o : csHash . values ( ) ) { \nRadialCoordSys sys = ( RadialCoordSys ) o ; \nsys . setOrigin ( origin ) ; \nLatLonRect bb = sys . getBoundingBox ( ) ; \nif ( ! ( largestBB == null ) ) if ( bb != null ) largestBB . extend ( bb ) ; \nelse largestBB = bb ; \n} \nboundingBox = largestBB ; \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( ! ( cdmdim . isShared ( ) ) ) if ( ! ( cdmdim . isVariableLength ( ) ) ) { \ndapdim = builddim ( cdmdim ) ; \n} \nelse { \ncontinue ; \n} \nelse { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) throw new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < dimset . size ( ) ; \ni ++ ) { \nif ( ! ( dimset . get ( i ) . isVariableLength ( ) ) ) core . add ( dimset . get ( i ) ) ; \nelse { \npos = i ; \ncount ++ ; \n} \n} \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4679": "public class ListenerManager { \npublic synchronized void addListener ( Object l ) { \nif ( ! ( ! listeners . contains ( l ) ) ) logger . warn ( \"ListenerManager.addListener already has Listener \" + l ) ; \nelse { \nlisteners . add ( l ) ; \nhasListeners = true ; \n} \n} \n} \n"}
{"4680": "public class ListenerManager { \npublic synchronized void removeListener ( Object l ) { \nif ( ! ( listeners . contains ( l ) ) ) logger . warn ( \"ListenerManager.removeListener couldnt find Listener \" + l ) ; \nelse { \nlisteners . remove ( l ) ; \nhasListeners = ( listeners . size ( ) > 0 ) ; \n} \n} \n} \n"}
{"4683": "public class NCdumpW { \npublic static boolean print ( String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nString filename ; \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nif ( ! ( stoke . hasMoreTokens ( ) ) ) { \nout . write ( usage ) ; \nreturn false ; \n} \nelse filename = stoke . nextToken ( ) ; \ntry ( NetcdfFile nc = NetcdfDataset . openFile ( filename , ct ) ) { \nint pos = command . indexOf ( filename ) ; \ncommand = command . substring ( pos + filename . length ( ) ) ; \nreturn print ( nc , command , out , ct ) ; \n} \ncatch ( java . io . FileNotFoundException e ) { \nout . write ( \"file not found= \" ) ; \nout . write ( filename ) ; \nreturn false ; \n} \nfinally { \nout . close ( ) ; \n} \n} \n} \n"}
{"4691": "public class AbstractTransformBuilder { \nprotected double readAttributeDouble ( AttributeContainer v , String attname , double defValue ) { \nAttribute att = v . findAttributeIgnoreCase ( attname ) ; \nif ( att == null ) return defValue ; \nif ( ! ( att . isString ( ) ) ) return att . getNumericValue ( ) . doubleValue ( ) ; \nelse return Double . parseDouble ( att . getStringValue ( ) ) ; \n} \n} \n"}
{"4694": "public class D4Cursor { \nprotected Object readAs ( DapVariable atomvar , DapType basetype , List < Slice > slices ) throws DapException { \nif ( basetype . getTypeSort ( ) == TypeSort . Enum ) { \nbasetype = ( ( DapEnumeration ) basetype ) . getBaseType ( ) ; \nreturn readAs ( atomvar , basetype , slices ) ; \n} \nlong count = DapUtil . sliceProduct ( slices ) ; \nObject result = LibTypeFcns . newVector ( basetype , count ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( ! ( DapUtil . isContiguous ( slices ) && basetype . isFixedSize ( ) ) ) readOdom ( slices , basetype , odom , result ) ; \nelse readContig ( slices , basetype , count , odom , result ) ; \nreturn result ; \n} \n} \n"}
{"4698": "public class BitReader { \npublic void setBitOffset ( int bitOffset ) throws IOException { \nif ( ! ( bitOffset % 8 == 0 ) ) { \nraf . seek ( startPos + bitOffset / 8 ) ; \nbitPos = 8 - ( bitOffset % 8 ) ; \nbitBuf = ( byte ) raf . read ( ) ; \nbitBuf &= 0xff >> ( 8 - bitPos ) ; \n} \nelse { \nraf . seek ( startPos + bitOffset / 8 ) ; \nbitPos = 0 ; \nbitBuf = 0 ; \n} \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( ! ( encoding != null && encoding . equals ( \"deflate\" ) ) ) if ( ! ( encoding != null && encoding . equals ( \"gzip\" ) ) ) { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \nelse { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4702": "public class DConnect2 { \npublic DAS getDAS ( ) throws IOException , DAP2Exception { \nDASCommand command = new DASCommand ( ) ; \nif ( ! ( filePath != null ) ) if ( ! ( stream != null ) ) { \ntry { \nopenConnection ( urlString + \".das\" + getCompleteCE ( projString , selString ) , command ) ; \n} \ncatch ( DAP2Exception de ) { \n} \n} \nelse { \ncommand . process ( stream ) ; \n} \nelse { \nFile daspath = new File ( filePath + \".das\" ) ; \nif ( daspath . canRead ( ) ) { \ntry ( FileInputStream is = new FileInputStream ( daspath ) ) { \ncommand . process ( is ) ; \n} \n} \n} \nreturn command . das ; \n} \n} \n"}
{"4703": "public class DConnect2 { \npublic DDS getDDS ( String CE ) throws IOException , ParseException , DAP2Exception { \nDDSCommand command = new DDSCommand ( ) ; \ncommand . setURL ( CE == null || CE . length ( ) == 0 ? urlString : urlString + \"?\" + CE ) ; \nif ( ! ( filePath != null ) ) if ( ! ( stream != null ) ) { \nopenConnection ( urlString + \".dds\" + ( getCompleteCE ( CE ) ) , command ) ; \n} \nelse { \ncommand . process ( stream ) ; \n} \nelse { \ntry ( FileInputStream is = new FileInputStream ( filePath + \".dds\" ) ) { \ncommand . process ( is ) ; \n} \n} \nreturn command . dds ; \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nint selIndex = CE . indexOf ( '&' ) ; \nif ( ! ( selIndex == 0 ) ) if ( ! ( selIndex > 0 ) ) { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nelse { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) ce += \",\" ; \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += localSelString ; \n} \nif ( ce . length ( ) > 0 ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4705": "public class Sinusoidal { \n@ Override public LatLonPoint projToLatLon ( ProjectionPoint world , LatLonPointImpl result ) { \ndouble fromX = world . getX ( ) - falseEasting ; \ndouble fromY = world . getY ( ) - falseNorthing ; \ndouble toLat_r = fromY / earthRadius ; \ndouble toLon_r ; \nif ( ! ( Misc . nearlyEquals ( Math . abs ( toLat_r ) , PI_OVER_2 , 1e-10 ) ) ) if ( ! ( Math . abs ( toLat_r ) < PI_OVER_2 ) ) { \nreturn INVALID ; \n} \nelse { \ntoLon_r = Math . toRadians ( centMeridian ) + fromX / ( earthRadius * Math . cos ( toLat_r ) ) ; \n} \nelse { \ntoLat_r = toLat_r < 0 ? - PI_OVER_2 : + PI_OVER_2 ; \ntoLon_r = Math . toRadians ( centMeridian ) ; \n} \nif ( ! ( Misc . nearlyEquals ( Math . abs ( toLon_r ) , PI , 1e-10 ) ) ) if ( Math . abs ( toLon_r ) > PI ) { \nreturn INVALID ; \n} \nelse { \ntoLon_r = toLon_r < 0 ? - PI : + PI ; \n} \nresult . setLatitude ( Math . toDegrees ( toLat_r ) ) ; \nresult . setLongitude ( Math . toDegrees ( toLon_r ) ) ; \nreturn result ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( ! ( b == plus && spaceplus ) ) if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nelse { \nout [ index8 ++ ] = blank ; \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( ! ( hcs . isLatLon ( ) ) ) { \ndims = dims + \" y x\" ; \n} \nelse { \ndims = dims + \" lat lon\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( ! ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) ) if ( ! ( SimpleUnit . isCompatible ( \"m\" , units ) ) ) { \naxisType = AxisType . GeoZ ; \n} \nelse { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . Pressure ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( ! ( file . isDirectory ( ) ) ) { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \nelse { \ncleanCache ( file , sbuff , false ) ; \n} \n} \n} \n} \n"}
{"4750": "public class SourcePicture { \npublic void loadPicture ( ) { \nTools . log ( \"SourcePicture.loadPicture: \" + imageUrl . toString ( ) + \" loaded into SourcePicture object: \" + Integer . toString ( this . hashCode ( ) ) ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nabortFlag = false ; \ntry { \nImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; \nIterator i = ImageIO . getImageReaders ( iis ) ; \nif ( ! i . hasNext ( ) ) { \nthrow new IOException ( \"No Readers Available!\" ) ; \n} \nreader = ( ImageReader ) i . next ( ) ; \nreader . addIIOReadProgressListener ( imageProgressListener ) ; \nreader . setInput ( iis ) ; \nsourcePictureBufferedImage = null ; \nsourcePictureBufferedImage = reader . read ( 0 ) ; \niis . close ( ) ; \nreader . removeIIOReadProgressListener ( imageProgressListener ) ; \nreader . dispose ( ) ; \nif ( ! ( ! abortFlag ) ) { \nsetStatus ( ERROR , \"Aborted: \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \nelse { \nif ( rotation != 0 ) { \nsetStatus ( ROTATING , \"Rotating: \" + imageUrl . toString ( ) ) ; \nint xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; \nint yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; \nAffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; \nAffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nRectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \ndouble minX = newBounds . getMinX ( ) ; \ndouble minY = newBounds . getMinY ( ) ; \nAffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; \nrotateAf . preConcatenate ( translateAf ) ; \nop = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nnewBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \nBufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nsourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; \n} \nsetStatus ( READY , \"Loaded: \" + imageUrl . toString ( ) ) ; \nPictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; \n} \n} \ncatch ( IOException e ) { \nsetStatus ( ERROR , \"Error while reading \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \n} \n"}
{"4752": "public class SourcePicture { \npublic boolean stopLoadingExcept ( URL exemptionURL ) { \nif ( imageUrl == null ) return false ; \nif ( pictureStatusCode != LOADING ) { \nTools . log ( \"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \" + imageUrl . toString ( ) ) ; \nreturn false ; \n} \nif ( ! ( ! exemptionURL . toString ( ) . equals ( imageUrl . toString ( ) ) ) ) return false ; \nelse { \nTools . log ( \"SourcePicture.stopLoadingExcept: called with Url \" + exemptionURL . toString ( ) + \" --> stopping loading of \" + imageUrl . toString ( ) ) ; \nstopLoading ( ) ; \nreturn true ; \n} \n} \n} \n"}
{"4753": "public class SourcePicture { \npublic Dimension getSize ( ) { \nif ( ! ( sourcePictureBufferedImage != null ) ) return new Dimension ( 0 , 0 ) ; \nelse return new Dimension ( sourcePictureBufferedImage . getWidth ( ) , sourcePictureBufferedImage . getHeight ( ) ) ; \n} \n} \n"}
{"4758": "public class DataDescriptor { \nint countBits ( ) { \nint total_nbits = 0 ; \ntotal_nbytesCDM = 0 ; \nfor ( DataDescriptor dd : subKeys ) { \nif ( ! ( dd . subKeys != null ) ) if ( dd . f == 0 ) { \ntotal_nbits += dd . bitWidth ; \ntotal_nbytesCDM += dd . getByteWidthCDM ( ) ; \n} \nelse { \ntotal_nbits += dd . countBits ( ) ; \ntotal_nbytesCDM += dd . total_nbytesCDM ; \n} \n} \nif ( replication > 1 ) { \ntotal_nbits *= replication ; \ntotal_nbytesCDM *= replication ; \n} \nreturn total_nbits ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( int i = 0 ; \ni < nrecords ; \ni ++ ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( ! ( recbyte == 0x20 ) ) { \nnrecords -- ; \ni -- ; \n} \nelse { \nfor ( int j = 0 ; \nj < nfields ; \nj ++ ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( int i = 0 ; \ni < s . length ; \ni ++ ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( int i = 0 ; \ni < b . length ; \ni ++ ) { \nif ( ! ( b [ i ] ) ) { \ndd [ i ] = 0 ; \n} \nelse { \ndd [ i ] = 1 ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( ! ( field < nf - 1 ) ) System . out . println ( ) ; \nelse System . out . print ( \", \" ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4810": "public class SortedTable { \npublic synchronized Object get ( Object key ) { \nint index = keys . indexOf ( key ) ; \nif ( ! ( index != - 1 ) ) return null ; \nelse return elements . elementAt ( index ) ; \n} \n} \n"}
{"4811": "public class SortedTable { \npublic synchronized Object put ( Object key , Object value ) throws NullPointerException { \nif ( key == null || value == null ) throw new NullPointerException ( ) ; \nint index = keys . indexOf ( key ) ; \nif ( ! ( index != - 1 ) ) { \nkeys . addElement ( key ) ; \nelements . addElement ( value ) ; \nreturn null ; \n} \nelse { \nObject prev = elements . elementAt ( index ) ; \nelements . setElementAt ( value , index ) ; \nreturn prev ; \n} \n} \n} \n"}
{"4815": "public class DMRPrinter { \nstatic boolean isSpecial ( DapAttribute attr ) { \nif ( ! ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) ) if ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) { \nfor ( String s : VARSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \n} \nelse { \nfor ( String s : GROUPSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \ni < var . getRank ( ) ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( ! ( dim . isShared ( ) ) ) { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nelse { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \n} \n} \n"}
{"4820": "public class AreaReader { \nprivate int getCalType ( String calName ) { \nint calTypeOut = Calibrator . CAL_NONE ; \nif ( ! ( calName . trim ( ) . equals ( \"ALB\" ) ) ) if ( ! ( calName . trim ( ) . equals ( \"BRIT\" ) ) ) if ( ! ( calName . trim ( ) . equals ( \"RAD\" ) ) ) if ( ! ( calName . trim ( ) . equals ( \"RAW\" ) ) ) if ( calName . trim ( ) . equals ( \"TEMP\" ) ) { \ncalTypeOut = Calibrator . CAL_TEMP ; \n} \nelse { \ncalTypeOut = Calibrator . CAL_RAW ; \n} \nelse { \ncalTypeOut = Calibrator . CAL_RAD ; \n} \nelse { \ncalTypeOut = Calibrator . CAL_BRIT ; \n} \nelse { \ncalTypeOut = Calibrator . CAL_ALB ; \n} \nreturn calTypeOut ; \n} \n} \n"}
{"4827": "public class CoordSysEvaluator { \nstatic private CoordinateSystem findBestCoordinateSystem ( NetcdfDataset ds ) { \nCoordinateSystem use = null ; \nfor ( CoordinateSystem cs : ds . getCoordinateSystems ( ) ) { \nif ( ! ( use == null ) ) if ( cs . getCoordinateAxes ( ) . size ( ) > use . getCoordinateAxes ( ) . size ( ) ) use = cs ; \nelse use = cs ; \n} \nreturn use ; \n} \n} \n"}
{"4829": "public class DSequence { \npublic BaseType getVariable ( int row , String name ) throws NoSuchVariableException { \nint dotIndex = name . indexOf ( '.' ) ; \nif ( ! ( dotIndex != - 1 ) ) { \nVector selectedRow = ( Vector ) allValues . elementAt ( row ) ; \nfor ( Enumeration e = selectedRow . elements ( ) ; \ne . hasMoreElements ( ) ; \n) { \nBaseType v = ( BaseType ) e . nextElement ( ) ; \nif ( v . getEncodedName ( ) . equals ( name ) ) return v ; \n} \n} \nelse { \nString aggregate = name . substring ( 0 , dotIndex ) ; \nString field = name . substring ( dotIndex + 1 ) ; \nBaseType aggRef = getVariable ( aggregate ) ; \nif ( ! ( aggRef instanceof DConstructor ) ) ; \nelse return ( ( DConstructor ) aggRef ) . getVariable ( field ) ; \n} \nthrow new NoSuchVariableException ( \"DSequence: getVariable()\" ) ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( ! ( m . getDataType ( ) == DataType . STRING ) ) if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \nelse { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( ! ( workingArray != null && workingArray . length == nCells ) ) { \nvalues = new float [ nCells ] ; \n} \nelse { \nvalues = workingArray ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( int cell = 0 ; \ncell < nCells ; \ncell ++ ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4866": "public class H4iosp { \nprivate ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { \nH4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; \nvinfo . setLayoutInfo ( ) ; \nint recsize = vinfo . elemSize ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nH4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( minfo . offset ) ; \n} \nmembers . setStructureSize ( recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nif ( ! ( ! vinfo . isLinked && ! vinfo . isCompressed ) ) if ( ! ( vinfo . isLinked && ! vinfo . isCompressed ) ) if ( ! ( ! vinfo . isLinked && vinfo . isCompressed ) ) if ( ! ( vinfo . isLinked && vinfo . isCompressed ) ) { \nthrow new IllegalStateException ( ) ; \n} \nelse { \nInputStream is = getLinkedCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nInputStream is = getCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nInputStream is = new LinkedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nLayout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4870": "public class PicturePane { \npublic void paintComponent ( Graphics g ) { \nint WindowWidth = getSize ( ) . width ; \nint WindowHeight = getSize ( ) . height ; \nTools . log ( \"paintComponent called\" ) ; \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; \n} \nif ( ! ( sclPic . getScaledPicture ( ) != null ) ) { \ng . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; \ng . setColor ( Color . black ) ; \ng . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; \n} \nelse { \nGraphics2D g2d = ( Graphics2D ) g ; \nint X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; \nint Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; \nRectangle clipBounds = g2d . getClipBounds ( ) ; \ng2d . setColor ( Color . black ) ; \ng2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; \ng2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; \nif ( showInfo ) { \ng2d . setColor ( Color . white ) ; \ng2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; \ng2d . drawString ( \"Size: \" + Integer . toString ( sclPic . getOriginalWidth ( ) ) + \" x \" + Integer . toString ( sclPic . getOriginalHeight ( ) ) + \" Offset: \" + X_Offset + \" x \" + Y_Offset + \" Mid: \" + Integer . toString ( focusPoint . x ) + \" x \" + Integer . toString ( focusPoint . y ) + \" Scale: \" + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; \n} \n} \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; \n} \n} \n} \n"}
{"4871": "public class GempakUtil { \npublic static int [ ] TG_FTOI ( int [ ] iftime , int start ) { \nint [ ] intdtf = new int [ 3 ] ; \nif ( ! ( iftime [ start ] < 100000000 ) ) { \nintdtf [ 0 ] = iftime [ start ] / 10000 ; \nintdtf [ 1 ] = iftime [ start ] - intdtf [ 0 ] * 10000 ; \nint mmdd = intdtf [ 0 ] / 100 ; \nint iyyy = intdtf [ 0 ] - mmdd * 100 ; \nintdtf [ 0 ] = iyyy * 10000 + mmdd ; \nintdtf [ 2 ] = iftime [ start + 1 ] ; \n} \nelse { \nintdtf [ 0 ] = iftime [ start ] ; \nintdtf [ 1 ] = iftime [ start + 1 ] ; \nintdtf [ 2 ] = 0 ; \n} \nreturn intdtf ; \n} \n} \n"}
{"4875": "public class GempakUtil { \npublic static String LV_CCRD ( int ivcord ) { \nString vcoord = \"\" ; \nif ( ! ( ( ivcord >= 0 ) && ( ivcord < vertCoords . length ) ) ) if ( ivcord > 100 ) { \nvcoord = ST_ITOC ( ivcord ) ; \n} \nelse { \nvcoord = vertCoords [ ivcord ] ; \n} \nreturn vcoord ; \n} \n} \n"}
{"4880": "public class DataDDS { \npublic final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { \nif ( headers ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; \npw . println ( \"HTTP/1.0 200 OK\" ) ; \npw . println ( \"XDAP: \" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"XDODS-Server: DODS/\" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"Content-type: application/octet-stream\" ) ; \npw . println ( \"Content-Description: dods-data\" ) ; \nif ( compress ) { \npw . println ( \"Content-Encoding: deflate\" ) ; \n} \npw . println ( ) ; \npw . flush ( ) ; \n} \nOutputStream bufferedOS ; \nif ( ! ( compress ) ) { \nbufferedOS = new BufferedOutputStream ( os ) ; \n} \nelse { \nbufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; \n} \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; \nprint ( pw ) ; \npw . flush ( ) ; \nbufferedOS . write ( \"\\nData:\\n\" . getBytes ( CDM . utf8Charset ) ) ; \nbufferedOS . flush ( ) ; \nDataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . externalize ( dataOS ) ; \n} \ndataOS . close ( ) ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( ! ( forward ) ) { \nthis . time -- ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nelse { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ni < currentDirFileList . size ( ) ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( ! ( forward ) ) { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nelse { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4893": "public class BaseUnit { \npublic static synchronized BaseUnit getOrCreate ( final UnitName id , final BaseQuantity baseQuantity ) throws NameException , UnitExistsException { \nBaseUnit baseUnit ; \nfinal BaseUnit nameUnit = nameMap . get ( id ) ; \nfinal BaseUnit quantityUnit = quantityMap . get ( baseQuantity ) ; \nif ( ! ( nameUnit != null || quantityUnit != null ) ) { \nbaseUnit = new BaseUnit ( id , baseQuantity ) ; \nquantityMap . put ( baseQuantity , baseUnit ) ; \nnameMap . put ( id , baseUnit ) ; \n} \nelse { \nbaseUnit = nameUnit != null ? nameUnit : quantityUnit ; \nif ( ( nameUnit != null && ! baseQuantity . equals ( nameUnit . getBaseQuantity ( ) ) ) || ( quantityUnit != null && ! id . equals ( quantityUnit . getUnitName ( ) ) ) ) { \nthrow new UnitExistsException ( \"Attempt to incompatibly redefine base unit \\\"\" + baseUnit + '\"' ) ; \n} \n} \nreturn baseUnit ; \n} \n} \n"}
{"4897": "public class DatasetUrl { \nstatic private ServiceType checkIfDods ( String location ) throws IOException { \nint len = location . length ( ) ; \nif ( location . endsWith ( \".dds\" ) ) location = location . substring ( 0 , len - \".dds\" . length ( ) ) ; \nif ( location . endsWith ( \".das\" ) ) location = location . substring ( 0 , len - \".das\" . length ( ) ) ; \nif ( location . endsWith ( \".dods\" ) ) location = location . substring ( 0 , len - \".dods\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dds\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( ! ( v . equalsIgnoreCase ( \"dods-dds\" ) || v . equalsIgnoreCase ( \"dods_dds\" ) ) ) throw new IOException ( \"OPeNDAP Server Error= \" + method . getResponseAsString ( ) ) ; \nelse return ServiceType . OPENDAP ; \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4898": "public class DatasetUrl { \nstatic private ServiceType checkIfDap4 ( String location ) throws IOException { \nif ( ! ( location . endsWith ( \".dap\" ) ) ) if ( ! ( location . endsWith ( \".dmr\" ) ) ) if ( ! ( location . endsWith ( \".dmr.xml\" ) ) ) if ( location . endsWith ( \".dsr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dsr\" . length ( ) ) ; \nelse location = location . substring ( 0 , location . length ( ) - \".dmr.xml\" . length ( ) ) ; \nelse location = location . substring ( 0 , location . length ( ) - \".dmr\" . length ( ) ) ; \nelse location = location . substring ( 0 , location . length ( ) - \".dap\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dmr.xml\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Type\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . startsWith ( \"application/vnd.opendap.org\" ) ) return ServiceType . DAP4 ; \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4900": "public class DapUtil { \nstatic public String fqnSuffix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( ! ( structindex >= 0 ) ) return fqn . substring ( groupindex + 1 , fqn . length ( ) ) ; \nelse return fqn . substring ( structindex + 1 , fqn . length ( ) ) ; \n} \n} \n"}
{"4901": "public class DapUtil { \nstatic public String fqnPrefix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( ! ( structindex >= 0 ) ) return fqn . substring ( 0 , groupindex ) ; \nelse return fqn . substring ( 0 , structindex ) ; \n} \n} \n"}
{"4918": "public class FeatureCollectionConfigBuilder { \npublic FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { \nString catFilename ; \nString fcName = null ; \nint pos = catalogAndPath . indexOf ( \"#\" ) ; \nif ( ! ( pos > 0 ) ) { \ncatFilename = catalogAndPath ; \n} \nelse { \ncatFilename = catalogAndPath . substring ( 0 , pos ) ; \nfcName = catalogAndPath . substring ( pos + 1 ) ; \n} \nFile cat = new File ( catFilename ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \ndoc = builder . build ( cat ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \ntry { \nList < Element > fcElems = new ArrayList < > ( ) ; \nfindFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; \nif ( fcElems . size ( ) > 0 ) return readConfig ( fcElems . get ( 0 ) ) ; \n} \ncatch ( IllegalStateException e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4919": "public class DapGroup { \npublic void addDecl ( DapNode newdecl ) throws DapException { \nDapSort newsort = newdecl . getSort ( ) ; \nString newname = newdecl . getShortName ( ) ; \nboolean suppress = false ; \nif ( ! ( newsort != DapSort . DIMENSION || newname != null ) ) { \nDapDimension anon = ( DapDimension ) newdecl ; \nassert ( newsort == DapSort . DIMENSION && newname == null ) ; \nboolean found = false ; \nfor ( DapDimension dim : dimensions ) { \nif ( ! dim . isShared ( ) && dim . getSize ( ) == anon . getSize ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found && ! isTopLevel ( ) ) getDataset ( ) . addDecl ( anon ) ; \nsuppress = found || ! isTopLevel ( ) ; \n} \nelse { \nfor ( DapNode decl : decls ) { \nif ( newsort == decl . getSort ( ) && newname . equals ( decl . getShortName ( ) ) ) throw new DapException ( \"DapGroup: attempt to add duplicate decl: \" + newname ) ; \n} \n} \nif ( ! suppress ) { \ndecls . add ( newdecl ) ; \nnewdecl . setParent ( this ) ; \n} \nswitch ( newdecl . getSort ( ) ) { \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; \nbreak ; \ncase DIMENSION : if ( ! suppress ) dimensions . add ( ( DapDimension ) newdecl ) ; \nbreak ; \ncase ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; \nbreak ; \ncase ATOMICTYPE : break ; \ncase STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; \nbreak ; \ncase VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; \nbreak ; \ncase GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) groups . add ( ( DapGroup ) newdecl ) ; \nbreak ; \ndefault : throw new ClassCastException ( newdecl . getShortName ( ) ) ; \n} \n} \n} \n"}
{"4922": "public class COARDSConvention { \nprotected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { \nString unit = v . getUnitsString ( ) ; \nif ( unit == null ) return null ; \nunit = unit . trim ( ) ; \nif ( unit . equalsIgnoreCase ( \"degrees_east\" ) || unit . equalsIgnoreCase ( \"degrees_E\" ) || unit . equalsIgnoreCase ( \"degreesE\" ) || unit . equalsIgnoreCase ( \"degree_east\" ) || unit . equalsIgnoreCase ( \"degree_E\" ) || unit . equalsIgnoreCase ( \"degreeE\" ) ) return AxisType . Lon ; \nif ( unit . equalsIgnoreCase ( \"degrees_north\" ) || unit . equalsIgnoreCase ( \"degrees_N\" ) || unit . equalsIgnoreCase ( \"degreesN\" ) || unit . equalsIgnoreCase ( \"degree_north\" ) || unit . equalsIgnoreCase ( \"degree_N\" ) || unit . equalsIgnoreCase ( \"degreeN\" ) ) return AxisType . Lat ; \nif ( SimpleUnit . isDateUnit ( unit ) ) { \nreturn AxisType . Time ; \n} \nif ( SimpleUnit . isCompatible ( \"mbar\" , unit ) ) return AxisType . Pressure ; \nif ( unit . equalsIgnoreCase ( \"level\" ) || unit . equalsIgnoreCase ( \"layer\" ) || unit . equalsIgnoreCase ( \"sigma_level\" ) ) return AxisType . GeoZ ; \nString positive = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . POSITIVE , null ) ; \nif ( positive != null ) { \nif ( ! ( SimpleUnit . isCompatible ( \"m\" , unit ) ) ) return AxisType . GeoZ ; \nelse return AxisType . Height ; \n} \nreturn null ; \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( ! ( bestMatch != null ) ) { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nelse { \ncp = localcreds . get ( bestMatch ) ; \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null && ( httpproxy != null || httpsproxy != null ) ) { \nif ( ! ( httpproxy != null ) ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \nelse proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \nif ( ! ( cp == null && proxycreds != null && proxyscope != null ) ) if ( cp != null && proxycreds != null && proxyscope != null ) { \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nif ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( ! ( r == null ) ) if ( ! ( r . length ( ) != 1 ) ) { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \nelse { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4942": "public class Index { \nIndexIterator getIndexIterator ( Array maa ) { \nif ( ! ( fastIterator ) ) return new IteratorImpl ( maa ) ; \nelse return new IteratorFast ( size , maa ) ; \n} \n} \n"}
{"4947": "public class CoordinateTimeIntv { \npublic String getTimeIntervalName ( ) { \nint firstValue = - 1 ; \nfor ( TimeCoordIntvValue tinv : timeIntervals ) { \nint value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; \nif ( ! ( firstValue < 0 ) ) if ( value != firstValue ) return MIXED_INTERVALS ; \nelse firstValue = value ; \n} \nfirstValue = ( firstValue * timeUnit . getValue ( ) ) ; \nreturn firstValue + \"_\" + timeUnit . getField ( ) . toString ( ) ; \n} \n} \n"}
{"4949": "public class AbstractGempakStationFileReader { \nprotected List < String > makeDateList ( boolean unique ) { \nKey date = dateTimeKeys . get ( 0 ) ; \nKey time = dateTimeKeys . get ( 1 ) ; \nList < int [ ] > toCheck ; \nif ( ! ( date . type . equals ( ROW ) ) ) { \ntoCheck = headers . colHeaders ; \n} \nelse { \ntoCheck = headers . rowHeaders ; \n} \nList < String > fileDates = new ArrayList < > ( ) ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nint idate = header [ date . loc + 1 ] ; \nint itime = header [ time . loc + 1 ] ; \nString dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; \nfileDates . add ( dateTime ) ; \n} \n} \nif ( unique && ! fileDates . isEmpty ( ) ) { \nSortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; \nuniqueTimes . addAll ( fileDates ) ; \nfileDates . clear ( ) ; \nfileDates . addAll ( uniqueTimes ) ; \n} \nreturn fileDates ; \n} \n} \n"}
{"4951": "public class AbstractGempakStationFileReader { \nprivate List < GempakStation > getStationList ( ) { \nKey slat = findKey ( GempakStation . SLAT ) ; \nif ( slat == null ) { \nreturn null ; \n} \nList < int [ ] > toCheck ; \nif ( ! ( slat . type . equals ( ROW ) ) ) { \ntoCheck = headers . colHeaders ; \n} \nelse { \ntoCheck = headers . rowHeaders ; \n} \nList < GempakStation > fileStations = new ArrayList < > ( ) ; \nint i = 0 ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nGempakStation station = makeStation ( header ) ; \nif ( station != null ) { \nstation . setIndex ( i + 1 ) ; \nfileStations . add ( station ) ; \n} \n} \ni ++ ; \n} \nreturn fileStations ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth += n ; \nif ( ! ( depth < 0 ) ) if ( depth > MAXDEPTH ) depth = MAXDEPTH ; \nelse depth = 0 ; \n} \n} \n"}
{"4958": "public class IndentWriter { \npublic void setIndent ( int n ) { \ndepth = n ; \nif ( ! ( depth < 0 ) ) if ( depth > MAXDEPTH ) depth = MAXDEPTH ; \nelse depth = 0 ; \n} \n} \n"}
{"4959": "public class GribIndex { \npublic static GribIndex readOrCreateIndexFromSingleFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType force , org . slf4j . Logger logger ) throws IOException { \nGribIndex index = isGrib1 ? new Grib1Index ( ) : new Grib2Index ( ) ; \nif ( ! ( ! index . readIndex ( mfile . getPath ( ) , mfile . getLastModified ( ) , force ) ) ) if ( debug ) { \nlogger . debug ( \"  Index read: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \n} \nelse { \nindex . makeIndex ( mfile . getPath ( ) , null ) ; \nlogger . debug ( \"  Index written: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \n} \nreturn index ; \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( ! ( null != regexpPatternString ) ) if ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \nelse filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \nif ( olderS != null ) { \ntry { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \n} \nboolean wantSubdirs = true ; \nif ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( \"false\" ) ) wantSubdirs = false ; \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) sb . append ( \"**/\" ) ; \nif ( ! ( null != regexpPatternString ) ) if ( ! ( suffix != null ) ) sb . append ( \"noFilter\" ) ; \nelse sb . append ( suffix ) ; \nelse sb . append ( regexpPatternString ) ; \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \n} \n} \n"}
{"4964": "public class FileWriter2 { \npublic Variable addVariable ( Variable oldVar ) { \nList < Dimension > newDims = getNewDimensions ( oldVar ) ; \nVariable newVar ; \nif ( ! ( ( oldVar . getDataType ( ) . equals ( DataType . STRING ) ) && ( ! version . isExtendedModel ( ) ) ) ) { \nnewVar = writer . addVariable ( null , oldVar . getShortName ( ) , oldVar . getDataType ( ) , newDims ) ; \n} \nelse { \nnewVar = writer . addStringVariable ( null , oldVar , newDims ) ; \n} \nvarMap . put ( oldVar , newVar ) ; \nvarList . add ( oldVar ) ; \nfor ( Attribute orgAtt : oldVar . getAttributes ( ) ) writer . addVariableAttribute ( newVar , convertAttribute ( orgAtt ) ) ; \nreturn newVar ; \n} \n} \n"}
{"4965": "public class FileWriter2 { \npublic NetcdfFile write ( CancelTask cancel ) throws IOException { \ntry { \nif ( ! ( version . isExtendedModel ( ) ) ) addGroupClassic ( ) ; \nelse addGroupExtended ( null , fileIn . getRootGroup ( ) ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . create ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \ndouble total = copyVarData ( varList , null , cancel ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . flush ( ) ; \nif ( debug ) System . out . println ( \"FileWriter done total bytes = \" + total ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nwriter . abort ( ) ; \nthrow ioe ; \n} \nreturn writer . getNetcdfFile ( ) ; \n} \n} \n"}
{"4967": "public class MultiSlice { \n@ Override public String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( \"[\" ) ; \nboolean first = true ; \nfor ( Slice sub : this . subslices ) { \nif ( ! first ) buf . append ( \",\" ) ; \nfirst = false ; \nif ( ! ( ( sub . stop - sub . first ) == 0 ) ) if ( ! ( sub . stride == 1 ) ) buf . append ( String . format ( \"%d:%d:%d\" , sub . first , sub . stride , sub . stop - 1 ) ) ; \nelse { \nif ( ! ( ( sub . stop - sub . first ) == 1 ) ) buf . append ( String . format ( \"%d:%d\" , sub . first , sub . stop - 1 ) ) ; \nelse buf . append ( sub . first ) ; \n} \nelse { \nbuf . append ( \"0\" ) ; \n} \n} \nbuf . append ( \"]\" ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4969": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , CancelTask cancelTask ) throws IOException { \nArray result ; \nif ( ! ( hasCachedData ( ) ) ) if ( ! ( orgVar != null ) ) { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \nelse result = orgVar . read ( ) ; \nelse result = super . reallyRead ( client , cancelTask ) ; \nreturn convert ( result , null ) ; \n} \n} \n"}
{"4970": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nif ( section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nArray result ; \nif ( ! ( hasCachedData ( ) ) ) if ( ! ( orgVar != null ) ) { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \nelse result = orgVar . read ( section ) ; \nelse result = super . reallyRead ( client , section , cancelTask ) ; \nreturn convert ( result , section ) ; \n} \n} \n"}
{"4971": "public class StructureDS { \nprivate boolean convertNeeded ( StructureMembers smData ) { \nfor ( Variable v : getVariables ( ) ) { \nif ( ! ( v instanceof VariableDS ) ) if ( v instanceof StructureDS ) { \nStructureDS nested = ( StructureDS ) v ; \nif ( nested . convertNeeded ( null ) ) return true ; \n} \nelse { \nVariableDS vds = ( VariableDS ) v ; \nif ( vds . needConvert ( ) ) return true ; \n} \nif ( ( smData != null ) && ! varHasData ( v , smData ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( ! ( v2 instanceof VariableDS ) ) if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( ! ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \nelse { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \nelse { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nint vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( ! ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) ) if ( pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nelse { \nif ( ! ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) ) if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \n} \nelse { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \n} \n} \n} \n"}
{"4988": "public class DerivedUnitImpl { \n@ Override protected Unit myMultiplyBy ( final Unit that ) throws MultiplyException { \nUnit result ; \nif ( ! ( dimension . getRank ( ) == 0 ) ) { \nif ( ! ( ! ( that instanceof DerivedUnit ) ) ) { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . multiplyBy ( thatDimension ) ) ; \n} \nelse { \nresult = that . multiplyBy ( this ) ; \n} \n} \nelse { \nresult = that ; \n} \nreturn result ; \n} \n} \n"}
{"4989": "public class DerivedUnitImpl { \n@ Override protected Unit myDivideBy ( final Unit that ) throws OperationException { \nUnit result ; \nif ( ! ( dimension . getRank ( ) == 0 ) ) { \nif ( ! ( ! ( that instanceof DerivedUnit ) ) ) { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . divideBy ( thatDimension ) ) ; \n} \nelse { \nresult = that . divideInto ( this ) ; \n} \n} \nelse { \nresult = that . raiseTo ( - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"4992": "public class GMLFeatureWriter { \npublic String writeFeature ( SimpleGeometry geom ) { \nif ( ! ( geom instanceof Point ) ) if ( ! ( geom instanceof Line ) ) if ( ! ( geom instanceof Polygon ) ) return null ; \nelse return writePolygon ( ( Polygon ) geom ) ; \nelse return writeLine ( ( Line ) geom ) ; \nelse return writePoint ( ( Point ) geom ) ; \n} \n} \n"}
{"4995": "public class GMLFeatureWriter { \nprivate String writePolygon ( Polygon poly ) { \nString xml = \"\" ; \nxml += \"<gml:Polygon>\" ; \nPolygon polygon = poly ; \nif ( ! ( ! polygon . getInteriorRing ( ) ) ) { \nxml += \"<gml:interior><gml:LinearRing><gml:posList>\" ; \nfor ( Point point : polygon . getPoints ( ) ) { \nxml += point . getX ( ) + \" \" + point . getY ( ) + \" \" ; \n} \nxml += \"</gml:posList></gml:LinearRing></gml:interior>\" ; \n} \nelse { \nxml += \"<gml:exterior><gml:LinearRing><gml:posList>\" ; \nfor ( Point point : polygon . getPoints ( ) ) { \nxml += point . getX ( ) + \" \" + point . getY ( ) + \" \" ; \n} \nxml += \"</gml:posList></gml:LinearRing></gml:exterior>\" ; \n} \nxml += \"</gml:Polygon>\" ; \nreturn xml ; \n} \n} \n"}
{"4998": "public class DOM4Parser { \nprotected void parseresponse ( Node root ) throws ParseException { \nString elemname = root . getNodeName ( ) ; \nif ( ! ( elemname . equalsIgnoreCase ( \"Error\" ) ) ) if ( ! ( elemname . equalsIgnoreCase ( \"Dataset\" ) ) ) throw new ParseException ( \"Unexpected response root: \" + elemname ) ; \nelse { \nparsedataset ( root ) ; \n} \nelse { \nparseerror ( root ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) ) { \nif ( ! ( beginInd < 0 || endInd < 0 ) ) subStr += ( beginInd + \":\" + endInd ) ; \nelse subStr += \":\" ; \n} \nelse { \nsubStr += id ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5001": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { \nif ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; \nif ( from . getSize ( ) > 0 ) { \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nto . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; \n} \nreturn to ; \n} \nint numRecords = - 1 ; \nMap < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nArray array = from . extractMemberArray ( m ) ; \nassert array . getSize ( ) > 0 : \"array's size should have been computed in extractMemberArray().\" ; \nint firstDimLen = array . getShape ( ) [ 0 ] ; \nif ( ! ( numRecords == - 1 ) ) { \nassert numRecords == firstDimLen : String . format ( \"Expected all structure members to have the same first\" + \"dimension length, but %d != %d.\" , numRecords , firstDimLen ) ; \n} \nelse { \nnumRecords = firstDimLen ; \n} \nmemberArrayMap . put ( m . getName ( ) , array ) ; \n} \nint [ ] shape ; \nif ( ! ( numRecords == - 1 ) ) { \nshape = new int [ ] { \nnumRecords } \n; \n} \nelse { \nshape = new int [ ] { \n0 } \n; \n} \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; \nfor ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { \nto . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn to ; \n} \n} \n"}
{"5003": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( Structure from , int [ ] shape ) throws IOException { \nStructureMembers sm = from . makeStructureMembers ( ) ; \nfor ( Variable v : from . getVariables ( ) ) { \nArray data ; \nif ( ! ( v instanceof Sequence ) ) if ( ! ( v instanceof Structure ) ) data = Array . factory ( v . getDataType ( ) , combine ( shape , v . getShape ( ) ) ) ; \nelse data = ArrayStructureMA . factoryMA ( ( Structure ) v , combine ( shape , v . getShape ( ) ) ) ; \nelse { \ndata = Array . factory ( DataType . SEQUENCE , shape ) ; \n} \nStructureMembers . Member m = sm . findMember ( v . getShortName ( ) ) ; \nm . setDataArray ( data ) ; \n} \nreturn new ArrayStructureMA ( sm , shape ) ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) return ; \nif ( ! ( expr . sort == CEAST . Sort . SEGMENT ) ) if ( ! ( expr . sort == CEAST . Sort . EXPR ) ) if ( ! ( expr . sort == CEAST . Sort . CONSTANT ) ) throw new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \nelse { \nreturn ; \n} \nelse { \nif ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; \nif ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; \nif ( expr . lhs != null && expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar && ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \nelse { \nif ( expr . subnodes != null ) throw new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) throw new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \nexpr . field = field ; \n} \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( ! ( allLongitude ) ) if ( ! ( crossDateline ) ) { \nif ( ! ( lon > upperRight . getLongitude ( ) ) ) if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( ! ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse { \nif ( ! ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) ) { \nupperRight . setLongitude ( lon ) ; \n} \nelse { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nelse { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( ! ( d1 > d2 ) ) { \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nelse { \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5012": "public class LatLonRect { \npublic void extend ( LatLonRect r ) { \nPreconditions . checkNotNull ( r ) ; \ndouble latMin = r . getLatMin ( ) ; \ndouble latMax = r . getLatMax ( ) ; \nif ( latMax > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( latMax ) ; \n} \nif ( latMin < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( latMin ) ; \n} \nif ( allLongitude ) return ; \ndouble lonMin = getLonMin ( ) ; \ndouble lonMax = getLonMax ( ) ; \ndouble nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; \ndouble nlonMax = nlonMin + r . getWidth ( ) ; \nlonMin = Math . min ( lonMin , nlonMin ) ; \nlonMax = Math . max ( lonMax , nlonMax ) ; \nwidth = lonMax - lonMin ; \nallLongitude = width >= 360.0 ; \nif ( ! ( allLongitude ) ) { \nlonMin = LatLonPointImpl . lonNormal ( lonMin ) ; \n} \nelse { \nwidth = 360.0 ; \nlonMin = - 180.0 ; \n} \nlowerLeft . setLongitude ( lonMin ) ; \nupperRight . setLongitude ( lonMin + width ) ; \nlon0 = lonMin + width / 2 ; \ncrossDateline = lowerLeft . getLongitude ( ) > upperRight . getLongitude ( ) ; \n} \n} \n"}
{"5014": "public class MAMath { \npublic static Array add ( Array a , Array b ) throws IllegalArgumentException { \nArray result = Array . factory ( a . getDataType ( ) , a . getShape ( ) ) ; \nif ( ! ( a . getElementType ( ) == double . class ) ) throw new UnsupportedOperationException ( ) ; \nelse { \naddDouble ( result , a , b ) ; \n} \nreturn result ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nwhile ( dimB < rankB ) if ( ! ( shapeB [ dimB ] == 1 ) ) break ; \nelse dimB ++ ; \nif ( aShapeA != shapeB [ dimB ] ) return false ; \ndimB ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5018": "public class MAMath { \npublic static void copy ( Array result , Array a ) throws IllegalArgumentException { \nClass classType = a . getElementType ( ) ; \nif ( ! ( classType == double . class ) ) if ( ! ( classType == float . class ) ) if ( ! ( classType == long . class ) ) if ( ! ( classType == int . class ) ) if ( ! ( classType == short . class ) ) if ( ! ( classType == char . class ) ) if ( ! ( classType == byte . class ) ) if ( ! ( classType == boolean . class ) ) copyObject ( result , a ) ; \nelse { \ncopyBoolean ( result , a ) ; \n} \nelse { \ncopyByte ( result , a ) ; \n} \nelse { \ncopyChar ( result , a ) ; \n} \nelse { \ncopyShort ( result , a ) ; \n} \nelse { \ncopyInt ( result , a ) ; \n} \nelse { \ncopyLong ( result , a ) ; \n} \nelse { \ncopyFloat ( result , a ) ; \n} \nelse { \ncopyDouble ( result , a ) ; \n} \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( ! ( x == null ) ) if ( reservedChars == null ) { \nreturn x ; \n} \nelse { \nreturn null ; \n} \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \nif ( ! ( _allowableInDAP . indexOf ( c ) < 0 ) ) buf . append ( c ) ; \nelse { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5033": "public class Nc4Cursor { \nprotected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { \nDapVariable atomvar = ( DapVariable ) getTemplate ( ) ; \nNc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; \nint ret ; \nDapType basetype = ti . getType ( ) ; \nObject result = null ; \nif ( ! ( basetype . isFixedSize ( ) ) ) if ( ! ( basetype . isStringType ( ) ) ) if ( ! ( basetype . isOpaqueType ( ) ) ) throw new DapException ( \"Unexpected atomic type: \" + basetype ) ; \nelse { \nNc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; \nbuf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; \nresult = buf ; \n} \nelse { \nString [ ] s = new String [ 1 ] ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; \nresult = s ; \n} \nelse { \nlong memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; \nNc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nresult = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; \n} \nreturn result ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( ! ( comp < 0 ) ) if ( ! ( comp == 0 ) ) { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \nelse { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( ! ( power == 0 ) ) { \nfactors = getFactors ( ) ; \nif ( power != 1 ) { \nfor ( int i = factors . length ; \n-- i >= 0 ; \n) { \nfactors [ i ] = factors [ i ] . pow ( power ) ; \n} \n} \n} \nelse { \nfactors = new Factor [ 0 ] ; \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( ! ( theseFactors . length != thoseFactors . length ) ) { \nint i ; \nfor ( i = theseFactors . length ; \n-- i >= 0 ; \n) { \nif ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { \nbreak ; \n} \n} \nisReciprocalOf = i < 0 ; \n} \nelse { \nisReciprocalOf = false ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5076": "public class DoradeDescriptor { \nprotected float grabFloat ( byte [ ] bytes , int offset ) throws DescriptorException { \ntry { \nbyte [ ] src ; \nif ( ! ( littleEndianData ) ) { \nsrc = bytes ; \n} \nelse { \nsrc = new byte [ 4 ] ; \nsrc [ 0 ] = bytes [ offset + 3 ] ; \nsrc [ 1 ] = bytes [ offset + 2 ] ; \nsrc [ 2 ] = bytes [ offset + 1 ] ; \nsrc [ 3 ] = bytes [ offset ] ; \noffset = 0 ; \n} \nDataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 4 ) ) ; \nreturn stream . readFloat ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new DescriptorException ( ex ) ; \n} \n} \n} \n"}
{"5077": "public class DoradeDescriptor { \nprotected double grabDouble ( byte [ ] bytes , int offset ) throws DescriptorException { \ntry { \nbyte [ ] src ; \nif ( ! ( littleEndianData ) ) { \nsrc = bytes ; \n} \nelse { \nsrc = new byte [ 8 ] ; \nsrc [ 0 ] = bytes [ offset + 7 ] ; \nsrc [ 1 ] = bytes [ offset + 6 ] ; \nsrc [ 2 ] = bytes [ offset + 5 ] ; \nsrc [ 3 ] = bytes [ offset + 4 ] ; \nsrc [ 4 ] = bytes [ offset + 3 ] ; \nsrc [ 5 ] = bytes [ offset + 2 ] ; \nsrc [ 6 ] = bytes [ offset + 1 ] ; \nsrc [ 7 ] = bytes [ offset ] ; \noffset = 0 ; \n} \nDataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 8 ) ) ; \nreturn stream . readDouble ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new DescriptorException ( ex ) ; \n} \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) System . out . println ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( ! ( dataProject == null ) ) if ( ! ( dataProject . isLatLon ( ) ) ) if ( ! ( dataProject == displayProject ) ) { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nelse { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse shape = feature . getShape ( ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( ! ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) ) if ( ! ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) ) { \nlookingFor = 0 ; \n} \nelse { \nlookingFor = 1 ; \n} \nelse { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5089": "public class HeaderInputStream { \npublic long skip ( long n ) { \nif ( ! ( bytesRemaining >= n ) ) { \nint oldBytesRemaining = bytesRemaining ; \nbytesRemaining = 0 ; \nreturn oldBytesRemaining ; \n} \nelse { \nbytesRemaining -= n ; \nreturn n ; \n} \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( ! ( usesBounds ) ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \nfor ( int i = 0 ; \nisgridarray && i < rank ; \ni ++ ) { \nDimension dim = dimset . get ( i ) ; \nif ( ! ( dim . getShortName ( ) == null ) ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \nelse isgridarray = false ; \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5097": "public class NcDDS { \nprivate BaseType createVariable ( NetcdfFile ncfile , Variable v ) { \nBaseType bt ; \nif ( ! ( v . getRank ( ) == 0 ) ) if ( ! ( v . getDataType ( ) == DataType . CHAR ) ) if ( ! ( v . getDataType ( ) == DataType . STRING ) ) bt = createArray ( ncfile , v ) ; \nelse { \nif ( ! ( v . getRank ( ) == 0 ) ) bt = new NcSDArray ( v , new NcSDString ( v ) ) ; \nelse bt = new NcSDString ( v ) ; \n} \nelse { \nif ( ! ( v . getRank ( ) > 1 ) ) bt = new NcSDString ( v ) ; \nelse bt = new NcSDCharArray ( v ) ; \n} \nelse bt = createScalarVariable ( ncfile , v ) ; \nreturn bt ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . println ( \"  newBounds = \" + b ) ; \nif ( ! ( ( b . width > 0 ) && ( b . height > 0 ) ) ) { \nbImage = null ; \n} \nelse { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5114": "public class GradsDataDescriptorFile { \nprivate void swapByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( ! ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) ) { \nbigEndian = false ; \n} \nelse { \nbigEndian = true ; \n} \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! ( ! isTemplate ( ) ) ) { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( ! ( GradsTimeDimension . hasTimeTemplate ( template ) ) ) { \nif ( ! ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) ) { \ntemplateType = TIME_TEMPLATE ; \n} \nelse { \ntemplateType = ENS_TEMPLATE ; \n} \n} \nelse { \nif ( ! ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) ) { \ntemplateType = TIME_TEMPLATE ; \n} \nelse { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \n} \nif ( ! ( templateType == ENS_TEMPLATE ) ) if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nelse { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nfileNames . addAll ( fileSet ) ; \n} \nelse { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5119": "public class GradsDataDescriptorFile { \nprivate String getFullPath ( String filename ) { \nString file ; \nString ddfPath = getDDFPath ( ) ; \nif ( ! ( filename . startsWith ( \"^\" ) ) ) { \nFile f = new File ( filename ) ; \nif ( ! ( ! f . isAbsolute ( ) ) ) { \nfile = filename ; \n} \nelse { \nfile = ddfPath + filename ; \n} \n} \nelse { \nfile = filename . replace ( \"^\" , \"\" ) ; \nfile = ddfPath + file ; \n} \nreturn file ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( ! ( pib . indexOf ( \"SDUS\" ) != - 1 ) ) if ( ! ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) ) return 0 ; \nelse { \nnoHeader = true ; \nreturn 1 ; \n} \nelse { \nnoHeader = false ; \nreturn 1 ; \n} \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \nfor ( int i = 0 ; \ni < nlevel ; \ni ++ ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ! ( ( ival & 0x00008000 ) == 0 ) ) { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \nelse { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5133": "public class Nidsheader { \nvoid addParameter ( String pName , String longName , NetcdfFile nc , ArrayList dims , Attribute att , DataType dtype , String ut , long hoff , long doff , boolean isZ , int y0 ) { \nString vName = pName ; \nVariable vVar = new Variable ( nc , null , null , vName ) ; \nvVar . setDataType ( dtype ) ; \nif ( ! ( dims != null ) ) vVar . setDimensions ( \"\" ) ; \nelse vVar . setDimensions ( dims ) ; \nif ( att != null ) vVar . addAttribute ( att ) ; \nvVar . addAttribute ( new Attribute ( CDM . UNITS , ut ) ) ; \nvVar . addAttribute ( new Attribute ( CDM . LONG_NAME , longName ) ) ; \nnc . addVariable ( null , vVar ) ; \nvVar . setSPobject ( new Vinfo ( numX , numX0 , numY , y0 , hoff , doff , isR , isZ , null , null , 0 , 0 ) ) ; \n} \n} \n"}
{"5137": "public class Nidsheader { \nprotected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { \nif ( dataType == DataType . BYTE ) { \nreturn barray ; \n} \nif ( dataType == DataType . CHAR ) { \nreturn IospHelper . convertByteToChar ( barray ) ; \n} \nByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; \nif ( byteOrder >= 0 ) bbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; \nif ( ! ( dataType == DataType . SHORT ) ) if ( ! ( dataType == DataType . INT ) ) if ( ! ( dataType == DataType . FLOAT ) ) if ( dataType == DataType . DOUBLE ) { \nDoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; \ndouble [ ] pa = new double [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nFloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; \nfloat [ ] pa = new float [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nIntBuffer tbuff = bbuff . asIntBuffer ( ) ; \nint [ ] pa = new int [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nShortBuffer tbuff = bbuff . asShortBuffer ( ) ; \nshort [ ] pa = new short [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"5138": "public class DapController { \nprotected void doDMR ( DapRequest drq , DapContext cxt ) throws IOException { \nString realpath = getResourcePath ( drq , drq . getDatasetPath ( ) ) ; \nDSP dsp = DapCache . open ( realpath , cxt ) ; \nDapDataset dmr = dsp . getDMR ( ) ; \nByteOrder order = ( ByteOrder ) cxt . get ( Dap4Util . DAP4ENDIANTAG ) ; \nsetEndianness ( dmr , order ) ; \nCEConstraint ce = null ; \nString sce = drq . queryLookup ( DapProtocol . CONSTRAINTTAG ) ; \nce = CEConstraint . compile ( sce , dmr ) ; \nsetConstraint ( dmr , ce ) ; \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter pw = new PrintWriter ( sw ) ; \nDMRPrinter dapprinter = new DMRPrinter ( dmr , ce , pw , drq . getFormat ( ) ) ; \nif ( ! ( cxt . get ( Dap4Util . DAP4TESTTAG ) != null ) ) dapprinter . print ( ) ; \nelse dapprinter . testprint ( ) ; \npw . close ( ) ; \nsw . close ( ) ; \nString sdmr = sw . toString ( ) ; \nif ( DEBUG ) System . err . println ( \"Sending: DMR:\\n\" + sdmr ) ; \naddCommonHeaders ( drq ) ; \nOutputStream out = drq . getOutputStream ( ) ; \nChunkWriter cw = new ChunkWriter ( out , RequestMode . DMR , order ) ; \ncw . cacheDMR ( sdmr ) ; \ncw . close ( ) ; \n} \n} \n"}
{"5140": "public class DapController { \nprotected void senderror ( DapRequest drq , int httpcode , Throwable t ) throws IOException { \nif ( httpcode == 0 ) httpcode = HttpServletResponse . SC_BAD_REQUEST ; \nErrorResponse err = new ErrorResponse ( ) ; \nerr . setCode ( httpcode ) ; \nif ( ! ( t == null ) ) { \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter p = new PrintWriter ( sw ) ; \nt . printStackTrace ( p ) ; \np . close ( ) ; \nsw . close ( ) ; \nerr . setMessage ( sw . toString ( ) ) ; \n} \nelse { \nerr . setMessage ( \"Servlet error: \" + drq . getURL ( ) ) ; \n} \nerr . setContext ( drq . getURL ( ) ) ; \nString errormsg = err . buildXML ( ) ; \ndrq . getResponse ( ) . sendError ( httpcode , errormsg ) ; \n} \n} \n"}
{"5142": "public class Rubberband { \npublic void stretch ( Point p ) { \nlastPt . x = stretchedPt . x ; \nlastPt . y = stretchedPt . y ; \nstretchedPt . x = p . x ; \nstretchedPt . y = p . y ; \nGraphics2D g = ( Graphics2D ) component . getGraphics ( ) ; \nif ( g != null ) { \ntry { \ng . setXORMode ( component . getBackground ( ) ) ; \nif ( ! ( firstStretch == true ) ) drawLast ( g ) ; \nelse firstStretch = false ; \ndrawNext ( g ) ; \n} \nfinally { \ng . dispose ( ) ; \n} \n} \n} \n} \n"}
{"5158": "public class LambertConformal { \npublic String toWKS ( ) { \nStringBuilder sbuff = new StringBuilder ( ) ; \nsbuff . append ( \"PROJCS[\\\"\" ) . append ( getName ( ) ) . append ( \"\\\",\" ) ; \nif ( ! ( true ) ) { \nsbuff . append ( \"GEOGCS[\\\"WGS 84\\\",\" ) ; \nsbuff . append ( \"DATUM[\\\"WGS_1984\\\",\" ) ; \nsbuff . append ( \"SPHEROID[\\\"WGS 84\\\",6378137,298.257223563],\" ) ; \nsbuff . append ( \"TOWGS84[0,0,0,0,0,0,0]],\" ) ; \n} \nelse { \nsbuff . append ( \"GEOGCS[\\\"Normal Sphere (r=6371007)\\\",\" ) ; \nsbuff . append ( \"DATUM[\\\"unknown\\\",\" ) ; \nsbuff . append ( \"SPHEROID[\\\"sphere\\\",6371007,0]],\" ) ; \n} \nsbuff . append ( \"PRIMEM[\\\"Greenwich\\\",0],\" ) ; \nsbuff . append ( \"UNIT[\\\"degree\\\",0.0174532925199433]],\" ) ; \nsbuff . append ( \"PROJECTION[\\\"Lambert_Conformal_Conic_1SP\\\"],\" ) ; \nsbuff . append ( \"PARAMETER[\\\"latitude_of_origin\\\",\" ) . append ( getOriginLat ( ) ) . append ( \"],\" ) ; \nsbuff . append ( \"PARAMETER[\\\"central_meridian\\\",\" ) . append ( getOriginLon ( ) ) . append ( \"],\" ) ; \nsbuff . append ( \"PARAMETER[\\\"scale_factor\\\",1],\" ) ; \nsbuff . append ( \"PARAMETER[\\\"false_easting\\\",\" ) . append ( falseEasting ) . append ( \"],\" ) ; \nsbuff . append ( \"PARAMETER[\\\"false_northing\\\",\" ) . append ( falseNorthing ) . append ( \"],\" ) ; \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) wrt = ENTITYESCAPES ; \nStringBuilder escaped = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nint index = wrt . indexOf ( c ) ; \nif ( ! ( index < 0 ) ) switch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( c >= ' ' ) escaped . append ( c ) ; \nbreak ; \n} \nelse escaped . append ( c ) ; \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \n) { \nchar c = s . charAt ( i ++ ) ; \nif ( ! ( c == '\\\\' ) ) clear . append ( c ) ; \nelse { \nc = s . charAt ( i ++ ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \ni <= len - 1 ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! ( c == '\\\\' && i < ( len - 1 ) ) ) if ( ! ( c == sep ) ) piece . append ( c ) ; \nelse { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5163": "public class LogCategorizer { \nstatic public String getServiceSpecial ( String path ) { \nString ss = null ; \nif ( ! ( path . startsWith ( \"/dqcServlet\" ) ) ) if ( path . startsWith ( \"/cdmvalidator\" ) ) ss = \"cdmvalidator\" ; \nelse ss = \"dqcServlet\" ; \nreturn ss ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nint comp ; \nif ( ! ( constrained ) ) { \ncomp = 1 + mapVars . size ( ) ; \n} \nelse { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nif ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; \n} \n} \nreturn comp ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( ! ( idMap . contains ( id ) ) ) { \nidMap . add ( id ) ; \n} \nelse { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ! ( ds instanceof CatalogRef ) ) { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \nelse { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( ! ( href . startsWith ( contextPathPlus ) ) ) if ( ! ( href . startsWith ( \"/\" ) ) ) { \npath = dirPath + href ; \n} \nelse { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \n} \n} \n} \n"}
{"5186": "public class BaseQuantity { \npublic int compareTo ( final BaseQuantity that ) { \nint comp ; \nif ( ! ( this == that ) ) { \ncomp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; \nif ( comp == 0 && getSymbol ( ) != null ) { \ncomp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; \n} \n} \nelse { \ncomp = 0 ; \n} \nreturn comp ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( ! ( code >= 0x01 && code <= 0x7F ) ) if ( ! ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) ) { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ! ( ( b & 0x80 ) == 0 ) ) if ( ! ( ( b & 0xE0 ) != 0xE0 ) ) buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \nelse { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( b & 0x7F ) ; \n} \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( ! ( useThreads && ( modelIndex [ i ] == threadCol ) ) ) tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \nelse { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( ! ( state ) ) acts [ colno ] . hideColumn ( ) ; \nelse acts [ colno ] . addAtPos ( pos ) ; \n} \n} \n"}
{"5224": "public class DatasetBuilder { \npublic void transferMetadata ( DatasetNode from , boolean parentsAlso ) { \nif ( parentsAlso ) { \nThreddsMetadata inherit = getInheritableMetadata ( ) ; \ninheritMetadata ( from , inherit . getFlds ( ) ) ; \n} \nfor ( Map . Entry < String , Object > entry : from . getFldIterator ( ) ) { \nif ( parentsAlso && entry . getKey ( ) . equals ( Dataset . ThreddsMetadataInheritable ) ) continue ; \nif ( ! ( Dataset . listFlds . contains ( entry . getKey ( ) ) ) ) flds . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \nelse addToNewList ( flds , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nThreddsMetadata tmiOld = ( ThreddsMetadata ) get ( Dataset . ThreddsMetadataInheritable ) ; \nif ( tmiOld != null && tmiOld . isImmutable ( ) ) { \nThreddsMetadata tmiNew = new ThreddsMetadata ( tmiOld ) ; \nflds . put ( Dataset . ThreddsMetadataInheritable , tmiNew ) ; \n} \n} \n} \n"}
{"5229": "public class GridVariable { \npublic GridRecord findRecord ( int ens , int time , int level ) { \nif ( ! ( hasEnsemble ( ) ) ) { \nreturn recordTracker [ time * nlevels + level ] ; \n} \nelse { \nreturn recordTracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; \n} \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < nlats ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \ni < nyRaw ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( ! ( goesUp ) ) { \nuseIndex -- ; \n} \nelse { \nuseIndex ++ ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( ! ( pos1 < 0 ) ) { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nelse { \nvarNameEsc = selector ; \n} \nif ( debugSelector ) System . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \nVariable v = null ; \nif ( ! ( parent instanceof NetcdfFile ) ) if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nelse { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( ! ( indexSelect != null ) ) { \nsection = v . getShapeAsSection ( ) ; \n} \nelse { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5241": "public class HTTPMethod { \npublic synchronized void close ( ) { \nif ( closed ) return ; \nclosed = true ; \nif ( methodstream != null ) { \ntry { \nthis . methodstream . close ( ) ; \n} \ncatch ( IOException ioe ) { \n} \nthis . methodstream = null ; \n} \nif ( this . lastresponse != null ) { \nif ( ! ( false ) ) HttpClientUtils . closeQuietly ( this . lastresponse ) ; \nelse { \ntry { \ntry { \nEntityUtils . consume ( this . lastresponse . getEntity ( ) ) ; \n} \nfinally { \nHttpClientUtils . closeQuietly ( this . lastresponse ) ; \n} \n} \ncatch ( IOException ignore ) { \n} \n} \nthis . lastresponse = null ; \n} \nif ( session != null ) { \nsession . removeMethod ( this ) ; \nif ( localsession ) { \nsession . close ( ) ; \nsession = null ; \n} \n} \nthis . lastrequest = null ; \n} \n} \n"}
{"5242": "public class HTTPMethod { \npublic int execute ( ) throws HTTPException { \nHttpResponse res = executeRaw ( ) ; \nif ( ! ( res != null ) ) throw new HTTPException ( \"HTTPMethod.execute: null response\" ) ; \nelse return res . getStatusLine ( ) . getStatusCode ( ) ; \n} \n} \n"}
{"5243": "public class CFpointObs { \nprotected boolean identifyEncodingStation ( NetcdfDataset ds , EncodingInfo info , CF . FeatureType ftype , Formatter errlog ) { \nDimension obsDim = null ; \nif ( ! ( info . time . getRank ( ) > 0 ) ) if ( info . time . getParentStructure ( ) != null ) { \nStructure parent = info . time . getParentStructure ( ) ; \nobsDim = parent . getDimension ( parent . getRank ( ) - 1 ) ; \n} \nelse obsDim = info . time . getDimension ( info . time . getRank ( ) - 1 ) ; \nif ( obsDim == null ) { \nerrlog . format ( \"CFpointObs: must have a non-scalar Time coordinate%n\" ) ; \nreturn false ; \n} \nif ( info . lat . getRank ( ) == 0 ) { \ninfo . set ( Encoding . single , null , obsDim ) ; \nreturn true ; \n} \nDimension stnDim = info . lat . getDimension ( 0 ) ; \nif ( obsDim == stnDim ) { \ninfo . set ( Encoding . flat , null , obsDim ) ; \nreturn true ; \n} \nif ( identifyRaggeds ( ds , info , stnDim , obsDim , errlog ) ) return true ; \nif ( info . lat . getRank ( ) == 1 ) { \ninfo . set ( Encoding . multidim , stnDim , obsDim ) ; \nreturn true ; \n} \nerrlog . format ( \"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\" , ftype ) ; \nreturn false ; \n} \n} \n"}
{"5246": "public class CBZip2InputStream { \npublic int read ( ) { \nif ( ! ( streamEnd ) ) { \nint retChar = currentChar ; \nswitch ( currentState ) { \ncase START_BLOCK_STATE : break ; \ncase RAND_PART_A_STATE : break ; \ncase RAND_PART_B_STATE : setupRandPartB ( ) ; \nbreak ; \ncase RAND_PART_C_STATE : setupRandPartC ( ) ; \nbreak ; \ncase NO_RAND_PART_A_STATE : break ; \ncase NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; \nbreak ; \ncase NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; \nbreak ; \ndefault : break ; \n} \nreturn retChar ; \n} \nelse { \nreturn - 1 ; \n} \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( ! ( pm . isCanceled ( ) ) ) { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nelse { \ntask . cancel ( ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( ! ( task . isSuccess ( ) ) ) if ( ! ( task . isError ( ) ) ) if ( ! ( task . isCancel ( ) ) ) fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nint i = 0 ; \nwhile ( i < u . length ( ) ) { \nchar c = u . charAt ( i ) ; \nif ( ! ( c == '\\\\' ) ) buf . append ( c ) ; \nelse { \nif ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \nbuf . append ( \"%5c\" ) ; \ni ++ ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \ni ++ ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( suffix == null ) suffix = \"\" ; \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nint prelen = prefix . length ( ) ; \nif ( prelen > 0 && result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen ++ ; \n} \nif ( ! ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) ) result . append ( suffix ) ; \nelse result . append ( suffix . substring ( 1 ) ) ; \nint len = result . length ( ) ; \nif ( len > 0 && result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5258": "public class BitCounterCompressed { \npublic int ncounters ( ) { \nif ( ! ( nested == null ) ) { \nint ncounters = 0 ; \nfor ( BitCounterCompressed [ ] counters : nested ) { \nif ( counters == null ) continue ; \nfor ( BitCounterCompressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; \n} \nreturn ncounters ; \n} \nelse return 1 ; \n} \n} \n"}
{"5267": "public class GempakSurfaceFileReader { \nprotected void makeFileSubType ( ) { \nKey key = findKey ( GempakStation . SLAT ) ; \nif ( key == null ) throw new IllegalStateException ( \"File does not have key=\" + GempakStation . SLAT ) ; \nString latType = key . type ; \nKey dateKey = findKey ( DATE ) ; \nif ( ! ( dateKey != null && ! dateKey . type . equals ( latType ) ) ) { \nsubType = SHIP ; \n} \nelse { \nif ( ! ( latType . equals ( ROW ) ) ) { \nsubType = STANDARD ; \n} \nelse { \nsubType = CLIMATE ; \n} \n} \n} \n} \n"}
{"5268": "public class WFSGetFeatureWriter { \nprivate void writeHeadersAndBB ( ) { \nfileOutput += \"<wfs:FeatureCollection xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" + namespace + \" \" + server + \"?request=DescribeFeatureType\" + WFSXMLHelper . AMPERSAND + \"service=wfs\" + WFSXMLHelper . AMPERSAND + \"version=2.0.0\" + WFSXMLHelper . AMPERSAND + \"typename=\" + WFSController . TDSNAMESPACE + \"%3A\" + ftName ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml/3.2\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:wfs=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/wfs/2.0\" ) + \" xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\" numberMatched=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \" numberReturned=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \">\" ; \ndouble [ ] boundLower ; \ndouble [ ] boundUpper ; \nif ( ! ( geometries . isEmpty ( ) ) ) { \nboundLower = geometries . get ( 0 ) . getBBLower ( ) ; \nboundUpper = geometries . get ( 0 ) . getBBUpper ( ) ; \n} \nelse { \nboundLower = new double [ 2 ] ; \nboundUpper = new double [ 2 ] ; \nboundLower [ 0 ] = - 180 ; \nboundLower [ 1 ] = - 90 ; \nboundUpper [ 0 ] = 180 ; \nboundUpper [ 1 ] = 90 ; \n} \nfor ( SimpleGeometry item : geometries ) { \ndouble [ ] low = item . getBBLower ( ) ; \nif ( boundLower [ 0 ] > low [ 0 ] ) boundLower [ 0 ] = low [ 0 ] ; \nif ( boundLower [ 1 ] > low [ 1 ] ) boundLower [ 1 ] = low [ 1 ] ; \ndouble [ ] upper = item . getBBUpper ( ) ; \nif ( boundUpper [ 0 ] < upper [ 0 ] ) boundUpper [ 0 ] = upper [ 0 ] ; \nif ( boundUpper [ 1 ] < upper [ 1 ] ) boundUpper [ 1 ] = upper [ 1 ] ; \nboundLower [ 0 ] -= 10 ; \nboundLower [ 1 ] -= 10 ; \nboundUpper [ 0 ] += 10 ; \nboundUpper [ 1 ] += 10 ; \n} \nfileOutput += \"<wfs:boundedBy>\" + \"<wfs:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<wfs:lowerCorner>\" + boundLower [ 0 ] + \" \" + boundLower [ 1 ] + \"</wfs:lowerCorner>\" + \"<wfs:upperCorner>\" + boundUpper [ 0 ] + \" \" + boundUpper [ 1 ] + \"</wfs:upperCorner>\" + \"</wfs:Envelope>\" + \"</wfs:boundedBy>\" ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null || dxr8 . length == 0 ) return ; \nif ( ! ( mode == RequestMode . DMR || mode == RequestMode . DSR ) ) { \nint flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \nelse { \nstate = State . END ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \n} \n} \n"}
{"5274": "public class ChunkWriter { \npublic void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { \ndmr8 = null ; \nErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; \nString errorbody = response . buildXML ( ) ; \nbyte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; \nif ( ! ( mode == RequestMode . DMR ) ) { \nchunk . clear ( ) ; \nint flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; \nchunkheader ( errbody8 . length , flags , header ) ; \noutput . write ( DapUtil . extract ( header ) ) ; \noutput . write ( errbody8 ) ; \noutput . flush ( ) ; \n} \nelse { \nsendDXR ( errbody8 ) ; \n} \nstate = State . ERROR ; \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( ! ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == short . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) ) if ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \nelse { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \n} \nelse { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \n} \nelse { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \ntnum > 0 ; \ntnum -- ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( ! ( oldDatabaseFile . delete ( ) ) ) { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n"}
{"5292": "public class Dap4Controller { \n@ Override public String getResourcePath ( DapRequest drq , String location ) throws DapException { \nString realpath ; \nif ( ! ( TdsRequestedDataset . getDatasetManager ( ) != null ) ) { \nassert TdsRequestedDataset . getDatasetManager ( ) == null ; \nString prefix = drq . getResourceRoot ( ) ; \nassert ( prefix != null ) ; \nrealpath = DapUtil . canonjoin ( prefix , location ) ; \n} \nelse { \nrealpath = TdsRequestedDataset . getLocationFromRequestPath ( location ) ; \n} \nif ( ! TESTING ) { \nif ( ! TdsRequestedDataset . resourceControlOk ( drq . getRequest ( ) , drq . getResponse ( ) , realpath ) ) throw new DapException ( \"Not authorized: \" + location ) . setCode ( DapCodes . SC_FORBIDDEN ) ; \n} \nFile f = new File ( realpath ) ; \nif ( ! f . exists ( ) || ! f . canRead ( ) ) throw new DapException ( \"Not found: \" + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; \nreturn realpath ; \n} \n} \n"}
{"5294": "public class FysatHeader { \nboolean readPIB ( RandomAccessFile raf ) throws IOException { \nthis . firstHeader = new AwxFileFirstHeader ( ) ; \nint pos = 0 ; \nraf . seek ( pos ) ; \nbyte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; \nint count = raf . read ( buf ) ; \nEndianByteBuffer byteBuffer ; \nif ( ! ( count == FY_AWX_PIB_LEN ) ) { \nreturn false ; \n} \nelse { \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nthis . firstHeader . fillHeader ( byteBuffer ) ; \n} \nif ( ! ( ( this . firstHeader . fileName . endsWith ( \".AWX\" ) || this . firstHeader . fileName . endsWith ( \".awx\" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) { \nreturn false ; \n} \nbuf = new byte [ this . firstHeader . secondHeaderLength ] ; \nraf . readFully ( buf ) ; \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nswitch ( this . firstHeader . typeOfProduct ) { \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( ! ( service != null ) ) { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nelse { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nif ( ! ( request != null ) ) { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nelse { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( ! ( version != null ) ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nelse { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nind < versionParts . length ; \nind ++ ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( ! ( actualPath != null ) ) return ; \nelse dataset = NetcdfDataset . openDataset ( actualPath ) ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( ! ( paramError == null ) ) { \nparamError . write ( hsres ) ; \nreturn ; \n} \nelse { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5316": "public class CrawlableDatasetAmazonS3 { \n@ Override public long length ( ) { \nS3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; \nif ( objectSummary != null ) { \nreturn objectSummary . getSize ( ) ; \n} \nObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; \nif ( ! ( metadata != null ) ) { \nreturn 0 ; \n} \nelse { \nreturn metadata . getContentLength ( ) ; \n} \n} \n} \n"}
{"5317": "public class CrawlableDatasetAmazonS3 { \n@ Override public Date lastModified ( ) { \nS3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; \nif ( objectSummary != null ) { \nreturn objectSummary . getLastModified ( ) ; \n} \nObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; \nif ( ! ( metadata != null ) ) { \nreturn null ; \n} \nelse { \nreturn metadata . getLastModified ( ) ; \n} \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( ! ( bitCounter == null ) ) { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \nelse countBits += nd . getBitWidth ( ) ; \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) { \nthrow new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \n} \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( ! ( bb != null ) ) if ( ! ( names != null ) ) stations = sobs . getStationFeatures ( ) ; \nelse stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \nelse stations = sobs . getStationFeatures ( bb ) ; \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) sElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \nif ( ( s . getDescription ( ) != null ) && ( s . getDescription ( ) . length ( ) > 0 ) ) sElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \ni >= firstpos ; \ni -- ) { \nif ( ! ( this . index . indices [ i ] > this . endpoint [ i ] ) ) { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \nelse this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5343": "public class Grib1GdsPredefined { \npublic static Grib1Gds factory ( int center , int gridNumber ) { \nif ( ! ( center == 7 ) ) throw new IllegalArgumentException ( \"Dont have predefined GDS \" + gridNumber + \" from \" + center ) ; \nelse { \nreturn factoryNCEP ( gridNumber ) ; \n} \n} \n} \n"}
{"5350": "public class IO { \nstatic public void copyDirTree ( String fromDirName , String toDirName ) throws IOException { \nFile fromDir = new File ( fromDirName ) ; \nFile toDir = new File ( toDirName ) ; \nif ( ! fromDir . exists ( ) ) return ; \nif ( ! toDir . exists ( ) ) { \nif ( ! toDir . mkdirs ( ) ) { \nthrow new IOException ( \"Could not create directory: \" + toDir ) ; \n} \n} \nFile [ ] files = fromDir . listFiles ( ) ; \nif ( files != null ) for ( File f : files ) { \nif ( ! ( f . isDirectory ( ) ) ) copyFile ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \nelse copyDirTree ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \n} \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( c < 0x20 ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( int i = 0 , len = name . length ( ) ; \ni < len ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( ! ( ( c == '/' ) || ( c == ' ' ) ) ) if ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; \nelse sbuff . append ( '_' ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) { \nreturn s ; \n} \nStringBuilder buff = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( i < buff . length ( ) ) { \nif ( ! ( buff . charAt ( i ) == c ) ) { \ni ++ ; \n} \nelse { \nbuff . deleteCharAt ( i ) ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! ( ! Character . isWhitespace ( c ) ) ) { \nb . append ( ' ' ) ; \nwhile ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { \ni ++ ; \n} \n} \nelse { \nb . append ( c ) ; \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5401": "public class CoordinateAxis1D { \npublic CoordinateAxis1D section ( Range r ) throws InvalidRangeException { \nSection section = new Section ( ) . appendRange ( r ) ; \nCoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; \nint len = r . length ( ) ; \nif ( isNumeric ( ) ) { \ndouble [ ] new_mids = new double [ len ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_mids [ idx ] = coords [ old_idx ] ; \n} \nresult . coords = new_mids ; \nif ( ! ( isInterval ) ) { \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_edge [ idx ] = edge [ old_idx ] ; \nnew_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; \n} \nresult . edge = new_edge ; \n} \nelse { \ndouble [ ] new_bound1 = new double [ len ] ; \ndouble [ ] new_bound2 = new double [ len ] ; \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_bound1 [ idx ] = bound1 [ old_idx ] ; \nnew_bound2 [ idx ] = bound2 [ old_idx ] ; \nnew_edge [ idx ] = bound1 [ old_idx ] ; \nnew_edge [ idx + 1 ] = bound2 [ old_idx ] ; \n} \nresult . bound1 = new_bound1 ; \nresult . bound2 = new_bound2 ; \nresult . edge = new_edge ; \n} \n} \nif ( names != null ) { \nString [ ] new_names = new String [ len ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_names [ idx ] = names [ old_idx ] ; \n} \nresult . names = new_names ; \n} \nresult . wasCalcRegular = false ; \nresult . calcIsRegular ( ) ; \nreturn result ; \n} \n} \n"}
{"5402": "public class TableAnalyzer { \nstatic public TableAnalyzer factory ( TableConfigurer tc , FeatureType wantFeatureType , NetcdfDataset ds ) throws IOException { \nTableAnalyzer analyzer = new TableAnalyzer ( ds , tc ) ; \nif ( ! ( tc != null ) ) { \nanalyzer . userAdvice . format ( \" No TableConfigurer found, using default analysis.%n\" ) ; \n} \nelse { \nif ( ! ( tc . getConvName ( ) == null ) ) analyzer . userAdvice . format ( \" Conventions global attribute = %s %n\" , tc . getConvName ( ) ) ; \nelse analyzer . userAdvice . format ( \" No 'Conventions' global attribute.%n\" ) ; \nif ( tc . getConvUsed ( ) != null ) { \nanalyzer . setConventionUsed ( tc . getConvUsed ( ) ) ; \nif ( ! tc . getConvUsed ( ) . equals ( tc . getConvName ( ) ) ) analyzer . userAdvice . format ( \" TableConfigurer used = \" + tc . getConvUsed ( ) + \".%n\" ) ; \n} \n} \nanalyzer . analyze ( wantFeatureType ) ; \nreturn analyzer ; \n} \n} \n"}
{"5404": "public class TableAnalyzer { \nprivate void analyze ( FeatureType wantFeatureType ) throws IOException { \nboolean structAdded = ( Boolean ) ds . sendIospMessage ( NetcdfFile . IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \nif ( ! ( tc == null ) ) { \nconfigResult = tc . getConfig ( wantFeatureType , ds , errlog ) ; \nif ( ! ( configResult != null ) ) { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \nelse addTableRecurse ( configResult ) ; \n} \nelse { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \nfor ( TableConfig config : tableSet ) { \nif ( config . children == null ) { \nNestedTable flatTable = new NestedTable ( ds , config , errlog ) ; \nleaves . add ( flatTable ) ; \n} \n} \nif ( PointDatasetStandardFactory . showTables ) getDetailInfo ( new Formatter ( System . out ) ) ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( ! ( type . equalsIgnoreCase ( GAUST62 ) ) ) if ( ! ( type . equalsIgnoreCase ( GAUSR15 ) ) ) if ( ! ( type . equalsIgnoreCase ( GAUSR20 ) ) ) if ( ! ( type . equalsIgnoreCase ( GAUSR30 ) ) ) if ( ! ( type . equalsIgnoreCase ( GAUSR40 ) ) ) { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \nelse { \nbaseArray = glats ; \n} \nelse { \nbaseArray = glts30 ; \n} \nelse { \nbaseArray = glts20 ; \n} \nelse { \nbaseArray = glts15 ; \n} \nelse { \nbaseArray = gltst62 ; \n} \nif ( start + num > baseArray . length ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nretVals [ i ] = baseArray [ start + i ] ; \n} \nreturn retVals ; \n} \n} \n"}
{"5411": "public class CSMConvention { \nprotected boolean addParameter2 ( CoordinateTransform rs , String paramName , NetcdfFile ds , AttributeContainer v , String attName , boolean readData ) { \nString varName ; \nif ( null == ( varName = v . findAttValueIgnoreCase ( attName , null ) ) ) { \nparseInfo . format ( \"CSMConvention No Attribute named %s%n\" , attName ) ; \nreturn false ; \n} \nvarName = varName . trim ( ) ; \nVariable dataVar ; \nif ( null == ( dataVar = ds . findVariable ( varName ) ) ) { \nparseInfo . format ( \"CSMConvention No Variable named %s%n\" , varName ) ; \nreturn false ; \n} \nif ( ! ( readData ) ) rs . addParameter ( new Parameter ( paramName , varName ) ) ; \nelse { \nArray data ; \ntry { \ndata = dataVar . read ( ) ; \n} \ncatch ( IOException e ) { \nparseInfo . format ( \"CSMConvention failed on read of %s err= %s%n\" , varName , e . getMessage ( ) ) ; \nreturn false ; \n} \ndouble [ ] vals = ( double [ ] ) data . get1DJavaArray ( DataType . DOUBLE ) ; \nrs . addParameter ( new Parameter ( paramName , vals ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"5427": "public class GeotiffWriter { \nprivate ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \ndouble scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; \nArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator resultIter = byteArray . getIndexIterator ( ) ; \nbyte bv ; \nwhile ( dataIter . hasNext ( ) ) { \ndouble v = dataIter . getDoubleNext ( ) ; \nif ( ! ( grid . isMissing ( v ) ) ) { \nint iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; \nbv = ( byte ) ( iv & 0xff ) ; \n} \nelse { \nbv = 0 ; \n} \nresultIter . setByteNext ( bv ) ; \n} \nreturn byteArray ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( ! ( greyScale ) ) { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \n} \n} \n"}
{"5434": "public class GribCdmIndex { \npublic static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { \nif ( logger == null ) logger = classLogger ; \nlong start = System . currentTimeMillis ( ) ; \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \nPath rootPath = Paths . get ( specp . getRootDir ( ) ) ; \nboolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; \nboolean changed ; \nif ( ! ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) ) if ( ! ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) ) { \nif ( ! ( specp . wantSubdirs ( ) ) ) { \nchanged = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; \n} \nelse { \ntry ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { \ndpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nchanged = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; \n} \n} \n} \nelse { \ntry ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { \nchanged = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; \n} \n} \nelse { \ntry ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { \nchanged = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; \n} \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . info ( \"updateGribCollection {} changed {} took {} msecs\" , config . collectionName , changed , took ) ; \nreturn changed ; \n} \n} \n"}
{"5435": "public class GribCdmIndex { \nprivate static boolean updateLeafCollection ( boolean isGrib1 , FeatureCollectionConfig config , CollectionUpdateType updateType , boolean isTop , Logger logger , Path dirPath ) throws IOException { \nif ( ! ( config . ptype == FeatureCollectionConfig . PartitionType . file ) ) { \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \ntry ( DirectoryCollection dcm = new DirectoryCollection ( config . collectionName , dirPath , isTop , config . olderThan , logger ) ) { \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( specp . getFilter ( ) != null ) dcm . setStreamFilter ( new StreamFilter ( specp . getFilter ( ) , specp . getFilterOnName ( ) ) ) ; \nboolean changed = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . directory , logger , errlog ) ; \nlogger . debug ( \"  GribCdmIndex.updateDirectoryPartition was updated=%s on %s%n\" , changed , dirPath ) ; \nreturn changed ; \n} \n} \nelse { \nreturn updateFilePartition ( isGrib1 , config , updateType , isTop , logger , dirPath ) ; \n} \n} \n} \n"}
{"5436": "public class GribCdmIndex { \npublic static GribCollectionImmutable openGribCollectionFromRaf ( RandomAccessFile raf , FeatureCollectionConfig config , CollectionUpdateType updateType , org . slf4j . Logger logger ) throws IOException { \nGribCollectionImmutable result ; \nboolean isGrib1 = false ; \nboolean isGrib2 = Grib2RecordScanner . isValidFile ( raf ) ; \nif ( ! isGrib2 ) isGrib1 = Grib1RecordScanner . isValidFile ( raf ) ; \nif ( ! ( isGrib1 || isGrib2 ) ) { \nresult = openGribCollectionFromIndexFile ( raf , config , logger ) ; \n} \nelse { \nresult = openGribCollectionFromDataFile ( isGrib1 , raf , config , updateType , null , logger ) ; \nraf . close ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"5438": "public class GribCdmIndex { \n@ Nullable public static GribCollectionImmutable openGribCollectionFromDataFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType updateType , FeatureCollectionConfig config , Formatter errlog , org . slf4j . Logger logger ) throws IOException { \nMCollection dcm = new CollectionSingleFile ( mfile , logger ) ; \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( ! ( isGrib1 ) ) { \nGrib2CollectionBuilder builder = new Grib2CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \nboolean changed = ( builder . updateNeeded ( updateType ) && builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ) ; \n} \nelse { \nGrib1CollectionBuilder builder = new Grib1CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \nboolean changed = ( builder . updateNeeded ( updateType ) && builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ) ; \n} \nGribCollectionImmutable result = openCdmIndex ( dcm . getIndexFilename ( NCX_SUFFIX ) , config , true , logger ) ; \nif ( result != null ) return result ; \nif ( updateType == CollectionUpdateType . never ) return null ; \nif ( updateType == CollectionUpdateType . always ) return null ; \nreturn openGribCollectionFromDataFile ( isGrib1 , mfile , CollectionUpdateType . always , config , errlog , logger ) ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! ( ! displayProject . equals ( fs . project ) ) ) { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nelse { \nfs . setProjection ( displayProject ) ; \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \nSystem . out . println ( \"GisFeature/MapDraw: makeShapes with \" + displayProject ) ; \n} \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( ! ( dataProject . isLatLon ( ) ) ) if ( ! ( dataProject == displayProject ) ) shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nelse shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( ! ( isCancelled && ! task . isCancel ( ) ) ) { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . println ( \" stop count=\" + count ) ; \n} \nelse { \ntask . cancel ( ) ; \nif ( debug ) System . out . println ( \" task.cancel\" ) ; \nreturn ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( ! ( task . isSuccess ( ) ) ) if ( ! ( task . isError ( ) ) ) if ( ! ( task . isCancel ( ) ) ) fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5457": "public class ArrayStructure { \npublic Object getScalarObject ( int recno , StructureMembers . Member m ) { \nDataType dataType = m . getDataType ( ) ; \nif ( ! ( dataType == DataType . DOUBLE ) ) if ( ! ( dataType == DataType . FLOAT ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == byte . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == short . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == int . class ) ) if ( ! ( dataType . getPrimitiveClassType ( ) == long . class ) ) if ( ! ( dataType == DataType . CHAR ) ) if ( ! ( dataType == DataType . STRING ) ) if ( ! ( dataType == DataType . STRUCTURE ) ) if ( dataType == DataType . OPAQUE ) { \nArrayObject data = ( ArrayObject ) m . getDataArray ( ) ; \nreturn data . getObject ( recno * m . getSize ( ) ) ; \n} \nelse { \nreturn getScalarStructure ( recno , m ) ; \n} \nelse { \nreturn getScalarString ( recno , m ) ; \n} \nelse { \nreturn getScalarString ( recno , m ) ; \n} \nelse { \nreturn getScalarLong ( recno , m ) ; \n} \nelse { \nreturn getScalarInt ( recno , m ) ; \n} \nelse { \nreturn getScalarShort ( recno , m ) ; \n} \nelse { \nreturn getScalarByte ( recno , m ) ; \n} \nelse { \nreturn getScalarFloat ( recno , m ) ; \n} \nelse { \nreturn getScalarDouble ( recno , m ) ; \n} \nthrow new RuntimeException ( \"Dont have implementation for \" + dataType ) ; \n} \n} \n"}
{"5469": "public class CEConstraint { \nprotected Object eval ( DapVariable var , DapSequence seq , DataCursor record , CEAST expr ) throws DapException { \nswitch ( expr . sort ) { \ncase CONSTANT : return expr . value ; \ncase SEGMENT : return fieldValue ( var , seq , record , expr . name ) ; \ncase EXPR : Object lhs = eval ( var , seq , record , expr . lhs ) ; \nObject rhs = ( expr . rhs == null ? null : eval ( var , seq , record , expr . rhs ) ) ; \nif ( ! ( rhs != null ) ) switch ( expr . op ) { \ncase NOT : return ! ( ( Boolean ) lhs ) ; \n} \nelse switch ( expr . op ) { \ncase LT : return compare ( lhs , rhs ) < 0 ; \ncase LE : return compare ( lhs , rhs ) <= 0 ; \ncase GT : return compare ( lhs , rhs ) > 0 ; \ncase GE : return compare ( lhs , rhs ) >= 0 ; \ncase EQ : return lhs . equals ( rhs ) ; \ncase NEQ : return ! lhs . equals ( rhs ) ; \ncase REQ : return lhs . toString ( ) . matches ( rhs . toString ( ) ) ; \ncase AND : return ( ( Boolean ) lhs ) && ( ( Boolean ) rhs ) ; \n} \n} \nthrow new DapException ( \"Malformed Filter\" ) ; \n} \n} \n"}
{"5477": "public class Grib2Iosp { \n@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { \nif ( ! ( raf instanceof HTTPRandomAccessFile ) ) { \nGribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; \nif ( type == GribCdmIndex . GribCollectionType . GRIB2 ) return true ; \nif ( type == GribCdmIndex . GribCollectionType . Partition2 ) return true ; \n} \nelse { \nif ( raf . length ( ) > raf . getBufferSize ( ) ) return false ; \n} \nreturn Grib2RecordScanner . isValidFile ( raf ) ; \n} \n} \n"}
{"5480": "public class GempakFileReader { \nvoid setByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( ! ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) ) { \nMTMACH = RandomAccessFile . BIG_ENDIAN ; \n} \nelse { \nMTMACH = RandomAccessFile . LITTLE_ENDIAN ; \n} \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { \nreturn null ; \n} \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( int i = 0 ; \ni < knt ; \ni ++ ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nint nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( ! ( name . equals ( \"NAVB\" ) && needToSwap ) ) { \nDM_RFLT ( iread , rheader ) ; \n} \nelse { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5486": "public class GempakFileReader { \npublic float DM_RFLT ( int word ) throws IOException { \nif ( rf == null ) { \nthrow new IOException ( \"DM_RFLT: no file to read from\" ) ; \n} \nif ( dmLabel == null ) { \nthrow new IOException ( \"DM_RFLT: reader not initialized\" ) ; \n} \nrf . seek ( getOffset ( word ) ) ; \nif ( ! ( needToSwap ) ) { \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \n} \nelse { \nrf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \n} \nfloat rdata = rf . readFloat ( ) ; \nif ( RMISSD != dmLabel . smissd ) { \nif ( Math . abs ( rdata - dmLabel . smissd ) < RDIFFD ) { \nrdata = RMISSD ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn rdata ; \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \nfor ( int pack = 0 ; \npack < npack ; \npack ++ ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( int idata = 0 ; \nidata < nparms ; \nidata ++ ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ! ( ifield == pkinf . imissc [ idata ] ) ) { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \nelse { \ndata [ ir + idata ] = RMISSD ; \n} \n} \nir += nparms ; \nii += nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \nfor ( int i = 31 ; \ni >= 0 ; \ni -- ) { \nif ( ! ( ( b & ( 1 << i ) ) != 0 ) ) { \ns . format ( \"0\" ) ; \n} \nelse { \ns . format ( \"1\" ) ; \n} \nif ( i % 8 == 0 ) { \ns . format ( \"|\" ) ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( ! ( type . equals ( \"Attribute\" ) ) ) if ( ! ( type . equals ( \"Alias\" ) ) ) if ( ! ( type . equals ( \"dataBLOB\" ) ) ) { \nif ( _Debug ) System . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( ! ( bt instanceof DConstructor ) ) if ( bt instanceof DArray ) { \nif ( _Debug ) System . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \nelse { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( ! ( bt instanceof DGrid ) ) { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \nelse { \nparseGrid ( e , indent ) ; \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \n} \nelse { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \n} \nelse { \n} \nparseLevel -- ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) System . out . println ( indent + \"Parsing Aliases: \" ) ; \nif ( _Debug ) System . out . println ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . println ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" ) ; \n} \nif ( ! ( currentAT == null ) ) currentAT . addAlias ( name , attributeName ) ; \nelse currentBT . addAttributeAlias ( name , attributeName ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5494": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > decode ( List < Short > keyDesc , BufrTableLookup lookup ) { \nif ( keyDesc == null ) return null ; \nList < DataDescriptor > keys = new ArrayList < DataDescriptor > ( ) ; \nfor ( short id : keyDesc ) { \nDataDescriptor dd = new DataDescriptor ( id , lookup ) ; \nkeys . add ( dd ) ; \nif ( dd . f == 3 ) { \nTableD . Descriptor tdd = lookup . getDescriptorTableD ( dd . fxy ) ; \nif ( ! ( tdd == null || tdd . getSequence ( ) == null ) ) { \ndd . name = tdd . getName ( ) ; \ndd . subKeys = decode ( tdd . getSequence ( ) , lookup ) ; \n} \nelse { \ndd . bad = true ; \n} \n} \n} \nreturn keys ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( ! ( dk . f == 1 ) ) if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( ! ( replication . y == 0 ) ) if ( ! ( replication . y == 1 ) ) if ( ! ( replication . y == 2 ) ) if ( ! ( replication . y == 11 ) ) if ( ! ( replication . y == 12 ) ) log . error ( \"Unknown replication type= \" + replication ) ; \nelse dk . repetitionCountSize = 16 ; \nelse dk . repetitionCountSize = 8 ; \nelse dk . replicationCountSize = 16 ; \nelse dk . replicationCountSize = 8 ; \nelse dk . replicationCountSize = 1 ; \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nint last = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < time2runtime . length ; \ni ++ ) { \nint time = time2runtime [ i ] ; \nif ( ! ( time >= last ) ) { \nbest [ i ] = - 1 ; \n} \nelse { \nlast = time ; \nbest [ i ] = time ; \ncount ++ ; \n} \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5504": "public class LatLonProjection { \npublic ProjectionRect [ ] latLonToProjRect ( LatLonRect latlonR ) { \ndouble lat0 = latlonR . getLowerLeftPoint ( ) . getLatitude ( ) ; \ndouble height = Math . abs ( latlonR . getUpperRightPoint ( ) . getLatitude ( ) - lat0 ) ; \ndouble width = latlonR . getWidth ( ) ; \ndouble lon0 = LatLonPointImpl . lonNormal ( latlonR . getLowerLeftPoint ( ) . getLongitude ( ) , centerLon ) ; \ndouble lon1 = LatLonPointImpl . lonNormal ( latlonR . getUpperRightPoint ( ) . getLongitude ( ) , centerLon ) ; \nProjectionRect [ ] rects = new ProjectionRect [ ] { \nnew ProjectionRect ( ) , new ProjectionRect ( ) } \n; \nif ( ! ( lon0 < lon1 ) ) { \ndouble y = centerLon + 180 - lon0 ; \nrects [ 0 ] . setRect ( lon0 , lat0 , y , height ) ; \nrects [ 1 ] . setRect ( lon1 - width + y , lat0 , width - y , height ) ; \n} \nelse { \nrects [ 0 ] . setRect ( lon0 , lat0 , width , height ) ; \nrects [ 1 ] = null ; \n} \nreturn rects ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( ! ( isString ( ) ) ) if ( ! ( getEnumType ( ) != null ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( ! ( dataType == DataType . FLOAT ) ) if ( ! ( dataType == DataType . SHORT || dataType == DataType . USHORT ) ) if ( ! ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) ) if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \nelse { \nf . format ( \"B\" ) ; \n} \nelse { \nf . format ( \"S\" ) ; \n} \nelse f . format ( \"f\" ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( ! ( c == String . class ) ) if ( ! ( c == Integer . class ) ) if ( ! ( c == Double . class ) ) if ( ! ( c == Float . class ) ) if ( ! ( c == Short . class ) ) if ( ! ( c == Byte . class ) ) if ( ! ( c == Long . class ) ) { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nelse { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( state >= 2 ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \nfor ( int i = 0 ; \ni < crDsList . size ( ) ; \ni ++ ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( ! ( curCrDs . isCollection ( ) ) ) atomicDsInfo . add ( dsInfo ) ; \nelse catRefInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5518": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( DataFactory . Result threddsData ) { \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( this , \"Cant open dataset=\" + threddsData . errLog ) ; \ntry { \nthreddsData . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \nif ( ! ( threddsData . featureType . isCoverageFeatureType ( ) ) ) if ( ! ( threddsData . featureType == FeatureType . IMAGE ) ) if ( ! ( threddsData . featureType == FeatureType . RADIAL ) ) if ( ! ( threddsData . featureType . isPointFeatureType ( ) ) ) if ( threddsData . featureType == FeatureType . STATION_RADIAL ) { \nmakeComponent ( ftTabPane , \"StationRadial\" ) ; \nstationRadialPanel . setStationRadialDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( stationRadialPanel ) ; \n} \nelse { \nmakeComponent ( ftTabPane , \"PointFeature\" ) ; \npointFeaturePanel . setPointFeatureDataset ( ( PointDatasetImpl ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( pointFeaturePanel ) ; \n} \nelse { \nmakeComponent ( ftTabPane , \"Radial\" ) ; \nradialPanel . setDataset ( ( RadialDatasetSweep ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( radialPanel ) ; \n} \nelse { \nmakeComponent ( ftTabPane , \"Images\" ) ; \nimagePanel . setImageLocation ( threddsData . imageURL ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( imagePanel ) ; \n} \nelse { \nif ( ! ( threddsData . featureDataset instanceof FeatureDatasetCoverage ) ) if ( threddsData . featureDataset instanceof GridDataset ) { \nmakeComponent ( ftTabPane , \"Grids\" ) ; \ngridPanel . setDataset ( ( GridDataset ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( gridPanel ) ; \n} \nelse { \nmakeComponent ( ftTabPane , \"Coverages\" ) ; \ncoveragePanel . setDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( coveragePanel ) ; \n} \n} \n} \n} \n"}
{"5520": "public class ToolsUI { \nprivate static void prepareGui ( ) { \nfinal String osName = System . getProperty ( \"os.name\" ) . toLowerCase ( ) ; \nfinal boolean isMacOs = osName . startsWith ( \"mac os x\" ) ; \nif ( ! ( isMacOs ) ) { \ntry { \nfor ( UIManager . LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { \nif ( \"Nimbus\" . equals ( info . getName ( ) ) ) { \nUIManager . setLookAndFeel ( info . getClassName ( ) ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception exc ) { \nlog . warn ( \"Unable to apply Nimbus look-and-feel due to {}\" , exc . toString ( ) ) ; \nif ( log . isTraceEnabled ( ) ) { \nexc . printStackTrace ( ) ; \n} \n} \n} \nelse { \nSystem . setProperty ( \"apple.laf.useScreenMenuBar\" , \"true\" ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { \n@ Override public void run ( ) { \ndoSavePrefsAndUI ( ) ; \n} \n} \n) ; \n} \nBAMutil . setResourcePath ( \"/resources/nj22/ui/icons/\" ) ; \nSwingUtilities . invokeLater ( ( ) -> { \nfinal Toolkit tk = Toolkit . getDefaultToolkit ( ) ; \nfinal Font f = new Font ( \"SansSerif\" , Font . PLAIN , 12 ) ; \n@ SuppressWarnings ( \"deprecation\" ) final FontMetrics fm = tk . getFontMetrics ( f ) ; \n} \n) ; \n} \n} \n"}
{"5544": "public class NestedTable { \nprivate CoordVarExtractor findCoordinateAxis ( Table . CoordName coordName , Table t , int nestingLevel ) { \nif ( t == null ) return null ; \nString axisName = t . findCoordinateVariableName ( coordName ) ; \nif ( axisName != null ) { \nVariableDS v = t . findVariable ( axisName ) ; \nif ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \nif ( t . extraJoins != null ) { \nfor ( Join j : t . extraJoins ) { \nv = j . findVariable ( axisName ) ; \nif ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \n} \n} \nif ( t instanceof Table . TableSingleton ) { \nTable . TableSingleton ts = ( Table . TableSingleton ) t ; \nreturn new CoordVarStructureData ( axisName , ts . sdata ) ; \n} \nif ( t instanceof Table . TableTop ) { \nv = ( VariableDS ) ds . findVariable ( axisName ) ; \nif ( ! ( v != null ) ) return new CoordVarConstant ( coordName . toString ( ) , \"\" , axisName ) ; \nelse return new CoordVarTop ( v ) ; \n} \nerrlog . format ( \"NestedTable: cant find variable '%s' for coordinate type %s %n\" , axisName , coordName ) ; \n} \nreturn findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; \n} \n} \n"}
{"5560": "public class ClauseFactory { \npublic TopLevelClause newBoolFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { \nBoolFunction function = functionLibrary . getBoolFunction ( functionName ) ; \nif ( function == null ) { \nif ( ! ( functionLibrary . getBTFunction ( functionName ) != null ) ) { \nthrow new NoSuchFunctionException ( \"This server does not support a \" + functionName + \"() function\" ) ; \n} \nelse { \nthrow new NoSuchFunctionException ( \"The function \" + functionName + \"() does not return a \" + \"boolean value, and must be used in a comparison or \" + \"as an argument to another function.\" ) ; \n} \n} \nreturn new BoolFunctionClause ( function , children ) ; \n} \n} \n"}
{"5561": "public class ClauseFactory { \npublic SubClause newBTFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { \nBTFunction function = functionLibrary . getBTFunction ( functionName ) ; \nif ( function == null ) { \nif ( ! ( functionLibrary . getBoolFunction ( functionName ) != null ) ) { \nthrow new NoSuchFunctionException ( \"This server does not support a \" + functionName + \"() function\" ) ; \n} \nelse { \nthrow new NoSuchFunctionException ( \"The function \" + functionName + \"() cannot be used as a \" + \"sub-expression in a constraint clause\" ) ; \n} \n} \nreturn new BTFunctionClause ( function , children ) ; \n} \n} \n"}
{"5563": "public class CatalogCrawler { \npublic int crawl ( InvCatalogImpl cat , CancelTask task , PrintWriter out , Object context ) { \nif ( out != null ) out . println ( \"***CATALOG \" + cat . getCreateFrom ( ) ) ; \ncountCatrefs = 0 ; \nfor ( InvDataset ds : cat . getDatasets ( ) ) { \nif ( ! ( type == Type . all ) ) crawlDirectDatasets ( ds , task , out , context , true ) ; \nelse crawlDataset ( ds , task , out , context , true ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nreturn 1 + countCatrefs ; \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( ! ( type == Type . first_direct ) ) if ( ! ( type == Type . random_direct ) ) if ( ! ( type == Type . random_direct_middle ) ) { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \nelse { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( ! ( cacheState == 1 ) ) { \nreturn ; \n} \nelse { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . println ( \"  close \" + location ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( ! ( filePosition < dataEnd ) ) if ( ! ( endOfFile ) ) { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \nelse { \nreturn - 1 ; \n} \nelse { \nint pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition ++ ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \n} \n} \n"}
{"5575": "public class RandomAccessFile { \npublic final int readIntUnbuffered ( long pos ) throws IOException { \nbyte [ ] bb = new byte [ 4 ] ; \nread_ ( pos , bb , 0 , 4 ) ; \nint ch1 = bb [ 0 ] & 0xff ; \nint ch2 = bb [ 1 ] & 0xff ; \nint ch3 = bb [ 2 ] & 0xff ; \nint ch4 = bb [ 3 ] & 0xff ; \nif ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { \nthrow new EOFException ( ) ; \n} \nif ( ! ( bigEndian ) ) { \nreturn ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; \n} \nelse { \nreturn ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; \n} \n} \n} \n"}
{"5592": "public class Selector { \npublic void appendQuery ( StringBuffer sbuff , ArrayList values ) { \nif ( ! ( template != null ) ) appendQueryFromParamValue ( sbuff , values ) ; \nelse appendQueryFromTemplate ( sbuff , values ) ; \n} \n} \n"}
{"5593": "public class DirectoryBuilder { \nstatic public MCollection factory ( FeatureCollectionConfig config , Path topDir , boolean isTop , IndexReader indexReader , String suffix , org . slf4j . Logger logger ) throws IOException { \nDirectoryBuilder builder = new DirectoryBuilder ( config . collectionName , topDir . toString ( ) , suffix ) ; \nDirectoryPartition dpart = new DirectoryPartition ( config , topDir , isTop , indexReader , suffix , logger ) ; \nif ( ! builder . isLeaf ( indexReader ) ) { \nreturn dpart ; \n} \nboolean hasIndex = builder . findIndex ( ) ; \nif ( ! ( hasIndex ) ) { \nDirectoryCollection result = new DirectoryCollection ( config . collectionName , topDir , isTop , config . olderThan , logger ) ; \nreturn result ; \n} \nelse { \nreturn dpart . makeChildCollection ( builder ) ; \n} \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nint countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nwhile ( iterator . hasNext ( ) && count ++ < 100 ) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( ! ( attr . isDirectory ( ) ) ) countFile ++ ; \nelse countDir ++ ; \n} \n} \npartitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5596": "public class DirectoryBuilder { \npublic List < DirectoryBuilder > constructChildren ( IndexReader indexReader , CollectionUpdateType forceCollection ) throws IOException { \nif ( childrenConstructed ) return children ; \nif ( ! ( index != null && forceCollection == CollectionUpdateType . nocheck ) ) { \nscanForChildren ( ) ; \n} \nelse { \nconstructChildrenFromIndex ( indexReader , false ) ; \n} \npartitionStatus = ( children . size ( ) > 0 ) ? PartitionStatus . isDirectoryPartition : PartitionStatus . isLeaf ; \nchildrenConstructed = true ; \nreturn children ; \n} \n} \n"}
{"5606": "public class FileCacheARC { \npublic synchronized void clearCache ( boolean force ) { \nList < CacheElement . CacheFile > deleteList = new ArrayList < > ( 2 * cache . size ( ) ) ; \nif ( ! ( force ) ) { \nIterator < CacheElement . CacheFile > iter = files . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCacheElement . CacheFile file = iter . next ( ) ; \nif ( file . isLocked . compareAndSet ( false , true ) ) { \nfile . remove ( ) ; \ndeleteList . add ( file ) ; \niter . remove ( ) ; \n} \n} \nfor ( CacheElement elem : cache . values ( ) ) { \nif ( elem . list . size ( ) == 0 ) cache . remove ( elem . hashKey ) ; \n} \n} \nelse { \ncache . clear ( ) ; \ndeleteList . addAll ( files . values ( ) ) ; \nfiles . clear ( ) ; \n} \nfor ( CacheElement . CacheFile file : deleteList ) { \nif ( force && file . isLocked . get ( ) ) cacheLog . warn ( \"FileCacheARC \" + name + \" force close locked file= \" + file ) ; \nif ( file . ncfile == null ) continue ; \ntry { \nfile . ncfile . setFileCache ( null ) ; \nfile . ncfile . close ( ) ; \nfile . ncfile = null ; \n} \ncatch ( IOException e ) { \nlog . error ( \"FileCacheARC \" + name + \" close failed on \" + file ) ; \n} \n} \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList . size ( ) + \" left=\" + files . size ( ) ) ; \n} \n} \n"}
{"5607": "public class GridCoordSys { \nvoid makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { \nif ( vt != null ) return ; \nif ( vCT == null ) return ; \nvt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; \nif ( ! ( vt == null ) ) { \nif ( parseInfo != null ) parseInfo . format ( \"  - VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \nelse { \nif ( parseInfo != null ) parseInfo . format ( \"  - ERR can't make VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \n} \n} \n"}
{"5610": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoord ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ! ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) ) if ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \nboolean found = g2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nif ( ! ( found ) ) { \nresult [ 0 ] = - 1 ; \nresult [ 1 ] = - 1 ; \n} \nelse { \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \n} \nreturn result ; \n} \nelse { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElement ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElement ( y_coord ) ; \nreturn result ; \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5611": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoordBounded ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ! ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) ) if ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \ng2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \nreturn result ; \n} \nelse { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElementBounded ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElementBounded ( y_coord ) ; \nreturn result ; \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5614": "public class MyTextField { \nprotected int getItemPos ( ) { \nif ( ! ( nitems < 1 ) ) if ( nitems == 1 ) return b . width / 2 ; \nelse return - arrow_size ; \nint item = table . getSelectedRowIndex ( ) ; \nint eff_width = b . width - 2 * arrow_size ; \nint pixel = ( item * eff_width ) / ( nitems - 1 ) ; \nreturn pixel + arrow_size ; \n} \n} \n"}
{"5617": "public class TdsDownloader { \npublic void getRemoteFiles ( final CancelTask _cancel ) { \nthis . cancel = _cancel ; \nString urls = config . getServerPrefix ( ) + \"/thredds/admin/log/\" + type + \"/\" ; \nta . append ( String . format ( \"Download URL = %s%n\" , urls ) ) ; \nString contents = null ; \ntry ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { \nint statusCode = method . execute ( ) ; \nif ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; \nif ( ! ( ( contents == null ) || ( contents . length ( ) == 0 ) ) ) { \nta . append ( String . format ( \"Logs at URL = %s%n%s%n\" , urls , contents ) ) ; \n} \nelse { \nta . append ( String . format ( \"Failed to get logs at URL = %s%n%n\" , urls ) ) ; \nreturn ; \n} \n} \ncatch ( Throwable t ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s error = %s%n%n\" , urls , t . getMessage ( ) ) ) ; \nt . printStackTrace ( ) ; \nreturn ; \n} \nfinal String list = contents ; \nSwingWorker worker = new SwingWorker < String , Void > ( ) { \n@ Override protected String doInBackground ( ) throws Exception { \ntry { \nta . append ( String . format ( \"Local log files stored in = %s%n%n\" , localDir ) ) ; \nString [ ] lines = list . split ( \"\\n\" ) ; \nfor ( String line : lines ) { \nnew RemoteLog ( line . trim ( ) ) ; \nif ( cancel . isCancel ( ) ) { \nbreak ; \n} \n} \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \n} \nreturn null ; \n} \npublic void done ( ) { \nif ( ! ( cancel . isCancel ( ) ) ) ta . append ( String . format ( \"Download complete for %s%n\" , type ) ) ; \nelse ta . append ( String . format ( \"Download was cancelled for %s%n\" , type ) ) ; \n} \n} \n; \nworker . execute ( ) ; \n} \n} \n"}
{"5621": "public class CalendarPeriod { \npublic static CalendarPeriod of ( String udunit ) { \nint value ; \nString units ; \nString [ ] split = StringUtil2 . splitString ( udunit ) ; \nif ( ! ( split . length == 1 ) ) if ( ! ( split . length == 2 ) ) return null ; \nelse { \ntry { \nvalue = Integer . parseInt ( split [ 0 ] ) ; \n} \ncatch ( Throwable t ) { \nreturn null ; \n} \nunits = split [ 1 ] ; \n} \nelse { \nvalue = 1 ; \nunits = split [ 0 ] ; \n} \nCalendarPeriod . Field unit = CalendarPeriod . fromUnitString ( units ) ; \nreturn CalendarPeriod . of ( value , unit ) ; \n} \n} \n"}
{"5624": "public class CalendarPeriod { \npublic double getValueInMillisecs ( ) { \nif ( ! ( field == CalendarPeriod . Field . Month ) ) if ( ! ( field == CalendarPeriod . Field . Year ) ) return millisecs ( ) ; \nelse return 365.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \nelse return 30.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \n} \n} \n"}
{"5625": "public class CalendarPeriod { \npublic int getOffset ( CalendarDate start , CalendarDate end ) { \nif ( start . equals ( end ) ) return 0 ; \nlong start_millis = start . getDateTime ( ) . getMillis ( ) ; \nlong end_millis = end . getDateTime ( ) . getMillis ( ) ; \nPeriod p ; \nif ( ! ( start_millis < end_millis ) ) p = new Period ( start_millis + 5000 , end_millis , getPeriodType ( ) ) ; \nelse p = new Period ( start_millis , end_millis + 5000 , getPeriodType ( ) ) ; \nreturn p . get ( getDurationFieldType ( ) ) ; \n} \n} \n"}
{"5642": "public class ThreddsMetadataExtractor { \npublic ThreddsMetadata extract ( Dataset threddsDataset ) throws IOException { \nThreddsMetadata metadata = new ThreddsMetadata ( ) ; \nMap < String , Object > flds = metadata . getFlds ( ) ; \ntry ( DataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( threddsDataset , null ) ) { \nif ( result . fatalError ) { \nlogger . warn ( \" openFeatureDataset failed, errs=%s%n\" , result . errLog ) ; \nreturn null ; \n} \nif ( ! ( result . featureType . isCoverageFeatureType ( ) ) ) if ( result . featureType . isPointFeatureType ( ) ) { \nPointDatasetImpl pobsDataset = ( PointDatasetImpl ) result . featureDataset ; \nLatLonRect llbb = pobsDataset . getBoundingBox ( ) ; \nif ( null != llbb ) flds . put ( Dataset . GeospatialCoverage , new ThreddsMetadata . GeospatialCoverage ( llbb , null , 0.0 , 0.0 ) ) ; \nCalendarDateRange tc = extractCalendarDateRange ( pobsDataset ) ; \nif ( tc != null ) flds . put ( Dataset . TimeCoverage , tc ) ; \nThreddsMetadata . VariableGroup vars = extractVariables ( pobsDataset ) ; \nif ( vars != null ) flds . put ( Dataset . VariableGroups , vars ) ; \n} \nelse { \nGridDataset gridDataset = ( GridDataset ) result . featureDataset ; \nflds . put ( Dataset . GeospatialCoverage , extractGeospatial ( gridDataset ) ) ; \nCalendarDateRange tc = extractCalendarDateRange ( gridDataset ) ; \nif ( tc != null ) flds . put ( Dataset . TimeCoverage , tc ) ; \nThreddsMetadata . VariableGroup vars = extractVariables ( threddsDataset . getDataFormatName ( ) , gridDataset ) ; \nif ( vars != null ) flds . put ( Dataset . VariableGroups , vars ) ; \n} \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Error opening dataset \" + threddsDataset . getName ( ) , ioe ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"5647": "public class ConvertD2N { \npublic Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { \nArray data = convert ( dataV ) ; \nif ( ( dataV . darray != null ) && ( dataV . bt instanceof DString ) ) { \nif ( ! ( v . getDataType ( ) == DataType . STRING ) ) if ( ! ( v . getDataType ( ) == DataType . CHAR ) ) { \nString mess = \"DODSVariable convertArray String invalid dataType= \" + v . getDataType ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalArgumentException ( mess ) ; \n} \nelse return convertStringArrayToChar ( dataV . darray , v , section ) ; \nelse return convertStringArray ( data , v ) ; \n} \nif ( ( dataV . bt instanceof DString ) && ( v . getDataType ( ) == DataType . CHAR ) ) { \nreturn convertStringToChar ( data , v ) ; \n} \nreturn data ; \n} \n} \n"}
{"5648": "public class ConvertD2N { \npublic Array convert ( DodsV dataV ) throws IOException , DAP2Exception { \nif ( dataV . darray == null ) { \nif ( ! ( dataV . bt instanceof DStructure ) ) if ( ! ( dataV . bt instanceof DGrid ) ) if ( ! ( dataV . bt instanceof DSequence ) ) { \nDataType dtype = dataV . getDataType ( ) ; \nArray scalarData = Array . factory ( dtype , new int [ 0 ] ) ; \nIndexIterator scalarIndex = scalarData . getIndexIterator ( ) ; \niconvertDataPrimitiveScalar ( dataV . bt , scalarIndex ) ; \nreturn scalarData ; \n} \nelse { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataSequenceArray ( ( DSequence ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse { \nthrow new IllegalStateException ( \"DGrid without a darray\" ) ; \n} \nelse { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructure ( ( DStructure ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \n} \nif ( dataV . darray != null ) { \nif ( ! ( dataV . bt instanceof DStructure ) ) if ( ! ( dataV . bt instanceof DString ) ) { \nopendap . dap . PrimitiveVector pv = dataV . darray . getPrimitiveVector ( ) ; \nObject storage = pv . getInternalStorage ( ) ; \nDataType dtype = dataV . getDataType ( ) ; \nreturn Array . factory ( dtype , makeShape ( dataV . darray ) , storage ) ; \n} \nelse { \nreturn convertStringArray ( dataV . darray ) ; \n} \nelse { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructureArray ( dataV . darray , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \n} \nString mess = \"Unknown baseType \" + dataV . bt . getClass ( ) . getName ( ) + \" name=\" + dataV . getEncodedName ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalStateException ( mess ) ; \n} \n} \n"}
{"5663": "public class EcmwfLocalConcepts { \nprivate void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { \nHashMap < String , HashMap < String , String > > tmpTable ; \nif ( ! ( localConcepts . containsKey ( tableVersion ) ) ) { \ntmpTable = new HashMap < > ( ) ; \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nelse { \ntmpTable = localConcepts . get ( tableVersion ) ; \nif ( ! ( tmpTable . containsKey ( parameterNumber ) ) ) { \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nelse { \nHashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; \nif ( ! ( ! tmpParam . containsKey ( key ) ) ) { \nSystem . out . println ( \"already has key value pair: \" + key + \":\" + value ) ; \n} \nelse { \ntmpParam . put ( key , value ) ; \n} \n} \n} \nlocalConcepts . put ( tableVersion , tmpTable ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( ! ( this . isFlatten ( ) ) ) { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < datasetContainer . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( ! ( curNamer . getAddLevel ( ) ) ) { \nnamedDs . addDataset ( curDs ) ; \n} \nelse { \naddLevelDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni ++ ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5679": "public class ScalablePicture { \npublic Dimension getScaledSize ( ) { \nif ( ! ( scaledPicture != null ) ) return new Dimension ( 0 , 0 ) ; \nelse return new Dimension ( scaledPicture . getWidth ( ) , scaledPicture . getHeight ( ) ) ; \n} \n} \n"}
{"5680": "public class ScalablePicture { \npublic String getScaledSizeString ( ) { \nif ( ! ( scaledPicture != null ) ) return \"0 x 0\" ; \nelse return Integer . toString ( scaledPicture . getWidth ( ) ) + \" x \" + Integer . toString ( scaledPicture . getHeight ( ) ) ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \nfor ( int group = 0 ; \ngroup < belowGroups . length ; \ngroup ++ ) { \nif ( ! ( above ) ) { \npartToCheck = belowGroups [ group ] ; \n} \nelse { \npartToCheck = aboveGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \n} \nif ( ! ( ! above ) ) { \ndone = true ; \n} \nelse { \nabove = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( ! ( file . length ( ) + total > maxBytes ) ) { \ntotal += file . length ( ) ; \n} \nelse { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) && sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5691": "public class CoordinateAxis { \nstatic public CoordinateAxis factory ( NetcdfDataset ncd , VariableDS vds ) { \nif ( ! ( ( vds . getRank ( ) == 0 ) || ( vds . getRank ( ) == 1 ) || ( vds . getRank ( ) == 2 && vds . getDataType ( ) == DataType . CHAR ) ) ) if ( ! ( vds . getRank ( ) == 2 ) ) return new CoordinateAxis ( ncd , vds ) ; \nelse return new CoordinateAxis2D ( ncd , vds ) ; \nelse { \nreturn new CoordinateAxis1D ( ncd , vds ) ; \n} \n} \n} \n"}
{"5696": "public class JTableSorted { \npublic void setList ( ArrayList rowList ) { \nthis . list = rowList ; \nif ( ! ( list . size ( ) > 0 ) ) jtable . clearSelection ( ) ; \nelse jtable . setRowSelectionInterval ( 0 , 0 ) ; \nmodel . sort ( ) ; \njtable . revalidate ( ) ; \n} \n} \n"}
{"5697": "public class JTableSorted { \npublic TableRow getSelected ( ) { \nif ( list . size ( ) == 0 ) return null ; \nint sel = jtable . getSelectedRow ( ) ; \nif ( ! ( sel >= 0 ) ) return null ; \nelse return ( TableRow ) list . get ( sel ) ; \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nint curr = jtable . getSelectedRow ( ) ; \nif ( ! ( increment && ( curr < list . size ( ) - 1 ) ) ) if ( ! increment && ( curr > 0 ) ) setSelected ( curr - 1 ) ; \nelse setSelected ( curr + 1 ) ; \n} \n} \n"}
{"5709": "public class XMLStore { \npublic void save ( ) throws java . io . IOException { \nif ( prefsFile == null ) throw new UnsupportedOperationException ( \"XMLStore is read-only\" ) ; \nFile prefTemp ; \nString parentFilename = prefsFile . getParent ( ) ; \nif ( ! ( parentFilename == null ) ) { \nFile parentFile = new File ( parentFilename ) ; \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" , parentFile ) ; \n} \nelse { \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" ) ; \n} \nprefTemp . deleteOnExit ( ) ; \nFileOutputStream fos = new FileOutputStream ( prefTemp , false ) ; \nsave ( fos ) ; \nfos . close ( ) ; \nPath xmlBackup = Paths . get ( prefsFile . getAbsolutePath ( ) + \".bak\" ) ; \nPath prefsPath = prefsFile . toPath ( ) ; \nif ( Files . exists ( prefsPath ) ) Files . move ( prefsPath , xmlBackup , StandardCopyOption . REPLACE_EXISTING ) ; \nFiles . move ( prefTemp . toPath ( ) , prefsFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; \n} \n} \n"}
{"5710": "public class XMLStore { \npublic void save ( OutputStream out ) throws java . io . IOException { \noutputExceptionMessage = null ; \nOutputMunger bos = new OutputMunger ( out ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bos , CDM . utf8Charset ) ) ; \nXMLEncoder beanEncoder = new XMLEncoder ( bos ) ; \nbeanEncoder . setExceptionListener ( new ExceptionListener ( ) { \npublic void exceptionThrown ( Exception exception ) { \nSystem . out . println ( \"XMLStore.save() got Exception: abort saving the preferences!\" ) ; \nexception . printStackTrace ( ) ; \noutputExceptionMessage = exception . getMessage ( ) ; \n} \n} \n) ; \npw . printf ( \"<?xml version='1.0' encoding='UTF-8'?>%n\" ) ; \npw . printf ( \"<preferences EXTERNAL_XML_VERSION='1.0'>%n\" ) ; \nif ( ! ( ! rootPrefs . isUserNode ( ) ) ) pw . printf ( \"  <root type='user'>%n\" ) ; \nelse pw . printf ( \"  <root type='system'>%n\" ) ; \nIndent indent = new Indent ( 2 ) ; \nindent . incr ( ) ; \nwriteXmlNode ( bos , pw , rootPrefs , beanEncoder , indent ) ; \nif ( outputExceptionMessage != null ) throw new IOException ( outputExceptionMessage ) ; \npw . printf ( \"  </root>%n\" ) ; \npw . printf ( \"</preferences>%n\" ) ; \npw . flush ( ) ; \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( ! ( false ) ) { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \nelse while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \n} \n} \n"}
{"5718": "public class DbaseData { \nint readRowN ( DataInputStream ds , int n ) { \nif ( n > nrec ) return - 1 ; \ntry { \nds . readFully ( field , 0 , desc . FieldLength ) ; \n} \ncatch ( java . io . IOException e ) { \nreturn - 1 ; \n} \nswitch ( desc . Type ) { \ncase 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; \nbreak ; \ncase 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; \nbreak ; \ncase 'F' : if ( ! ( desc . FieldLength == 4 ) ) { \nnumeric [ n ] = Swap . swapDouble ( field , 0 ) ; \n} \nelse { \nnumeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; \n} \nbreak ; \ncase 'L' : switch ( field [ 0 ] ) { \ncase 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; \nbreak ; \ndefault : logical [ n ] = false ; \nbreak ; \n} \ndefault : return - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( ! ( bitmap == null ) ) { \nfor ( int i = 0 ; \ni < totalNPoints ; \ni ++ ) { \nif ( ! ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) ) { \ndata [ i ] = staticMissingValue ; \n} \nelse { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \n} \n} \nelse { \nfor ( int i = 0 ; \ni < totalNPoints ; \ni ++ ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \n} \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { \nlogger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \n} \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( ! ( bitmap == null ) ) { \nfor ( int bitPt = 0 , dataPt = 0 ; \nbitPt < totalNPoints ; \nbitPt ++ ) { \nif ( ! ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) ) { \ndata [ bitPt ] = staticMissingValue ; \n} \nelse { \ndata [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; \n} \n} \n} \nelse { \nfor ( int i = 0 ; \ni < dataNPoints ; \ni ++ ) { \ndata [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \n} \n} \nreturn data ; \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nint dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( ! ( gateIdx >= dataCount ) ) { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nshort value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \nelse ii . setShortNext ( uf_header2 . missing ) ; \n} \n} \n} \n"}
{"5748": "public class Grib1SectionGridDefinition { \npublic long calcCRC ( ) { \nlong crc ; \nif ( ! ( rawData == null ) ) { \nCRC32 crc32 = new CRC32 ( ) ; \ncrc32 . update ( rawData ) ; \ncrc = crc32 . getValue ( ) ; \n} \nelse crc = predefinedGridDefinitionCenter << 16 + predefinedGridDefinition ; \nreturn crc ; \n} \n} \n"}
{"5750": "public class AbstractCursor { \n@ Override public int fieldIndex ( String name ) throws DapException { \nDapStructure ds ; \nif ( ! ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) ) if ( ! ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) ) throw new DapException ( \"Attempt to get field name on non-compound object\" ) ; \nelse ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; \nelse ds = ( DapStructure ) getTemplate ( ) ; \nint i = ds . indexByName ( name ) ; \nif ( i < 0 ) throw new DapException ( \"Unknown field name: \" + name ) ; \nreturn i ; \n} \n} \n"}
{"5753": "public class CFPolygon { \npublic void setNext ( Polygon next ) { \nif ( ! ( next instanceof CFPolygon ) ) this . next = next ; \nelse { \nsetNext ( ( CFPolygon ) next ) ; \n} \n} \n} \n"}
{"5754": "public class CFPolygon { \npublic void setPrev ( Polygon prev ) { \nif ( ! ( prev instanceof CFPolygon ) ) this . prev = prev ; \nelse { \nsetPrev ( ( CFPolygon ) prev ) ; \n} \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( ! ( 0 <= ( row = model . search ( proj ) ) ) ) { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection not found = \" + row ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \nelse { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection found = \" + row ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \n} \n} \n"}
{"5757": "public class TimeOffsetAxis { \npublic Optional < TimeOffsetAxis > subsetFromTime ( SubsetParams params , CalendarDate runDate ) { \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \nCoverageCoordAxisBuilder builder = null ; \nif ( params . isTrue ( SubsetParams . timePresent ) ) { \ndouble offset = getOffsetInTimeUnits ( runDate , CalendarDate . present ( ) ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nCalendarDate dateWanted = ( CalendarDate ) params . get ( SubsetParams . time ) ; \nif ( dateWanted != null ) { \ndouble offset = getOffsetInTimeUnits ( runDate , dateWanted ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nInteger stride = ( Integer ) params . get ( SubsetParams . timeStride ) ; \nif ( stride == null || stride < 0 ) stride = 1 ; \nCalendarDateRange dateRange = ( CalendarDateRange ) params . get ( SubsetParams . timeRange ) ; \nif ( dateRange != null ) { \ndouble min = getOffsetInTimeUnits ( runDate , dateRange . getStart ( ) ) ; \ndouble max = getOffsetInTimeUnits ( runDate , dateRange . getEnd ( ) ) ; \nOptional < CoverageCoordAxisBuilder > buildero = helper . subset ( min , max , stride ) ; \nif ( ! ( buildero . isPresent ( ) ) ) return Optional . empty ( buildero . getErrorMessage ( ) ) ; \nelse builder = buildero . get ( ) ; \n} \nassert ( builder != null ) ; \nbuilder . setReferenceDate ( runDate ) ; \nreturn Optional . of ( new TimeOffsetAxis ( builder ) ) ; \n} \n} \n"}
{"5759": "public class NetcdfFile { \nstatic public void registerIOProvider ( Class iospClass , boolean last ) throws IllegalAccessException , InstantiationException { \nIOServiceProvider spi ; \nspi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nif ( ! ( userLoads && ! last ) ) registeredProviders . add ( spi ) ; \nelse registeredProviders . add ( 0 , spi ) ; \n} \n} \n"}
{"5782": "public class NetcdfFile { \npublic Object sendIospMessage ( Object message ) { \nif ( null == message ) return null ; \nif ( ! ( message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ) if ( message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE ) { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nif ( gotit ) { \nrootGroup . remove ( v ) ; \nvariables . remove ( v ) ; \nremoveRecordStructure ( ) ; \n} \nreturn ( gotit ) ; \n} \nelse { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nreturn gotit || makeRecordStructure ( ) ; \n} \nif ( spi != null ) return spi . sendIospMessage ( message ) ; \nreturn null ; \n} \n} \n"}
{"5785": "public class NetcdfFile { \npublic Array readSection ( String variableSection ) throws IOException , InvalidRangeException { \nParsedSectionSpec cer = ParsedSectionSpec . parseVariableSection ( this , variableSection ) ; \nif ( cer . child == null ) { \nreturn cer . v . read ( cer . section ) ; \n} \nif ( ! ( spi == null ) ) return spi . readSection ( cer ) ; \nelse return IospHelper . readSection ( cer ) ; \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nlog . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( ! ( val > 0xFF || val < 0 ) ) return true ; \nelse return false ; \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5800": "public class Attribute { \nprivate static final boolean checkUInt ( String s ) { \ntry { \nlong val = Long . parseLong ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkUInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( ! ( val > 0xFFFFFFFFL ) ) return true ; \nelse return false ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( ! ( s . equals ( \".\" ) ) ) if ( ! ( s . equals ( \"..\" ) ) ) { \ni ++ ; \n} \nelse { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse continue ; \n} \nreturn true ; \n} \n} \n"}
{"5810": "public class GridDefRecord { \npublic final String getParam ( String key ) { \nString value = paramStr . get ( key ) ; \nif ( value == null ) { \nDouble result = paramDbl . get ( key ) ; \nif ( ! ( result != null ) ) { \nInteger intResult = paramInt . get ( key ) ; \nif ( intResult != null ) { \nvalue = intResult . toString ( ) ; \n} \n} \nelse { \nvalue = result . toString ( ) ; \n} \nif ( value != null ) { \nparamStr . put ( key , value ) ; \n} \n} \nif ( debug && value == null ) { \nSystem . out . println ( key + \" value not found\" ) ; \n} \nreturn value ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) return false ; \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( ! ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) ) if ( ! ( val . matches ( \"^[0-9]+\" ) ) ) { \nif ( ! val . equals ( oval ) ) return false ; \n} \nelse { \nif ( ! val . equals ( oval ) ) return false ; \n} \nelse { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( ! ( start == 0 ) ) return start ; \nelse return b . have - 3 ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( ! ( last > b . have ) ) { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nelse { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5814": "public class Ceparse { \nString removeQuotes ( String s ) { \nif ( ! ( s . startsWith ( \"\\\"\" ) && s . endsWith ( \"\\\"\" ) ) ) return s ; \nelse return s . substring ( 1 , s . length ( ) - 1 ) ; \n} \n} \n"}
{"5816": "public class NcmlEditor { \nboolean writeNcml ( String location ) { \nboolean err = false ; \ncloseOpenFiles ( ) ; \ntry { \nfinal String result ; \nds = openDataset ( location , addCoords , null ) ; \nif ( ! ( ds == null ) ) { \nfinal NcMLWriter ncmlWriter = new NcMLWriter ( ) ; \nfinal Element netcdfElem = ncmlWriter . makeNetcdfElement ( ds , null ) ; \nresult = ncmlWriter . writeToString ( netcdfElem ) ; \neditor . setText ( result ) ; \neditor . setCaretPosition ( 0 ) ; \n} \nelse { \neditor . setText ( \"Failed to open <\" + location + \">\" ) ; \n} \n} \ncatch ( Exception e ) { \nfinal StringWriter sw = new StringWriter ( 10000 ) ; \ne . printStackTrace ( ) ; \ne . printStackTrace ( new PrintWriter ( sw ) ) ; \neditor . setText ( sw . toString ( ) ) ; \nerr = true ; \n} \nreturn ! err ; \n} \n} \n"}
{"5821": "public class Cinrad2Record { \npublic float getAzimuth ( ) { \nif ( message_type != 1 ) return - 1.0f ; \nif ( ! ( Cinrad2IOServiceProvider . isSC ) ) if ( ! ( Cinrad2IOServiceProvider . isCC ) ) if ( Cinrad2IOServiceProvider . isCC20 ) return azimuth_ang * 0.01f ; \nelse return 360.0f * azimuth_ang / 512.0f ; \nelse return 360.0f * azimuth_ang / 65536.0f ; \nreturn 180.0f * azimuth_ang / 32768.0f ; \n} \n} \n"}
{"5822": "public class Cinrad2Record { \npublic float getElevation ( ) { \nif ( message_type != 1 ) return - 1.0f ; \nif ( ! ( Cinrad2IOServiceProvider . isSC ) ) if ( ! ( Cinrad2IOServiceProvider . isCC ) ) if ( Cinrad2IOServiceProvider . isCC20 ) return elevation_ang * 0.01f ; \nelse return elevation_ang * 0.01f ; \nelse return 120.0f * elevation_ang / 65536.0f ; \nreturn 180.0f * elevation_ang / 32768.0f ; \n} \n} \n"}
{"5834": "public class Structure { \npublic StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { \nSection section = null ; \nif ( ! ( getRank ( ) == 1 ) ) if ( getRank ( ) > 1 ) { \nIndex ii = Index . factory ( shape ) ; \nii . setCurrentCounter ( index ) ; \nint [ ] origin = ii . getCurrentCounter ( ) ; \nsection = new Section ( ) ; \nfor ( int anOrigin : origin ) section . appendRange ( anOrigin , anOrigin ) ; \n} \nelse { \nsection = new Section ( ) . appendRange ( index , index ) ; \n} \nArray dataArray = read ( section ) ; \nArrayStructure data = ( ArrayStructure ) dataArray ; \nreturn data . getStructureData ( 0 ) ; \n} \n} \n"}
{"5841": "public class ProjectionImpl { \nProjectionRect latLonToProjBB2 ( LatLonRect latlonRect ) { \ndouble minx , maxx , miny , maxy ; \nLatLonPointImpl llpt = latlonRect . getLowerLeftPoint ( ) ; \nLatLonPointImpl urpt = latlonRect . getUpperRightPoint ( ) ; \nLatLonPointImpl lrpt = latlonRect . getLowerRightPoint ( ) ; \nLatLonPointImpl ulpt = latlonRect . getUpperLeftPoint ( ) ; \nif ( ! ( isLatLon ( ) ) ) { \nProjectionPoint ll = latLonToProj ( llpt , new ProjectionPointImpl ( ) ) ; \nProjectionPoint ur = latLonToProj ( urpt , new ProjectionPointImpl ( ) ) ; \nProjectionPoint lr = latLonToProj ( lrpt , new ProjectionPointImpl ( ) ) ; \nProjectionPoint ul = latLonToProj ( ulpt , new ProjectionPointImpl ( ) ) ; \nminx = Math . min ( ll . getX ( ) , ul . getX ( ) ) ; \nminy = Math . min ( ll . getY ( ) , lr . getY ( ) ) ; \nmaxx = Math . max ( ur . getX ( ) , lr . getX ( ) ) ; \nmaxy = Math . max ( ul . getY ( ) , ur . getY ( ) ) ; \n} \nelse { \nminx = getMinOrMaxLon ( llpt . getLongitude ( ) , ulpt . getLongitude ( ) , true ) ; \nminy = Math . min ( llpt . getLatitude ( ) , lrpt . getLatitude ( ) ) ; \nmaxx = getMinOrMaxLon ( urpt . getLongitude ( ) , lrpt . getLongitude ( ) , false ) ; \nmaxy = Math . min ( ulpt . getLatitude ( ) , urpt . getLatitude ( ) ) ; \n} \nreturn new ProjectionRect ( minx , miny , maxx , maxy ) ; \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \nfor ( int i = 0 ; \ni < rawTypes . length ; \ni ++ ) { \nif ( ! ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) ) { \nresult . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \n} \nelse { \nresult . add ( i , \"PRIMARY\" ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5864": "public class ListTransformation { \nprivate void initListEvents ( ) { \nthis . listChangeListener = new ListChangeListener < SourceType > ( ) { \n@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { \nList < TargetType > deleteStaging = new ArrayList < > ( ) ; \nwhile ( listEvent . next ( ) ) { \nif ( ! ( listEvent . wasUpdated ( ) ) ) if ( ! ( listEvent . wasReplaced ( ) ) ) if ( ! ( listEvent . wasAdded ( ) ) ) if ( listEvent . wasRemoved ( ) ) { \nprocessRemoveEvent ( listEvent , deleteStaging ) ; \n} \nelse { \nprocessAddEvent ( listEvent ) ; \n} \nelse { \nprocessReplaceEvent ( listEvent , deleteStaging ) ; \n} \nelse { \nprocessUpdateEvent ( listEvent ) ; \n} \n} \nprocessStagingLists ( deleteStaging ) ; \n} \n} \n; \nmodelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; \n} \n} \n"}
{"5877": "public class SelectableItemList { \nprivate void createIndexEvents ( ) { \nselectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { \nint index = newVal . intValue ( ) ; \nListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; \nselectedItem . set ( item ) ; \n} \n) ; \nselectedItem . addListener ( ( observable , oldVal , newVal ) -> { \nif ( ! ( newVal == null ) ) { \nint index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; \nif ( ! ( index != - 1 ) ) { \nselectedItem . set ( oldVal ) ; \n} \nelse { \nselectionModel . select ( index ) ; \n} \n} \nelse { \nselectionModel . select ( - 1 ) ; \nselectedItem . set ( null ) ; \n} \n} \n) ; \n} \n} \n"}
{"5880": "public class FxmlViewLoader { \nprivate String createFxmlPath ( Class < ? > viewType ) { \nfinal StringBuilder pathBuilder = new StringBuilder ( ) ; \nfinal FxmlPath pathAnnotation = viewType . getDeclaredAnnotation ( FxmlPath . class ) ; \nfinal String fxmlPath = Optional . ofNullable ( pathAnnotation ) . map ( FxmlPath :: value ) . map ( String :: trim ) . orElse ( \"\" ) ; \nif ( ! ( fxmlPath . isEmpty ( ) ) ) { \npathBuilder . append ( fxmlPath ) ; \n} \nelse { \npathBuilder . append ( \"/\" ) ; \nif ( viewType . getPackage ( ) != null ) { \npathBuilder . append ( viewType . getPackage ( ) . getName ( ) . replaceAll ( \"\\\\.\" , \"/\" ) ) ; \npathBuilder . append ( \"/\" ) ; \n} \npathBuilder . append ( viewType . getSimpleName ( ) ) ; \npathBuilder . append ( \".fxml\" ) ; \n} \nreturn pathBuilder . toString ( ) ; \n} \n} \n"}
{"5890": "public class UserConnection { \npublic TResult query ( UserQuery query ) { \nCursor cursor = null ; \nString [ ] selectionArgs = query . getSelectionArgs ( ) ; \nString sql = query . getSql ( ) ; \nif ( ! ( sql != null ) ) { \nString table = query . getTable ( ) ; \nString [ ] columns = query . getColumns ( ) ; \nString selection = query . getSelection ( ) ; \nString groupBy = query . getGroupBy ( ) ; \nString having = query . getHaving ( ) ; \nString orderBy = query . getOrderBy ( ) ; \nString [ ] columnsAs = query . getColumnsAs ( ) ; \nString limit = query . getLimit ( ) ; \nif ( ! ( columnsAs != null && limit != null ) ) if ( ! ( columnsAs != null ) ) if ( ! ( limit != null ) ) { \ncursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; \n} \nelse { \ncursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \n} \nelse { \ncursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy ) ; \n} \nelse { \ncursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \n} \n} \nelse { \ncursor = database . rawQuery ( sql , selectionArgs ) ; \n} \nTResult result = handleCursor ( cursor , query ) ; \nreturn result ; \n} \n} \n"}
{"5904": "public class Icons { \npublic void setIcon ( IconRow iconRow , GeometryType geometryType ) { \nif ( ! ( geometryType != null ) ) { \ndefaultIcon = iconRow ; \n} \nelse { \nif ( ! ( iconRow != null ) ) { \nicons . remove ( geometryType ) ; \n} \nelse { \nicons . put ( geometryType , iconRow ) ; \n} \n} \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \nfor ( int zoom = minZoom ; \nzoom <= maxZoom ; \nzoom ++ ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( ! ( degrees ) ) { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5931": "public class TileGenerator { \nprivate void adjustBounds ( BoundingBox boundingBox , int zoom ) { \nif ( ! ( googleTiles ) ) if ( ! ( projection . isUnit ( Units . DEGREES ) ) ) { \nadjustGeoPackageBounds ( boundingBox , zoom ) ; \n} \nelse { \nadjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; \n} \nelse { \nadjustGoogleBounds ( ) ; \n} \n} \n} \n"}
{"5959": "public class GeoPackageManagerImpl { \nprivate boolean isValid ( String database , boolean validateHeader , boolean validateIntegrity ) { \nboolean valid = false ; \nif ( exists ( database ) ) { \nGeoPackageCursorFactory cursorFactory = new GeoPackageCursorFactory ( ) ; \nString path = null ; \nSQLiteDatabase sqlite ; \nGeoPackageMetadata metadata = getGeoPackageMetadata ( database ) ; \nif ( ! ( metadata != null && metadata . isExternal ( ) ) ) { \npath = context . getDatabasePath ( database ) . getAbsolutePath ( ) ; \nsqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , cursorFactory ) ; \n} \nelse { \npath = metadata . getExternalPath ( ) ; \ntry { \nsqlite = SQLiteDatabase . openDatabase ( path , cursorFactory , SQLiteDatabase . OPEN_READWRITE | SQLiteDatabase . NO_LOCALIZED_COLLATORS ) ; \n} \ncatch ( Exception e ) { \nsqlite = SQLiteDatabase . openDatabase ( path , cursorFactory , SQLiteDatabase . OPEN_READONLY | SQLiteDatabase . NO_LOCALIZED_COLLATORS ) ; \n} \n} \ntry { \nvalid = ( ! validateHeader || isDatabaseHeaderValid ( sqlite ) ) && ( ! validateIntegrity || sqlite . isDatabaseIntegrityOk ( ) ) ; \n} \ncatch ( Exception e ) { \nLog . e ( GeoPackageManagerImpl . class . getSimpleName ( ) , \"Failed to validate database\" , e ) ; \n} \nfinally { \nsqlite . close ( ) ; \n} \n} \nreturn valid ; \n} \n} \n"}
{"5966": "public class GeoPackageManagerImpl { \nprivate void addExternalDatabases ( Collection < String > databases ) { \nList < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; \nfor ( GeoPackageMetadata external : externalGeoPackages ) { \nif ( ! ( new File ( external . getExternalPath ( ) ) . exists ( ) ) ) { \ndelete ( external . getName ( ) ) ; \n} \nelse { \ndatabases . add ( external . getName ( ) ) ; \n} \n} \n} \n} \n"}
{"5967": "public class GeoPackageManagerImpl { \nprivate boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { \ntry { \nif ( exists ( database ) ) { \nif ( ! ( override ) ) { \nthrow new GeoPackageException ( \"GeoPackage database already exists: \" + database ) ; \n} \nelse { \nif ( ! delete ( database ) ) { \nthrow new GeoPackageException ( \"Failed to delete existing database: \" + database ) ; \n} \n} \n} \nFile newDbFile = context . getDatabasePath ( database ) ; \ntry { \nSQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; \ndb . close ( ) ; \nGeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; \n} \ncatch ( IOException e ) { \nthrow new GeoPackageException ( \"Failed to import GeoPackage database: \" + database , e ) ; \n} \n} \nfinally { \nGeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; \n} \nif ( progress == null || progress . isActive ( ) ) { \ntry { \nSQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { \n@ Override public void onCorruption ( SQLiteDatabase dbObj ) { \n} \n} \n) ; \nvalidateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; \nGeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; \nmetadataDb . open ( ) ; \ntry { \nGeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; \nGeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; \nmetadata . setName ( database ) ; \ndataSource . create ( metadata ) ; \n} \nfinally { \nmetadataDb . close ( ) ; \n} \n} \ncatch ( Exception e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; \n} \nGeoPackage geoPackage = open ( database , false ) ; \nif ( ! ( geoPackage != null ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; \n} \nelse { \ntry { \nif ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \n} \ncatch ( SQLException e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nfinally { \ngeoPackage . close ( ) ; \n} \n} \n} \nreturn exists ( database ) ; \n} \n} \n"}
{"5973": "public class GeometryMetadataDataSource { \npublic boolean createOrUpdate ( GeometryMetadata metadata ) { \nboolean success = false ; \nif ( ! ( exists ( metadata ) ) ) { \ncreate ( metadata ) ; \nsuccess = true ; \n} \nelse { \nsuccess = update ( metadata ) ; \n} \nreturn success ; \n} \n} \n"}
{"5993": "public class FeatureTiles { \npublic void calculateDrawOverlap ( ) { \nif ( ! ( pointIcon != null ) ) { \nheightOverlap = this . density * pointRadius ; \nwidthOverlap = this . density * pointRadius ; \n} \nelse { \nheightOverlap = this . density * pointIcon . getHeight ( ) ; \nwidthOverlap = this . density * pointIcon . getWidth ( ) ; \n} \nfloat linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; \nfloat polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; \nif ( featureTableStyles != null && featureTableStyles . has ( ) ) { \nSet < Long > styleRowIds = new HashSet < > ( ) ; \nList < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; \nif ( tableStyleIds != null ) { \nstyleRowIds . addAll ( tableStyleIds ) ; \n} \nList < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; \nif ( styleIds != null ) { \nstyleRowIds . addAll ( styleIds ) ; \n} \nStyleDao styleDao = featureTableStyles . getStyleDao ( ) ; \nfor ( long styleRowId : styleRowIds ) { \nStyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; \nfloat styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; \nwidthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; \nheightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; \n} \nSet < Long > iconRowIds = new HashSet < > ( ) ; \nList < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; \nif ( tableIconIds != null ) { \niconRowIds . addAll ( tableIconIds ) ; \n} \nList < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; \nif ( iconIds != null ) { \niconRowIds . addAll ( iconIds ) ; \n} \nIconDao iconDao = featureTableStyles . getIconDao ( ) ; \nfor ( long iconRowId : iconRowIds ) { \nIconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; \ndouble [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; \nfloat iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; \nfloat iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; \nwidthOverlap = Math . max ( widthOverlap , iconWidth ) ; \nheightOverlap = Math . max ( heightOverlap , iconHeight ) ; \n} \n} \n} \n} \n"}
{"5998": "public class FeatureTiles { \npublic Bitmap drawTile ( int x , int y , int zoom ) { \nBitmap bitmap ; \nif ( ! ( isIndexQuery ( ) ) ) { \nbitmap = drawTileQueryAll ( x , y , zoom ) ; \n} \nelse { \nbitmap = drawTileQueryIndex ( x , y , zoom ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"5999": "public class FeatureTiles { \npublic Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { \nBoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; \ntry { \nlong tileCount = results . count ( ) ; \nif ( tileCount > 0 ) { \nif ( ! ( maxFeaturesPerTile == null || tileCount <= maxFeaturesPerTile . longValue ( ) ) ) if ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; \n} \nelse { \nbitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; \n} \n} \n} \nfinally { \nresults . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6004": "public class FeatureTiles { \npublic Bitmap drawTileQueryAll ( int x , int y , int zoom ) { \nBoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureCursor cursor = featureDao . queryForAll ( ) ; \ntry { \nint totalCount = cursor . getCount ( ) ; \nif ( totalCount > 0 ) { \nif ( ! ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) ) if ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; \n} \nelse { \nbitmap = drawTile ( zoom , boundingBox , cursor ) ; \n} \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6005": "public class FeatureTiles { \nprotected List < Point > simplifyPoints ( double simplifyTolerance , List < Point > points ) { \nList < Point > simplifiedPoints = null ; \nif ( ! ( simplifyGeometries ) ) { \nsimplifiedPoints = points ; \n} \nelse { \nif ( projection != null && ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform toWebMercator = projection . getTransformation ( WEB_MERCATOR_PROJECTION ) ; \npoints = toWebMercator . transform ( points ) ; \n} \nsimplifiedPoints = GeometryUtils . simplifyPoints ( points , simplifyTolerance ) ; \nif ( projection != null && ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform fromWebMercator = WEB_MERCATOR_PROJECTION . getTransformation ( projection ) ; \nsimplifiedPoints = fromWebMercator . transform ( simplifiedPoints ) ; \n} \n} \nreturn simplifiedPoints ; \n} \n} \n"}
{"6009": "public class FeatureTiles { \nprotected Paint getPolygonFillPaint ( FeatureStyle featureStyle ) { \nPaint paint = null ; \nboolean hasStyleColor = false ; \nif ( featureStyle != null ) { \nStyleRow style = featureStyle . getStyle ( ) ; \nif ( style != null ) { \nif ( ! ( style . hasFillColor ( ) ) ) { \nhasStyleColor = style . hasColor ( ) ; \n} \nelse { \npaint = getStylePaint ( style , FeatureDrawType . FILL ) ; \n} \n} \n} \nif ( paint == null && ! hasStyleColor && fillPolygon ) { \npaint = polygonFillPaint ; \n} \nreturn paint ; \n} \n} \n"}
{"6017": "public class FeatureTileCanvas { \npublic Bitmap createBitmap ( ) { \nBitmap bitmap = null ; \nCanvas canvas = null ; \nfor ( int layer = 0 ; \nlayer < 4 ; \nlayer ++ ) { \nBitmap layerBitmap = layeredBitmap [ layer ] ; \nif ( layerBitmap != null ) { \nif ( ! ( bitmap == null ) ) { \ncanvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; \nlayerBitmap . recycle ( ) ; \n} \nelse { \nbitmap = layerBitmap ; \ncanvas = layeredCanvas [ layer ] ; \n} \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \nreturn bitmap ; \n} \n} \n"}
{"6036": "public class FeatureStyleExtension { \npublic void setTableFeatureStyles ( String featureTable , FeatureStyles featureStyles ) { \nif ( ! ( featureStyles != null ) ) { \ndeleteTableFeatureStyles ( featureTable ) ; \n} \nelse { \nsetTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; \nsetTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; \n} \n} \n} \n"}
{"6040": "public class FeatureStyleExtension { \npublic void setFeatureStyles ( String featureTable , long featureId , FeatureStyles featureStyles ) { \nif ( ! ( featureStyles != null ) ) { \ndeleteStyles ( featureTable , featureId ) ; \ndeleteIcons ( featureTable , featureId ) ; \n} \nelse { \nsetStyles ( featureTable , featureId , featureStyles . getStyles ( ) ) ; \nsetIcons ( featureTable , featureId , featureStyles . getIcons ( ) ) ; \n} \n} \n} \n"}
{"6051": "public class FeatureStyleExtension { \nprivate long getOrInsertStyle ( StyleRow style ) { \nlong styleId ; \nif ( ! ( style . hasId ( ) ) ) { \nStyleDao styleDao = getStyleDao ( ) ; \nstyleId = styleDao . create ( style ) ; \n} \nelse { \nstyleId = style . getId ( ) ; \n} \nreturn styleId ; \n} \n} \n"}
{"6052": "public class FeatureStyleExtension { \nprivate long getOrInsertIcon ( IconRow icon ) { \nlong iconId ; \nif ( ! ( icon . hasId ( ) ) ) { \nIconDao iconDao = getIconDao ( ) ; \niconId = iconDao . create ( icon ) ; \n} \nelse { \niconId = icon . getId ( ) ; \n} \nreturn iconId ; \n} \n} \n"}
{"6063": "public class CoverageDataPngImage { \npublic byte [ ] getImageBytes ( ) { \nbyte [ ] bytes = null ; \nif ( ! ( imageBytes != null ) ) if ( outputStream != null ) { \nbytes = outputStream . toByteArray ( ) ; \n} \nelse { \nbytes = imageBytes ; \n} \nreturn bytes ; \n} \n} \n"}
{"6065": "public class CoverageDataPngImage { \npublic int getPixel ( int x , int y ) { \nint pixel = - 1 ; \nif ( pixels == null ) { \nreadPixels ( ) ; \n} \nif ( ! ( pixels != null ) ) { \nthrow new GeoPackageException ( \"Could not retrieve pixel value\" ) ; \n} \nelse { \npixel = pixels [ y ] [ x ] ; \n} \nreturn pixel ; \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( ! ( i == 0 ) ) { \npath . lineTo ( x , y ) ; \n} \nelse { \npath . moveTo ( x , y ) ; \n} \n} \n} \n} \n} \n"}
{"6102": "public class ContextIOUtils { \npublic static File getInternalFile ( Context context , String filePath ) { \nFile internalFile = null ; \nif ( ! ( filePath != null ) ) { \ninternalFile = context . getFilesDir ( ) ; \n} \nelse { \ninternalFile = new File ( context . getFilesDir ( ) , filePath ) ; \n} \nreturn internalFile ; \n} \n} \n"}
{"6112": "public class FeatureIndexer { \nprivate boolean index ( long geoPackageId , FeatureRow row , boolean possibleUpdate ) { \nboolean indexed = false ; \nGeoPackageGeometryData geomData = row . getGeometry ( ) ; \nif ( geomData != null ) { \nGeometryEnvelope envelope = geomData . getEnvelope ( ) ; \nif ( envelope == null ) { \nGeometry geometry = geomData . getGeometry ( ) ; \nif ( geometry != null ) { \nenvelope = GeometryEnvelopeBuilder . buildEnvelope ( geometry ) ; \n} \n} \nif ( envelope != null ) { \nGeometryMetadata metadata = geometryMetadataDataSource . populate ( geoPackageId , featureDao . getTableName ( ) , row . getId ( ) , envelope ) ; \nif ( ! ( possibleUpdate ) ) { \ngeometryMetadataDataSource . create ( metadata ) ; \n} \nelse { \ngeometryMetadataDataSource . createOrUpdate ( metadata ) ; \n} \nindexed = true ; \n} \n} \nreturn indexed ; \n} \n} \n"}
{"6130": "public class FeatureTileGenerator { \nprivate static BoundingBox getBoundingBox ( GeoPackage geoPackage , FeatureTiles featureTiles , BoundingBox boundingBox , Projection projection ) { \nString tableName = featureTiles . getFeatureDao ( ) . getTableName ( ) ; \nboolean manualQuery = boundingBox == null ; \nBoundingBox featureBoundingBox = geoPackage . getBoundingBox ( projection , tableName , manualQuery ) ; \nif ( featureBoundingBox != null ) { \nif ( ! ( boundingBox == null ) ) { \nboundingBox = boundingBox . overlap ( featureBoundingBox ) ; \n} \nelse { \nboundingBox = featureBoundingBox ; \n} \n} \nif ( boundingBox != null ) { \nboundingBox = featureTiles . expandBoundingBox ( boundingBox , projection ) ; \n} \nreturn boundingBox ; \n} \n} \n"}
{"6157": "public class ContextInitializer { \nprivate URL findConfigFileFromSystemProperties ( boolean updateStatus ) { \nString logbackConfigFile = OptionHelper . getSystemProperty ( CONFIG_FILE_PROPERTY ) ; \nif ( logbackConfigFile != null ) { \nURL result = null ; \ntry { \nFile file = new File ( logbackConfigFile ) ; \nif ( ! ( file . exists ( ) && file . isFile ( ) ) ) { \nresult = new URL ( logbackConfigFile ) ; \n} \nelse { \nif ( updateStatus ) { \nstatusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; \n} \nresult = file . toURI ( ) . toURL ( ) ; \n} \nreturn result ; \n} \ncatch ( MalformedURLException e ) { \nresult = Loader . getResource ( logbackConfigFile , this . classLoader ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \nfinally { \nif ( updateStatus ) { \nstatusOnResourceSearch ( logbackConfigFile , this . classLoader , result != null ? result . toString ( ) : null ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6160": "public class ContextInitializer { \nprivate void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { \nStatusManager sm = loggerContext . getStatusManager ( ) ; \nif ( ! ( path == null ) ) { \nsm . add ( new InfoStatus ( \"Found resource [\" + resourceName + \"] at [\" + path + \"]\" , loggerContext ) ) ; \n} \nelse { \nsm . add ( new InfoStatus ( \"Could NOT find resource [\" + resourceName + \"]\" , loggerContext ) ) ; \n} \n} \n} \n"}
{"6163": "public class ConverterUtil { \npublic static < E > void startConverters ( Converter < E > head ) { \nConverter < E > c = head ; \nwhile ( c != null ) { \nif ( ! ( c instanceof CompositeConverter ) ) if ( c instanceof DynamicConverter ) { \nDynamicConverter < E > dc = ( DynamicConverter < E > ) c ; \ndc . start ( ) ; \n} \nelse { \nCompositeConverter < E > cc = ( CompositeConverter < E > ) c ; \nConverter < E > childConverter = cc . childConverter ; \nstartConverters ( childConverter ) ; \ncc . start ( ) ; \n} \nc = c . getNext ( ) ; \n} \n} \n} \n"}
{"6166": "public class InterpretationContext { \npublic String getProperty ( String key ) { \nString v = propertiesMap . get ( key ) ; \nif ( ! ( v != null ) ) { \nreturn context . getProperty ( key ) ; \n} \nelse { \nreturn v ; \n} \n} \n} \n"}
{"6169": "public class Parser { \nNode T ( ) throws ScanException { \nToken t = getCurentToken ( ) ; \nexpectNotNull ( t , \"a LITERAL or '%'\" ) ; \nswitch ( t . getType ( ) ) { \ncase Token . LITERAL : advanceTokenPointer ( ) ; \nreturn new Node ( Node . LITERAL , t . getValue ( ) ) ; \ncase Token . PERCENT : advanceTokenPointer ( ) ; \nFormatInfo fi ; \nToken u = getCurentToken ( ) ; \nFormattingNode c ; \nexpectNotNull ( u , \"a FORMAT_MODIFIER, SIMPLE_KEYWORD or COMPOUND_KEYWORD\" ) ; \nif ( ! ( u . getType ( ) == Token . FORMAT_MODIFIER ) ) { \nc = C ( ) ; \n} \nelse { \nfi = FormatInfo . valueOf ( ( String ) u . getValue ( ) ) ; \nadvanceTokenPointer ( ) ; \nc = C ( ) ; \nc . setFormatInfo ( fi ) ; \n} \nreturn c ; \ndefault : return null ; \n} \n} \n} \n"}
{"6171": "public class FileNamePattern { \npublic String toRegexForFixedDate ( Date date ) { \nStringBuilder buf = new StringBuilder ( ) ; \nConverter < Object > p = headTokenConverter ; \nwhile ( p != null ) { \nif ( ! ( p instanceof LiteralConverter ) ) if ( ! ( p instanceof IntegerTokenConverter ) ) if ( p instanceof DateTokenConverter ) { \nDateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; \nif ( ! ( dtc . isPrimary ( ) ) ) { \nbuf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; \n} \nelse { \nbuf . append ( p . convert ( date ) ) ; \n} \n} \nelse { \nbuf . append ( FileFinder . regexEscapePath ( \"(\\\\d+)\" ) ) ; \n} \nelse { \nbuf . append ( p . convert ( null ) ) ; \n} \np = p . getNext ( ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6173": "public class AbstractEventEvaluatorAction { \n@ SuppressWarnings ( \"unchecked\" ) public void end ( InterpretationContext ec , String e ) { \nif ( inError ) { \nreturn ; \n} \nif ( evaluator instanceof LifeCycle ) { \n( ( LifeCycle ) evaluator ) . start ( ) ; \naddInfo ( \"Starting evaluator named [\" + evaluator . getName ( ) + \"]\" ) ; \n} \nObject o = ec . peekObject ( ) ; \nif ( ! ( o != evaluator ) ) { \nec . popObject ( ) ; \ntry { \nMap < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context . getObject ( CoreConstants . EVALUATOR_MAP ) ; \nif ( ! ( evaluatorMap == null ) ) { \nevaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; \n} \nelse { \naddError ( \"Could not find EvaluatorMap\" ) ; \n} \n} \ncatch ( Exception ex ) { \naddError ( \"Could not set evaluator named [\" + evaluator + \"].\" , ex ) ; \n} \n} \nelse { \naddWarn ( \"The object on the top the of the stack is not the evaluator pushed earlier.\" ) ; \n} \n} \n} \n"}
{"6174": "public class ContextSelectorStaticBinder { \npublic void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { \nif ( ! ( this . key == null ) ) if ( this . key != key ) { \nthrow new IllegalAccessException ( \"Only certain classes can access this method.\" ) ; \n} \nelse { \nthis . key = key ; \n} \nString contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; \nif ( ! ( contextSelectorStr == null ) ) if ( ! ( contextSelectorStr . equals ( \"JNDI\" ) ) ) { \ncontextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; \n} \nelse { \nthrow new RuntimeException ( \"JNDI not supported\" ) ; \n} \nelse { \ncontextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; \n} \n} \n} \n"}
{"6181": "public class MDCBasedDiscriminator { \npublic String getDiscriminatingValue ( ILoggingEvent event ) { \nMap < String , String > mdcMap = event . getMDCPropertyMap ( ) ; \nif ( mdcMap == null ) { \nreturn defaultValue ; \n} \nString mdcValue = mdcMap . get ( key ) ; \nif ( ! ( mdcValue == null ) ) { \nreturn mdcValue ; \n} \nelse { \nreturn defaultValue ; \n} \n} \n} \n"}
{"6182": "public class ReconfigureOnChangeFilter { \nprivate void updateMaskIfNecessary ( long now ) { \nfinal long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; \nlastMaskCheck = now ; \nif ( ! ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) ) if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { \nmask = mask >>> 2 ; \n} \nelse { \nmask = ( mask << 1 ) | 1 ; \n} \n} \n} \n"}
{"6188": "public class LocationUtil { \npublic static URL urlForResource ( String location ) throws MalformedURLException , FileNotFoundException { \nif ( location == null ) { \nthrow new NullPointerException ( \"location is required\" ) ; \n} \nURL url = null ; \nif ( ! ( ! location . matches ( SCHEME_PATTERN ) ) ) if ( ! ( location . startsWith ( CLASSPATH_SCHEME ) ) ) { \nurl = new URL ( location ) ; \n} \nelse { \nString path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; \nif ( path . startsWith ( \"/\" ) ) { \npath = path . substring ( 1 ) ; \n} \nif ( path . length ( ) == 0 ) { \nthrow new MalformedURLException ( \"path is required\" ) ; \n} \nurl = Loader . getResourceBySelfClassLoader ( path ) ; \n} \nelse { \nurl = Loader . getResourceBySelfClassLoader ( location ) ; \n} \nif ( url == null ) { \nthrow new FileNotFoundException ( location ) ; \n} \nreturn url ; \n} \n} \n"}
{"6191": "public class StatusPrinter { \npublic static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( ! ( sm == null ) ) { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) { \nprint ( sm , threshold ) ; \n} \n} \nelse { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \n} \n} \n"}
{"6192": "public class StatusPrinter { \npublic static void printIfErrorsOccured ( Context context ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( ! ( sm == null ) ) { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) { \nprint ( sm ) ; \n} \n} \nelse { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \n} \n} \n"}
{"6193": "public class StatusPrinter { \npublic static void print ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( ! ( sm == null ) ) { \nprint ( sm , threshold ) ; \n} \nelse { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \n} \n} \n"}
{"6195": "public class AbstractComponentTracker { \nprivate Entry < C > getFromEitherMap ( String key ) { \nEntry < C > entry = liveMap . get ( key ) ; \nif ( ! ( entry != null ) ) { \nreturn lingerersMap . get ( key ) ; \n} \nelse return entry ; \n} \n} \n"}
{"6197": "public class FormatInfo { \npublic static FormatInfo valueOf ( String str ) throws IllegalArgumentException { \nif ( str == null ) { \nthrow new NullPointerException ( \"Argument cannot be null\" ) ; \n} \nFormatInfo fi = new FormatInfo ( ) ; \nint indexOfDot = str . indexOf ( '.' ) ; \nString minPart = null ; \nString maxPart = null ; \nif ( ! ( indexOfDot != - 1 ) ) { \nminPart = str ; \n} \nelse { \nminPart = str . substring ( 0 , indexOfDot ) ; \nif ( ! ( indexOfDot + 1 == str . length ( ) ) ) { \nmaxPart = str . substring ( indexOfDot + 1 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; \n} \n} \nif ( minPart != null && minPart . length ( ) > 0 ) { \nint min = Integer . parseInt ( minPart ) ; \nif ( ! ( min >= 0 ) ) { \nfi . min = - min ; \nfi . leftPad = false ; \n} \nelse { \nfi . min = min ; \n} \n} \nif ( maxPart != null && maxPart . length ( ) > 0 ) { \nint max = Integer . parseInt ( maxPart ) ; \nif ( ! ( max >= 0 ) ) { \nfi . max = - max ; \nfi . leftTruncate = false ; \n} \nelse { \nfi . max = max ; \n} \n} \nreturn fi ; \n} \n} \n"}
{"6198": "public class RenameUtil { \npublic void rename ( String src , String target ) throws RolloverFailure { \nif ( src . equals ( target ) ) { \naddWarn ( \"Source and target files are the same [\" + src + \"]. Skipping.\" ) ; \nreturn ; \n} \nFile srcFile = new File ( src ) ; \nif ( ! ( srcFile . exists ( ) ) ) { \nthrow new RolloverFailure ( \"File [\" + src + \"] does not exist.\" ) ; \n} \nelse { \nFile targetFile = new File ( target ) ; \ncreateMissingTargetDirsIfNecessary ( targetFile ) ; \naddInfo ( \"Renaming file [\" + srcFile + \"] to [\" + targetFile + \"]\" ) ; \nboolean result = srcFile . renameTo ( targetFile ) ; \nif ( ! result ) { \naddWarn ( \"Failed to rename file [\" + srcFile + \"] as [\" + targetFile + \"].\" ) ; \nBoolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; \nif ( ! ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) ) { \naddWarn ( \"Please consider leaving the [file] option of \" + RollingFileAppender . class . getSimpleName ( ) + \" empty.\" ) ; \naddWarn ( \"See also \" + RENAMING_ERROR_URL ) ; \n} \nelse { \naddWarn ( \"Detected different file systems for source [\" + src + \"] and target [\" + target + \"]. Attempting rename by copying.\" ) ; \nrenameByCopying ( src , target ) ; \nreturn ; \n} \n} \n} \n} \n} \n"}
{"6203": "public class MDCConverter { \nprivate String outputMDCForAllKeys ( Map < String , String > mdcPropertyMap ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Map . Entry < String , String > entry : mdcPropertyMap . entrySet ( ) ) { \nif ( ! ( first ) ) { \nbuf . append ( \", \" ) ; \n} \nelse { \nfirst = false ; \n} \nbuf . append ( entry . getKey ( ) ) . append ( '=' ) . append ( entry . getValue ( ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \nfor ( int i = 0 ; \ni < steArray . length ; \ni ++ ) { \nif ( ! ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) ) { \nif ( found != LINE_NA ) { \nbreak ; \n} \n} \nelse { \nfound = i + 1 ; \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nint availableDepth = steArray . length - found ; \nint desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( int i = 0 ; \ni < desiredDepth ; \ni ++ ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6206": "public class BasicStatusManager { \npublic void add ( Status newStatus ) { \nfireStatusAddEvent ( newStatus ) ; \ncount ++ ; \nif ( newStatus . getLevel ( ) > level ) { \nlevel = newStatus . getLevel ( ) ; \n} \nsynchronized ( statusListLock ) { \nif ( ! ( statusList . size ( ) < MAX_HEADER_COUNT ) ) { \ntailBuffer . add ( newStatus ) ; \n} \nelse { \nstatusList . add ( newStatus ) ; \n} \n} \n} \n} \n"}
{"6213": "public class Introspector { \nstatic public String decapitalize ( String name ) { \nif ( ! ( name == null || name . length ( ) == 0 ) ) { \nString nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; \nif ( name . length ( ) > 1 ) { \nnm += name . substring ( 1 ) ; \n} \nreturn nm ; \n} \nelse { \nreturn name ; \n} \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal int LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nif ( isGet || isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( ! ( isSet ) ) if ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \nelse { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6218": "public class DefinePropertyAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) { \nreturn ; \n} \nObject o = ec . peekObject ( ) ; \nif ( ! ( o != definer ) ) { \naddInfo ( \"Popping property definer for property named [\" + propertyName + \"] from the object stack\" ) ; \nec . popObject ( ) ; \nString propertyValue = definer . getPropertyValue ( ) ; \nif ( propertyValue != null ) { \nActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; \n} \n} \nelse { \naddWarn ( \"The object at the of the stack is not the property definer for property named [\" + propertyName + \"] pushed earlier.\" ) ; \n} \n} \n} \n"}
{"6219": "public class ContextBasedDiscriminator { \npublic String getDiscriminatingValue ( ILoggingEvent event ) { \nString contextName = event . getLoggerContextVO ( ) . getName ( ) ; \nif ( ! ( contextName == null ) ) { \nreturn contextName ; \n} \nelse { \nreturn defaultValue ; \n} \n} \n} \n"}
{"6222": "public class ShutdownHookAction { \n@ Override public void end ( InterpretationContext ic , String name ) throws ActionException { \nif ( inError ) { \nreturn ; \n} \nObject o = ic . peekObject ( ) ; \nif ( ! ( o != hook ) ) { \nic . popObject ( ) ; \nThread hookThread = new Thread ( hook , \"Logback shutdown hook [\" + context . getName ( ) + \"]\" ) ; \naddInfo ( \"Registering shutdown hook with JVM runtime\" ) ; \ncontext . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( hookThread ) ; \n} \nelse { \naddWarn ( \"The object at the of the stack is not the hook pushed earlier.\" ) ; \n} \n} \n} \n"}
{"6223": "public class SSLParametersConfiguration { \nprivate String [ ] enabledProtocols ( String [ ] supportedProtocols , String [ ] defaultProtocols ) { \nif ( enabledProtocols == null ) { \nif ( ! ( OptionHelper . isEmpty ( getIncludedProtocols ( ) ) && OptionHelper . isEmpty ( getExcludedProtocols ( ) ) ) ) { \nenabledProtocols = includedStrings ( supportedProtocols , getIncludedProtocols ( ) , getExcludedProtocols ( ) ) ; \n} \nelse { \nenabledProtocols = Arrays . copyOf ( defaultProtocols , defaultProtocols . length ) ; \n} \nfor ( String protocol : enabledProtocols ) { \naddInfo ( \"enabled protocol: \" + protocol ) ; \n} \n} \nreturn enabledProtocols ; \n} \n} \n"}
{"6224": "public class SSLParametersConfiguration { \nprivate String [ ] enabledCipherSuites ( String [ ] supportedCipherSuites , String [ ] defaultCipherSuites ) { \nif ( enabledCipherSuites == null ) { \nif ( ! ( OptionHelper . isEmpty ( getIncludedCipherSuites ( ) ) && OptionHelper . isEmpty ( getExcludedCipherSuites ( ) ) ) ) { \nenabledCipherSuites = includedStrings ( supportedCipherSuites , getIncludedCipherSuites ( ) , getExcludedCipherSuites ( ) ) ; \n} \nelse { \nenabledCipherSuites = Arrays . copyOf ( defaultCipherSuites , defaultCipherSuites . length ) ; \n} \nfor ( String cipherSuite : enabledCipherSuites ) { \naddInfo ( \"enabled cipher suite: \" + cipherSuite ) ; \n} \n} \nreturn enabledCipherSuites ; \n} \n} \n"}
{"6234": "public class Logger { \nLogger createChildByLastNamePart ( final String lastPart ) { \nint i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; \nif ( i_index != - 1 ) { \nthrow new IllegalArgumentException ( \"Child name [\" + lastPart + \" passed as parameter, may not include [\" + CoreConstants . DOT + \"]\" ) ; \n} \nif ( childrenList == null ) { \nchildrenList = new CopyOnWriteArrayList < Logger > ( ) ; \n} \nLogger childLogger ; \nif ( ! ( this . isRootLogger ( ) ) ) { \nchildLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; \n} \nelse { \nchildLogger = new Logger ( lastPart , this , this . loggerContext ) ; \n} \nchildrenList . add ( childLogger ) ; \nchildLogger . effectiveLevelInt = this . effectiveLevelInt ; \nreturn childLogger ; \n} \n} \n"}
{"6244": "public class Loader { \npublic static ClassLoader getClassLoaderAsPrivileged ( final Class < ? > clazz ) { \nif ( ! ( ! HAS_GET_CLASS_LOADER_PERMISSION ) ) return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { \npublic ClassLoader run ( ) { \nreturn clazz . getClassLoader ( ) ; \n} \n} \n) ; \nelse return null ; \n} \n} \n"}
{"6245": "public class Loader { \npublic static ClassLoader getClassLoaderOfClass ( final Class < ? > clazz ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nif ( ! ( cl == null ) ) { \nreturn cl ; \n} \nelse { \nreturn ClassLoader . getSystemClassLoader ( ) ; \n} \n} \n} \n"}
{"6248": "public class PropertyAction { \npublic void begin ( InterpretationContext ec , String localName , Attributes attributes ) { \nif ( \"substitutionProperty\" . equals ( localName ) ) { \naddWarn ( \"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\" ) ; \n} \nString name = attributes . getValue ( NAME_ATTRIBUTE ) ; \nString value = attributes . getValue ( VALUE_ATTRIBUTE ) ; \nString scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; \nScope scope = ActionUtil . stringToScope ( scopeStr ) ; \nif ( ! ( checkFileAttributeSanity ( attributes ) ) ) if ( ! ( checkResourceAttributeSanity ( attributes ) ) ) if ( ! ( checkValueNameAttributesSanity ( attributes ) ) ) { \naddError ( INVALID_ATTRIBUTES ) ; \n} \nelse { \nvalue = RegularEscapeUtil . basicEscape ( value ) ; \nvalue = value . trim ( ) ; \nvalue = ec . subst ( value ) ; \nActionUtil . setProperty ( ec , name , value , scope ) ; \n} \nelse { \nString resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; \nresource = ec . subst ( resource ) ; \nURL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; \nif ( ! ( resourceURL == null ) ) { \ntry { \nInputStream istream = resourceURL . openStream ( ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( IOException e ) { \naddError ( \"Could not read resource file [\" + resource + \"].\" , e ) ; \n} \n} \nelse { \naddError ( \"Could not find resource [\" + resource + \"].\" ) ; \n} \n} \nelse { \nString file = attributes . getValue ( FILE_ATTRIBUTE ) ; \nfile = ec . subst ( file ) ; \ntry { \nFileInputStream istream = new FileInputStream ( file ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( FileNotFoundException e ) { \naddError ( \"Could not find properties file [\" + file + \"].\" ) ; \n} \ncatch ( IOException e1 ) { \naddError ( \"Could not read properties file [\" + file + \"].\" , e1 ) ; \n} \n} \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) { \nreturn ; \n} \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( ! ( asynchronousSending ) ) { \nsendBuffer ( cbClone , eventObject ) ; \n} \nelse { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount ++ ; \nif ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { \naddError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \n} \nif ( eventMarksEndOfLife ( eventObject ) ) { \ncbTracker . endOfLife ( key ) ; \n} \ncbTracker . removeStaleComponents ( now ) ; \nif ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { \ndelayBetweenStatusMessages *= 4 ; \n} \n} \n} \n} \n"}
{"6255": "public class SMTPAppenderBase { \nprotected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { \ntry { \nMimeBodyPart part = new MimeBodyPart ( ) ; \nStringBuffer sbuf = new StringBuffer ( ) ; \nString header = layout . getFileHeader ( ) ; \nif ( header != null ) { \nsbuf . append ( header ) ; \n} \nString presentationHeader = layout . getPresentationHeader ( ) ; \nif ( presentationHeader != null ) { \nsbuf . append ( presentationHeader ) ; \n} \nfillBuffer ( cb , sbuf ) ; \nString presentationFooter = layout . getPresentationFooter ( ) ; \nif ( presentationFooter != null ) { \nsbuf . append ( presentationFooter ) ; \n} \nString footer = layout . getFileFooter ( ) ; \nif ( footer != null ) { \nsbuf . append ( footer ) ; \n} \nString subjectStr = \"Undefined subject\" ; \nif ( subjectLayout != null ) { \nsubjectStr = subjectLayout . doLayout ( lastEventObject ) ; \nint newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\\n' ) : - 1 ; \nif ( newLinePos > - 1 ) { \nsubjectStr = subjectStr . substring ( 0 , newLinePos ) ; \n} \n} \nMimeMessage mimeMsg = new MimeMessage ( session ) ; \nif ( ! ( from != null ) ) { \nmimeMsg . setFrom ( ) ; \n} \nelse { \nmimeMsg . setFrom ( getAddress ( from ) ) ; \n} \nmimeMsg . setSubject ( subjectStr , charsetEncoding ) ; \nList < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; \nif ( destinationAddresses . isEmpty ( ) ) { \naddInfo ( \"Empty destination address. Aborting email transmission\" ) ; \nreturn ; \n} \nInternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; \nmimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; \nString contentType = layout . getContentType ( ) ; \nif ( ! ( ContentTypeUtil . isTextual ( contentType ) ) ) { \npart . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; \n} \nelse { \npart . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; \n} \nMultipart mp = new MimeMultipart ( ) ; \nmp . addBodyPart ( part ) ; \nmimeMsg . setContent ( mp ) ; \nupdateMimeMsg ( mimeMsg , cb , lastEventObject ) ; \nmimeMsg . setSentDate ( new Date ( ) ) ; \naddInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; \nTransport . send ( mimeMsg ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Error occurred while sending e-mail notification.\" , e ) ; \n} \n} \n} \n"}
{"6256": "public class DynamicThresholdFilter { \npublic void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { \nif ( ! ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) ) { \nvalueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair . getLevel ( ) ) ; \n} \nelse { \naddError ( mdcValueLevelPair . getValue ( ) + \" has been already set\" ) ; \n} \n} \n} \n"}
{"6257": "public class Compiler { \n@ SuppressWarnings ( \"unchecked\" ) DynamicConverter < E > createConverter ( SimpleKeywordNode kn ) { \nString keyword = ( String ) kn . getValue ( ) ; \nString converterClassStr = ( String ) converterMap . get ( keyword ) ; \nif ( ! ( converterClassStr != null ) ) { \naddError ( \"There is no conversion class registered for conversion word [\" + keyword + \"]\" ) ; \nreturn null ; \n} \nelse { \ntry { \nreturn ( DynamicConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , DynamicConverter . class , context ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] for keyword [\" + keyword + \"]\" , e ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"6258": "public class Compiler { \n@ SuppressWarnings ( \"unchecked\" ) CompositeConverter < E > createCompositeConverter ( CompositeNode cn ) { \nString keyword = ( String ) cn . getValue ( ) ; \nString converterClassStr = ( String ) converterMap . get ( keyword ) ; \nif ( ! ( converterClassStr != null ) ) { \naddError ( \"There is no conversion class registered for composite conversion word [\" + keyword + \"]\" ) ; \nreturn null ; \n} \nelse { \ntry { \nreturn ( CompositeConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , CompositeConverter . class , context ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] as a composite converter for keyword [\" + keyword + \"]\" , e ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"6259": "public class RollingPolicyBase { \nprotected void determineCompressionMode ( ) { \nif ( ! ( fileNamePatternStr . endsWith ( \".gz\" ) ) ) if ( ! ( fileNamePatternStr . endsWith ( \".zip\" ) ) ) { \naddInfo ( \"No compression will be used\" ) ; \ncompressionMode = CompressionMode . NONE ; \n} \nelse { \naddInfo ( \"Will use zip compression\" ) ; \ncompressionMode = CompressionMode . ZIP ; \n} \nelse { \naddInfo ( \"Will use gz compression\" ) ; \ncompressionMode = CompressionMode . GZ ; \n} \n} \n} \n"}
{"6267": "public class ContextBase { \npublic void setName ( String name ) throws IllegalStateException { \nif ( name != null && name . equals ( this . name ) ) { \nreturn ; \n} \nif ( ! ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) ) { \nthrow new IllegalStateException ( \"Context has been already given a name\" ) ; \n} \nelse { \nthis . name = name ; \n} \n} \n} \n"}
{"6268": "public class StatusUtil { \nstatic public boolean contextHasStatusListener ( Context context ) { \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) return false ; \nList < StatusListener > listeners = sm . getCopyOfStatusListenerList ( ) ; \nif ( ! ( listeners == null || listeners . size ( ) == 0 ) ) return true ; \nelse return false ; \n} \n} \n"}
{"6274": "public class AppenderAction { \n@ SuppressWarnings ( \"unchecked\" ) public void begin ( InterpretationContext ec , String localName , Attributes attributes ) throws ActionException { \nappender = null ; \ninError = false ; \nString className = attributes . getValue ( CLASS_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( className ) ) { \naddError ( \"Missing class name for appender. Near [\" + localName + \"] line \" + getLineNumber ( ec ) ) ; \ninError = true ; \nreturn ; \n} \ntry { \naddInfo ( \"About to instantiate appender of type [\" + className + \"]\" ) ; \nwarnDeprecated ( className ) ; \nappender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . Appender . class , context ) ; \nappender . setContext ( context ) ; \nString appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; \nif ( ! ( OptionHelper . isEmpty ( appenderName ) ) ) { \nappender . setName ( appenderName ) ; \naddInfo ( \"Naming appender as [\" + appenderName + \"]\" ) ; \n} \nelse { \naddWarn ( \"No appender name given for appender of type \" + className + \"].\" ) ; \n} \nHashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( ActionConst . APPENDER_BAG ) ; \nappenderBag . put ( appenderName , appender ) ; \nec . pushObject ( appender ) ; \n} \ncatch ( Exception oops ) { \ninError = true ; \naddError ( \"Could not create an Appender of type [\" + className + \"].\" , oops ) ; \nthrow new ActionException ( oops ) ; \n} \n} \n} \n"}
{"6275": "public class AppenderAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) { \nreturn ; \n} \nif ( appender instanceof LifeCycle ) { \n( ( LifeCycle ) appender ) . start ( ) ; \n} \nObject o = ec . peekObject ( ) ; \nif ( ! ( o != appender ) ) { \nec . popObject ( ) ; \n} \nelse { \naddWarn ( \"The object at the of the stack is not the appender named [\" + appender . getName ( ) + \"] pushed earlier.\" ) ; \n} \n} \n} \n"}
{"6279": "public class LogbackMDCAdapter { \npublic Map < String , String > getCopyOfContextMap ( ) { \nMap < String , String > hashMap = copyOnThreadLocal . get ( ) ; \nif ( ! ( hashMap == null ) ) { \nreturn new HashMap < String , String > ( hashMap ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"6286": "public class SyslogAppenderBase { \nstatic public int facilityStringToint ( String facilityStr ) { \nif ( ! ( \"KERN\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"USER\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"MAIL\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"DAEMON\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"AUTH\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"SYSLOG\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LPR\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"NEWS\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"UUCP\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"CRON\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"AUTHPRIV\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"FTP\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"NTP\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"AUDIT\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"ALERT\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"CLOCK\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL0\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL1\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL2\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL3\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL4\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL5\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL6\" . equalsIgnoreCase ( facilityStr ) ) ) if ( ! ( \"LOCAL7\" . equalsIgnoreCase ( facilityStr ) ) ) { \nthrow new IllegalArgumentException ( facilityStr + \" is not a valid syslog facility string\" ) ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL7 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL6 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL5 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL4 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL3 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL2 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL1 ; \n} \nelse { \nreturn SyslogConstants . LOG_LOCAL0 ; \n} \nelse { \nreturn SyslogConstants . LOG_CLOCK ; \n} \nelse { \nreturn SyslogConstants . LOG_ALERT ; \n} \nelse { \nreturn SyslogConstants . LOG_AUDIT ; \n} \nelse { \nreturn SyslogConstants . LOG_NTP ; \n} \nelse { \nreturn SyslogConstants . LOG_FTP ; \n} \nelse { \nreturn SyslogConstants . LOG_AUTHPRIV ; \n} \nelse { \nreturn SyslogConstants . LOG_CRON ; \n} \nelse { \nreturn SyslogConstants . LOG_UUCP ; \n} \nelse { \nreturn SyslogConstants . LOG_NEWS ; \n} \nelse { \nreturn SyslogConstants . LOG_LPR ; \n} \nelse { \nreturn SyslogConstants . LOG_SYSLOG ; \n} \nelse { \nreturn SyslogConstants . LOG_AUTH ; \n} \nelse { \nreturn SyslogConstants . LOG_DAEMON ; \n} \nelse { \nreturn SyslogConstants . LOG_MAIL ; \n} \nelse { \nreturn SyslogConstants . LOG_USER ; \n} \nelse { \nreturn SyslogConstants . LOG_KERN ; \n} \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \nreturn 0 ; \n} \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \ni < minLen ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( ! ( equalityCheck ( l , r ) ) ) { \nbreak ; \n} \nelse { \nmatch ++ ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6299": "public class PropertySetter { \npublic void setProperty ( String name , String value ) { \nif ( value == null ) { \nreturn ; \n} \nname = Introspector . decapitalize ( name ) ; \nPropertyDescriptor prop = getPropertyDescriptor ( name ) ; \nif ( ! ( prop == null ) ) { \ntry { \nsetProperty ( prop , name , value ) ; \n} \ncatch ( PropertySetterException ex ) { \naddWarn ( \"Failed to set property [\" + name + \"] to value \\\"\" + value + \"\\\". \" , ex ) ; \n} \n} \nelse { \naddWarn ( \"No such property [\" + name + \"] in \" + objClass . getName ( ) + \".\" ) ; \n} \n} \n} \n"}
{"6300": "public class PropertySetter { \nprivate boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { \nif ( clazz . isInterface ( ) ) { \nreturn false ; \n} \nObject o ; \ntry { \no = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; \nif ( ! ( o != null ) ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \ncatch ( InstantiationException e ) { \nreturn false ; \n} \ncatch ( IllegalAccessException e ) { \nreturn false ; \n} \ncatch ( NoSuchMethodException e ) { \nreturn false ; \n} \ncatch ( InvocationTargetException e ) { \nreturn false ; \n} \n} \n} \n"}
{"6301": "public class CopyOnInheritThreadLocal { \n@ Override protected HashMap < String , String > childValue ( HashMap < String , String > parentValue ) { \nif ( ! ( parentValue == null ) ) { \nreturn new HashMap < String , String > ( parentValue ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"6306": "public class AlgoliaException { \npublic boolean isTransient ( ) { \nThrowable cause = getCause ( ) ; \nif ( ! ( cause == null ) ) if ( ! ( cause instanceof AlgoliaException ) ) if ( ! ( cause instanceof IOException ) ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \nelse { \nreturn ( ( AlgoliaException ) cause ) . isTransient ( ) ; \n} \nelse { \nreturn isServerError ( statusCode ) ; \n} \n} \n} \n"}
{"6317": "public class PlacesQuery { \npublic @ NonNull PlacesQuery setType ( Type type ) { \nif ( ! ( type == null ) ) { \nswitch ( type ) { \ncase CITY : set ( KEY_TYPE , \"city\" ) ; \nbreak ; \ncase COUNTRY : set ( KEY_TYPE , \"country\" ) ; \nbreak ; \ncase ADDRESS : set ( KEY_TYPE , \"address\" ) ; \nbreak ; \ncase BUS_STOP : set ( KEY_TYPE , \"busStop\" ) ; \nbreak ; \ncase TRAIN_STATION : set ( KEY_TYPE , \"trainStation\" ) ; \nbreak ; \ncase TOWN_HALL : set ( KEY_TYPE , \"townhall\" ) ; \nbreak ; \ncase AIRPORT : set ( KEY_TYPE , \"airport\" ) ; \nbreak ; \n} \n} \nelse { \nset ( KEY_TYPE , null ) ; \n} \nreturn this ; \n} \n} \n"}
{"6320": "public class ExpiringCache { \nsynchronized public V get ( K key ) { \nfinal Pair < V , Long > cachePair = lruCache . get ( key ) ; \nif ( cachePair != null && cachePair . first != null ) { \nif ( ! ( cachePair . second > System . currentTimeMillis ( ) ) ) { \nlruCache . remove ( key ) ; \n} \nelse { \nreturn cachePair . first ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nint i = 0 ; \nwhile ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) { \ni ++ ; \n} \nif ( ! ( i < firstVersion . length && i < secondVersion . length ) ) { \nreturn Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \nelse { \nint diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \n} \n} \n"}
{"6324": "public class FileUtils { \npublic static void copyDirectory ( File src , File target ) { \ncheckNotNull ( src , \"src can't be null\" ) ; \ncheckNotNull ( target , \"target can't be null\" ) ; \nFile [ ] files = src . listFiles ( ) ; \nif ( files == null ) { \nreturn ; \n} \nfor ( File srcFile : files ) { \nif ( ! ( srcFile . isDirectory ( ) ) ) { \ncopyFileToDirectory ( srcFile , target ) ; \n} \nelse { \nFile targetChild = new File ( target , srcFile . getName ( ) ) ; \nensureExistingDirectory ( targetChild ) ; \ncopyDirectory ( srcFile , targetChild ) ; \n} \n} \n} \n} \n"}
{"6332": "public class JsonProtocol { \nprivate static byte hexVal ( byte ch ) throws IOException { \nif ( ! ( ( ch >= '0' ) && ( ch <= '9' ) ) ) if ( ! ( ( ch >= 'a' ) && ( ch <= 'f' ) ) ) { \nthrow new ProtocolException ( \"Expected hex character\" ) ; \n} \nelse { \nreturn ( byte ) ( ( char ) ch - 'a' + 10 ) ; \n} \nelse { \nreturn ( byte ) ( ( char ) ch - '0' ) ; \n} \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( ! ( ( b [ i ] & 0x00FF ) >= 0x30 ) ) { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( ! ( tmpbuf [ 0 ] == 1 ) ) if ( ! ( tmpbuf [ 0 ] > 1 ) ) { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \nelse { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \nif ( ! ( b [ i ] == BACKSLASH [ 0 ] ) ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) { \ncontext . read ( ) ; \n} \nreadJsonSyntaxChar ( QUOTE ) ; \nwhile ( true ) { \nbyte ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) { \nbreak ; \n} \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ! ( ch == ESCSEQ [ 1 ] ) ) { \nint off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) { \nthrow new ProtocolException ( \"Expected control char\" ) ; \n} \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \nelse { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nshort cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( ! ( Character . isHighSurrogate ( ( char ) cu ) ) ) if ( ! ( Character . isLowSurrogate ( ( char ) cu ) ) ) { \nbuffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \n} \nelse { \nif ( codeunits . size ( ) == 0 ) { \nthrow new ProtocolException ( \"Expected high surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse { \nif ( codeunits . size ( ) > 0 ) { \nthrow new ProtocolException ( \"Expected low surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \n} \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6339": "public class JsonProtocol { \nprivate double readJsonDouble ( ) throws IOException { \ncontext . read ( ) ; \nif ( ! ( reader . peek ( ) == QUOTE [ 0 ] ) ) { \nif ( context . escapeNum ( ) ) { \nreadJsonSyntaxChar ( QUOTE ) ; \n} \ntry { \nreturn Double . valueOf ( readJsonNumericChars ( ) ) ; \n} \ncatch ( NumberFormatException ex ) { \nthrow new ProtocolException ( \"Bad data encountered in numeric data\" ) ; \n} \n} \nelse { \nByteString str = readJsonString ( true ) ; \ndouble dub = Double . valueOf ( str . utf8 ( ) ) ; \nif ( ! context . escapeNum ( ) && ! Double . isNaN ( dub ) && ! Double . isInfinite ( dub ) ) { \nthrow new ProtocolException ( \"Numeric data unexpectedly quoted\" ) ; \n} \nreturn dub ; \n} \n} \n} \n"}
{"6342": "public class ClientBase { \nfinal Object invokeRequest ( MethodCall < ? > call ) throws Exception { \nboolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; \nint sid = seqId . incrementAndGet ( ) ; \nprotocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; \ncall . send ( protocol ) ; \nprotocol . writeMessageEnd ( ) ; \nprotocol . flush ( ) ; \nif ( isOneWay ) { \nreturn null ; \n} \nMessageMetadata metadata = protocol . readMessageBegin ( ) ; \nif ( metadata . seqId != sid ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Unrecognized sequence ID\" ) ; \n} \nif ( ! ( metadata . type == TMessageType . EXCEPTION ) ) if ( metadata . type != TMessageType . REPLY ) { \nthrow new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , \"Invalid message type: \" + metadata . type ) ; \n} \nelse { \nThriftException e = ThriftException . read ( protocol ) ; \nprotocol . readMessageEnd ( ) ; \nthrow new ServerException ( e ) ; \n} \nif ( metadata . seqId != seqId . get ( ) ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Out-of-order response\" ) ; \n} \nif ( ! metadata . name . equals ( call . name ) ) { \nthrow new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , \"Unexpected method name in reply; expected \" + call . name + \" but received \" + metadata . name ) ; \n} \ntry { \nObject result = call . receive ( protocol , metadata ) ; \nprotocol . readMessageEnd ( ) ; \nreturn result ; \n} \ncatch ( Exception e ) { \nif ( e instanceof Struct ) { \nprotocol . readMessageEnd ( ) ; \n} \nthrow e ; \n} \n} \n} \n"}
{"6351": "public class KieNavigatorView { \nprivate Control createDefaultPage ( FormToolkit kit ) { \nForm form = kit . createForm ( book ) ; \nComposite body = form . getBody ( ) ; \nGridLayout layout = new GridLayout ( 2 , false ) ; \nbody . setLayout ( layout ) ; \nLink hlink = new Link ( body , SWT . NONE ) ; \nhlink . setText ( \"<a>Use the Servers View to create a new server...</a>\" ) ; \nhlink . setBackground ( book . getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; \nGridData gd = new GridData ( SWT . LEFT , SWT . FILL , true , false ) ; \nhlink . setLayoutData ( gd ) ; \nhlink . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \nViewUtils . showServersView ( ) ; \n} \n} \n) ; \nfinal CommonViewer commonViewer = this . getCommonViewer ( ) ; \nif ( ! ( commonViewer != null ) ) { \n} \nelse { \nICommonViewerSite commonViewerSite = CommonViewerSiteFactory . createCommonViewerSite ( this . getViewSite ( ) ) ; \nif ( ! ( commonViewerSite != null ) ) { \n} \nelse { \nfinal NavigatorActionService actionService = new NavigatorActionService ( commonViewerSite , commonViewer , commonViewer . getNavigatorContentService ( ) ) ; \nMenuManager menuManager = new MenuManager ( \"#PopupMenu\" ) ; \nmenuManager . addMenuListener ( new IMenuListener ( ) { \npublic void menuAboutToShow ( IMenuManager mgr ) { \nISelection selection = commonViewer . getSelection ( ) ; \nactionService . setContext ( new ActionContext ( selection ) ) ; \nactionService . fillContextMenu ( mgr ) ; \n} \n} \n) ; \nMenu menu = menuManager . createContextMenu ( body ) ; \nbody . setMenu ( menu ) ; \nhlink . setMenu ( menu ) ; \n} \n} \nreturn form ; \n} \n} \n"}
{"6353": "public class PropertyBehavior { \npublic void setIsKeepAllAlive ( boolean isKeepAllAlive ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyKeepAllAlive = false ; \nif ( isDAVElement ( child , \"keepalive\" ) ) isAlreadyKeepAllAlive = \"*\" . equals ( getFirstText ( child ) ) ; \nif ( ! ( isKeepAllAlive ) ) if ( isAlreadyKeepAllAlive ) root . removeChild ( child ) ; \nelse { \nif ( ! isAlreadyKeepAllAlive ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"keepalive\" , \"*\" ) ; \n} \n} \n} \n} \n"}
{"6354": "public class PropertyBehavior { \npublic void setIsOmit ( boolean isOmit ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyOmit = isDAVElement ( child , \"omit\" ) ; \nif ( ! ( isOmit ) ) if ( isAlreadyOmit ) root . removeChild ( child ) ; \nelse { \nif ( ! isAlreadyOmit ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"omit\" ) ; \n} \n} \n} \n} \n"}
{"6357": "public class ConditionTerm { \npublic static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { \nConditionTerm term = new ConditionTerm ( ) ; \ntry { \nint token = tokenizer . ttype ; \nif ( ! ( token == '(' ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"(\" ) ) ; \nelse token = tokenizer . nextToken ( ) ; \nwhile ( token == StreamTokenizer . TT_WORD || token == '<' || token == '[' ) { \nterm . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; \ntoken = tokenizer . ttype ; \n} \nif ( ! ( token == ')' ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \")\" ) ) ; \nelse token = tokenizer . nextToken ( ) ; \n} \ncatch ( IOException exc ) { \n} \nif ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingStateOrEntity\" ) ) ; \nreturn term ; \n} \n} \n"}
{"6358": "public class ConditionTerm { \npublic boolean matches ( ConditionTerm conditionTerm ) { \nint numberOfItemsToMatch = 0 ; \nboolean match = true ; \nEnumeration factors = getConditionFactors ( ) ; \nwhile ( match && factors . hasMoreElements ( ) ) { \nConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; \nif ( ! ( factor . not ( ) ) ) { \nmatch = conditionTerm . contains ( factor ) ; \nnumberOfItemsToMatch ++ ; \n} \nelse { \nmatch = ! conditionTerm . contains ( factor ) ; \n} \n} \nmatch = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; \nreturn match ; \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( ! ( file == null ) ) { \nif ( fos != null ) { \nwhile ( skip ( 4096 ) > 0 ) ; \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) { \nlength = totalBytesRead ; \n} \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \nelse { \n( ( ByteArrayInputStream ) is ) . reset ( ) ; \n} \ntotalBytesRead = 0 ; \n} \n} \n"}
{"6376": "public class GraphicalVertex { \npublic void addConnection ( Connection conn ) { \nif ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( ! ( conn . getSource ( ) == this ) ) if ( conn . getTarget ( ) == this ) { \ntargetConnections . add ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \nelse { \nsourceConnections . add ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n"}
{"6378": "public class GraphicalVertex { \npublic void removeConnection ( Connection conn ) { \nif ( conn == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( ! ( conn . getSource ( ) == this ) ) if ( conn . getTarget ( ) == this ) { \ntargetConnections . remove ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \nelse { \nsourceConnections . remove ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n"}
{"6380": "public class GraphicalVertex { \npublic void setPropertyValue ( Object propertyId , Object value ) { \nif ( ! ( XPOS_PROP . equals ( propertyId ) ) ) if ( ! ( YPOS_PROP . equals ( propertyId ) ) ) if ( ! ( HEIGHT_PROP . equals ( propertyId ) ) ) if ( WIDTH_PROP . equals ( propertyId ) ) { \nint width = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( width , size . height ) ) ; \n} \nelse { \nint height = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( size . width , height ) ) ; \n} \nelse { \nint y = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( location . x , y ) ) ; \n} \nelse { \nint x = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( x , location . y ) ) ; \n} \n} \n} \n"}
{"6403": "public class CompletionContext { \nprivate void determineDialect ( String backText ) { \ndialect = null ; \nboolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nboolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nif ( ! ( mvel ) ) if ( java ) { \ndialect = JAVA_DIALECT ; \n} \nelse { \ndialect = MVEL_DIALECT ; \n} \n} \n} \n"}
{"6411": "public class Node { \npublic Node addChild ( Node n ) { \nif ( ! ( ! this . children . containsKey ( n . getToken ( ) ) ) ) { \nreturn ( Node ) this . children . get ( n . getToken ( ) ) ; \n} \nelse { \nthis . children . put ( n . getToken ( ) , n ) ; \nn . setParent ( this ) ; \nreturn n ; \n} \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nline = line . trim ( ) ; \nif ( line . length ( ) > 0 && ! line . startsWith ( \"-\" ) ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( ! ( last . indexOf ( \"(\" ) > - 1 && ! last . endsWith ( \")\" ) ) ) if ( last . indexOf ( \"(\" ) > - 1 && last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \nelse { \nlast = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \n} \nreturn last ; \n} \n} \n"}
{"6424": "public class NewJBPMProjectWizard { \nprivate void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) throws CoreException , IOException { \nString fileName = \"org/jbpm/eclipse/wizard/project/\" + exampleType + \".bpmn.template\" ; \nIFolder folder = null ; \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/com/sample\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \nIFile file = folder . getFile ( \"sample.bpmn\" ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \nif ( ! ( ! file . exists ( ) ) ) { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \nelse { \nfile . create ( inputstream , true , monitor ) ; \n} \nfileName = \"org/jbpm/eclipse/wizard/project/ProcessMain-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( ! ( runtime . getVersion ( ) . getMajor ( ) == 5 ) ) { \nfileName += \".template\" ; \n} \nelse { \nfileName += \".v5.template\" ; \n} \nfolder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \npackageFragment . createCompilationUnit ( \"ProcessMain.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \nif ( \"advanced\" . equals ( exampleType ) ) { \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/META-INF\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( \"org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template\" ) ; \nfile = folder . getFile ( \"persistence.xml\" ) ; \nif ( ! ( ! file . exists ( ) ) ) { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \nelse { \nfile . create ( inputstream , true , monitor ) ; \n} \n} \n} \n} \n} \n"}
{"6425": "public class NewJBPMProjectWizard { \nprivate void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) throws JavaModelException , IOException { \nString s = \"org/jbpm/eclipse/wizard/project/ProcessJUnit-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( ! ( runtime . getVersion ( ) . getMajor ( ) == 5 ) ) { \ns += \".template\" ; \n} \nelse { \ns += \".v5.template\" ; \n} \nIFolder folder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( s ) ; \npackageFragment . createCompilationUnit ( \"ProcessTest.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \n} \n} \n"}
{"6436": "public class StateToken { \npublic static ConditionFactor create ( StreamTokenizer tokenizer ) throws WebDAVException { \nStateToken stateToken = new StateToken ( ) ; \ntry { \nint token = tokenizer . ttype ; \nif ( ! ( token == '<' ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"<\" ) ) ; \nelse token = tokenizer . nextToken ( ) ; \nif ( ! ( token == StreamTokenizer . TT_WORD ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingURI\" , String . valueOf ( token ) ) ) ; \nelse { \nstateToken . setURI ( tokenizer . sval ) ; \ntoken = tokenizer . nextToken ( ) ; \n} \nif ( ! ( token == '>' ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \">\" ) ) ; \nelse token = tokenizer . nextToken ( ) ; \n} \ncatch ( IOException exc ) { \n} \nreturn stateToken ; \n} \n} \n"}
{"6441": "public class PullOperationUI { \n@ SuppressWarnings ( \"restriction\" ) public void execute ( IProgressMonitor monitor ) { \ntry { \npullOperation . execute ( monitor ) ; \nresults . putAll ( pullOperation . getResults ( ) ) ; \n} \ncatch ( CoreException e ) { \nif ( ! ( e . getStatus ( ) . getSeverity ( ) == IStatus . CANCEL ) ) repoNode . handleException ( ( Throwable ) e ) ; \nelse results . putAll ( pullOperation . getResults ( ) ) ; \n} \n} \n} \n"}
{"6459": "public class ReteViewer { \npublic void drawGraph ( ReteGraph newGraph ) { \nLayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; \nif ( getGraphicalViewer ( ) . getContents ( ) == null ) { \ngetGraphicalViewer ( ) . setContents ( getModel ( ) ) ; \n} \nfinal boolean isNewDiagram = newGraph != null && newGraph != diagram ; \nif ( isNewDiagram ) { \ndiagram . removeAll ( ) ; \n} \nConnectionRouter router ; \nif ( ! ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) ) { \nrouter = ConnectionRouter . NULL ; \n} \nelse { \nrouter = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; \n} \nconnLayer . setConnectionRouter ( router ) ; \nif ( newGraph != null && newGraph != diagram ) { \ndiagram . addAll ( newGraph . getChildren ( ) ) ; \n} \n} \n} \n"}
{"6463": "public class AbstractResourceHandle { \npublic void copy ( ILocator destination , String depth , boolean overwrite , Collection propertyNames ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setDepth ( depth ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( ! ( propertyNames == null ) ) { \nIterator namesItr = propertyNames . iterator ( ) ; \nwhile ( namesItr . hasNext ( ) ) { \nQualifiedName name = ( QualifiedName ) namesItr . next ( ) ; \nString nameURI = name . getQualifier ( ) + \"/\" + name . getLocalName ( ) ; \npropertyBehavior . addProperty ( nameURI ) ; \n} \n} \nelse propertyBehavior . setIsKeepAllAlive ( true ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . copy ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6471": "public class AbstractResourceHandle { \npublic void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( ! ( names == null ) ) { \nwhile ( names . hasMoreElements ( ) ) { \nObject obj = names . nextElement ( ) ; \nAssert . isTrue ( obj instanceof QualifiedName , Policy . bind ( \"assert.propNameMustBeEnumOverQual\" ) ) ; \npropertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; \n} \n} \nelse { \npropertyBehavior . setIsKeepAllAlive ( true ) ; \n} \nIResponse response = null ; \ntry { \nresponse = davClient . move ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6485": "public class Request { \npublic void write ( OutputStream os ) throws IOException { \nif ( ! ( requestBodyWriter == null ) ) { \nrequestBodyWriter . writeRequestBody ( os ) ; \n} \nelse { \nif ( inputRead ) { \nis . reset ( ) ; \ninputRead = false ; \n} \nsuper . write ( os ) ; \n} \n} \n} \n"}
{"6488": "public class PropFind { \npublic void setIsAllProp ( boolean isAllProp ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyAllProp = isDAVElement ( child , \"allprop\" ) ; \nif ( ! ( isAllProp ) ) if ( isAlreadyAllProp ) root . removeChild ( child ) ; \nelse { \nif ( ! isAlreadyAllProp ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"allprop\" ) ; \n} \n} \n} \n} \n"}
{"6489": "public class PropFind { \npublic void setIsPropName ( boolean isPropName ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyPropName = isDAVElement ( child , \"propname\" ) ; \nif ( ! ( isPropName ) ) if ( isAlreadyPropName ) root . removeChild ( child ) ; \nelse { \nif ( ! isAlreadyPropName ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"propname\" ) ; \n} \n} \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( ! ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) ) { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \nfor ( int i = c . length - 1 ; \ni >= 0 ; \ni -- ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \nelse { \nreturn \"\" ; \n} \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { \nif ( ! ( contentLength == - 1 ) ) { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nelse { \nbytesRead = is . read ( buffer ) ; \n} \nif ( ! ( bytesRead == - 1 ) ) { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \nelse { \nif ( contentLength >= 0 ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \nfor ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nObject error = iter . next ( ) ; \nif ( ! ( error instanceof ParserError ) ) if ( ! ( error instanceof KnowledgeBuilderResult ) ) if ( ! ( error instanceof ExpanderException ) ) { \nmarkers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \nelse { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \n} \n} \n} \n"}
{"6505": "public class Context { \npublic void put ( String key , String value ) { \nContextKey ckey = new ContextKey ( key ) ; \nif ( ! ( ( value == null ) || ( value . length ( ) == 0 ) ) ) properties . put ( ckey , value ) ; \nelse properties . remove ( ckey ) ; \n} \n} \n"}
{"6506": "public class Context { \npublic void setTimeout ( int value ) { \nif ( ! ( value == - 1 ) ) put ( TIMEOUT , ( value == - 2 ) ? DEPTH_INFINITY : \"Second-\" + Integer . toString ( value ) ) ; \nelse put ( TIMEOUT , \"\" ) ; \n} \n} \n"}
{"6509": "public class DSLTree { \nprotected String getObjMetadata ( String text ) { \nif ( ! ( text . startsWith ( \"[\" ) ) ) { \nreturn \"\" ; \n} \nelse { \nreturn text . substring ( 1 , text . lastIndexOf ( \"]\" ) ) ; \n} \n} \n} \n"}
{"6510": "public class DSLTree { \nprotected String stripObjMetadata ( String text ) { \nif ( ! ( text . startsWith ( \"[\" ) ) ) { \nreturn text ; \n} \nelse { \nreturn text . substring ( text . lastIndexOf ( \"]\" ) + 1 ) ; \n} \n} \n} \n"}
{"6512": "public class DSLTree { \npublic Node [ ] getConditionChildren ( String text ) { \nNode thenode = this . rootCond ; \nif ( text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ! ( ch != null ) ) { \nbreak ; \n} \nelse { \nthenode = ch ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) { \nfor ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nint index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null && obj . startsWith ( substring ) ) { \nthenode = child ; \n} \n} \n} \n} \n} \nif ( thenode != null && text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ! ( ch != null ) ) { \nbreak ; \n} \nelse { \nthenode = ch ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nif ( thenode == null ) { \nreturn null ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( ! ( n . getChildren ( ) . size ( ) > 0 ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \n} \nelse { \nfor ( Node child : n . getChildren ( ) ) { \nif ( prefix != null && \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \nreturn ; \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \n} \n} \n} \n"}
{"6522": "public class NewDroolsProjectWizard { \nprivate void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( ! ( version . getMajor ( ) == 4 ) ) if ( ! ( version . getMajor ( ) == 5 ) ) if ( version . getMajor ( ) >= 6 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template\" , \"DroolsTest.java\" ) ; \n} \n} \n} \n"}
{"6523": "public class NewDroolsProjectWizard { \nprivate void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nif ( ! ( startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) >= 6 ) ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/rules\" , \"Sample.drl\" ) ; \n} \nelse { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/rules\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/resources/com/sample/rules\" , \"Sample.drl\" ) ; \n} \n} \n} \n"}
{"6524": "public class NewDroolsProjectWizard { \nprivate void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( ! ( version . getMajor ( ) == 4 ) ) if ( ! ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) ) if ( ! ( version . getMajor ( ) == 5 ) ) { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/process\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/resources/com/sample/process\" , \"sample.bpmn\" ) ; \n} \nelse { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/rules\" , \"sample.bpmn\" ) ; \n} \nelse { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \n} \nelse { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rfm.template\" , \"src/main/rules\" , \"ruleflow.rfm\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.drl.template\" , \"src/main/rules\" , \"ruleflow.drl\" ) ; \n} \n} \n} \n"}
{"6525": "public class NewDroolsProjectWizard { \nprivate void createRuleFlowSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nString s ; \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( ! ( version . getMajor ( ) == 4 ) ) if ( ! ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) ) if ( ! ( version . getMajor ( ) == 5 ) ) { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template\" ; \n} \nelse { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template\" ; \n} \nelse { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template\" ; \n} \nelse { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template\" ; \n} \ncreateProjectJavaFile ( project , s , \"ProcessTest.java\" ) ; \n} \n} \n"}
{"6531": "public class WebDavClient { \nprivate void addGuvnorResourceProperties ( ResourceProperties props , String filename , String resource ) throws Exception { \nif ( props == null ) { \nreturn ; \n} \nIResponse response = null ; \ntry { \nString path = resource . substring ( 0 , resource . lastIndexOf ( '/' ) ) ; \nString apiVer = changeToAPICall ( path ) ; \nProperties guvProps = new Properties ( ) ; \nresponse = getResourceInputStream ( apiVer ) ; \nguvProps . load ( response . getInputStream ( ) ) ; \nString val = guvProps . getProperty ( filename ) ; \nif ( ! ( val != null ) ) { \nException nfe = new Exception ( \"Failed to get Guvnor properties for \" + filename ) ; \nActivator . getDefault ( ) . writeLog ( IStatus . WARNING , nfe . getMessage ( ) , nfe ) ; \n} \nelse { \nStringTokenizer tokens = new StringTokenizer ( val , \",\" ) ; \nif ( tokens . hasMoreElements ( ) ) { \nprops . setLastModifiedDate ( tokens . nextToken ( ) ) ; \n} \nif ( tokens . hasMoreElements ( ) ) { \nprops . setRevision ( tokens . nextToken ( ) ) ; \n} \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \n} \n} \n} \n"}
{"6534": "public class CollectionHandle { \npublic ILocator getMember ( String memberName ) { \nAssert . isTrue ( locator . getLabel ( ) == null ) ; \nAssert . isTrue ( ! locator . isStable ( ) ) ; \nString parentName = locator . getResourceURL ( ) ; \nString childName ; \nif ( ! ( parentName . endsWith ( \"/\" ) ) ) childName = parentName + \"/\" + memberName ; \nelse childName = parentName + memberName ; \nreturn davClient . getDAVFactory ( ) . newLocator ( childName ) ; \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) { \nreturn 1 ; \n} \nif ( v1OutDegree > v2OutDegree ) { \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( ! ( front ) ) { \noptimized . addLast ( vertex ) ; \n} \nelse { \noptimized . addFirst ( vertex ) ; \n} \nfront = ! front ; \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( ! ( originalFile != null ) ) if ( originalName != null ) { \nresourceGroup . setResource ( originalName ) ; \n} \nelse { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nint index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) { \nfileName = fileName . substring ( 0 , index ) ; \n} \nfileName += \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nsetDialogComplete ( validatePage ( ) ) ; \n} \n} \n"}
{"6537": "public class ExportImageDialog { \nprivate boolean validatePage ( ) { \nif ( ! resourceGroup . areAllValuesValid ( ) ) { \nif ( ! ( ! resourceGroup . getResource ( ) . equals ( \"\" ) ) ) { \nsetErrorMessage ( null ) ; \n} \nelse { \nsetErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; \n} \nreturn false ; \n} \nString resourceName = resourceGroup . getResource ( ) ; \nIWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; \nIPath fullPath = resourceGroup . getContainerFullPath ( ) ; \nif ( fullPath != null ) { \nString projectName = fullPath . segment ( 0 ) ; \nIStatus isValidProjectName = workspace . validateName ( projectName , IResource . PROJECT ) ; \nif ( isValidProjectName . isOK ( ) ) { \nIProject project = workspace . getRoot ( ) . getProject ( projectName ) ; \nif ( ! project . isOpen ( ) ) { \nsetErrorMessage ( IDEWorkbenchMessages . SaveAsDialog_closedProjectMessage ) ; \nreturn false ; \n} \n} \n} \nIStatus result = workspace . validateName ( resourceName , IResource . FILE ) ; \nif ( ! result . isOK ( ) ) { \nsetErrorMessage ( result . getMessage ( ) ) ; \nreturn false ; \n} \nsetErrorMessage ( null ) ; \nreturn true ; \n} \n} \n"}
{"6540": "public class YubikeyLoginModule { \nprivate boolean validate_otps ( List < String > otps , NameCallback nameCb ) throws LoginException { \nboolean validated = false ; \nfor ( String otp : otps ) { \nlog . trace ( \"Checking OTP {}\" , otp ) ; \nVerificationResponse ykr ; \ntry { \nykr = this . yc . verify ( otp ) ; \n} \ncatch ( YubicoVerificationException e ) { \nlog . warn ( \"Errors during validation: \" , e ) ; \nthrow new LoginException ( \"Errors during validation: \" + e . getMessage ( ) ) ; \n} \ncatch ( YubicoValidationFailure e ) { \nlog . warn ( \"Something went very wrong during authentication: \" , e ) ; \nthrow new LoginException ( \"Something went very wrong during authentication: \" + e . getMessage ( ) ) ; \n} \nif ( ykr != null ) { \nlog . trace ( \"OTP {} verify result : {}\" , otp , ykr . getStatus ( ) . toString ( ) ) ; \nif ( ! ( ykr . getStatus ( ) == ResponseStatus . OK ) ) { \nlog . debug ( \"OTP validation returned {}\" , ykr . getStatus ( ) . toString ( ) ) ; \n} \nelse { \nString publicId = YubicoClient . getPublicId ( otp ) ; \nlog . info ( \"OTP verified successfully (YubiKey id {})\" , publicId ) ; \nif ( is_right_user ( nameCb . getName ( ) , publicId ) ) { \nthis . principals . add ( new YubikeyPrincipal ( publicId , this . idRealm ) ) ; \nvalidated = true ; \n} \n} \n} \n} \nreturn validated ; \n} \n} \n"}
{"6554": "public class OgnlRuntime { \npublic static String getUniqueDescriptor ( Object object , boolean fullyQualified ) { \nStringBuffer result = new StringBuffer ( ) ; \nif ( ! ( object != null ) ) { \nresult . append ( NULL_OBJECT_STRING ) ; \n} \nelse { \nif ( object instanceof Proxy ) { \nClass interfaceClass = object . getClass ( ) . getInterfaces ( ) [ 0 ] ; \nresult . append ( getClassName ( interfaceClass , fullyQualified ) ) ; \nresult . append ( '^' ) ; \nobject = Proxy . getInvocationHandler ( object ) ; \n} \nresult . append ( getClassName ( object , fullyQualified ) ) ; \nresult . append ( '@' ) ; \nresult . append ( getPointerString ( object ) ) ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"6555": "public class OgnlRuntime { \npublic static final Class getArgClass ( Object arg ) { \nif ( arg == null ) return null ; \nClass c = arg . getClass ( ) ; \nif ( ! ( c == Boolean . class ) ) if ( ! ( c . getSuperclass ( ) == Number . class ) ) if ( c == Character . class ) return Character . TYPE ; \nelse { \nif ( c == Integer . class ) return Integer . TYPE ; \nif ( c == Double . class ) return Double . TYPE ; \nif ( c == Byte . class ) return Byte . TYPE ; \nif ( c == Long . class ) return Long . TYPE ; \nif ( c == Float . class ) return Float . TYPE ; \nif ( c == Short . class ) return Short . TYPE ; \n} \nelse return Boolean . TYPE ; \nreturn c ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \nindex < count ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( ! ( c1 == c2 ) ) if ( ! ( c1 . isPrimitive ( ) ) ) if ( ! ( c1 . isAssignableFrom ( c2 ) ) ) if ( c2 . isAssignableFrom ( c1 ) ) return true ; \nelse return false ; \nelse return true ; \nelse continue ; \n} \nreturn false ; \n} \n} \n"}
{"6558": "public class OgnlRuntime { \npublic static final Object getMethodValue ( OgnlContext context , Object target , String propertyName , boolean checkAccessAndExistence ) throws OgnlException , IllegalAccessException , NoSuchMethodException , IntrospectionException { \nObject result = null ; \nMethod m = getGetMethod ( context , ( target == null ) ? null : target . getClass ( ) , propertyName ) ; \nif ( m == null ) m = getReadMethod ( ( target == null ) ? null : target . getClass ( ) , propertyName , null ) ; \nif ( checkAccessAndExistence ) { \nif ( ( m == null ) || ! context . getMemberAccess ( ) . isAccessible ( context , target , m , propertyName ) ) { \nresult = NotFound ; \n} \n} \nif ( result == null ) { \nif ( ! ( m != null ) ) { \nthrow new NoSuchMethodException ( propertyName ) ; \n} \nelse { \ntry { \nresult = invokeMethod ( target , m , NoArguments ) ; \n} \ncatch ( InvocationTargetException ex ) { \nthrow new OgnlException ( propertyName , ex . getTargetException ( ) ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ! ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) ) { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \nelse { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( ! ( backSlashCnt == 1 ) ) { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nelse return c ; \n} \n} \n} \n"}
{"6563": "public class OgnlParser { \nfinal public void projection ( ) throws ParseException { \nASTProject jjtn000 = new ASTProject ( JJTPROJECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( ! ( jjtc000 ) ) { \njjtree . popNode ( ) ; \n} \nelse { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n} \n"}
{"6564": "public class OgnlParser { \nfinal public void selectAll ( ) throws ParseException { \nASTSelect jjtn000 = new ASTSelect ( JJTSELECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \njj_consume_token ( 3 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( ! ( jjtc000 ) ) { \njjtree . popNode ( ) ; \n} \nelse { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n} \n"}
{"6569": "public class OgnlOps { \npublic static String stringValue ( Object value , boolean trim ) { \nString result ; \nif ( ! ( value == null ) ) { \nresult = value . toString ( ) ; \nif ( trim ) { \nresult = result . trim ( ) ; \n} \n} \nelse { \nresult = OgnlRuntime . NULL_STRING ; \n} \nreturn result ; \n} \n} \n"}
{"6573": "public class OgnlOps { \npublic static int getNumericType ( int t1 , int t2 , boolean canBeNonNumeric ) { \nif ( t1 == t2 ) return t1 ; \nif ( canBeNonNumeric && ( t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR ) ) return NONNUMERIC ; \nif ( t1 == NONNUMERIC ) t1 = DOUBLE ; \nif ( t2 == NONNUMERIC ) t2 = DOUBLE ; \nif ( ! ( t1 >= MIN_REAL_TYPE ) ) if ( ! ( t2 >= MIN_REAL_TYPE ) ) return Math . max ( t1 , t2 ) ; \nelse { \nif ( t1 < INT ) return t2 ; \nif ( t1 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t2 ) ; \n} \nelse { \nif ( t2 >= MIN_REAL_TYPE ) return Math . max ( t1 , t2 ) ; \nif ( t2 < INT ) return t1 ; \nif ( t2 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t1 ) ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) if ( ! ( _children [ i ] . getClass ( ) == getClass ( ) ) ) ++ newSize ; \nelse { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( ! ( c . getClass ( ) == getClass ( ) ) ) newChildren [ j ++ ] = c ; \nelse { \nfor ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6587": "public class FileWatchServices { \npublic static String getDefaultWatchServiceId ( ) { \nString result = \"polling\" ; \nString osName = System . getProperty ( \"os.name\" ) ; \nif ( osName != null ) { \nosName = osName . toLowerCase ( Locale . ENGLISH ) ; \nif ( ! ( osName . contains ( \"windows\" ) || osName . contains ( \"linux\" ) ) ) if ( osName . contains ( \"mac\" ) ) { \nresult = \"jnotify\" ; \n} \nelse { \nresult = isAtLeastJava7 ( ) ? \"jdk7\" : \"jnotify\" ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( ! ( dir == null ) ) if ( ! ( ! dir . isDirectory ( ) ) ) { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( ! ( contents != null ) ) { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \nelse { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter ++ ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \n} \nelse { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6601": "public class DirectoryChooserFragment { \nprivate void returnSelectedFolder ( ) { \nif ( ! ( mSelectedDir != null ) ) { \nmListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onCancelChooser ( ) ; \n} \n} \n) ; \n} \nelse { \ndebug ( \"Returning %s as result\" , mSelectedDir . getAbsolutePath ( ) ) ; \nmListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onSelectDirectory ( mSelectedDir . getAbsolutePath ( ) ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"6602": "public class DirectoryChooserFragment { \nprivate int createFolder ( ) { \nif ( ! ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) ) if ( ! ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) ) { \nreturn R . string . create_folder_error ; \n} \nelse { \nreturn R . string . create_folder_error_no_write_access ; \n} \nelse { \nfinal File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; \nif ( ! ( newDir . exists ( ) ) ) { \nfinal boolean result = newDir . mkdir ( ) ; \nif ( ! ( result ) ) { \nreturn R . string . create_folder_error ; \n} \nelse { \nreturn R . string . create_folder_success ; \n} \n} \nelse { \nreturn R . string . create_folder_error_already_exists ; \n} \n} \n} \n} \n"}
{"6605": "public class ConverterHtmlToSpanned { \nprivate void startList ( boolean isOrderedList , Attributes attributes ) { \nboolean isIndentation = isIndentation ( attributes ) ; \nParagraphType newType = isIndentation && isOrderedList ? ParagraphType . INDENTATION_OL : isIndentation && ! isOrderedList ? ParagraphType . INDENTATION_UL : isOrderedList ? ParagraphType . NUMBERING : ParagraphType . BULLET ; \nAccumulatedParagraphStyle currentStyle = mParagraphStyles . isEmpty ( ) ? null : mParagraphStyles . peek ( ) ; \nif ( ! ( currentStyle == null ) ) if ( ! ( currentStyle . getType ( ) == newType ) ) { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , currentStyle . getAbsoluteIndent ( ) + 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \nelse { \ncurrentStyle . setAbsoluteIndent ( currentStyle . getAbsoluteIndent ( ) + 1 ) ; \ncurrentStyle . setRelativeIndent ( currentStyle . getRelativeIndent ( ) + 1 ) ; \n} \nelse { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \n} \n} \n"}
{"6606": "public class ConverterHtmlToSpanned { \nprivate void endList ( boolean orderedList ) { \nif ( ! mParagraphStyles . isEmpty ( ) ) { \nAccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; \nParagraphType type = style . getType ( ) ; \nif ( ! ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) ) { \nmParagraphStyles . pop ( ) ; \nendList ( orderedList ) ; \n} \nelse { \nint indent = style . getRelativeIndent ( ) ; \nif ( ! ( indent > 1 ) ) { \nmParagraphStyles . pop ( ) ; \n} \nelse { \nstyle . setRelativeIndent ( indent - 1 ) ; \nstyle . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; \n} \n} \n} \n} \n} \n"}
{"6607": "public class HighlightView { \nvoid handleMotion ( int edge , float dx , float dy ) { \nRect r = computeLayout ( ) ; \nif ( ! ( edge == GROW_NONE ) ) if ( ! ( edge == MOVE ) ) { \nif ( ( ( GROW_LEFT_EDGE | GROW_RIGHT_EDGE ) & edge ) == 0 ) { \ndx = 0 ; \n} \nif ( ( ( GROW_TOP_EDGE | GROW_BOTTOM_EDGE ) & edge ) == 0 ) { \ndy = 0 ; \n} \nfloat xDelta = dx * ( mCropRect . width ( ) / r . width ( ) ) ; \nfloat yDelta = dy * ( mCropRect . height ( ) / r . height ( ) ) ; \ngrowBy ( ( ( ( edge & GROW_LEFT_EDGE ) != 0 ) ? - 1 : 1 ) * xDelta , ( ( ( edge & GROW_TOP_EDGE ) != 0 ) ? - 1 : 1 ) * yDelta ) ; \n} \nelse { \nmoveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; \n} \nelse { \nreturn ; \n} \n} \n} \n"}
{"6617": "public class MediaUtils { \npublic static String determineOriginalFile ( Context context , Uri uri ) throws IllegalArgumentException { \nString originalFile = null ; \nif ( ! ( uri != null ) ) { \nthrow new IllegalArgumentException ( \"Image Uri was null!\" ) ; \n} \nelse { \nif ( uri . getScheme ( ) . startsWith ( \"content\" ) ) { \noriginalFile = getPathFromUri ( context , uri ) ; \n} \nif ( uri . toString ( ) . matches ( \"https?://\\\\w+\\\\.googleusercontent\\\\.com/.+\" ) ) { \noriginalFile = uri . toString ( ) ; \n} \nif ( uri . getScheme ( ) . startsWith ( \"file\" ) ) { \noriginalFile = uri . toString ( ) . substring ( 7 ) ; \n} \nif ( isNullOrEmpty ( originalFile ) ) { \nthrow new IllegalArgumentException ( \"File path was null\" ) ; \n} \n} \nreturn originalFile ; \n} \n} \n"}
{"6618": "public class ElementType { \npublic String namespace ( String name , boolean attribute ) { \nint colon = name . indexOf ( ':' ) ; \nif ( colon == - 1 ) { \nreturn attribute ? \"\" : theSchema . getURI ( ) ; \n} \nString prefix = name . substring ( 0 , colon ) ; \nif ( ! ( prefix . equals ( \"xml\" ) ) ) { \nreturn ( \"urn:x-prefix:\" + prefix ) . intern ( ) ; \n} \nelse { \nreturn \"http://www.w3.org/XML/1998/namespace\" ; \n} \n} \n} \n"}
{"6619": "public class ElementType { \npublic String localName ( String name ) { \nint colon = name . indexOf ( ':' ) ; \nif ( ! ( colon == - 1 ) ) { \nreturn name . substring ( colon + 1 ) . intern ( ) ; \n} \nelse { \nreturn name ; \n} \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) || name . startsWith ( \"xmlns:\" ) ) { \nreturn ; \n} \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nint i = atts . getIndex ( name ) ; \nif ( ! ( i == - 1 ) ) { \nif ( type == null ) type = atts . getType ( i ) ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \nelse { \nname = name . intern ( ) ; \nif ( type == null ) type = \"CDATA\" ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( ! ( currentBufferIndex < buffers . size ( ) - 1 ) ) { \nint newBufferSize ; \nif ( ! ( currentBuffer == null ) ) { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum += currentBuffer . length ; \n} \nelse { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \ncurrentBufferIndex ++ ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \nelse { \nfilledBufferSum += currentBuffer . length ; \ncurrentBufferIndex ++ ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ! ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) ) if ( len == 0 ) { \nreturn ; \n} \nelse { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( ! ( size <= 0 ) ) { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( int pos = 0 ; \npos < mFontSizeAdapter . getCount ( ) ; \npos ++ ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \nelse { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \n} \n} \n} \n"}
{"6643": "public class CharacterEffect { \npublic void applyToSelection ( RTEditText editor , V value ) { \nSelection selection = getSelection ( editor ) ; \nint flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nSpannable str = editor . getText ( ) ; \nfor ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { \nboolean sameSpan = span . getValue ( ) . equals ( value ) ; \nint spanStart = str . getSpanStart ( span ) ; \nif ( spanStart < selection . start ( ) ) { \nif ( ! ( sameSpan ) ) { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; \n} \nelse { \nflags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nselection . offset ( selection . start ( ) - spanStart , 0 ) ; \n} \n} \nint spanEnd = str . getSpanEnd ( span ) ; \nif ( spanEnd > selection . end ( ) ) { \nif ( ! ( sameSpan ) ) { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; \n} \nelse { \nselection . offset ( 0 , spanEnd - selection . end ( ) ) ; \n} \n} \nstr . removeSpan ( span ) ; \n} \nif ( value != null ) { \nRTSpan < V > newSpan = newSpan ( value ) ; \nif ( newSpan != null ) { \nstr . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; \n} \n} \n} \n} \n"}
{"6647": "public class ConverterTextToHtml { \nprivate static String replaceAll ( String source , String search , String replace ) { \nif ( ! ( USE_REPLACE_ALL ) ) { \nPattern p = Pattern . compile ( search ) ; \nMatcher m = p . matcher ( source ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nboolean atLeastOneFound = false ; \nwhile ( m . find ( ) ) { \nm . appendReplacement ( sb , replace ) ; \natLeastOneFound = true ; \n} \nif ( ! ( atLeastOneFound ) ) { \nreturn source ; \n} \nelse { \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse { \nreturn source . replaceAll ( search , replace ) ; \n} \n} \n} \n"}
{"6656": "public class Parser { \nprivate Reader getReader ( InputSource s ) throws SAXException , IOException { \nReader r = s . getCharacterStream ( ) ; \nInputStream i = s . getByteStream ( ) ; \nString encoding = s . getEncoding ( ) ; \nString publicid = s . getPublicId ( ) ; \nString systemid = s . getSystemId ( ) ; \nif ( r == null ) { \nif ( i == null ) i = getInputStream ( publicid , systemid ) ; \nif ( ! ( encoding == null ) ) { \ntry { \nr = new InputStreamReader ( i , encoding ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nr = new InputStreamReader ( i ) ; \n} \n} \nelse { \nr = theAutoDetector . autoDetectingReader ( i ) ; \n} \n} \nreturn r ; \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ! ( ch == '&' && refStart == - 1 ) ) if ( ! ( refStart == - 1 ) ) if ( ! ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) ) if ( ! ( ch == ';' ) ) { \nrefStart = - 1 ; \n} \nelse { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ! ( ent > 0xFFFF ) ) if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nelse { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nrefStart = - 1 ; \n} \nelse { \n} \nelse { \n} \nelse { \nrefStart = dstlen ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( ! ( val . length ( ) == 0 ) ) { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! ( ! dq && c == '\\'' && lastc != '\\\\' ) ) if ( ! ( ! sq && c == '\\\"' && lastc != '\\\\' ) ) if ( ! sq && ! dq ) { \nif ( ! ( Character . isWhitespace ( c ) ) ) if ( s < 0 && c != ' ' ) { \ns = e ; \n} \nelse { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \n} \nelse { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \nelse { \nreturn new String [ 0 ] ; \n} \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength -- > 0 ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( ! ( Character . isLetter ( ch ) || ch == '_' ) ) if ( ! ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) ) if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \nelse { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse { \nstart = false ; \ndst . append ( ch ) ; \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6682": "public class HTMLWriter { \npublic void setOutput ( Writer writer ) { \nif ( ! ( writer == null ) ) { \noutput = writer ; \n} \nelse { \noutput = new OutputStreamWriter ( System . out ) ; \n} \n} \n} \n"}
{"6687": "public class HTMLWriter { \n@ SuppressWarnings ( \"unchecked\" ) private void writeNSDecls ( ) throws SAXException { \nEnumeration < String > prefixes = ( Enumeration < String > ) nsSupport . getDeclaredPrefixes ( ) ; \nwhile ( prefixes . hasMoreElements ( ) ) { \nString prefix = ( String ) prefixes . nextElement ( ) ; \nString uri = nsSupport . getURI ( prefix ) ; \nif ( uri == null ) { \nuri = \"\" ; \n} \nwrite ( ' ' ) ; \nif ( ! ( \"\" . equals ( prefix ) ) ) { \nwrite ( \"xmlns:\" ) ; \nwrite ( prefix ) ; \nwrite ( \"=\\\"\" ) ; \n} \nelse { \nwrite ( \"xmlns=\\\"\" ) ; \n} \nwriteEscUTF16 ( uri , 0 , uri . length ( ) , true ) ; \nwrite ( '\\\"' ) ; \n} \n} \n} \n"}
{"6688": "public class HTMLWriter { \nprivate void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { \nString prefix = doPrefix ( uri , qName , isElement ) ; \nif ( prefix != null && ! \"\" . equals ( prefix ) ) { \nwrite ( prefix ) ; \nwrite ( ':' ) ; \n} \nif ( ! ( localName != null && ! \"\" . equals ( localName ) ) ) { \nint i = qName . indexOf ( ':' ) ; \nwrite ( qName . substring ( i + 1 , qName . length ( ) ) ) ; \n} \nelse { \nwrite ( localName ) ; \n} \n} \n} \n"}
{"6702": "public class ConfigurableWroManagerFactory { \nprivate void updatePropertiesWithConfiguration ( final Properties props , final String key ) { \nfinal FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; \nfinal String valuesAsString = filterConfig . getInitParameter ( key ) ; \nif ( ! ( valuesAsString != null ) ) { \nfinal String value = getConfigProperties ( ) . getProperty ( key ) ; \nif ( value != null ) { \nprops . setProperty ( key , value ) ; \n} \n} \nelse { \nprops . setProperty ( key , valuesAsString ) ; \n} \n} \n} \n"}
{"6714": "public class WildcardExpanderModelTransformer { \npublic Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , final String baseNameFolder ) { \nLOG . debug ( \"createExpanderHandler using baseNameFolder: {}\\n for resource {}\" , baseNameFolder , resource ) ; \nreturn new Function < Collection < File > , Void > ( ) { \npublic Void apply ( final Collection < File > files ) { \nif ( ! ( baseNameFolder == null ) ) { \nfinal List < Resource > expandedResources = new ArrayList < Resource > ( ) ; \nLOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; \nfor ( final File file : files ) { \nfinal String resourcePath = getFullPathNoEndSeparator ( resource ) ; \nLOG . debug ( \"\\tresourcePath: {}\" , resourcePath ) ; \nLOG . debug ( \"\\tfile path: {}\" , file . getPath ( ) ) ; \nfinal String computedResourceUri = resourcePath + StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( '\\\\' , '/' ) ; \nfinal Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; \nLOG . debug ( \"\\texpanded resource: {}\" , expandedResource ) ; \nexpandedResources . add ( expandedResource ) ; \n} \nLOG . debug ( \"\\treplace resource {}\" , resource ) ; \ngroup . replace ( resource , expandedResources ) ; \n} \nelse { \nLOG . warn ( \"The resource {} is probably invalid, removing it from the group.\" , resource ) ; \ngroup . replace ( resource , new ArrayList < Resource > ( ) ) ; \n} \nreturn null ; \n} \nprivate String getFullPathNoEndSeparator ( final Resource resource1 ) { \nfinal String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; \nif ( result != null && 1 == result . length ( ) && 0 == FilenameUtils . indexOfLastSeparator ( result ) ) { \nreturn \"\" ; \n} \nreturn result ; \n} \n} \n; \n} \n} \n"}
{"6725": "public class AbstractProcessorsFilter { \nprivate void doProcess ( final String requestUri , final Reader reader , final Writer writer ) throws IOException { \nReader input = reader ; \nWriter output = null ; \nLOG . debug ( \"processing resource: {}\" , requestUri ) ; \ntry { \nfinal StopWatch stopWatch = new StopWatch ( ) ; \nfinal Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; \nfinal List < ResourcePreProcessor > processors = getProcessorsList ( ) ; \nif ( ! ( processors == null || processors . isEmpty ( ) ) ) { \nfor ( final ResourcePreProcessor processor : processors ) { \nstopWatch . start ( \"Using \" + processor . getClass ( ) . getSimpleName ( ) ) ; \ninjector . inject ( processor ) ; \noutput = new StringWriter ( ) ; \nLOG . debug ( \"Using {} processor\" , processor ) ; \nprocessor . process ( createResource ( requestUri ) , input , output ) ; \ninput = new StringReader ( output . toString ( ) ) ; \nstopWatch . stop ( ) ; \n} \nLOG . debug ( stopWatch . prettyPrint ( ) ) ; \nif ( output != null ) { \nwriter . write ( output . toString ( ) ) ; \n} \n} \nelse { \nIOUtils . copy ( reader , writer ) ; \n} \n} \nfinally { \nreader . close ( ) ; \nwriter . close ( ) ; \n} \n} \n} \n"}
{"6734": "public class DefaultWroManagerFactory { \nprivate WroManagerFactory initFactory ( final Properties properties ) { \nWroManagerFactory factory = null ; \nfinal String wroManagerClassName = properties . getProperty ( ConfigConstants . managerFactoryClassName . name ( ) ) ; \nif ( ! ( StringUtils . isEmpty ( wroManagerClassName ) ) ) { \nClass < ? > factoryClass = null ; \ntry { \nfactoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerClassName ) ; \nfactory = ( WroManagerFactory ) factoryClass . newInstance ( ) ; \n} \ncatch ( final Exception e ) { \nthrow new WroRuntimeException ( \"Exception while loading WroManagerFactory class:\" + wroManagerClassName , e ) ; \n} \n} \nelse { \nfactory = newManagerFactory ( ) ; \n} \nif ( factory instanceof ConfigurableWroManagerFactory ) { \n( ( ConfigurableWroManagerFactory ) factory ) . addConfigProperties ( properties ) ; \n} \nreturn factory ; \n} \n} \n"}
{"6738": "public class PreProcessorExecutor { \npublic String processAndMerge ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { \nnotNull ( criteria ) ; \nLOG . debug ( \"criteria: {}\" , criteria ) ; \ncallbackRegistry . onBeforeMerge ( ) ; \ntry { \nnotNull ( resources ) ; \nLOG . debug ( \"process and merge resources: {}\" , resources ) ; \nfinal StringBuffer result = new StringBuffer ( ) ; \nif ( ! ( shouldRunInParallel ( resources ) ) ) { \nfor ( final Resource resource : resources ) { \nLOG . debug ( \"\\tmerging resource: {}\" , resource ) ; \nresult . append ( applyPreProcessors ( resource , criteria ) ) ; \n} \n} \nelse { \nresult . append ( runInParallel ( resources , criteria ) ) ; \n} \nreturn result . toString ( ) ; \n} \nfinally { \ncallbackRegistry . onAfterMerge ( ) ; \n} \n} \n} \n"}
{"6739": "public class PreProcessorExecutor { \nprivate String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { \nLOG . debug ( \"Running preProcessing in Parallel\" ) ; \nfinal StringBuffer result = new StringBuffer ( ) ; \nfinal List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; \nfor ( final Resource resource : resources ) { \ncallables . add ( new Callable < String > ( ) { \npublic String call ( ) throws Exception { \nLOG . debug ( \"Callable started for resource: {} ...\" , resource ) ; \nreturn applyPreProcessors ( resource , criteria ) ; \n} \n} \n) ; \n} \nfinal ExecutorService exec = getExecutorService ( ) ; \nfinal List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; \nfor ( final Callable < String > callable : callables ) { \nfinal Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; \nfutures . add ( exec . submit ( decoratedCallable ) ) ; \n} \nfor ( final Future < String > future : futures ) { \ntry { \nresult . append ( future . get ( ) ) ; \n} \ncatch ( final Exception e ) { \nfinal Throwable cause = e . getCause ( ) ; \nif ( ! ( cause instanceof WroRuntimeException ) ) if ( ! ( cause instanceof IOException ) ) { \nthrow new WroRuntimeException ( \"Problem during parallel pre processing\" , e ) ; \n} \nelse { \nthrow ( IOException ) cause ; \n} \nelse { \nthrow ( WroRuntimeException ) cause ; \n} \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"6740": "public class PreProcessorExecutor { \nprivate String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) throws IOException { \nfinal Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; \nLOG . debug ( \"applying preProcessors: {}\" , processors ) ; \nString resourceContent = null ; \ntry { \nresourceContent = getResourceContent ( resource ) ; \n} \ncatch ( final IOException e ) { \nLOG . debug ( \"Invalid resource found: {}\" , resource ) ; \nif ( ! ( Context . get ( ) . getConfig ( ) . isIgnoreMissingResources ( ) ) ) { \nLOG . error ( \"Cannot ignore missing resource:  {}\" , resource ) ; \nthrow e ; \n} \nelse { \nreturn StringUtils . EMPTY ; \n} \n} \nif ( ! processors . isEmpty ( ) ) { \nWriter writer = null ; \nfor ( final ResourcePreProcessor processor : processors ) { \nfinal ResourcePreProcessor decoratedProcessor = decoratePreProcessor ( processor , criteria ) ; \nwriter = new StringWriter ( ) ; \nfinal Reader reader = new StringReader ( resourceContent ) ; \ndecoratedProcessor . process ( resource , reader , writer ) ; \nresourceContent = writer . toString ( ) ; \n} \n} \nreturn String . format ( \"%s%n\" , resourceContent ) ; \n} \n} \n"}
{"6747": "public class ResourceBundleProcessor { \npublic void serveProcessedBundle ( ) throws IOException { \nfinal WroConfiguration configuration = context . getConfig ( ) ; \nfinal HttpServletRequest request = context . getRequest ( ) ; \nfinal HttpServletResponse response = context . getResponse ( ) ; \nOutputStream os = null ; \ntry { \nfinal CacheKey cacheKey = getSafeCacheKey ( request ) ; \ninitAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; \nfinal CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; \nfinal String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; \nfinal String etagValue = String . format ( \"\\\"%s\\\"\" , cacheValue . getHash ( ) ) ; \nif ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { \nLOG . debug ( \"ETag hash detected: {}. Sending {} status code\" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \nreturn ; \n} \nresponse . setContentType ( cacheKey . getType ( ) . getContentType ( ) + \"; charset=\" + configuration . getEncoding ( ) ) ; \nresponse . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; \nos = response . getOutputStream ( ) ; \nif ( cacheValue . getRawContent ( ) != null ) { \nif ( ! ( isGzipAllowed ( ) ) ) { \nresponse . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; \nIOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; \n} \nelse { \nresponse . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nresponse . setHeader ( \"Vary\" , \"Accept-Encoding\" ) ; \nIOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; \n} \n} \n} \nfinally { \nif ( os != null ) { \nIOUtils . closeQuietly ( os ) ; \n} \n} \n} \n} \n"}
{"6751": "public class CssVariablesProcessor { \nprivate String replaceVariables ( final String css , final Map < String , String > variables ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfinal Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; \nwhile ( m . find ( ) ) { \nfinal String oldMatch = m . group ( ) ; \nfinal String variableName = m . group ( 1 ) ; \nfinal String variableValue = variables . get ( variableName ) ; \nif ( ! ( variableValue != null ) ) { \nLOG . warn ( \"No variable with name \" + variableName + \" was found!\" ) ; \n} \nelse { \nfinal String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; \nm . appendReplacement ( sb , newReplacement . trim ( ) ) ; \n} \n} \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6758": "public class ResourceChangeHandler { \npublic void remember ( final Resource resource ) { \nfinal WroManager manager = getManagerFactory ( ) . create ( ) ; \nfinal HashStrategy hashStrategy = manager . getHashStrategy ( ) ; \nfinal UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; \nif ( ! ( rememberedSet . contains ( resource . getUri ( ) ) ) ) { \ntry { \nfinal String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; \nrememberedSet . add ( resource . getUri ( ) ) ; \ngetLog ( ) . debug ( \"Persist fingerprint for resource '\" + resource . getUri ( ) + \"' : \" + fingerprint ) ; \nif ( resource . getType ( ) == ResourceType . CSS ) { \nfinal Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetLog ( ) . debug ( \"Check @import directive from \" + resource ) ; \npersistFingerprintsForCssImports ( resource , reader ) ; \n} \n} \ncatch ( final IOException e ) { \ngetLog ( ) . debug ( \"could not check fingerprint of resource: \" + resource ) ; \n} \n} \nelse { \ngetLog ( ) . debug ( \"Resource with uri '\" + resource . getUri ( ) + \"' has already been updated in this run.\" ) ; \n} \n} \n} \n"}
{"6762": "public class AbstractCssImportPreProcessor { \nprivate List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { \nfinal List < Resource > imports = new ArrayList < Resource > ( ) ; \nfinal String css = cssContent ; \nfinal List < String > foundImports = findImports ( css ) ; \nfor ( final String importUrl : foundImports ) { \nfinal Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; \nif ( ! ( imports . contains ( importedResource ) ) ) { \nimports . add ( importedResource ) ; \nonImportDetected ( importedResource . getUri ( ) ) ; \n} \nelse { \nLOG . debug ( \"[WARN] Duplicate imported resource: {}\" , importedResource ) ; \n} \n} \nreturn imports ; \n} \n} \n"}
{"6774": "public class Wro4jMojo { \nprivate void processGroup ( final String group , final File parentFoder ) throws Exception { \nByteArrayOutputStream resultOutputStream = null ; \nInputStream resultInputStream = null ; \ntry { \ngetLog ( ) . info ( \"processing group: \" + group ) ; \nfinal HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; \nMockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; \nMockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; \nfinal HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; \nresultOutputStream = new ByteArrayOutputStream ( ) ; \nMockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; \nfinal WroConfiguration config = Context . get ( ) . getConfig ( ) ; \nconfig . setIgnoreEmptyGroup ( true ) ; \nContext . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; \nContext . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; \ngetManagerFactory ( ) . create ( ) . process ( ) ; \nresultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; \nfinal File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; \nfinal File parentFolder = destinationFile . getParentFile ( ) ; \nif ( ! parentFolder . exists ( ) ) { \nparentFolder . mkdirs ( ) ; \n} \ndestinationFile . createNewFile ( ) ; \nresultInputStream . reset ( ) ; \ngetLog ( ) . debug ( \"Created file: \" + destinationFile . getName ( ) ) ; \nfinal OutputStream fos = new FileOutputStream ( destinationFile ) ; \nIOUtils . copy ( resultInputStream , fos ) ; \nfos . close ( ) ; \nif ( ! ( destinationFile . length ( ) == 0 ) ) { \ngetLog ( ) . info ( \"file size: \" + destinationFile . getName ( ) + \" -> \" + destinationFile . length ( ) + \" bytes\" ) ; \ngetLog ( ) . info ( destinationFile . getAbsolutePath ( ) + \" (\" + destinationFile . length ( ) + \" bytes\" + \")\" ) ; \n} \nelse { \ngetLog ( ) . debug ( \"No content found for group: \" + group ) ; \ndestinationFile . delete ( ) ; \n} \n} \nfinally { \nif ( getBuildContext ( ) != null ) { \ngetBuildContext ( ) . refresh ( parentFoder ) ; \n} \nif ( resultOutputStream != null ) { \nresultOutputStream . close ( ) ; \n} \nif ( resultInputStream != null ) { \nresultInputStream . close ( ) ; \n} \n} \n} \n} \n"}
{"6795": "public class WroUtil { \npublic static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { \nif ( StringUtils . isEmpty ( location ) ) { \nthrow new IllegalArgumentException ( \"Location cannot be empty string!\" ) ; \n} \nfinal String contextPath = request . getContextPath ( ) ; \nif ( contextPath != null ) { \nif ( ! ( startsWithIgnoreCase ( location , contextPath ) ) ) { \nreturn location ; \n} \nelse { \nreturn location . substring ( contextPath . length ( ) ) ; \n} \n} \nfinal String noSlash = location . substring ( 1 ) ; \nfinal int nextSlash = noSlash . indexOf ( '/' ) ; \nif ( nextSlash == - 1 ) { \nreturn \"\" ; \n} \nreturn noSlash . substring ( nextSlash ) ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( ! ( threadId != 0 ) ) if ( ! ( threadCount > 1 ) ) { \ntimerLabel = name ; \n} \nelse { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nif ( ! ( todoFlags == RECORD_NONE ) ) { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ! ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) ) { \nseparator = \"\" ; \n} \nelse { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nelse { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n} \n"}
{"6820": "public class ElkTimer { \npublic static long stopNamedTimer ( String timerName , int todoFlags , long threadId ) { \nElkTimer key = new ElkTimer ( timerName , todoFlags , threadId ) ; \nif ( ! ( registeredTimers . containsKey ( key ) ) ) { \nreturn - 1 ; \n} \nelse { \nreturn registeredTimers . get ( key ) . stop ( ) ; \n} \n} \n} \n"}
{"6829": "public class ObjectPropertyTaxonomyComputationFactory { \nprivate void instertIntoTaxonomy ( final IndexedObjectProperty property ) { \nfinal Map < IndexedObjectProperty , ElkObjectProperty > equivalent = collectEquivalent ( property ) ; \nif ( equivalent == null ) { \nreturn ; \n} \nfinal Map < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > subEquivalent = new ArrayHashMap < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > ( ) ; \nfinal Set < IndexedObjectProperty > indirect = new ArrayHashSet < IndexedObjectProperty > ( ) ; \nfor ( final IndexedObjectProperty subProperty : property . getSaturated ( ) . getSubProperties ( ) ) { \nif ( equivalent . containsKey ( subProperty ) ) { \ncontinue ; \n} \nfinal Map < IndexedObjectProperty , ElkObjectProperty > subEq = collectEquivalent ( subProperty ) ; \nsubEquivalent . put ( subProperty , subEq . values ( ) ) ; \nfor ( final IndexedObjectProperty subSubProperty : subProperty . getSaturated ( ) . getSubProperties ( ) ) { \nif ( ! subEq . containsKey ( subSubProperty ) ) { \nindirect . add ( subSubProperty ) ; \n} \n} \n} \nif ( subEquivalent . isEmpty ( ) && ( indexedBottomProperty_ == null || ! equivalent . containsKey ( indexedBottomProperty_ ) ) ) { \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , defaultDirectSubproperties_ ) ) ; \nreturn ; \n} \nfinal Collection < Collection < ? extends ElkObjectProperty > > direct = Operations . map ( subEquivalent . entrySet ( ) , new Operations . Transformation < Map . Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > , Collection < ? extends ElkObjectProperty > > ( ) { \n@ Override public Collection < ? extends ElkObjectProperty > transform ( final Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > element ) { \nif ( ! ( indirect . contains ( element . getKey ( ) ) ) ) { \nreturn element . getValue ( ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n) ; \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , direct ) ) ; \n} \n} \n"}
{"6830": "public class AbstractReasonerState { \npublic synchronized void ensureLoading ( ) throws ElkException { \nif ( ! isLoadingFinished ( ) ) { \nif ( ! ( isIncrementalMode ( ) ) ) { \nif ( ! stageManager . contextInitializationStage . isCompleted ( ) ) { \ncomplete ( stageManager . contextInitializationStage ) ; \n} \n} \nelse { \nif ( ! stageManager . incrementalAdditionStage . isCompleted ( ) ) { \ncomplete ( stageManager . incrementalAdditionStage ) ; \n} \n} \nLOGGER_ . trace ( \"Reset axiom loading\" ) ; \nstageManager . inputLoadingStage . invalidateRecursive ( ) ; \nstageManager . contextInitializationStage . invalidateRecursive ( ) ; \nstageManager . incrementalCompletionStage . invalidateRecursive ( ) ; \n} \ncomplete ( stageManager . inputLoadingStage ) ; \n} \n} \n"}
{"6831": "public class AbstractReasonerState { \nprivate void restoreSaturation ( ) throws ElkException { \nensureLoading ( ) ; \nfinal boolean changed ; \nif ( ! ( isIncrementalMode ( ) ) ) { \nchanged = ! stageManager . contextInitializationStage . isCompleted ( ) ; \ncomplete ( stageManager . contextInitializationStage ) ; \n} \nelse { \nchanged = ! stageManager . incrementalTaxonomyCleaningStage . isCompleted ( ) ; \ncomplete ( stageManager . incrementalTaxonomyCleaningStage ) ; \n} \nif ( changed ) { \nstageManager . consistencyCheckingStage . invalidateRecursive ( ) ; \n} \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( ! ( newMask == oldMask ) ) if ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \nelse return false ; \nsizes [ s ] ++ ; \nreturn true ; \n} \n} \n"}
{"6874": "public class Reasoner { \npublic synchronized boolean shutdown ( long timeout , TimeUnit unit ) throws InterruptedException { \nboolean success = true ; \nif ( ! ( success ) ) { \nLOGGER_ . error ( \"ELK reasoner failed to shut down!\" ) ; \n} \nelse { \nLOGGER_ . info ( \"ELK reasoner has shut down\" ) ; \n} \nreturn success ; \n} \n} \n"}
{"6879": "public class XhtmlResourceMessageConverter { \nprivate void writeResource ( XhtmlWriter writer , Object object ) { \nif ( object == null ) { \nreturn ; \n} \ntry { \nif ( ! ( object instanceof Resource ) ) if ( ! ( object instanceof Resources ) ) if ( ! ( object instanceof ResourceSupport ) ) if ( ! ( object instanceof Collection ) ) { \nwriteObject ( writer , object ) ; \n} \nelse { \nCollection < ? > collection = ( Collection < ? > ) object ; \nfor ( Object item : collection ) { \nwriteResource ( writer , item ) ; \n} \n} \nelse { \nResourceSupport resource = ( ResourceSupport ) object ; \nwriter . beginListItem ( ) ; \nwriteObject ( writer , resource ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse { \nResources < ? > resources = ( Resources < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriter . beginUnorderedList ( ) ; \nCollection < ? > content = resources . getContent ( ) ; \nwriteResource ( writer , content ) ; \nwriter . endUnorderedList ( ) ; \nwriter . writeLinks ( resources . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse { \nResource < ? > resource = ( Resource < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriteResource ( writer , resource . getContent ( ) ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( \"failed to transform object \" + object , ex ) ; \n} \n} \n} \n"}
{"6881": "public class SpringActionDescriptor { \nPropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { \nint pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; \nif ( ! ( pos > - 1 ) ) { \nreturn BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; \n} \nelse { \nString nestedProperty = propertyPath . substring ( 0 , pos ) ; \nString nestedPath = propertyPath . substring ( pos + 1 ) ; \nPropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; \nreturn getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; \n} \n} \n} \n"}
{"6883": "public class DataType { \npublic static boolean isSingleValueType ( Class < ? > clazz ) { \nboolean ret ; \nif ( ! ( isNumber ( clazz ) || isBoolean ( clazz ) || isString ( clazz ) || isEnum ( clazz ) || isDate ( clazz ) || isCalendar ( clazz ) || isCurrency ( clazz ) ) ) { \nret = false ; \n} \nelse { \nret = true ; \n} \nreturn ret ; \n} \n} \n"}
{"6885": "public class Affordance { \npublic void setType ( String mediaType ) { \nif ( ! ( mediaType != null ) ) linkParams . remove ( TYPE . paramName ) ; \nelse linkParams . set ( TYPE . paramName , mediaType ) ; \n} \n} \n"}
{"6893": "public class SpringActionInputParameter { \npublic String getValueFormatted ( ) { \nString ret ; \nif ( ! ( value == null ) ) { \nret = ( String ) conversionService . convert ( value , typeDescriptor , TypeDescriptor . valueOf ( String . class ) ) ; \n} \nelse { \nret = null ; \n} \nreturn ret ; \n} \n} \n"}
{"6897": "public class SpringActionInputParameter { \npublic boolean isRequired ( ) { \nboolean ret ; \nif ( ! ( isRequestBody ( ) ) ) if ( ! ( isRequestParam ( ) ) ) if ( ! ( isRequestHeader ( ) ) ) { \nret = true ; \n} \nelse { \nret = ! ( isDefined ( requestHeader . defaultValue ( ) ) || ! requestHeader . required ( ) ) ; \n} \nelse { \nret = ! ( isDefined ( requestParam . defaultValue ( ) ) || ! requestParam . required ( ) ) ; \n} \nelse { \nret = requestBody . required ( ) ; \n} \nreturn ret ; \n} \n} \n"}
{"6898": "public class SpringActionInputParameter { \npublic String getDefaultValue ( ) { \nString ret ; \nif ( ! ( isRequestParam ( ) ) ) if ( ! ( isRequestHeader ( ) ) ) { \nret = null ; \n} \nelse { \nret = ! ( ValueConstants . DEFAULT_NONE . equals ( requestHeader . defaultValue ( ) ) ) ? requestHeader . defaultValue ( ) : null ; \n} \nelse { \nret = isDefined ( requestParam . defaultValue ( ) ) ? requestParam . defaultValue ( ) : null ; \n} \nreturn ret ; \n} \n} \n"}
{"6899": "public class SpringActionInputParameter { \n@ Override public String getParameterName ( ) { \nString ret = null ; \nif ( requestParam != null ) { \nString requestParamName = requestParam . value ( ) ; \nif ( ! requestParamName . isEmpty ( ) ) ret = requestParamName ; \n} \nif ( pathVariable != null ) { \nString pathVariableName = pathVariable . value ( ) ; \nif ( ! pathVariableName . isEmpty ( ) ) ret = pathVariableName ; \n} \nif ( ret == null ) { \nString parameterName = methodParameter . getParameterName ( ) ; \nif ( ! ( parameterName == null ) ) { \nret = parameterName ; \n} \nelse { \nmethodParameter . initParameterNameDiscovery ( new LocalVariableTableParameterNameDiscoverer ( ) ) ; \nret = methodParameter . getParameterName ( ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"6900": "public class LinkListSerializer { \nprivate String getExposedPropertyOrParamName ( ActionInputParameter inputParameter ) { \nfinal Expose expose = inputParameter . getAnnotation ( Expose . class ) ; \nString property ; \nif ( ! ( expose != null ) ) { \nproperty = inputParameter . getParameterName ( ) ; \n} \nelse { \nproperty = expose . value ( ) ; \n} \nreturn property ; \n} \n} \n"}
{"6901": "public class LdContextFactory { \npublic String getVocab ( MixinSource mixinSource , Object bean , Class < ? > mixInClass ) { \nif ( proxyUnwrapper != null ) { \nbean = proxyUnwrapper . unwrapProxy ( bean ) ; \n} \nString classVocab = bean == null ? null : vocabFromClassOrPackage ( bean . getClass ( ) ) ; \nfinal Vocab mixinVocab = findAnnotation ( mixInClass , Vocab . class ) ; \nObject nestedContextProviderFromMixin = getNestedContextProviderFromMixin ( mixinSource , bean , mixInClass ) ; \nString contextProviderVocab = null ; \nif ( nestedContextProviderFromMixin != null ) { \ncontextProviderVocab = getVocab ( mixinSource , nestedContextProviderFromMixin , null ) ; \n} \nString vocab ; \nif ( ! ( mixinVocab != null ) ) if ( ! ( classVocab != null ) ) if ( ! ( contextProviderVocab != null ) ) { \nvocab = HTTP_SCHEMA_ORG ; \n} \nelse { \nvocab = contextProviderVocab ; \n} \nelse { \nvocab = classVocab ; \n} \nelse { \nvocab = mixinVocab . value ( ) ; \n} \nreturn vocab ; \n} \n} \n"}
{"6902": "public class PartialUriTemplateComponents { \npublic String getQuery ( ) { \nStringBuilder query = new StringBuilder ( ) ; \nif ( ! ( queryTail . length ( ) > 0 ) ) { \nquery . append ( queryHead ) ; \n} \nelse { \nif ( ! ( queryHead . length ( ) == 0 ) ) if ( queryHead . length ( ) > 0 ) { \nquery . append ( queryHead ) . append ( \"{&\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \nelse { \nquery . append ( \"{?\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( ! ( actionDescriptor . hasRequestBody ( ) ) ) { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( ! ( possibleValues . length > 0 ) ) { \nif ( ! ( actionInputParameter . isArrayOrCollection ( ) ) ) { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \nelse { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \ni < items ; \ni ++ ) { \nObject value ; \nif ( ! ( i < callValues . length ) ) { \nvalue = null ; \n} \nelse { \nvalue = callValues [ i ] ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \nelse { \nif ( ! ( actionInputParameter . isArrayOrCollection ( ) ) ) { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \n} \n} \nelse { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6905": "public class XhtmlWriter { \nprivate void appendInputOrSelect ( ActionInputParameter parentInputParameter , String paramName , ActionInputParameter childInputParameter , Object [ ] possibleValues ) throws IOException { \nif ( ! ( possibleValues . length > 0 ) ) { \nappendInput ( paramName , childInputParameter , childInputParameter . getValue ( ) , parentInputParameter . isReadOnly ( paramName ) ) ; \n} \nelse { \nif ( ! ( childInputParameter . isArrayOrCollection ( ) ) ) { \nappendSelectOne ( paramName , possibleValues , childInputParameter ) ; \n} \nelse { \nappendSelectMulti ( paramName , possibleValues , childInputParameter ) ; \n} \n} \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nj < ops . length ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \nif ( ! ( op . map != null ) ) if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \nelse { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6922": "public class OneOf3 { \n@ SuppressWarnings ( \"unchecked\" ) public < R > R match ( Fn1 < A , R > fa , Fn1 < B , R > fb , Fn1 < C , R > fc ) { \nif ( ! ( sel == 0 ) ) if ( ! ( sel == 1 ) ) { \nreturn fc . apply ( ( C ) item ) ; \n} \nelse { \nreturn fb . apply ( ( B ) item ) ; \n} \nelse { \nreturn fa . apply ( ( A ) item ) ; \n} \n} \n} \n"}
{"6925": "public class PersistentVector { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public PersistentVector < E > append ( E val ) { \nif ( size - tailoff ( ) < MAX_NODE_LENGTH ) { \nE [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; \nSystem . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; \nnewTail [ tail . length ] = val ; \nreturn new PersistentVector < > ( size + 1 , shift , root , newTail ) ; \n} \nNode newroot ; \nNode tailnode = new Node ( root . edit , tail ) ; \nint newshift = shift ; \nif ( ! ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) ) { \nnewroot = pushTail ( shift , root , tailnode ) ; \n} \nelse { \nnewroot = new Node ( root . edit ) ; \nnewroot . array [ 0 ] = root ; \nnewroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; \nnewshift += NODE_LENGTH_POW_2 ; \n} \nreturn new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { \nval } \n) ; \n} \n} \n"}
{"6933": "public class IndentUtils { \npublic static < T > String arrayString ( T [ ] items ) { \nStringBuilder sB = new StringBuilder ( \"A[\" ) ; \nboolean isFirst = true ; \nfor ( T item : items ) { \nif ( ! ( isFirst ) ) { \nsB . append ( \" \" ) ; \n} \nelse { \nisFirst = false ; \n} \nif ( ! ( item instanceof String ) ) { \nsB . append ( item ) ; \n} \nelse { \nsB . append ( \"\\\"\" ) . append ( item ) . append ( \"\\\"\" ) ; \n} \n} \nreturn sB . append ( \"]\" ) . toString ( ) ; \n} \n} \n"}
{"6947": "public class UsageNotificationManagerMBeanImpl { \npublic boolean getNotificationsEnabled ( String paramName ) { \nBoolean areNotificationsEnabled = paramNames . get ( paramName ) ; \nif ( ! ( ! isSlee11 ) ) { \nif ( ! ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \nelse { \nif ( ! ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \n} \n} \n"}
{"6952": "public class ServiceUsageMBeanImpl { \npublic synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { \nif ( sbbId == null ) throw new NullPointerException ( \"Sbb ID is null!\" ) ; \nSbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; \nif ( ! ( sbbComponent == null ) ) { \nif ( sbbComponent . getUsageParametersInterface ( ) == null ) { \nthrow new InvalidArgumentException ( \"no usage parameter interface for \" + sbbId ) ; \n} \n} \nelse { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) ) ; \n} \nServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; \nif ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) + \" is not part of \" + getService ( ) ) ; \n} \nSet < String > resultSet = new HashSet < String > ( ) ; \nfor ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { \nif ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { \nString name = usageMBeanImpl . getUsageParameterSet ( ) ; \nif ( name != null ) { \nresultSet . add ( name ) ; \n} \n} \n} \nreturn resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; \n} \n} \n"}
{"6956": "public class ProfileFacilityImpl { \npublic ProfileID getProfileByIndexedAttribute ( java . lang . String profileTableName , java . lang . String attributeName , java . lang . Object attributeValue ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedAttributeException , AttributeNotIndexedException , AttributeTypeMismatchException , TransactionRolledbackLocalException , FacilityException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"getProfileByIndexedAttribute( profileTableName = \" + profileTableName + \" , attributeName = \" + attributeName + \" , attributeValue = \" + attributeValue + \" )\" ) ; \n} \nprofileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; \ntry { \nProfileTableImpl profileTable = profileManagement . getProfileTable ( profileTableName ) ; \nif ( profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) { \nthrow new FacilityException ( \"JAIN SLEE 1.1 Specs forbidden the usage of this method on SLEE 1.1 Profile Tables\" ) ; \n} \nCollection < ProfileID > profileIDs = profileTable . getProfilesByAttribute ( attributeName , attributeValue , false ) ; \nif ( ! ( profileIDs . isEmpty ( ) ) ) { \nreturn profileIDs . iterator ( ) . next ( ) ; \n} \nelse { \nreturn null ; \n} \n} \ncatch ( NullPointerException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedProfileTableNameException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedAttributeException e ) { \nthrow e ; \n} \ncatch ( AttributeNotIndexedException e ) { \nthrow e ; \n} \ncatch ( AttributeTypeMismatchException e ) { \nthrow e ; \n} \ncatch ( Throwable e ) { \nthrow new FacilityException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \nfor ( int index = 0 ; \nindex < array . length ; \nindex ++ ) { \nif ( ! ( editor != null ) ) { \nsb . append ( array [ index ] . toString ( ) ) ; \n} \nelse { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nif ( index < array . length - 1 ) { \nsb . append ( CID_SEPARATOR ) ; \n} \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6960": "public class ActivityContextNamingFacilityCacheData { \npublic void bindName ( Object ach , String name ) throws NameAlreadyBoundException { \nfinal Node node = getNode ( ) ; \nif ( ! ( node . hasChild ( name ) ) ) { \nnode . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; \n} \nelse { \nthrow new NameAlreadyBoundException ( \"name already bound\" ) ; \n} \n} \n} \n"}
{"6961": "public class ActivityContextNamingFacilityCacheData { \npublic Object unbindName ( String name ) throws NameNotBoundException { \nfinal Node node = getNode ( ) ; \nfinal Node childNode = node . getChild ( name ) ; \nif ( ! ( childNode == null ) ) { \nfinal Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; \nnode . removeChild ( name ) ; \nreturn ach ; \n} \nelse { \nthrow new NameNotBoundException ( \"name not bound\" ) ; \n} \n} \n} \n"}
{"6962": "public class ActivityContextNamingFacilityCacheData { \npublic Object lookupName ( String name ) { \nfinal Node childNode = getNode ( ) . getChild ( name ) ; \nif ( ! ( childNode == null ) ) { \nreturn childNode . get ( CACHE_NODE_MAP_KEY ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"6964": "public class NextSbbEntityFinder { \npublic Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { \nSbbEntityID sbbEntityId = null ; \nSbbEntity sbbEntity = null ; \nEventEntryDescriptor mEventEntry = null ; \nfor ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nsbbEntityId = iter . next ( ) ; \nsbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; \nif ( sbbEntity == null ) { \ncontinue ; \n} \nif ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { \ncontinue ; \n} \nif ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { \nif ( ! ( ! sleeEvent . isActivityEndEvent ( ) ) ) { \nreturn new Result ( sbbEntity , false ) ; \n} \nelse { \ncontinue ; \n} \n} \nmEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; \nif ( ! ( mEventEntry != null && mEventEntry . isReceived ( ) ) ) { \nif ( ! ( ! sleeEvent . isActivityEndEvent ( ) ) ) { \nreturn new Result ( sbbEntity , false ) ; \n} \nelse { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; \n} \ncontinue ; \n} \n} \nelse { \nreturn new Result ( sbbEntity , true ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \nfor ( JarEntry entry = jarIs . getNextJarEntry ( ) ; \njarIs . available ( ) > 0 && entry != null ; \nentry = jarIs . getNextJarEntry ( ) ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( ! ( entry . isDirectory ( ) ) ) { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! ( ! dir . mkdirs ( ) ) ) logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \nelse { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \nelse { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! ( ! dir . exists ( ) ) ) logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \nelse { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) { \ntry { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"6969": "public class ActivityContextCacheData { \npublic boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { \nfinal Node node = getAttachedSbbsNode ( true ) ; \nif ( ! ( ! node . hasChild ( sbbEntityId ) ) ) { \nreturn false ; \n} \nelse { \nnode . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; \nreturn true ; \n} \n} \n} \n"}
{"6973": "public class ActivityContextCacheData { \npublic boolean attachTimer ( TimerID timerID ) { \nfinal Node node = getAttachedTimersNode ( true ) ; \nif ( ! ( ! node . hasChild ( timerID ) ) ) { \nreturn false ; \n} \nelse { \nnode . addChild ( Fqn . fromElements ( timerID ) ) ; \nreturn true ; \n} \n} \n} \n"}
{"6982": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public Object getCmpAttribute ( String attrName ) { \nfinal Node node = getCmpAttributesNode ( false ) ; \nif ( ! ( node == null ) ) { \nfinal Node cmpNode = node . getChild ( attrName ) ; \nif ( ! ( cmpNode != null ) ) { \nreturn null ; \n} \nelse { \nreturn cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ; \n} \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"6983": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public Map getCmpAttributesCopy ( ) { \nfinal Node node = getCmpAttributesNode ( false ) ; \nif ( ! ( node == null ) ) { \nMap result = new HashMap ( ) ; \nNode cmpNode = null ; \nfor ( Object obj : node . getChildren ( ) ) { \ncmpNode = ( Node ) obj ; \nresult . put ( cmpNode . getFqn ( ) . getLastElement ( ) , cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ) ; \n} \nreturn result ; \n} \nelse { \nreturn Collections . emptyMap ( ) ; \n} \n} \n} \n"}
{"6988": "public class DeploymentManager { \npublic void installDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( ! ( du . isReadyToInstall ( true ) ) ) { \nlogger . warn ( \"Unable to INSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependencies to be resolved.\" ) ; \nwaitingForInstallDUs . add ( du ) ; \n} \nelse { \nsciAction ( du . getInstallActions ( ) , du ) ; \ndu . setInstalled ( true ) ; \ndeployedDUs . add ( du ) ; \nupdateDeployedComponents ( ) ; \nIterator < DeployableUnit > duIt = waitingForInstallDUs . iterator ( ) ; \nwhile ( duIt . hasNext ( ) ) { \nDeployableUnit waitingDU = duIt . next ( ) ; \nif ( waitingDU . isReadyToInstall ( false ) ) { \nsciAction ( waitingDU . getInstallActions ( ) , waitingDU ) ; \nwaitingDU . setInstalled ( true ) ; \ndeployedDUs . add ( waitingDU ) ; \nupdateDeployedComponents ( ) ; \nwaitingForInstallDUs . remove ( waitingDU ) ; \nduIt = waitingForInstallDUs . iterator ( ) ; \n} \n} \n} \n} \n} \n"}
{"6989": "public class DeploymentManager { \npublic void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( ! ( ! du . isInstalled ( ) ) ) if ( ! ( ! du . areComponentsStillPresent ( ) ) ) if ( ! ( du . isReadyToUninstall ( ) ) ) { \nif ( ! waitingForUninstallDUs . contains ( du ) ) { \nwaitingForUninstallDUs . add ( du ) ; \nlogger . warn ( \"Unable to UNINSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependents to be removed.\" ) ; \n} \nthrow new DependencyException ( \"Unable to undeploy \" + du . getDeploymentInfoShortName ( ) ) ; \n} \nelse { \nsciAction ( du . getUninstallActions ( ) , du ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" components already removed. Removing DU info.\" ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nif ( waitingForInstallDUs . remove ( du ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" wasn't deployed. Removing from waiting list.\" ) ; \n} \n} \n} \n} \n"}
{"6992": "public class MobicentsLogFilter { \npublic boolean isLoggable ( LogRecord record ) { \nLogger logger = getLogger ( record ) ; \nif ( ! ( record . getThrown ( ) != null ) ) { \nlogWithoutThrowable ( logger , record ) ; \n} \nelse { \nlogWithThrowable ( logger , record ) ; \n} \nreturn false ; \n} \n} \n"}
{"7000": "public class ResourceAdaptorEntityImpl { \npublic void updateConfigurationProperties ( ConfigProperties properties ) throws InvalidConfigurationException , InvalidStateException { \nif ( ! ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) && ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) && ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) ) { \nobject . raConfigurationUpdate ( properties ) ; \n} \nelse { \nthrow new InvalidStateException ( \"the value of the supports-active-reconfiguration attribute of the resource-adaptor-class element in the deployment descriptor of the Resource Adaptor of the resource adaptor entity is False and the resource adaptor entity is in the Active or Stopping state and the SLEE is in the Starting, Running, or Stopping state\" ) ; \n} \n} \n} \n"}
{"7004": "public class ResourceAdaptorEntityImpl { \npublic void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { \nif ( ! this . state . isActive ( ) ) { \nthrow new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \n} \nthis . state = ResourceAdaptorEntityState . STOPPING ; \nif ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) { \nobject . raStopping ( ) ; \n} \nTimerTask t = new TimerTask ( ) { \n@ Override public void run ( ) { \ntry { \ncancel ( ) ; \nif ( state == ResourceAdaptorEntityState . STOPPING ) { \nif ( ! ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) ) { \nallActivitiesEnded ( ) ; \n} \nelse { \nscheduleAllActivitiesEnd ( ) ; \n} \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \nresourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; \n} \n} \n"}
{"7005": "public class ResourceAdaptorEntityImpl { \nprivate void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { \nboolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; \nif ( ! ( ! skipActivityEnding && hasActivities ( ) ) ) { \nallActivitiesEnded ( ) ; \n} \nelse { \nlogger . info ( \"RA entity \" + name + \" activities end scheduled.\" ) ; \ntimerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; \n} \n} \n} \n"}
{"7009": "public class ResourceAdaptorEntityImpl { \nActivityHandle derreferActivityHandle ( ActivityHandle handle ) { \nActivityHandle ah = null ; \nif ( ! ( resourceManagement . getHandleReferenceFactory ( ) != null && handle . getClass ( ) == ActivityHandleReference . class ) ) { \nah = handle ; \n} \nelse { \nActivityHandleReference ahReference = ( ActivityHandleReference ) handle ; \nah = resourceManagement . getHandleReferenceFactory ( ) . getActivityHandle ( ahReference ) ; \n} \nreturn ah ; \n} \n} \n"}
{"7010": "public class ResourceAdaptorEntityImpl { \npublic void activityEnded ( final ActivityHandle handle , int activityFlags ) { \nlogger . trace ( \"activityEnded( handle = \" + handle + \" )\" ) ; \nActivityHandle ah = null ; \nif ( ! ( handle instanceof ActivityHandleReference ) ) { \nah = handle ; \n} \nelse { \nah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; \n} \nif ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) { \nobject . activityEnded ( ah ) ; \n} \nif ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { \nsynchronized ( this ) { \nif ( ! hasActivities ( ) ) { \nif ( timerTask != null ) { \ntimerTask . cancel ( ) ; \n} \nallActivitiesEnded ( ) ; \n} \n} \n} \n} \n} \n"}
{"7013": "public class ResourceAdaptorObjectImpl { \npublic void raStopping ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raStopping()\" ) ; \n} \nif ( ! ( state == ResourceAdaptorObjectState . ACTIVE ) ) { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nelse { \nstate = ResourceAdaptorObjectState . STOPPING ; \nobject . raStopping ( ) ; \n} \n} \n} \n"}
{"7014": "public class ResourceAdaptorObjectImpl { \npublic void raInactive ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raInactive()\" ) ; \n} \nif ( ! ( state == ResourceAdaptorObjectState . STOPPING ) ) { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nelse { \nstate = ResourceAdaptorObjectState . INACTIVE ; \nobject . raInactive ( ) ; \n} \n} \n} \n"}
{"7015": "public class ResourceAdaptorObjectImpl { \npublic void raUnconfigure ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raUnconfigure()\" ) ; \n} \nif ( ! ( state == ResourceAdaptorObjectState . INACTIVE ) ) { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nelse { \nstate = ResourceAdaptorObjectState . UNCONFIGURED ; \nobject . raUnconfigure ( ) ; \n} \n} \n} \n"}
{"7016": "public class ResourceAdaptorObjectImpl { \npublic void unsetResourceAdaptorContext ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"unsetResourceAdaptorContext()\" ) ; \n} \nif ( ! ( state == ResourceAdaptorObjectState . UNCONFIGURED ) ) { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nelse { \nobject . unsetResourceAdaptorContext ( ) ; \nstate = null ; \n} \n} \n} \n"}
{"7017": "public class ResourceAdaptorObjectImpl { \n@ SuppressWarnings ( \"unchecked\" ) public void unsetFaultTolerantResourceAdaptorContext ( ) throws IllegalArgumentException { \nif ( doTraceLogs ) { \nlogger . trace ( \"unsetFaultTolerantResourceAdaptorContext()\" ) ; \n} \nif ( ! ( isFaultTolerant ( ) ) ) { \nthrow new IllegalArgumentException ( \"RA Object is not fault tolerant!\" ) ; \n} \nelse { \n( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; \n} \n} \n} \n"}
{"7018": "public class ProfileSpecificationComponentImpl { \nprivate void buildProfileAttributeMap ( ) throws DeploymentException { \nHashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; \nClass < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; \nString attributeGetterMethodPrefix = \"get\" ; \nfor ( Method method : cmpInterface . getMethods ( ) ) { \nif ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { \nString attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; \nswitch ( attributeName . length ( ) ) { \ncase 0 : throw new DeploymentException ( \"the profile cmp interface class has an invalid attribute getter method name > \" + method . getName ( ) ) ; \ncase 1 : attributeName = attributeName . toLowerCase ( ) ; \nbreak ; \ndefault : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; \nbreak ; \n} \nProfileAttributeImpl profileAttribute = null ; \ntry { \nprofileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new DeploymentException ( \"Invalid profile cmp interface attribute getter method definition ( name = \" + attributeName + \" , type = \" + method . getReturnType ( ) + \" )\" , e ) ; \n} \nif ( ! ( isSlee11 ( ) ) ) { \nfor ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { \nif ( profileIndex . getName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setIndex ( true ) ; \nprofileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; \n} \n} \n} \nelse { \nfor ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { \nif ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setUnique ( cmpField . isUnique ( ) ) ; \n} \n} \n} \nmap . put ( attributeName , profileAttribute ) ; \n} \n} \nprofileAttributeMap = Collections . unmodifiableMap ( map ) ; \n} \n} \n"}
{"7023": "public class ProfileAbstractClassDecorator { \npublic boolean decorateAbstractClass ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; \nif ( abstractClass == null ) { \nreturn false ; \n} \nString abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; \ntry { \nctClass = pool . get ( abstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Class: \" + abstractClassName , nfe ) ; \n} \ndecorateClassJNDIAddToEnvironmentCalls ( ) ; \nif ( ! ( isAbstractClassDecorated ) ) { \nreturn false ; \n} \nelse { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nctClass . writeFile ( deployDir ) ; \nctClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + ctClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nctClass . defrost ( ) ; \n} \nreturn true ; \n} \n} \n} \n"}
{"7031": "public class ProfileObjectPoolManagement { \npublic void removeObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Removing Pool for \" + profileTable ) ; \n} \nremoveObjectPool ( profileTable ) ; \n} \n} \n; \nif ( ! ( sleeTransactionManager != null ) ) { \naction . execute ( ) ; \n} \nelse { \nsleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; \n} \n} \n} \n"}
{"7033": "public class AlarmMBeanImpl { \npublic String raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { \nsynchronized ( notificationSource ) { \nif ( ! ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) ) { \nAlarm a = new Alarm ( UUID . randomUUID ( ) . toString ( ) , notificationSource . getNotificationSource ( ) , alarmType , instanceID , level , message , cause , System . currentTimeMillis ( ) ) ; \nAlarmPlaceHolder aph = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID , a ) ; \nthis . alarmIdToAlarm . put ( a . getAlarmID ( ) , aph ) ; \nthis . placeHolderToNotificationSource . put ( aph , aph . getNotificationSource ( ) . getNotificationSource ( ) ) ; \ngenerateNotification ( aph , false ) ; \nreturn a . getAlarmID ( ) ; \n} \nelse { \nAlarm a = null ; \ntry { \nAlarmPlaceHolder localAPH = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID ) ; \nfor ( Map . Entry < String , AlarmPlaceHolder > e : this . alarmIdToAlarm . entrySet ( ) ) { \nif ( e . getValue ( ) . equals ( localAPH ) ) { \na = e . getValue ( ) . getAlarm ( ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nif ( ! ( a != null ) ) { \nreturn this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; \n} \nelse { \nreturn a . getAlarmID ( ) ; \n} \n} \n} \n} \n} \n"}
{"7034": "public class ProfileManagementHandler { \npublic static Object getUsageParameterSet ( ProfileObjectImpl profileObject , String name ) throws UnrecognizedUsageParameterSetNameException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . info ( \"[getUsageParameterSet(\" + name + \")] @ \" + profileObject ) ; \n} \nif ( name == null ) { \nthrow new NullPointerException ( \"UsageParameterSet name must not be null.\" ) ; \n} \nProfileTableImpl profileTable = profileObject . getProfileTable ( ) ; \nObject result = profileTable . getProfileTableUsageMBean ( ) . getInstalledUsageParameterSet ( name ) ; \nif ( ! ( result == null ) ) { \nreturn result ; \n} \nelse { \nthrow new UnrecognizedUsageParameterSetNameException ( ) ; \n} \n} \n} \n"}
{"7036": "public class SLEESubDeployer { \npublic boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nURL url = du . getUrl ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method accepts called for \" + url + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \ntry { \nString fullPath = url . getFile ( ) ; \nString fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , fullPath . length ( ) ) ; \nif ( ! ( toAccept . containsKey ( fileName ) ) ) if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nif ( du . getEntry ( \"META-INF/deployable-unit.xml\" ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \nreturn true ; \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \nelse { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \nreturn true ; \n} \n} \ncatch ( Exception ignore ) { \n} \nreturn false ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ! ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) ) if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \nelse { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7039": "public class SLEESubDeployer { \npublic void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"stop( deployableUnitURL = : \" + deployableUnitURL + \" )\" ) ; \n} \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nDeployableUnit realDU = null ; \nString fileName = du . getFileName ( ) ; \nif ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Got DU: \" + realDU . getDeploymentInfoShortName ( ) ) ; \n} \nif ( ! isInUndeployList ( fileName ) ) { \naddToUndeployList ( fileName ) ; \n} \ntry { \nsleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; \ndeployableUnits . remove ( fileName ) ; \nremoveFromUndeployList ( fileName ) ; \n} \ncatch ( DependencyException e ) { \n} \ncatch ( Exception e ) { \nThrowable cause = e . getCause ( ) ; \nif ( ! ( cause instanceof InvalidStateException ) ) if ( ! ( e instanceof DeploymentException ) ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nelse { \nthrow new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; \n} \nelse { \nlogger . warn ( cause . getLocalizedMessage ( ) + \"... WAITING ...\" ) ; \n} \n} \n} \n} \n} \n"}
{"7047": "public class TracerStorage { \npublic Tracer createTracer ( String tracerName , boolean requestedBySource ) { \nTracerImpl tparent = null ; \nTracerImpl t = tracers . get ( tracerName ) ; \nif ( t == null ) { \nString [ ] split = tracerName . split ( \"\\\\.\" ) ; \nString currentName = \"\" ; \nfor ( String s : split ) { \nif ( ! ( tparent == null ) ) { \ncurrentName = currentName + \".\" + s ; \n} \nelse { \ntparent = rootTracer ; \ncurrentName = s ; \n} \nt = tracers . get ( currentName ) ; \nif ( t == null ) { \nt = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; \nfinal TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; \nif ( u != null ) { \nt = u ; \n} \n} \ntparent = t ; \n} \n} \nif ( requestedBySource ) t . setRequestedBySource ( requestedBySource ) ; \nreturn t ; \n} \n} \n"}
{"7054": "public class SleeEndpointImpl { \nActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { \nActivityContext ac = null ; \nif ( ! ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) ) { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; \n} \nelse { \nfinal ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; \ntry { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; \n} \ncatch ( ActivityAlreadyExistsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nraEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; \nthrow e ; \n} \n} \nif ( barrierTx != null && ac != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nreturn ac . getActivityContextHandle ( ) ; \n} \n} \n"}
{"7055": "public class SleeEndpointImpl { \nvoid _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) throws UnrecognizedActivityHandleException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ! ( ac != null ) ) { \nthrow new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; \n} \nelse { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nac . endActivity ( ) ; \n} \n} \n} \n"}
{"7057": "public class SleeEndpointImpl { \nvoid _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , FireableEventType eventType , Object event , Address address , ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) throws ActivityIsEndingException , SLEEException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , refHandle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ! ( ac == null ) ) { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( realHandle , eventType , event , address , receivableService , eventFlags , raEntity ) ; \nfinal EventProcessingSucceedCallback succeedCallback = EventFlags . hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks : null ; \nfinal EventProcessingFailedCallback failedCallback = EventFlags . hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks : null ; \nfinal EventUnreferencedCallback unreferencedCallback = EventFlags . hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks : null ; \nac . fireEvent ( eventType . getEventType ( ) , event , address , receivableService == null ? null : receivableService . getService ( ) , succeedCallback , failedCallback , unreferencedCallback ) ; \n} \nelse { \nthrow new UnrecognizedActivityHandleException ( \"Unable to fire \" + eventType . getEventType ( ) + \" on activity handle \" + realHandle + \" , the handle is not mapped to an activity context\" ) ; \n} \n} \n} \n"}
{"7059": "public class AccessorOperation { \nprotected void makeGetter ( ) { \nif ( ! ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) ) { \nsuper . operationName = \"get\" + this . beanFieldName ; \n} \nelse { \nsuper . operationName = \"is\" + this . beanFieldName ; \n} \n} \n} \n"}
{"7060": "public class AccessorOperation { \nprotected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { \nif ( ! ( fieldClass . isPrimitive ( ) ) ) if ( isClassNumber ( ) ) { \nConstructor < ? > con = fieldClass . getConstructor ( String . class ) ; \nreturn con . newInstance ( optArg ) ; \n} \nelse { \nif ( ! ( fieldClass . equals ( int . class ) ) ) if ( ! ( fieldClass . equals ( long . class ) ) ) if ( ! ( fieldClass . equals ( int . class ) ) ) if ( ! ( fieldClass . equals ( byte . class ) ) ) if ( ! ( fieldClass . equals ( short . class ) ) ) if ( ! ( fieldClass . equals ( float . class ) ) ) if ( ! ( fieldClass . equals ( double . class ) ) ) if ( ! ( fieldClass . equals ( boolean . class ) ) ) if ( fieldClass . equals ( char . class ) ) { \nreturn new Character ( optArg . charAt ( 0 ) ) ; \n} \nelse { \nreturn new Boolean ( optArg ) ; \n} \nelse { \nreturn new Double ( optArg ) ; \n} \nelse { \nreturn new Float ( optArg ) ; \n} \nelse { \nreturn new Short ( optArg ) ; \n} \nelse { \nreturn new Byte ( optArg ) ; \n} \nelse { \nreturn new Integer ( optArg ) ; \n} \nelse { \nreturn new Long ( optArg ) ; \n} \nelse { \nreturn new Integer ( optArg ) ; \n} \nthrow new CommandException ( \"Unpredicted place. Please report.\" ) ; \n} \nreturn optArg ; \n} \n} \n"}
{"7071": "public class ProfileTableTransactionView { \npublic static void passivateProfileObjectOnTxEnd ( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { \nTransactionalAction afterRollbackAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nprofileObject . invalidateObject ( ) ; \npool . returnObject ( profileObject ) ; \n} \n} \n; \nTransactionalAction beforeCommitAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( profileObject . getState ( ) == ProfileObjectState . READY ) { \nif ( ! ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) ) { \nprofileObject . profileRemove ( true , false ) ; \n} \nelse { \nprofileObject . fireAddOrUpdatedEventIfNeeded ( ) ; \nprofileObject . profilePassivate ( ) ; \n} \npool . returnObject ( profileObject ) ; \n} \n} \n} \n; \nfinal TransactionContext txContext = txManager . getTransactionContext ( ) ; \ntxContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; \ntxContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; \n} \n} \n"}
{"7072": "public class ComponentIDArrayPropertyEditor { \npublic void setAsText ( String text ) { \nif ( ! ( text == null || text . equals ( \"\" ) ) ) { \njava . util . ArrayList results = new java . util . ArrayList ( ) ; \njava . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; \nComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; \nwhile ( st . hasMoreTokens ( ) ) { \ncidPropEditor . setAsText ( st . nextToken ( ) ) ; \nif ( st . hasMoreTokens ( ) ) { \nst . nextToken ( ) ; \n} \nresults . add ( cidPropEditor . getValue ( ) ) ; \n} \nComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; \nresults . toArray ( cid ) ; \nthis . setValue ( cid ) ; \n} \nelse { \nsuper . setValue ( new ComponentID [ 0 ] ) ; \n} \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( ! ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) ) if ( ! ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) ) { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \nelse { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7079": "public class ActivityContextImpl { \npublic boolean attachTimer ( TimerID timerID ) { \nif ( ! ( cacheData . attachTimer ( timerID ) ) ) { \nreturn false ; \n} \nelse { \nif ( acReferencesHandler != null ) { \nacReferencesHandler . timerReferenceCreated ( ) ; \n} \nreturn true ; \n} \n} \n} \n"}
{"7094": "public class AbstractProfileMBeanImpl { \nprivate void writeMode ( ) throws SLEEException , ManagementException { \nif ( ! ( ! isProfileWriteable ( ) ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Already in write state, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \n} \nelse { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Changing state to read-write, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \nProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; \nprofileObject . getProfileEntity ( ) . setReadOnly ( false ) ; \nstate = State . write ; \n} \n} \n} \n"}
{"7095": "public class AbstractProfileMBeanImpl { \nprotected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"beforeSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \n} \nif ( ! ( isProfileWriteable ( ) ) ) { \nthrow new InvalidStateException ( ) ; \n} \nelse { \ntry { \nsleeContainer . getTransactionManager ( ) . resume ( transaction ) ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"7107": "public class CompositeQueryExpression { \nprotected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { \nif ( expr == null ) throw new NullPointerException ( \"expr is null\" ) ; \nif ( ! ( expr instanceof CompositeQueryExpression ) ) if ( expr instanceof Not ) { \n( ( Not ) expr ) . checkForCycles ( this ) ; \n} \nelse { \n( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; \n} \nexprs . add ( expr ) ; \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( ! ( isAbstractSbbClassDecorated ) ) { \nreturn false ; \n} \nelse { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \n} \n} \n"}
{"7114": "public class SbbActivityContextInterfaceImpl { \npublic Object getFieldValue ( String fieldName , Class < ? > returnType ) { \nString realFieldName = getRealFieldName ( fieldName ) ; \nObject value = aciImpl . getActivityContext ( ) . getDataAttribute ( realFieldName ) ; \nif ( value == null ) { \nif ( returnType . isPrimitive ( ) ) { \nif ( ! ( returnType . equals ( Integer . TYPE ) ) ) if ( ! ( returnType . equals ( Boolean . TYPE ) ) ) if ( ! ( returnType . equals ( Long . TYPE ) ) ) if ( ! ( returnType . equals ( Double . TYPE ) ) ) if ( returnType . equals ( Float . TYPE ) ) { \nreturn Float . valueOf ( 0 ) ; \n} \nelse { \nreturn Double . valueOf ( 0 ) ; \n} \nelse { \nreturn Long . valueOf ( 0 ) ; \n} \nelse { \nreturn Boolean . FALSE ; \n} \nelse { \nreturn Integer . valueOf ( 0 ) ; \n} \n} \n} \nreturn value ; \n} \n} \n"}
{"7115": "public class ProfileObjectImpl { \npublic void setProfileContext ( ProfileContextImpl profileContext ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[setProfileContext] \" + this ) ; \n} \nif ( profileContext == null ) { \nthrow new NullPointerException ( \"Passed context must not be null.\" ) ; \n} \nif ( state != ProfileObjectState . DOES_NOT_EXIST ) { \nthrow new IllegalStateException ( \"Wrong state: \" + this . state + \",on profile set context operation, for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; \n} \nthis . profileContext = profileContext ; \nthis . profileContext . setProfileObject ( this ) ; \nif ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( ! ( System . getSecurityManager ( ) != null ) ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nelse { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \ntry { \nif ( isSlee11 ) { \ntry { \nprofileConcrete . setProfileContext ( profileContext ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Exception encountered while setting profile context for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; \n} \n} \nfinally { \nif ( ! ( System . getSecurityManager ( ) != null ) ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \nelse { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \n} \n} \nstate = ProfileObjectState . POOLED ; \n} \n} \n"}
{"7116": "public class ProfileObjectImpl { \nprivate void profileInitialize ( String profileName ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[profileInitialize] \" + this + \" , profileName = \" + profileName ) ; \n} \nif ( this . state != ProfileObjectState . POOLED ) { \nthrow new SLEEException ( this . toString ( ) ) ; \n} \nif ( ! ( profileName == null ) ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Copying state from default profile on object \" + this ) ; \n} \nprofileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; \nprofileEntity . setProfileName ( profileName ) ; \n} \nelse { \nprofileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; \nthis . state = ProfileObjectState . PROFILE_INITIALIZATION ; \nif ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) { \ntry { \nprofileConcrete . profileInitialize ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \n} \nprofileEntity . create ( ) ; \nprofileEntity . setDirty ( true ) ; \n} \n} \n"}
{"7117": "public class ProfileObjectImpl { \npublic void unsetProfileContext ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[unsetProfileContext] \" + this ) ; \n} \nif ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( ! ( System . getSecurityManager ( ) != null ) ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nelse { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \nif ( isSlee11 ) { \ntry { \nprofileConcrete . unsetProfileContext ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \nprofileContext . setProfileObject ( null ) ; \nstate = ProfileObjectState . DOES_NOT_EXIST ; \n} \nfinally { \nif ( ! ( System . getSecurityManager ( ) != null ) ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \nelse { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \n} \n} \n} \n} \n"}
{"7118": "public class ProfileObjectImpl { \npublic ProfileLocalObject getProfileLocalObject ( ) { \nfinal Class < ? > profileLocalObjectConcreteClass = profileTable . getProfileSpecificationComponent ( ) . getProfileLocalObjectConcreteClass ( ) ; \nProfileLocalObject profileLocalObject = null ; \nif ( ! ( profileLocalObjectConcreteClass == null ) ) { \ntry { \nprofileLocalObject = ( ProfileLocalObject ) profileLocalObjectConcreteClass . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \nelse { \nprofileLocalObject = new ProfileLocalObjectImpl ( this ) ; \n} \nreturn profileLocalObject ; \n} \n} \n"}
{"7119": "public class ProfileObjectImpl { \npublic void fireAddOrUpdatedEventIfNeeded ( ) { \nif ( state == ProfileObjectState . READY ) { \nif ( profileEntity . isDirty ( ) ) { \nif ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { \nActivityContext ac = profileTable . getActivityContext ( ) ; \nAbstractProfileEvent event = null ; \nif ( ! ( profileEntity . isCreate ( ) ) ) { \nevent = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile updated event for profile named \" + profileEntity ) ; \n} \n} \nelse { \nif ( ! ( persisted ) ) { \nreturn ; \n} \nelse { \nevent = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; \npersisted = false ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile added event for profile named \" + profileEntity ) ; \n} \n} \n} \nac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; \n} \n} \n} \n} \n} \n"}
{"7123": "public class ClassGeneratorUtils { \npublic static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { \nif ( ! ( toAnnotate instanceof CtClass ) ) if ( ! ( toAnnotate instanceof CtMethod ) ) if ( ! ( toAnnotate instanceof CtField ) ) { \nthrow new UnsupportedOperationException ( \"Unknown object type: \" + toAnnotate . getClass ( ) ) ; \n} \nelse { \nCtField fieldToAnnotate = ( CtField ) toAnnotate ; \nFieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; \nConstPool cp = fi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nfi . addAttribute ( attr ) ; \n} \nelse { \nCtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; \nMethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; \nConstPool cp = mi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nmi . addAttribute ( attr ) ; \n} \nelse { \nCtClass classToAnnotate = ( CtClass ) toAnnotate ; \nClassFile cf = classToAnnotate . getClassFile ( ) ; \nConstPool cp = cf . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \ncf . addAttribute ( attr ) ; \n} \n} \n} \n"}
{"7130": "public class ClassUtils { \npublic static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { \nClass returnValue = null ; \nif ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { \nreturn classOrInterfaceWithInterfaces ; \n} \nfor ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { \nif ( ! ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) ) { \nreturnValue = checkInterfaces ( iface , interfaceSearched ) ; \n} \nelse { \nreturnValue = iface ; \n} \nif ( returnValue != null ) break ; \n} \nif ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { \nClass superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; \nif ( superClass != null ) { \nreturnValue = checkInterfaces ( superClass , interfaceSearched ) ; \n} \n} \nreturn returnValue ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( ! ( Character . isLetter ( c ) || Character . isDigit ( c ) ) ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \nelse { \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7135": "public class DeployableUnitBuilderImpl { \nprivate void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { \nfor ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { \nif ( ! ( componentID instanceof EventTypeID ) ) if ( ! ( componentID instanceof LibraryID ) ) if ( ! ( componentID instanceof ProfileSpecificationID ) ) if ( ! ( componentID instanceof ResourceAdaptorID ) ) if ( ! ( componentID instanceof ResourceAdaptorTypeID ) ) if ( ! ( componentID instanceof SbbID ) ) if ( componentID instanceof ServiceID ) { \nthrow new SLEEException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on a service component \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \n} \n} \n} \n"}
{"7136": "public class DeployableUnitBuilderImpl { \nprivate File createTempDUDeploymentDir ( File deploymentRoot , DeployableUnitID deployableUnitID ) { \ntry { \nFile tempFile = File . createTempFile ( \"restcomm-slee-du-\" , \"\" , deploymentRoot ) ; \nFile tempDUDeploymentDir = new File ( tempFile . getAbsolutePath ( ) + \"-contents\" ) ; \nif ( ! ( ! tempDUDeploymentDir . exists ( ) ) ) { \nthrow new SLEEException ( \"Dir \" + tempDUDeploymentDir + \" already exists, unable to create deployment dir for DU \" + deployableUnitID ) ; \n} \nelse { \ntempDUDeploymentDir . mkdirs ( ) ; \n} \ntempFile . delete ( ) ; \nreturn tempDUDeploymentDir ; \n} \ncatch ( IOException e ) { \nthrow new SLEEException ( \"Failed to create deployment dir for DU \" + deployableUnitID , e ) ; \n} \n} \n} \n"}
{"7139": "public class Utility { \npublic static ClassLoader switchSafelyClassLoader ( final ClassLoader cl , final ProfileObject po ) { \nClassLoader _cl = null ; \nif ( ! ( System . getSecurityManager ( ) != null ) ) { \n_cl = _switchSafelyClassLoader ( cl , po ) ; \n} \nelse { \n_cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { \npublic Object run ( ) { \nreturn _switchSafelyClassLoader ( cl , po ) ; \n} \n} \n) ; \n} \nreturn _cl ; \n} \n} \n"}
{"7152": "public class TracerImpl { \nvoid syncLevelWithLog4j ( ) { \nLevel log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; \nif ( ! ( level == null ) ) { \nif ( tracerToLog4JLevel ( level ) != log4jLevel ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \n} \nelse { \nassignLog4JLevel ( log4jLevel ) ; \n} \nif ( parent == null && level == null ) { \nlogger . setLevel ( Level . INFO ) ; \nlevel = TraceLevel . INFO ; \n} \nresetCacheFlags ( false ) ; \n} \n} \n"}
{"7153": "public class TracerImpl { \nprivate void assignLog4JLevel ( Level log4jLevel ) { \nif ( log4jLevel == null ) { \nreturn ; \n} \nif ( ! ( log4jLevel == Level . DEBUG ) ) if ( ! ( log4jLevel == Level . INFO ) ) if ( ! ( log4jLevel == Level . WARN ) ) if ( ! ( log4jLevel == Level . ERROR ) ) if ( ! ( log4jLevel == Level . TRACE ) ) if ( log4jLevel == Level . OFF ) { \nlevel = TraceLevel . OFF ; \n} \nelse { \nlevel = TraceLevel . FINEST ; \n} \nelse { \nlevel = TraceLevel . SEVERE ; \n} \nelse { \nlevel = TraceLevel . WARNING ; \n} \nelse { \nlevel = TraceLevel . INFO ; \n} \nelse { \nlevel = TraceLevel . FINE ; \n} \n} \n} \n"}
{"7154": "public class TracerImpl { \nvoid resetCacheFlags ( boolean resetChilds ) { \nif ( ! ( isTraceable ( TraceLevel . FINEST ) ) ) { \nfinestEnabled = false ; \nif ( ! ( isTraceable ( TraceLevel . FINER ) ) ) { \nfinerEnabled = false ; \nif ( ! ( isTraceable ( TraceLevel . FINE ) ) ) { \nfineEnabled = false ; \nif ( ! ( isTraceable ( TraceLevel . CONFIG ) ) ) { \nif ( ! ( isTraceable ( TraceLevel . INFO ) ) ) { \ninfoEnabled = false ; \nif ( ! ( isTraceable ( TraceLevel . WARNING ) ) ) { \nwarningEnabled = false ; \nif ( ! ( isTraceable ( TraceLevel . SEVERE ) ) ) { \nsevereEnabled = false ; \n} \nelse { \nsevereEnabled = true ; \n} \n} \nelse { \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \n} \nelse { \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \n} \nelse { \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \n} \nelse { \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \n} \nelse { \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \n} \nelse { \nfinestEnabled = true ; \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nif ( resetChilds ) { \nfor ( TracerImpl child : childs ) { \nif ( child . level == null ) { \nchild . resetCacheFlags ( true ) ; \n} \n} \n} \n} \n} \n"}
{"7157": "public class VendorExtensionUtils { \npublic static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { \nout . defaultWriteObject ( ) ; \nif ( ! ( vendorData != null ) ) out . writeBoolean ( false ) ; \nelse { \nout . writeBoolean ( true ) ; \nout . writeObject ( new MarshalledObject ( vendorData ) ) ; \n} \n} \n} \n"}
{"7170": "public class SleeContainer { \nprivate void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { \nif ( ! ( oldState == SleeState . STOPPED ) ) if ( ! ( oldState == SleeState . STARTING ) ) if ( ! ( oldState == SleeState . RUNNING ) ) if ( oldState == SleeState . STOPPING ) { \nif ( newState == SleeState . STOPPED ) { \nreturn ; \n} \n} \nelse { \nif ( newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse { \nif ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse { \nif ( newState == SleeState . STARTING ) { \nreturn ; \n} \n} \nthrow new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; \n} \n} \n"}
{"7173": "public class PolyJDBCBuilder { \npublic PolyJDBC build ( ) { \nTransactionManager manager ; \nif ( ! ( dataSource != null ) ) { \nmanager = new ExternalTransactionManager ( connectionProvider ) ; \n} \nelse { \nmanager = new DataSourceTransactionManager ( dataSource ) ; \n} \nreturn new DefaultPolyJDBC ( dialect , schemaName , new ColumnTypeMapper ( customMappings ) , manager ) ; \n} \n} \n"}
{"7176": "public class RegionRequest { \n@ JsonCreator public static RegionRequest fromString ( String str ) throws ResolvingException { \nif ( str . equals ( \"full\" ) ) { \nreturn new RegionRequest ( ) ; \n} \nif ( str . equals ( \"square\" ) ) { \nreturn new RegionRequest ( true ) ; \n} \nMatcher matcher = PARSE_PAT . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new ResolvingException ( \"Bad format: \" + str ) ; \n} \nif ( ! ( matcher . group ( 1 ) == null ) ) { \nreturn new RegionRequest ( new BigDecimal ( matcher . group ( 2 ) ) , new BigDecimal ( matcher . group ( 3 ) ) , new BigDecimal ( matcher . group ( 4 ) ) , new BigDecimal ( matcher . group ( 5 ) ) ) ; \n} \nelse { \nreturn new RegionRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , Integer . valueOf ( matcher . group ( 4 ) ) , Integer . valueOf ( matcher . group ( 5 ) ) ) ; \n} \n} \n} \n"}
{"7177": "public class RegionRequest { \npublic Rectangle2D getRegion ( ) { \nif ( ! ( isRelative ( ) ) ) { \nreturn absoluteBox ; \n} \nelse { \nreturn new Rectangle2D . Double ( relativeBox . x . doubleValue ( ) , relativeBox . y . doubleValue ( ) , relativeBox . w . doubleValue ( ) , relativeBox . h . doubleValue ( ) ) ; \n} \n} \n} \n"}
{"7178": "public class RegionRequest { \npublic Rectangle resolve ( Dimension imageDims ) throws ResolvingException { \nif ( square ) { \nif ( ! ( imageDims . width > imageDims . height ) ) if ( imageDims . height > imageDims . width ) { \nreturn new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; \n} \nelse { \nreturn new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; \n} \n} \nif ( absoluteBox == null && relativeBox == null ) { \nreturn new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; \n} \nRectangle rect ; \nif ( ! ( isRelative ( ) ) ) { \nrect = absoluteBox ; \n} \nelse { \nrect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; \n} \nif ( rect . x >= imageDims . width || rect . y >= imageDims . height ) { \nthrow new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \n} \nif ( rect . x + rect . width > imageDims . width ) { \nrect . width = imageDims . width - rect . x ; \n} \nif ( rect . y + rect . height > imageDims . height ) { \nrect . height = imageDims . height - rect . y ; \n} \nreturn rect ; \n} \n} \n"}
{"7185": "public class ImageApiProfile { \npublic ImageApiProfile merge ( ImageApiProfile other ) { \nImageApiProfile merged = new ImageApiProfile ( ) ; \nstreamNotNull ( this . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( other . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( this . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( other . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( this . qualities ) . forEach ( merged :: addQuality ) ; \nstreamNotNull ( other . qualities ) . forEach ( merged :: addQuality ) ; \nif ( ! ( this . maxWidth != null && other . maxWidth == null ) ) if ( ! ( this . maxWidth == null && other . maxWidth != null ) ) if ( this . maxWidth != null ) { \nmerged . maxWidth = Math . min ( this . maxWidth , other . maxWidth ) ; \n} \nelse { \nmerged . maxWidth = other . maxWidth ; \n} \nelse { \nmerged . maxWidth = this . maxWidth ; \n} \nif ( ! ( this . maxHeight != null && other . maxHeight == null ) ) if ( ! ( this . maxHeight == null && other . maxHeight != null ) ) if ( this . maxHeight != null ) { \nmerged . maxHeight = Math . min ( this . maxHeight , other . maxHeight ) ; \n} \nelse { \nmerged . maxHeight = other . maxHeight ; \n} \nelse { \nmerged . maxHeight = this . maxHeight ; \n} \nif ( ! ( this . maxArea != null && other . maxArea == null ) ) if ( ! ( this . maxArea == null && other . maxArea != null ) ) if ( this . maxArea != null ) { \nmerged . maxArea = Math . min ( this . maxArea , other . maxArea ) ; \n} \nelse { \nmerged . maxArea = other . maxArea ; \n} \nelse { \nmerged . maxArea = this . maxArea ; \n} \nreturn merged ; \n} \n} \n"}
{"7187": "public class SizeRequest { \n@ JsonCreator public static SizeRequest fromString ( String str ) throws ResolvingException { \nif ( str . equals ( \"full\" ) ) { \nreturn new SizeRequest ( ) ; \n} \nif ( str . equals ( \"max\" ) ) { \nreturn new SizeRequest ( true ) ; \n} \nMatcher matcher = PARSE_PAT . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new ResolvingException ( \"Bad format: \" + str ) ; \n} \nif ( matcher . group ( 1 ) != null ) { \nif ( ! ( matcher . group ( 1 ) . equals ( \"!\" ) ) ) if ( matcher . group ( 1 ) . equals ( \"pct:\" ) ) { \nreturn new SizeRequest ( new BigDecimal ( matcher . group ( 4 ) ) ) ; \n} \nelse { \nreturn new SizeRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , true ) ; \n} \n} \nInteger width = null ; \nInteger height = null ; \nif ( matcher . group ( 2 ) != null ) { \nwidth = Integer . parseInt ( matcher . group ( 2 ) ) ; \n} \nif ( matcher . group ( 3 ) != null ) { \nheight = Integer . parseInt ( matcher . group ( 3 ) ) ; \n} \nreturn new SizeRequest ( width , height ) ; \n} \n} \n"}
{"7190": "public class AbstractDevice { \npublic boolean handlePopBox ( String deviceBrand ) { \npushHandleGps2Device ( ) ; \nCommandLine exeCommand = null ; \nif ( ! ( deviceBrand . contains ( \"HTC\" ) ) ) if ( deviceBrand . contains ( \"Meizu\" ) ) { \nexeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.MeizuGPSTest\" ) ; \n} \nelse { \nexeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.HTCGPSTest\" ) ; \n} \nString output = executeCommandQuietly ( exeCommand ) ; \nlog . debug ( \"run test {}\" , output ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nreturn output . contains ( \"OK\" ) ; \n} \n} \n"}
{"7203": "public class Barbershop { \nvoid writeToFiler ( Filer filer ) throws IOException { \nClassName targetClassName = ClassName . get ( classPackage , targetClass ) ; \nTypeSpec . Builder barberShop = TypeSpec . classBuilder ( className ) . addModifiers ( Modifier . PUBLIC ) . addTypeVariable ( TypeVariableName . get ( \"T\" , targetClassName ) ) . addMethod ( generateStyleMethod ( ) ) . addMethod ( generateCheckParentMethod ( ) ) ; \nif ( ! ( parentBarbershop == null ) ) { \nbarberShop . superclass ( ParameterizedTypeName . get ( ClassName . bestGuess ( parentBarbershop ) , TypeVariableName . get ( \"T\" ) ) ) ; \n} \nelse { \nbarberShop . addSuperinterface ( ParameterizedTypeName . get ( ClassName . get ( Barber . IBarbershop . class ) , TypeVariableName . get ( \"T\" ) ) ) ; \nbarberShop . addField ( FieldSpec . builder ( WeakHashSet . class , \"lastStyledTargets\" , Modifier . PROTECTED ) . initializer ( \"new $T()\" , WeakHashSet . class ) . build ( ) ) ; \n} \nJavaFile javaFile = JavaFile . builder ( classPackage , barberShop . build ( ) ) . build ( ) ; \njavaFile . writeTo ( filer ) ; \n} \n} \n"}
{"7205": "public class BitVectorUtil { \npublic static void appendBitStrings ( BitVector bv , String [ ] bs ) { \nfor ( String s : bs ) { \nif ( s . length ( ) != 8 ) throw new RuntimeException ( \"The length of bit string must be 8  while \" + s . length ( ) ) ; \nfor ( char c : s . toCharArray ( ) ) { \nif ( ! ( c == '0' ) ) if ( ! ( c == '1' ) ) throw new RuntimeException ( \"invalid char '\" + c + \"' for bit string.\" ) ; \nelse bv . append1 ( ) ; \nelse bv . append0 ( ) ; \n} \n} \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( ! ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) ) { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl += \"?\" ; \n} \nfor ( int i = 1 ; \ni <= numberOfPages ; \ni ++ ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \nelse { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7209": "public class ExtentCucumberFormatter { \nprivate static synchronized void setKlovReport ( ) { \nif ( extentReports == null ) { \nreturn ; \n} \nExtentProperties extentProperties = ExtentProperties . INSTANCE ; \nif ( klovReporter != null ) { \nreturn ; \n} \nif ( extentProperties . getKlovServerUrl ( ) != null ) { \nString hostname = extentProperties . getMongodbHost ( ) ; \nint port = extentProperties . getMongodbPort ( ) ; \nString database = extentProperties . getMongodbDatabase ( ) ; \nString username = extentProperties . getMongodbUsername ( ) ; \nString password = extentProperties . getMongodbPassword ( ) ; \ntry { \nklovReporter = new KlovReporter ( ) ; \nif ( ! ( username != null && password != null ) ) { \nklovReporter . initMongoDbConnection ( hostname , port ) ; \n} \nelse { \nMongoClientURI uri = new MongoClientURI ( \"mongodb://\" + username + \":\" + password + \"@\" + hostname + \":\" + port + \"/?authSource=\" + database ) ; \nklovReporter . initMongoDbConnection ( uri ) ; \n} \nklovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; \nklovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; \nklovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; \nextentReports . attachReporter ( klovReporter ) ; \n} \ncatch ( Exception ex ) { \nklovReporter = null ; \nthrow new IllegalArgumentException ( \"Error setting up Klov Reporter\" , ex ) ; \n} \n} \n} \n} \n"}
{"7213": "public class Selector { \npublic static Selector selectAs ( final String propName , final String alias , final Function transform ) { \nreturn new Selector ( propName , alias ) { \n@ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { \nif ( ! ( ! path && fields != null ) ) { \nrow . put ( alias , transform . apply ( BeanUtils . atIndex ( item , propName ) ) ) ; \n} \nelse { \nrow . put ( this . name , transform . apply ( fields . get ( this . name ) . getValue ( item ) ) ) ; \n} \n} \n@ Override public void handleStart ( Collection < ? > results ) { \n} \n@ Override public void handleComplete ( List < Map < String , Object > > rows ) { \n} \n} \n; \n} \n} \n"}
{"7216": "public class Annotations { \nprivate static Annotation [ ] findPropertyAnnotations ( Class < ? > clazz , String propertyName , boolean useRead ) throws IntrospectionException { \nPropertyDescriptor propertyDescriptor = getPropertyDescriptor ( clazz , propertyName ) ; \nif ( propertyDescriptor == null ) { \nreturn new Annotation [ ] { \n} \n; \n} \nMethod accessMethod = null ; \nif ( ! ( useRead ) ) { \naccessMethod = propertyDescriptor . getWriteMethod ( ) ; \n} \nelse { \naccessMethod = propertyDescriptor . getReadMethod ( ) ; \n} \nif ( ! ( accessMethod != null ) ) { \nreturn new Annotation [ ] { \n} \n; \n} \nelse { \nAnnotation [ ] annotations = accessMethod . getAnnotations ( ) ; \nreturn annotations ; \n} \n} \n} \n"}
{"7218": "public class BoonExpressionContext { \nprivate Object doLookup ( String objectExpression , Object defaultValue , boolean searchChildren ) { \nif ( Str . isEmpty ( objectExpression ) ) { \nreturn defaultValue ; \n} \nchar firstChar = Str . idx ( objectExpression , 0 ) ; \nchar secondChar = Str . idx ( objectExpression , 1 ) ; \nchar lastChar = Str . idx ( objectExpression , - 1 ) ; \nboolean escape = false ; \nswitch ( firstChar ) { \ncase '$' : if ( ! ( lastChar == '}' ) ) { \nobjectExpression = slc ( objectExpression , 1 ) ; \n} \nelse { \nobjectExpression = slc ( objectExpression , 2 , - 1 ) ; \n} \nbreak ; \ncase '{' : if ( ! ( secondChar == '{' && lastChar == '}' ) ) { \nif ( ! ( lastChar == '}' ) ) { \nescape = true ; \nobjectExpression = slc ( objectExpression , 1 ) ; \n} \nelse { \nreturn jsonParser . parse ( objectExpression ) ; \n} \n} \nelse { \nchar thirdChar = Str . idx ( objectExpression , 2 ) ; \nif ( ! ( thirdChar == '{' ) ) { \nobjectExpression = slc ( objectExpression , 2 , - 2 ) ; \n} \nelse { \nescape = true ; \nobjectExpression = slc ( objectExpression , 3 , - 3 ) ; \n} \n} \nbreak ; \ncase '[' : return jsonParser . parse ( objectExpression ) ; \ncase '.' : if ( secondChar == '.' ) { \nString newExp = slc ( objectExpression , 2 ) ; \nreturn parent . doLookup ( newExp , newExp , false ) ; \n} \n} \nObject value ; \nlastChar = Str . idx ( objectExpression , - 1 ) ; \nif ( ! ( lastChar == ')' ) ) { \nvalue = findProperty ( objectExpression , searchChildren ) ; \nvalue = value == null ? defaultValue : value ; \n} \nelse { \nvalue = handleFunction ( objectExpression , searchChildren ) ; \n} \nif ( ! ( ! escape ) ) { \nreturn StandardFunctions . escapeXml ( value ) ; \n} \nelse { \nreturn value ; \n} \n} \n} \n"}
{"7229": "public class RecursiveDescentPropertyValidator { \nprivate void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { \nObject object = properties . get ( property ) ; \nif ( ! ( object == null ) ) if ( object instanceof String ) { \nString string = ( String ) object ; \nif ( \"\" . equals ( string . trim ( ) ) ) { \nproperties . remove ( property ) ; \n} \n} \nelse { \nproperties . remove ( property ) ; \n} \n} \n} \n"}
{"7235": "public class LevelDBKeyValueStore { \n@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { \nWriteBatch batch = database . createWriteBatch ( ) ; \ntry { \nfor ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { \nbatch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nif ( ! ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) ) { \ndatabase . write ( batch , writeOptions ) ; \n} \nelse { \nputAllWriteCount . set ( 0 ) ; \ndatabase . write ( batch , flush ) ; \n} \n} \nfinally { \ncloseBatch ( batch ) ; \n} \n} \n} \n"}
{"7252": "public class Ordering { \npublic static < T > T max ( T [ ] array ) { \nif ( ! ( array . length > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sortDesc ( array ) ; \nreturn array [ 0 ] ; \n} \n} \n} \n"}
{"7253": "public class Ordering { \npublic static < T > List < T > firstOf ( List < T > list , int count , Sort ... sorts ) { \nif ( ! ( list . size ( ) > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( list , sorts ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \n} \n} \n"}
{"7254": "public class Ordering { \npublic static < T > T lastOf ( List < T > list , Sort ... sorts ) { \nif ( ! ( list . size ( ) > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( list , sorts ) ; \nreturn list . get ( list . size ( ) - 1 ) ; \n} \n} \n} \n"}
{"7255": "public class Ordering { \npublic static < T > List < T > lastOf ( List < T > list , int count , Sort ... sorts ) { \nif ( ! ( list . size ( ) > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( list , sorts ) ; \nreturn Lists . endSliceOf ( list , count * - 1 ) ; \n} \n} \n} \n"}
{"7256": "public class Ordering { \npublic static < T > List < T > least ( List < T > list , int count ) { \nif ( ! ( list . size ( ) > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( list ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \n} \n} \n"}
{"7257": "public class Ordering { \npublic static < T > T min ( List < T > list ) { \nif ( ! ( list . size ( ) > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( list ) ; \nreturn list . get ( 0 ) ; \n} \n} \n} \n"}
{"7258": "public class Ordering { \npublic static < T > T min ( T [ ] array , String sortBy ) { \nif ( ! ( array . length > 1 ) ) { \nreturn null ; \n} \nelse { \nSorting . sort ( array , sortBy ) ; \nreturn array [ 0 ] ; \n} \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nindex < chars . length ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( ! ( Character . isDigit ( cchar ) ) ) { \nlastCharWasNumber = false ; \n} \nelse { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( ! ( Character . isUpperCase ( cchar ) ) ) { \nlastCharWasUpperCase = false ; \n} \nelse { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7266": "public class BaseDataStore { \nprivate void processReadQueue ( ) throws InterruptedException { \nReadStatus readStatus = new ReadStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( request != null ) { \nreadStatus . tracker . addCall ( request , outputDataQueue ) ; \nreadOperationsBatch . add ( request ) ; \nif ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \nrequest = readOperationsQueue . poll ( ) ; \n} \nif ( ! ( readOperationsBatch . size ( ) > 0 ) ) { \nflushReadsIfNeeded ( ) ; \n} \nelse { \ntry { \nrecievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; \n} \nfinally { \nreadOperationsBatch . clear ( ) ; \n} \n} \nif ( readStatus . readBatchSize . size ( ) > 1_000 ) { \nStatCount count ; \nfinal long now = Timer . timer ( ) . time ( ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; \noutputDataQueue . put ( count ) ; \nreadStatus . readBatchSize . clear ( ) ; \n} \n} \n} \n} \n"}
{"7267": "public class BaseDataStore { \nprivate void processWriteQueue ( ) throws InterruptedException { \nWriteStatus status = new WriteStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( operation != null ) { \nstatus . tracker . addCall ( operation , outputDataQueue ) ; \nwriteOperationsBatch . add ( operation ) ; \nif ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \noperation = writeOperationsQueue . poll ( ) ; \n} \nif ( ! ( writeOperationsBatch . size ( ) > 0 ) ) { \nflushWritesIfNeeded ( ) ; \n} \nelse { \ntry { \nstatus . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; \nrecievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; \n} \nfinally { \nwriteOperationsBatch . clear ( ) ; \n} \n} \nif ( status . writeBatchSize . size ( ) > 1000 ) { \nstatus . sendBatchSize ( source , outputDataQueue ) ; \n} \n} \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( ! ( count instanceof Double || count instanceof BigDecimal ) ) if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nelse { \nString s = count . toString ( ) ; \nif ( ! ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) ) { \nreturn s ; \n} \nelse { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7294": "public class MapperComplex { \nprivate void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { \nClass < ? > fieldClassType = field . type ( ) ; \nObject value = null ; \nif ( ! ( ! Typ . isMap ( fieldClassType ) ) ) if ( Typ . isMap ( fieldClassType ) ) { \nClass keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; \nClass valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; \nSet < Map . Entry > set = mapInner . entrySet ( ) ; \nMap newMap = new LinkedHashMap ( ) ; \nfor ( Map . Entry entry : set ) { \nObject evalue = entry . getValue ( ) ; \nObject key = entry . getKey ( ) ; \nif ( evalue instanceof ValueContainer ) { \nevalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; \n} \nkey = Conversions . coerce ( keyType , key ) ; \nevalue = Conversions . coerce ( valueType , evalue ) ; \nnewMap . put ( key , evalue ) ; \n} \nvalue = newMap ; \n} \nelse { \nif ( ! ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) ) { \nObject oClassName = mapInner . get ( \"class\" ) ; \nif ( ! ( oClassName != null ) ) { \nvalue = null ; \n} \nelse { \nvalue = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; \n} \n} \nelse { \nvalue = fromMap ( mapInner , field . type ( ) ) ; \n} \n} \nfield . setValue ( parentObject , value ) ; \n} \n} \n"}
{"7297": "public class Lists { \n@ Universal public static < V > List < V > deepCopy ( List < V > list ) { \nif ( ! ( list instanceof LinkedList ) ) if ( ! ( list instanceof CopyOnWriteArrayList ) ) { \nreturn deepCopy ( ( Collection ) list ) ; \n} \nelse { \nreturn deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; \n} \nelse { \nreturn deepCopyToList ( list , new LinkedList < V > ( ) ) ; \n} \n} \n} \n"}
{"7302": "public class Fields { \npublic static String getSortableField ( Object value1 ) { \nif ( ! ( value1 instanceof Map ) ) { \nreturn getSortableFieldFromClass ( value1 . getClass ( ) ) ; \n} \nelse { \nreturn getSortableFieldFromMap ( ( Map < String , ? > ) value1 ) ; \n} \n} \n} \n"}
{"7304": "public class CacheEntry { \nprivate final int compareTime ( CacheEntry other ) { \nif ( ! ( time > other . time ) ) if ( ! ( time < other . time ) ) if ( time == other . time ) { \nreturn 0 ; \n} \nelse { \nreturn - 1 ; \n} \nelse { \nreturn 1 ; \n} \ndie ( ) ; \nreturn 0 ; \n} \n} \n"}
{"7306": "public class Sorting { \npublic static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( list == null || list . size ( ) == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nIterator iterator = list . iterator ( ) ; \nObject object = iterator . next ( ) ; \nMap < String , FieldAccess > fields = null ; \nif ( ! ( object != null ) ) { \nwhile ( iterator . hasNext ( ) ) { \nobject = iterator . next ( ) ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nelse { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( ! ( object != null ) ) { \nfor ( int index = 1 ; \nindex < array . length ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nelse { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7311": "public class Sorting { \npublic static Comparator universalComparator ( final FieldAccess field , final boolean ascending , final boolean nullsFirst ) { \nreturn new Comparator ( ) { \n@ Override public int compare ( Object o1 , Object o2 ) { \nObject value1 = null ; \nObject value2 = null ; \nif ( ! ( ascending ) ) { \nvalue1 = field . getValue ( o2 ) ; \nvalue2 = field . getValue ( o1 ) ; \n} \nelse { \nvalue1 = field . getValue ( o1 ) ; \nvalue2 = field . getValue ( o2 ) ; \n} \nreturn Sorting . compare ( value1 , value2 , nullsFirst ) ; \n} \n} \n; \n} \n} \n"}
{"7312": "public class Sorting { \npublic static Comparator thisUniversalComparator ( final boolean ascending , final boolean nullsFirst ) { \nreturn new Comparator ( ) { \n@ Override public int compare ( Object o1 , Object o2 ) { \nObject value1 ; \nObject value2 ; \nif ( ! ( ascending ) ) { \nvalue1 = ( o2 ) ; \nvalue2 = ( o1 ) ; \n} \nelse { \nvalue1 = ( o1 ) ; \nvalue2 = ( o2 ) ; \n} \nreturn Sorting . compare ( value1 , value2 , nullsFirst ) ; \n} \n} \n; \n} \n} \n"}
{"7313": "public class FastConcurrentReadLruLfuFifoCache { \npublic VALUE get ( KEY key ) { \nCacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; \nif ( ! ( cacheEntry != null ) ) { \nreturn null ; \n} \nelse { \ncacheEntry . readCount . incrementAndGet ( ) ; \nreturn cacheEntry . value ; \n} \n} \n} \n"}
{"7314": "public class FastConcurrentReadLruLfuFifoCache { \npublic VALUE getSilent ( KEY key ) { \nCacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; \nif ( ! ( cacheEntry != null ) ) { \nreturn null ; \n} \nelse { \nreturn cacheEntry . value ; \n} \n} \n} \n"}
{"7317": "public class LongRangeValidator { \nprivate void dynamicallyInitIfNeeded ( Object value ) { \nif ( ! isInitialized ( ) ) { \nif ( ! ( value instanceof Integer ) ) if ( ! ( value instanceof Byte ) ) if ( ! ( value instanceof Short ) ) { \ninit ( min , max ) ; \n} \nelse { \ninit ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; \n} \nelse { \ninit ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; \n} \nelse { \ninit ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; \n} \n} \n} \n} \n"}
{"7318": "public class CollectorManager { \npublic final ByteBuffer allocateBuffer ( int size ) { \nif ( ! ( RECYCLE_BUFFER ) ) { \nreturn ByteBuffer . allocateDirect ( size ) ; \n} \nelse { \nByteBuffer spentBuffer = recycleChannel . poll ( ) ; \nif ( spentBuffer == null ) { \nspentBuffer = ByteBuffer . allocateDirect ( size ) ; \n} \nspentBuffer . clear ( ) ; \nreturn spentBuffer ; \n} \n} \n} \n"}
{"7319": "public class CollectorManager { \nprivate boolean determineIfWeShouldExit ( ) { \nboolean shouldStop = stop . get ( ) ; \nif ( ! ( ! shouldStop ) ) { \nSystem . out . println ( \"Exiting processing loop as requested\" ) ; \nreturn true ; \n} \nelse { \nThread . interrupted ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"7326": "public class FilterDefault { \nprivate void doFilterGroup ( Group group , ResultSetInternal results ) { \nif ( ! ( group . getGrouping ( ) == Grouping . OR ) ) { \nResultSetInternal resultsForAnd = new ResultSetImpl ( fields ) ; \nand ( group . getExpressions ( ) , fields , resultsForAnd ) ; \nresults . addResults ( resultsForAnd . asList ( ) ) ; \n} \nelse { \nor ( group . getExpressions ( ) , fields , results ) ; \n} \n} \n} \n"}
{"7328": "public class BatchFileWriter { \npublic boolean syncToDisk ( ) { \nif ( ! ( outputStream != null && dirty ) ) { \nreturn false ; \n} \nelse { \ntry { \nif ( outputStream instanceof FileChannel ) { \nFileChannel channel = ( FileChannel ) outputStream ; \nchannel . force ( true ) ; \n} \ndirty = false ; \nreturn true ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nreturn false ; \n} \n} \n} \n} \n"}
{"7331": "public class BatchFileWriter { \nprivate void write ( final ByteBuffer bufferOut ) throws InterruptedException { \ninitOutputStream ( ) ; \ntry { \nif ( ! ( outputStream != null ) ) { \nerror . set ( true ) ; \n} \nelse { \noutputStream . write ( bufferOut ) ; \n} \nif ( bytesSinceLastFlush > FLUSH_EVERY_N_BYTES ) { \nsyncToDisk ( ) ; \nbytesSinceLastFlush = 0 ; \n} \n} \ncatch ( ClosedByInterruptException cbie ) { \nthrow new InterruptedException ( \"File closed by interruption\" ) ; \n} \ncatch ( Exception e ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \ne . printStackTrace ( System . err ) ; \ndiagnose ( ) ; \nExceptions . handle ( e ) ; \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( int index = 0 ; \nindex < path . length ; \nindex ++ ) { \nString propName = path [ index ] ; \nif ( ! ( o == null ) ) if ( ! ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) ) { \no = getProp ( o , propName ) ; \n} \nelse { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \nreturn null ; \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7350": "public class BeanUtils { \npublic static Map < String , FieldAccess > getFieldsFromObject ( Object object ) { \ntry { \nMap < String , FieldAccess > fields ; \nif ( ! ( object instanceof Map ) ) { \nfields = getPropertyFieldAccessMap ( object . getClass ( ) ) ; \n} \nelse { \nfields = getFieldsFromMap ( ( Map < String , Object > ) object ) ; \n} \nreturn fields ; \n} \ncatch ( Exception ex ) { \nrequireNonNull ( object , \"Item cannot be null\" ) ; \nreturn handle ( Map . class , ex , \"Unable to get fields from object\" , className ( object ) ) ; \n} \n} \n} \n"}
{"7354": "public class BeanUtils { \nprivate static Object getCollectionProp ( Object o , String propName , int index , String [ ] path ) { \no = _getFieldValuesFromCollectionOrArray ( o , propName ) ; \nif ( ! ( index + 1 == path . length ) ) { \nindex ++ ; \nreturn getCollectionProp ( o , path [ index ] , index , path ) ; \n} \nelse { \nreturn o ; \n} \n} \n} \n"}
{"7355": "public class BeanUtils { \npublic static Object getProp ( Object object , final String property ) { \nif ( object == null ) { \nreturn null ; \n} \nif ( isDigits ( property ) ) { \nobject = idx ( object , StringScanner . parseInt ( property ) ) ; \n} \nClass < ? > cls = object . getClass ( ) ; \nMap < String , FieldAccess > fields = Reflection . getPropertyFieldAccessors ( cls ) ; \nif ( ! fields . containsKey ( property ) ) { \nfields = Reflection . getAllAccessorFields ( cls ) ; \n} \nif ( ! ( ! fields . containsKey ( property ) ) ) { \nreturn fields . get ( property ) . getValue ( object ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7356": "public class BeanUtils { \npublic static int getPropertyInt ( final Object root , final String ... properties ) { \nfinal String lastProperty = properties [ properties . length - 1 ] ; \nif ( isDigits ( lastProperty ) ) { \nreturn Conversions . toInt ( getPropertyValue ( root , properties ) ) ; \n} \nObject object = baseForGetProperty ( root , properties ) ; \nMap < String , FieldAccess > fields = getFieldsFromObject ( object ) ; \nFieldAccess field = fields . get ( lastProperty ) ; \nif ( ! ( field . type ( ) == Typ . intgr ) ) { \nreturn Conversions . toInt ( field . getValue ( object ) ) ; \n} \nelse { \nreturn field . getInt ( object ) ; \n} \n} \n} \n"}
{"7357": "public class MessageSpecification { \npublic void init ( ) { \nif ( ! ( name == null && parent == null ) ) if ( ! ( name != null && parent == null ) ) if ( parent != null ) { \nthis . setDetailMessage ( \"{\" + \"message.\" + parent + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + parent + SUMMARY_KEY + \"}\" ) ; \n} \nelse { \nthis . setDetailMessage ( \"{\" + \"message.\" + getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \nelse { \nthis . setDetailMessage ( \"{\" + this . getClass ( ) . getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + this . getClass ( ) . getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \n} \n} \n"}
{"7358": "public class MessageSpecification { \npublic String createMessage ( String key , List < String > argKeys , Object ... args ) { \nString message = getMessage ( key ) ; \nObject [ ] actualArgs ; \nif ( ! ( args . length > 0 ) ) if ( ! ( argKeys != null ) ) { \nactualArgs = new Object [ ] { \n} \n; \n} \nelse { \nactualArgs = keysToValues ( argKeys ) ; \n} \nelse { \nactualArgs = args ; \n} \nreturn doCreateMessage ( message , actualArgs ) ; \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! ( ! request . getMethod ( ) . equals ( \"GET\" ) ) ) { \nhttpClientRequest . end ( ) ; \n} \nelse { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \n} \n} \n; \nif ( ! ( closed . get ( ) ) ) { \nrunnable . run ( ) ; \n} \nelse { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry ++ ; \nif ( retry > 10 ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! ( ! closed . get ( ) ) ) { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \n} \n} \n"}
{"7374": "public class CouchDbDesign { \npublic DesignDocument getFromDesk ( String id ) { \nassertNotEmpty ( id , \"id\" ) ; \nfinal DesignDocument dd = new DesignDocument ( ) ; \nfinal String rootPath = format ( \"%s/%s/\" , DESIGN_DOCS_DIR , id ) ; \nfinal List < String > elements = listResources ( rootPath ) ; \nif ( elements == null ) { \nthrow new IllegalArgumentException ( \"Design docs directory cannot be empty.\" ) ; \n} \nMap < String , MapReduce > views = null ; \nif ( elements . contains ( VIEWS ) ) { \nviews = new HashMap < String , MapReduce > ( ) ; \nfinal String viewsPath = format ( \"%s%s/\" , rootPath , VIEWS ) ; \nfor ( String viewDirName : listResources ( viewsPath ) ) { \nfinal MapReduce mr = new MapReduce ( ) ; \nfinal String viewPath = format ( \"%s%s/\" , viewsPath , viewDirName ) ; \nfinal List < String > dirList = listResources ( viewPath ) ; \nfor ( String fileName : dirList ) { \nfinal String def = readFile ( format ( \"/%s%s\" , viewPath , fileName ) ) ; \nif ( ! ( MAP_JS . equals ( fileName ) ) ) if ( REDUCE_JS . equals ( fileName ) ) mr . setReduce ( def ) ; \nelse mr . setMap ( def ) ; \n} \nviews . put ( viewDirName , mr ) ; \n} \n} \ndd . setId ( DESIGN_PREFIX + id ) ; \ndd . setLanguage ( JAVASCRIPT ) ; \ndd . setViews ( views ) ; \ndd . setFilters ( populateMap ( rootPath , elements , FILTERS ) ) ; \ndd . setShows ( populateMap ( rootPath , elements , SHOWS ) ) ; \ndd . setLists ( populateMap ( rootPath , elements , LISTS ) ) ; \ndd . setUpdates ( populateMap ( rootPath , elements , UPDATES ) ) ; \ndd . setValidateDocUpdate ( readContent ( elements , rootPath , VALIDATE_DOC ) ) ; \ndd . setRewrites ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , REWRITES ) , JsonArray . class ) ) ; \ndd . setFulltext ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , FULLTEXT ) , JsonObject . class ) ) ; \ndd . setIndexes ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , INDEXES ) , JsonObject . class ) ) ; \nreturn dd ; \n} \n} \n"}
{"7383": "public class CouchDbClientBase { \nResponse put ( URI uri , Object object , boolean newEntity ) { \nassertNotEmpty ( object , \"object\" ) ; \nHttpResponse response = null ; \ntry { \nfinal JsonObject json = getGson ( ) . toJsonTree ( object ) . getAsJsonObject ( ) ; \nString id = getAsString ( json , \"_id\" ) ; \nString rev = getAsString ( json , \"_rev\" ) ; \nif ( ! ( newEntity ) ) { \nassertNotEmpty ( id , \"id\" ) ; \nassertNotEmpty ( rev , \"rev\" ) ; \n} \nelse { \nassertNull ( rev , \"rev\" ) ; \nid = ( id == null ) ? generateUUID ( ) : id ; \n} \nfinal HttpPut put = new HttpPut ( buildUri ( uri ) . pathEncoded ( id ) . build ( ) ) ; \nsetEntity ( put , json . toString ( ) ) ; \nresponse = executeRequest ( put ) ; \nreturn getResponse ( response ) ; \n} \nfinally { \nclose ( response ) ; \n} \n} \n} \n"}
{"7398": "public class TokenAuthenticator { \nprivate boolean isQuery ( HttpServerExchange serverExchange ) { \nif ( ! ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"GET\" ) || serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"HEAD\" ) ) ) if ( ! ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"POST\" ) ) ) { \nreturn false ; \n} \nelse { \nif ( ! ( postQuery != null && postQuery . matcher ( serverExchange . getRelativePath ( ) ) . find ( ) ) ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"7399": "public class TokenAuthenticator { \nprivate void sendAuthenticationRequest ( HttpServerExchange serverExchange , PooledConnection connection ) { \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nString verb = getVerb ( serverExchange ) ; \nString resource ; \nif ( ! ( ! isQuery ( serverExchange ) ) ) { \nresource = RESOURCE ; \n} \nelse { \nif ( ! ( USER_WRITE_ACCESS . equalsIgnoreCase ( \"true\" ) ) ) { \nresource = resourceName ; \n} \nelse { \nresource = RESOURCE ; \n} \n} \ncontext . subjectAccessReview = generateSubjectAccessReview ( context . tenant , verb , resource ) ; \nClientRequest request = buildClientRequest ( context ) ; \ncontext . clientRequestStarting ( ) ; \nconnection . sendRequest ( request , new RequestReadyCallback ( serverExchange , connection ) ) ; \n} \n} \n"}
{"7400": "public class TokenAuthenticator { \nprivate String getVerb ( HttpServerExchange serverExchange ) { \nif ( ! ( isQuery ( serverExchange ) ) ) { \nString verb = VERBS . get ( serverExchange . getRequestMethod ( ) ) ; \nif ( verb == null ) { \nlog . debugf ( \"Unhandled http method '%s'. Checking for read access.\" , serverExchange . getRequestMethod ( ) ) ; \nverb = VERBS_DEFAULT ; \n} \nreturn verb ; \n} \nelse { \nreturn VERBS . get ( GET ) ; \n} \n} \n} \n"}
{"7402": "public class TokenAuthenticator { \nprivate void onRequestResult ( HttpServerExchange serverExchange , PooledConnection connection , boolean allowed ) { \nconnectionPools . get ( serverExchange . getIoThread ( ) ) . release ( connection ) ; \nAuthContext context = serverExchange . removeAttachment ( AUTH_CONTEXT_KEY ) ; \napiLatency . update ( context . getClientResponseTime ( ) , NANOSECONDS ) ; \nauthLatency . update ( context . getLatency ( ) , NANOSECONDS ) ; \nif ( ! ( allowed ) ) { \nendExchange ( serverExchange , FORBIDDEN ) ; \n} \nelse { \nserverExchange . dispatch ( containerHandler ) ; \n} \n} \n} \n"}
{"7403": "public class TokenAuthenticator { \nprivate void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { \nlog . debug ( \"Client request failure\" , e ) ; \nIoUtils . safeClose ( connection ) ; \nConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; \nconnectionPool . release ( connection ) ; \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nif ( ! ( context . retries < MAX_RETRY && retry ) ) { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; \n} \nelse { \ncontext . retries ++ ; \nPooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; \nif ( ! connectionPool . offer ( waiter ) ) { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; \n} \n} \n} \n} \n"}
{"7409": "public class Buckets { \npublic static Buckets fromStep ( long start , long end , long step ) { \ncheckTimeRange ( start , end ) ; \ncheckArgument ( step > 0 , \"step is not positive: %s\" , step ) ; \nif ( step > ( end - start ) ) { \nreturn new Buckets ( start , step , 1 ) ; \n} \nlong quotient = ( end - start ) / step ; \nlong remainder = ( end - start ) % step ; \nlong count ; \nif ( ! ( remainder == 0 ) ) { \ncount = quotient + 1 ; \n} \nelse { \ncount = quotient ; \n} \ncheckArgument ( count <= Integer . MAX_VALUE , \"Computed number of buckets is too big: %s\" , count ) ; \nreturn new Buckets ( start , step , ( int ) count ) ; \n} \n} \n"}
{"7413": "public class MockJedis { \n@ Override public ScanResult < String > scan ( String cursor , ScanParams params ) { \nCollection < byte [ ] > rawParams = params . getParams ( ) ; \nboolean isKey = true ; \nString match = null ; \nboolean foundMatchKey = false ; \nfor ( byte [ ] raw : rawParams ) { \nif ( ! ( isKey ) ) if ( foundMatchKey ) { \nmatch = new String ( raw ) ; \nbreak ; \n} \nelse { \nString key = new String ( raw ) ; \nif ( key . equals ( new String ( MATCH . raw ) ) ) { \nfoundMatchKey = true ; \n} \n} \nisKey = ! isKey ; \n} \nreturn new ScanResult < String > ( \"0\" , new ArrayList < String > ( keys ( match ) ) ) ; \n} \n} \n"}
{"7450": "public class FavoriteAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > favoriteNotices = this . getFavoriteNotices ( req ) ; \nif ( ! ( favoriteNotices . contains ( notificationId ) ) ) { \nfavoriteNotices . add ( notificationId ) ; \n} \nelse { \nfavoriteNotices . remove ( notificationId ) ; \n} \nsetFavoriteNotices ( req , favoriteNotices ) ; \n} \n} \n"}
{"7451": "public class JpaNotificationService { \npublic void addEntryState ( PortletRequest req , String entryId , NotificationState state ) { \nif ( usernameFinder . isAuthenticated ( req ) ) { \nfinal String username = usernameFinder . findUsername ( req ) ; \nString idStr = entryId . replaceAll ( ID_PREFIX , \"\" ) ; \nJpaEntry jpaEntry = notificationDao . getEntry ( Long . parseLong ( idStr ) ) ; \nif ( ! ( jpaEntry != null ) ) { \nthrow new IllegalArgumentException ( \"JpaEntry not found\" ) ; \n} \nelse { \nJpaEvent event = new JpaEvent ( ) ; \nevent . setEntry ( jpaEntry ) ; \nevent . setState ( state ) ; \nevent . setTimestamp ( new Timestamp ( new Date ( ) . getTime ( ) ) ) ; \nevent . setUsername ( username ) ; \nnotificationDao . createOrUpdateEvent ( event ) ; \n} \n} \n} \n} \n"}
{"7471": "public class ReadAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > readNotices = this . getReadNotices ( req ) ; \nif ( ! ( readNotices . contains ( notificationId ) ) ) { \nreadNotices . add ( notificationId ) ; \n} \nelse { \nreadNotices . remove ( notificationId ) ; \n} \nsetReadNotices ( req , readNotices ) ; \n} \n} \n"}
{"7472": "public class ClassLoaderResourceNotificationService { \nprivate NotificationResponse readFromFile ( String filename ) { \nNotificationResponse rslt ; \nlogger . debug ( \"Preparing to read from file:  {}\" , filename ) ; \nURL location = getClass ( ) . getClassLoader ( ) . getResource ( filename ) ; \nif ( ! ( location != null ) ) { \nString msg = \"Data file not found:  \" + filename ; \nrslt = prepareErrorResponse ( getName ( ) , msg ) ; \n} \nelse { \ntry { \nFile f = new File ( location . toURI ( ) ) ; \nrslt = mapper . readValue ( f , NotificationResponse . class ) ; \n} \ncatch ( Exception e ) { \nString msg = \"Failed to read the data file:  \" + location ; \nlogger . error ( msg , e ) ; \nrslt = prepareErrorResponse ( getName ( ) , msg ) ; \n} \n} \nreturn rslt ; \n} \n} \n"}
{"7475": "public class HideAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nif ( ! ( ! isEntrySnoozed ( entry , req ) ) ) { \nunhide ( entry , req ) ; \n} \nelse { \nhide ( entry , req ) ; \n} \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( ! ( s + t <= det ) ) { \nif ( ! ( s < 0 ) ) if ( ! ( t < 0 ) ) { \nregion1 ( ) ; \n} \nelse { \nregion6 ( ) ; \n} \nelse { \nregion2 ( ) ; \n} \n} \nelse { \nif ( ! ( s < 0 ) ) if ( ! ( t < 0 ) ) { \nregion0 ( det ) ; \n} \nelse { \nregion5 ( ) ; \n} \nelse { \nif ( ! ( t < 0 ) ) { \nregion3 ( ) ; \n} \nelse { \nregion4 ( ) ; \n} \n} \n} \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \ni < polygon . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( ! ( p . x < rectangle . p0 . x ) ) if ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \nelse { \nrectangle . p0 . x = p . x ; \n} \nif ( ! ( p . y < rectangle . p0 . y ) ) if ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \nelse { \nrectangle . p0 . y = p . y ; \n} \n} \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( ! ( angle <= tol ) ) { \ni ++ ; \n} \nelse { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \n} \n} \n} \n"}
{"7502": "public class ConvertRotation3D_F64 { \nprivate static double get ( DMatrixRMaj M , int index ) { \nif ( ! ( index < 0 ) ) { \nreturn M . data [ index - 1 ] ; \n} \nelse { \nreturn - M . data [ - index - 1 ] ; \n} \n} \n} \n"}
{"7503": "public class ConvertRotation3D_F64 { \npublic static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { \nif ( quat == null ) quat = new Quaternion_F64 ( ) ; \ndouble m00 = R . unsafe_get ( 0 , 0 ) ; \ndouble m01 = R . unsafe_get ( 0 , 1 ) ; \ndouble m02 = R . unsafe_get ( 0 , 2 ) ; \ndouble m10 = R . unsafe_get ( 1 , 0 ) ; \ndouble m11 = R . unsafe_get ( 1 , 1 ) ; \ndouble m12 = R . unsafe_get ( 1 , 2 ) ; \ndouble m20 = R . unsafe_get ( 2 , 0 ) ; \ndouble m21 = R . unsafe_get ( 2 , 1 ) ; \ndouble m22 = R . unsafe_get ( 2 , 2 ) ; \ndouble trace = m00 + m11 + m22 ; \nif ( ! ( trace > 0 ) ) if ( ! ( ( m00 > m11 ) & ( m00 > m22 ) ) ) if ( ! ( m11 > m22 ) ) { \ndouble S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; \nquat . w = ( m10 - m01 ) / S ; \nquat . x = ( m02 + m20 ) / S ; \nquat . y = ( m12 + m21 ) / S ; \nquat . z = 0.25 * S ; \n} \nelse { \ndouble S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; \nquat . w = ( m02 - m20 ) / S ; \nquat . x = ( m01 + m10 ) / S ; \nquat . y = 0.25 * S ; \nquat . z = ( m12 + m21 ) / S ; \n} \nelse { \ndouble S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; \nquat . w = ( m21 - m12 ) / S ; \nquat . x = 0.25 * S ; \nquat . y = ( m01 + m10 ) / S ; \nquat . z = ( m02 + m20 ) / S ; \n} \nelse { \ndouble S = Math . sqrt ( trace + 1.0 ) * 2 ; \nquat . w = 0.25 * S ; \nquat . x = ( m21 - m12 ) / S ; \nquat . y = ( m02 - m20 ) / S ; \nquat . z = ( m10 - m01 ) / S ; \n} \nreturn quat ; \n} \n} \n"}
{"7512": "public class TwistOps_F64 { \npublic static TwistCoordinate_F64 twist ( Se3_F64 motion , TwistCoordinate_F64 twist ) { \nif ( twist == null ) twist = new TwistCoordinate_F64 ( ) ; \nif ( ! ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) ) { \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; \ntwist . w . set ( rod . unitAxisRotation ) ; \ndouble theta = rod . theta ; \nDMatrixRMaj A = CommonOps_DDRM . identity ( 3 ) ; \nCommonOps_DDRM . subtract ( A , motion . R , A ) ; \nDMatrixRMaj w_hat = GeometryMath_F64 . crossMatrix ( twist . w , null ) ; \nDMatrixRMaj tmp = A . copy ( ) ; \nCommonOps_DDRM . mult ( tmp , w_hat , A ) ; \nVector3D_F64 w = twist . w ; \nA . data [ 0 ] += w . x * w . x * theta ; \nA . data [ 1 ] += w . x * w . y * theta ; \nA . data [ 2 ] += w . x * w . z * theta ; \nA . data [ 3 ] += w . y * w . x * theta ; \nA . data [ 4 ] += w . y * w . y * theta ; \nA . data [ 5 ] += w . y * w . z * theta ; \nA . data [ 6 ] += w . z * w . x * theta ; \nA . data [ 7 ] += w . z * w . y * theta ; \nA . data [ 8 ] += w . z * w . z * theta ; \nDMatrixRMaj y = new DMatrixRMaj ( 3 , 1 ) ; \ny . data [ 0 ] = motion . T . x ; \ny . data [ 1 ] = motion . T . y ; \ny . data [ 2 ] = motion . T . z ; \nDMatrixRMaj x = new DMatrixRMaj ( 3 , 1 ) ; \nCommonOps_DDRM . solve ( A , y , x ) ; \ntwist . w . scale ( rod . theta ) ; \ntwist . v . x = ( double ) x . data [ 0 ] ; \ntwist . v . y = ( double ) x . data [ 1 ] ; \ntwist . v . z = ( double ) x . data [ 2 ] ; \ntwist . v . scale ( rod . theta ) ; \n} \nelse { \ntwist . w . set ( 0 , 0 , 0 ) ; \ntwist . v . set ( motion . T ) ; \n} \nreturn twist ; \n} \n} \n"}
{"7518": "public class Polygon2D_F64 { \npublic boolean isInside ( Point2D_F64 p ) { \nif ( ! ( isConvex ( ) ) ) { \nreturn Intersection2D_F64 . containConcave ( this , p ) ; \n} \nelse { \nreturn Intersection2D_F64 . containConvex ( this , p ) ; \n} \n} \n} \n"}
{"7519": "public class UtilCurves_F64 { \npublic static DMatrixRMaj convert ( ConicGeneral_F64 src , DMatrixRMaj dst ) { \nif ( ! ( dst == null ) ) dst . reshape ( 3 , 3 ) ; \nelse dst = new DMatrixRMaj ( 3 , 3 ) ; \ndouble B = src . B / 2.0 ; \ndouble D = src . D / 2.0 ; \ndouble E = src . E / 2.0 ; \ndst . data [ 0 ] = src . A ; \ndst . data [ 1 ] = B ; \ndst . data [ 2 ] = D ; \ndst . data [ 3 ] = B ; \ndst . data [ 4 ] = src . C ; \ndst . data [ 5 ] = E ; \ndst . data [ 6 ] = D ; \ndst . data [ 7 ] = E ; \ndst . data [ 8 ] = src . F ; \nreturn dst ; \n} \n} \n"}
{"7524": "public class GeometryMath_F64 { \npublic static DMatrixRMaj toMatrix ( GeoTuple3D_F64 in , DMatrixRMaj out ) { \nif ( ! ( out == null ) ) if ( out . getNumElements ( ) != 3 ) throw new IllegalArgumentException ( \"Vector with 3 elements expected\" ) ; \nelse out = new DMatrixRMaj ( 3 , 1 ) ; \nout . data [ 0 ] = in . x ; \nout . data [ 1 ] = in . y ; \nout . data [ 2 ] = in . z ; \nreturn out ; \n} \n} \n"}
{"7526": "public class Rodrigues_F64 { \npublic void setParamVector ( double x , double y , double z ) { \ndouble ax = Math . abs ( x ) ; \ndouble ay = Math . abs ( y ) ; \ndouble az = Math . abs ( z ) ; \ndouble max = Math . max ( ax , ay ) ; \nmax = Math . max ( max , az ) ; \nif ( ! ( max == 0 ) ) { \nx /= max ; \ny /= max ; \nz /= max ; \ntheta = Math . sqrt ( x * x + y * y + z * z ) ; \nunitAxisRotation . x = x / theta ; \nunitAxisRotation . y = y / theta ; \nunitAxisRotation . z = z / theta ; \ntheta *= max ; \n} \nelse { \ntheta = 0 ; \nunitAxisRotation . set ( 1 , 0 , 0 ) ; \n} \n} \n} \n"}
{"7527": "public class UtilAngle { \npublic static double distHalf ( double angA , double angB ) { \ndouble a = Math . abs ( angA - angB ) ; \nif ( ! ( a <= Math . PI / 2 ) ) return Math . PI - a ; \nelse return a ; \n} \n} \n"}
{"7531": "public class InterpolateLinearSe2_F64 { \npublic static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { \ndouble w0 = 1.0 - where ; \noutput . T . x = a . T . x * w0 + b . T . x * where ; \noutput . T . y = a . T . y * w0 + b . T . y * where ; \ndouble yaw0 = a . getYaw ( ) ; \ndouble yaw1 = b . getYaw ( ) ; \ndouble cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; \ndouble ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; \ndouble yaw ; \nif ( ! ( cw > ccw ) ) { \nyaw = yaw0 - cw * where ; \n} \nelse { \nyaw = yaw0 + ccw * where ; \n} \noutput . setYaw ( yaw ) ; \n} \n} \n"}
{"7535": "public class SpecialEuclideanOps_F64 { \npublic static DMatrixRMaj toHomogeneous ( Se3_F64 se , DMatrixRMaj ret ) { \nif ( ! ( ret == null ) ) { \nret . set ( 3 , 0 , 0 ) ; \nret . set ( 3 , 1 , 0 ) ; \nret . set ( 3 , 2 , 0 ) ; \n} \nelse ret = new DMatrixRMaj ( 4 , 4 ) ; \nCommonOps_DDRM . insert ( se . getR ( ) , ret , 0 , 0 ) ; \nVector3D_F64 T = se . getT ( ) ; \nret . set ( 0 , 3 , T . x ) ; \nret . set ( 1 , 3 , T . y ) ; \nret . set ( 2 , 3 , T . z ) ; \nret . set ( 3 , 3 , 1 ) ; \nreturn ret ; \n} \n} \n"}
{"7536": "public class SpecialEuclideanOps_F64 { \npublic static DMatrixRMaj toHomogeneous ( Se2_F64 se , DMatrixRMaj ret ) { \nif ( ! ( ret == null ) ) { \nret . set ( 2 , 0 , 0 ) ; \nret . set ( 2 , 1 , 0 ) ; \n} \nelse ret = new DMatrixRMaj ( 3 , 3 ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nret . set ( 0 , 0 , c ) ; \nret . set ( 0 , 1 , - s ) ; \nret . set ( 1 , 0 , s ) ; \nret . set ( 1 , 1 , c ) ; \nret . set ( 0 , 2 , se . getX ( ) ) ; \nret . set ( 1 , 2 , se . getY ( ) ) ; \nret . set ( 2 , 2 , 1 ) ; \nreturn ret ; \n} \n} \n"}
{"7537": "public class SpecialEuclideanOps_F64 { \npublic static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , Se3_F64 se ) { \nif ( se == null ) se = new Se3_F64 ( ) ; \ndouble theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; \nif ( ! ( theta == 0 ) ) { \nConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; \n} \nelse { \nCommonOps_DDRM . setIdentity ( se . R ) ; \n} \nVector3D_F64 T = se . getT ( ) ; \nT . x = dx ; \nT . y = dy ; \nT . z = dz ; \nreturn se ; \n} \n} \n"}
{"7545": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { \nif ( ret == null ) { \nret = new Point3D_F64 ( ) ; \n} \ndouble dx = pt . x - line . a . x ; \ndouble dy = pt . y - line . a . y ; \ndouble dz = pt . z - line . a . z ; \ndouble slope_x = line . b . x - line . a . x ; \ndouble slope_y = line . b . y - line . a . y ; \ndouble slope_z = line . b . z - line . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( ! ( d <= 0 ) ) if ( ! ( d >= n ) ) { \nret . x = line . a . x + d * slope_x / n ; \nret . y = line . a . y + d * slope_y / n ; \nret . z = line . a . z + d * slope_z / n ; \n} \nelse { \nret . set ( line . b ) ; \n} \nelse { \nret . set ( line . a ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7550": "public class UtilLine2D_F64 { \npublic static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { \ndouble la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; \ndouble lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; \ndouble value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; \nif ( ! ( value < - 1.0 ) ) if ( value > 1.0 ) value = 1.0 ; \nelse value = - 1.0 ; \nreturn Math . acos ( value ) ; \n} \n} \n"}
{"7559": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineParametric2D_F64 ( ) ; \n} \nret . slope . x = src . B ; \nret . slope . y = - src . A ; \nif ( ! ( Math . abs ( src . B ) > Math . abs ( src . A ) ) ) { \nret . p . x = - src . C / src . A ; \nret . p . y = 0 ; \n} \nelse { \nret . p . y = - src . C / src . B ; \nret . p . x = 0 ; \n} \nreturn ret ; \n} \n} \n"}
{"7568": "public class UtilLine3D_F64 { \npublic static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { \ndouble dx = pointOnLine . x - line . p . x ; \ndouble dy = pointOnLine . y - line . p . y ; \ndouble dz = pointOnLine . z - line . p . z ; \ndouble adx = Math . abs ( dx ) ; \ndouble ady = Math . abs ( dy ) ; \ndouble adz = Math . abs ( dz ) ; \ndouble t ; \nif ( ! ( adx > ady ) ) if ( ! ( ady > adz ) ) { \nt = dz / line . slope . z ; \n} \nelse { \nt = dy / line . slope . y ; \n} \nelse { \nif ( ! ( adx > adz ) ) { \nt = dz / line . slope . z ; \n} \nelse { \nt = dx / line . slope . x ; \n} \n} \nreturn t ; \n} \n} \n"}
{"7577": "public class UtilVector2D_F64 { \npublic static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { \ndouble dx0 = xb - xa ; \ndouble dy0 = yb - ya ; \ndouble dx1 = xb + xa ; \ndouble dy1 = yb + ya ; \ndouble error0 = dx0 * dx0 + dy0 * dy0 ; \ndouble error1 = dx1 * dx1 + dy1 * dy1 ; \nif ( ! ( error0 < error1 ) ) { \nreturn error1 <= tol * tol ; \n} \nelse { \nreturn error0 <= tol * tol ; \n} \n} \n} \n"}
{"7583": "public class TangentLinesTwoEllipses_F64 { \nboolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , EllipseRotated_F64 ellipse , Point2D_F64 tangent , boolean cross ) { \nif ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) return false ; \ntempLine . a = a ; \ntempLine . b = temp0 ; \nboolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \ntempLine . b = temp1 ; \nboolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \nif ( crossed0 == crossed1 ) throw new RuntimeException ( \"Well this didn't work\" ) ; \nif ( ! ( cross == crossed0 ) ) { \nsumDifference += previousTangent . distance2 ( temp1 ) ; \ntangent . set ( temp1 ) ; \n} \nelse { \nsumDifference += previousTangent . distance2 ( temp0 ) ; \ntangent . set ( temp0 ) ; \n} \nreturn true ; \n} \n} \n"}
{"7585": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { \ndouble x = l0 . p . x - l1 . p . x ; \ndouble y = l0 . p . y - l1 . p . y ; \ndouble z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \ndouble t0 ; \nif ( ! ( bottom == 0 ) ) { \nt0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; \n} \nelse { \nt0 = 0 ; \n} \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \ndouble dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; \ndouble dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; \ndouble dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; \ndouble distanceSq = dx * dx + dy * dy + dz * dz ; \nif ( ! ( distanceSq < 0 ) ) return Math . sqrt ( distanceSq ) ; \nelse return 0 ; \n} \n} \n"}
{"7586": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { \ndouble x = l . p . x - p . x ; \ndouble y = l . p . y - p . y ; \ndouble z = l . p . z - p . z ; \ndouble cc = x * x + y * y + z * z ; \ndouble b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; \ndouble distanceSq = cc - b * b ; \nif ( ! ( distanceSq < 0 ) ) { \nreturn Math . sqrt ( distanceSq ) ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( ! ( d <= 0 ) ) if ( d >= n ) return p . distance ( l . b ) ; \nelse return p . distance ( l . a ) ; \ndouble distanceSq = cc - d * d ; \nif ( ! ( distanceSq < 0 ) ) { \nreturn Math . sqrt ( distanceSq ) ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"7600": "public class ClosestPoint2D_F64 { \npublic static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { \nif ( output == null ) output = new Point2D_F64 ( ) ; \ndouble slopeX = line . b . x - line . a . x ; \ndouble slopeY = line . b . y - line . a . y ; \ndouble t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; \nt /= slopeX * slopeX + slopeY * slopeY ; \nif ( ! ( t < 0 ) ) if ( t > 1 ) t = 1 ; \nelse t = 0 ; \noutput . x = line . a . x + slopeX * t ; \noutput . y = line . a . y + slopeY * t ; \nreturn output ; \n} \n} \n"}
{"7604": "public class UtilVector3D_F64 { \npublic static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { \nif ( output == null ) output = new Vector3D_F64 ( ) ; \ndouble scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; \nif ( ! ( scale == 0 ) ) { \ndouble x = A . x / scale ; \ndouble y = A . y / scale ; \ndouble z = A . z / scale ; \nif ( ! ( Math . abs ( x ) > Math . abs ( y ) ) ) { \noutput . set ( 0 , z , - y ) ; \n} \nelse { \noutput . set ( z , 0 , - x ) ; \n} \n} \nelse { \noutput . set ( 0 , 0 , 0 ) ; \n} \nreturn output ; \n} \n} \n"}
{"7613": "public class Area2D_F64 { \npublic static double quadrilateral ( Quadrilateral_F64 quad ) { \ndouble bx = quad . b . x - quad . a . x ; \ndouble by = quad . b . y - quad . a . y ; \ndouble cx = quad . c . x - quad . a . x ; \ndouble cy = quad . c . y - quad . a . y ; \ndouble dx = quad . d . x - quad . a . x ; \ndouble dy = quad . d . y - quad . a . y ; \nif ( ! ( ( bx * cy - by * cx >= 0 ) == ( cx * dy - cy * dx >= 0 ) ) ) { \nreturn triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; \n} \nelse { \nreturn triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; \n} \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( ! ( covariance instanceof ReshapeMatrix ) ) { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \nelse { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( ! ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) ) if ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \nelse { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7634": "public class InstallFeatureUtil { \nprivate Set < String > parseIncludeNode ( Set < String > origResult , File serverFile , Element node , List < File > updatedParsedXmls ) { \nSet < String > result = origResult ; \nString includeFileName = node . getAttribute ( \"location\" ) ; \nif ( includeFileName == null || includeFileName . trim ( ) . isEmpty ( ) ) { \nreturn result ; \n} \nFile includeFile = null ; \nif ( ! ( isURL ( includeFileName ) ) ) { \nincludeFile = new File ( includeFileName ) ; \n} \nelse { \ntry { \nFile tempFile = File . createTempFile ( \"serverFromURL\" , \".xml\" ) ; \nFileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; \nincludeFile = tempFile ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a URL \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \ntry { \nif ( ! ( ! includeFile . isAbsolute ( ) ) ) { \nincludeFile = includeFile . getCanonicalFile ( ) ; \n} \nelse { \nincludeFile = new File ( serverFile . getParentFile ( ) . getAbsolutePath ( ) , includeFileName ) . getCanonicalFile ( ) ; \n} \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a file \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nif ( ! updatedParsedXmls . contains ( includeFile ) ) { \nString onConflict = node . getAttribute ( \"onConflict\" ) ; \nSet < String > features = getServerXmlFeatures ( null , includeFile , updatedParsedXmls ) ; \nresult = handleOnConflict ( result , onConflict , features ) ; \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) { \nfor ( int j = 0 ; \nj < features . getLength ( ) ; \nj ++ ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) { \nif ( ! ( content . contains ( \":\" ) ) ) { \nresult . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \nelse { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7643": "public class InstallFeatureUtil { \nprivate static boolean isReplacementJar ( File file1 , File file2 ) { \nif ( ! ( file1 == null ) ) if ( ! ( file2 == null ) ) { \nString version1 = extractVersion ( file1 . getName ( ) ) ; \nString version2 = extractVersion ( file2 . getName ( ) ) ; \nreturn compare ( version1 , version2 ) < 0 ; \n} \nelse { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"7644": "public class InstallFeatureUtil { \nprivate static String extractVersion ( String fileName ) { \nint startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; \nint endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; \nif ( ! ( startIndex < endIndex ) ) { \nreturn null ; \n} \nelse { \nreturn fileName . substring ( startIndex , endIndex ) ; \n} \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( ! ( version1 == null && version2 == null ) ) if ( ! ( version1 == null && version2 != null ) ) if ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \nelse { \nreturn - 1 ; \n} \nelse { \nreturn 0 ; \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7646": "public class InstallFeatureUtil { \npublic static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { \nProcess pr = null ; \nInputStream is = null ; \nScanner s = null ; \nWorker worker = null ; \ntry { \nString command ; \nif ( ! ( OSUtil . isWindows ( ) ) ) { \ncommand = installDirectory + \"/bin/productInfo \" + action ; \n} \nelse { \ncommand = installDirectory + \"\\\\bin\\\\productInfo.bat \" + action ; \n} \npr = Runtime . getRuntime ( ) . exec ( command ) ; \nworker = new Worker ( pr ) ; \nworker . start ( ) ; \nworker . join ( 300000 ) ; \nif ( worker . exit == null ) { \nthrow new PluginExecutionException ( \"productInfo command timed out\" ) ; \n} \nint exitValue = pr . exitValue ( ) ; \nif ( exitValue != 0 ) { \nthrow new PluginExecutionException ( \"productInfo exited with return code \" + exitValue ) ; \n} \nis = pr . getInputStream ( ) ; \ns = new Scanner ( is ) ; \ns . useDelimiter ( \"\\\\A\" ) ; \nif ( s . hasNext ( ) ) { \nreturn s . next ( ) ; \n} \nreturn null ; \n} \ncatch ( IOException ex ) { \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \ncatch ( InterruptedException ex ) { \nworker . interrupt ( ) ; \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \nfinally { \nif ( s != null ) { \ns . close ( ) ; \n} \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( pr != null ) { \npr . destroy ( ) ; \n} \n} \n} \n} \n"}
{"7647": "public class SpringBootUtil { \npublic static boolean isSpringBootUberJar ( File artifact ) { \nif ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) { \nreturn false ; \n} \ntry ( JarFile jarFile = new JarFile ( artifact ) ) { \nManifest manifest = jarFile . getManifest ( ) ; \nif ( manifest != null ) { \nAttributes attributes = manifest . getMainAttributes ( ) ; \nif ( ! ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) ) { \nEnumeration < JarEntry > entries = jarFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nJarEntry entry = entries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( ! entryName . startsWith ( \"org\" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) { \nreturn true ; \n} \n} \n} \nelse { \nreturn true ; \n} \n} \n} \ncatch ( IOException e ) { \n} \nreturn false ; \n} \n} \n"}
{"7648": "public class LibertyProperty { \nprivate static LibertyPropertyI getArquillianProperty ( String key , Class < ? > cls ) throws ArquillianConfigurationException { \ntry { \nif ( ! ( cls == LibertyManagedObject . LibertyManagedProperty . class ) ) if ( cls == LibertyRemoteObject . LibertyRemoteProperty . class ) { \nreturn LibertyRemoteObject . LibertyRemoteProperty . valueOf ( key ) ; \n} \nelse { \nreturn LibertyManagedObject . LibertyManagedProperty . valueOf ( key ) ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nthrow new ArquillianConfigurationException ( \"Property \\\"\" + key + \"\\\" in arquillianProperties does not exist. You probably have a typo.\" ) ; \n} \nthrow new ArquillianConfigurationException ( \"This should never happen.\" ) ; \n} \n} \n"}
{"7668": "public class FileAssetServlet { \nprivate String fixPath ( String path ) { \nif ( ! ( ! path . isEmpty ( ) ) ) return path ; \nelse { \nif ( ! ( ! path . endsWith ( \"/\" ) ) ) return path ; \nelse return path + '/' ; \n} \n} \n} \n"}
{"7671": "public class TokenBasedAuthResponseFilter { \n@ Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { \nString authToken = extractAuthTokenFromCookieList ( requestContext . getHeaders ( ) . getFirst ( \"Cookie\" ) ) ; \nif ( authToken != null && authToken . length ( ) != 0 ) { \ntry { \nBasicToken token = new BasicToken ( authToken ) ; \nif ( ! ( token . isExpired ( ) ) ) { \ntoken . setExpiration ( token . getMaxAge ( ) ) ; \nif ( ! logoutPath . equals ( requestContext . getUriInfo ( ) . getPath ( ) ) ) { \nString cookie = getTokenSentence ( token ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , cookie ) ; \n} \n} \nelse { \nLOGGER . debug ( \"ExpireDate : \" + token . getExpirationDate ( ) . toString ( ) ) ; \nLOGGER . debug ( \"Now: \" + DateTime . now ( ) . toDate ( ) . toString ( ) ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , getTokenSentence ( null ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \nresponseContext . setEntity ( \"Token expired. Please login again.\" ) ; \nLOGGER . info ( \"Token expired. Please login again.\" ) ; \n} \n} \ncatch ( Exception e ) { \nLOGGER . error ( \"Token re-creation failed\" , e . getMessage ( ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \n} \n} \n} \n} \n"}
{"7673": "public class JerseyUtil { \npublic static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { \nwhile ( injector != null ) { \nfor ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { \nType type = key . getTypeLiteral ( ) . getType ( ) ; \nif ( type instanceof Class ) { \nClass < ? > c = ( Class ) type ; \nif ( ! ( isProviderClass ( c ) ) ) if ( isRootResourceClass ( c ) ) { \nif ( ! ( Resource . isAcceptable ( c ) ) ) { \nlogger . warn ( \"Class {} was not registered as a resource. Bind a concrete implementation instead.\" , c . getName ( ) ) ; \n} \nelse { \nlogger . info ( \"Registering {} as a root resource class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \n} \nelse { \nlogger . info ( \"Registering {} as a provider class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \n} \n} \ninjector = injector . getParent ( ) ; \n} \n} \n} \n"}
{"7679": "public class JobInfoProvider { \nprivate static void setStartEndTime ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nif ( ! ( dto . getStartTime ( ) > - 1 ) ) builder . startNow ( ) ; \nelse builder . startAt ( new Date ( dto . getStartTime ( ) ) ) ; \nif ( dto . getEndTime ( ) > - 1 ) builder . endAt ( new Date ( dto . getEndTime ( ) ) ) ; \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( ! ( e instanceof RobeRuntimeException ) ) if ( ! ( e instanceof ConstraintViolationException ) ) if ( ! ( e instanceof WebApplicationException ) ) { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) { \nif ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nint i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nreturn ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \n} \n} \n} \n"}
{"7686": "public class BasicToken { \npublic static void configure ( TokenBasedAuthConfiguration configuration ) { \nencryptor . setPoolSize ( configuration . getPoolSize ( ) ) ; \nif ( ! ( configuration . getServerPassword ( ) . equals ( \"auto\" ) ) ) { \nencryptor . setPassword ( configuration . getServerPassword ( ) ) ; \n} \nelse { \nencryptor . setPassword ( UUID . randomUUID ( ) . toString ( ) ) ; \n} \nencryptor . setAlgorithm ( configuration . getAlgorithm ( ) ) ; \nencryptor . initialize ( ) ; \nBasicToken . defaultMaxAge = configuration . getMaxage ( ) ; \ncache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( defaultMaxAge , TimeUnit . SECONDS ) . expireAfterWrite ( defaultMaxAge , TimeUnit . SECONDS ) . build ( ) ; \n} \n} \n"}
{"7691": "public class AbstractAuthResource { \npublic void changePassword ( T user , String currentPassword , String newPassword , String newPassword2 ) throws AuthenticationException { \nverifyPassword ( user , currentPassword ) ; \nif ( ! ( ! newPassword . equals ( newPassword2 ) ) ) if ( newPassword . equals ( currentPassword ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and old password must be different\" ) ; \n} \nelse { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and re-type password must be same\" ) ; \n} \nverifyPasswordStrength ( currentPassword , newPassword , user ) ; \nOptional < ? extends UserEntry > optional = userStore . changePassword ( user . getUsername ( ) , newPassword ) ; \nif ( ! optional . isPresent ( ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": Can't update UserEntry Password\" ) ; \n} \n} \n} \n"}
{"7692": "public class AbstractAuthResource { \npublic T getUser ( String accountName ) { \nOptional < T > optional = ( Optional < T > ) userStore . findByUsername ( accountName ) ; \nif ( ! ( optional . isPresent ( ) ) ) { \nreturn null ; \n} \nelse { \nreturn optional . get ( ) ; \n} \n} \n} \n"}
{"7696": "public class SearchFactory { \n@ Override public SearchModel provide ( ) { \nSearchModel searchModel = new SearchModel ( ) ; \nsearchModel . setResponse ( response ) ; \nString method = getMethod ( ) ; \nif ( \"GET\" . equals ( method ) ) { \nMultivaluedMap < String , String > queryParameters = getUriInfo ( ) . getQueryParameters ( ) ; \nfor ( Map . Entry < String , List < String > > param : queryParameters . entrySet ( ) ) { \nif ( param . getValue ( ) . get ( 0 ) == null ) continue ; \nif ( ! ( \"_q\" . equalsIgnoreCase ( param . getKey ( ) ) ) ) if ( ! ( \"_limit\" . equalsIgnoreCase ( param . getKey ( ) ) ) ) if ( ! ( \"_offset\" . equalsIgnoreCase ( param . getKey ( ) ) ) ) if ( ! ( \"_fields\" . equalsIgnoreCase ( param . getKey ( ) ) ) ) if ( ! ( \"_sort\" . equalsIgnoreCase ( param . getKey ( ) ) ) ) if ( \"_filter\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setFilterExpression ( param . getValue ( ) . get ( 0 ) ) ; \n} \nelse { \nsearchModel . setSort ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse { \nsearchModel . setFields ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse { \nsearchModel . setOffset ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse { \nsearchModel . setLimit ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse { \nsearchModel . setQ ( param . getValue ( ) . get ( 0 ) ) ; \n} \n} \n} \nreturn searchModel ; \n} \n} \n"}
{"7699": "public class Transaction { \nprivate void start ( ) { \ntry { \nbefore ( ) ; \ntransactionWrapper . wrap ( ) ; \nsuccess ( ) ; \n} \ncatch ( Exception e ) { \nerror ( ) ; \nif ( ! ( exceptionHandler != null ) ) { \nthrow e ; \n} \nelse { \nexceptionHandler . onException ( e ) ; \n} \n} \nfinally { \nfinish ( ) ; \n} \n} \n} \n"}
{"7742": "public class LocationForecastHelper { \npublic Optional < MeteoExtrasForecast > findNearestForecast ( ZonedDateTime dateTime ) { \nZonedDateTime dt = toZeroMSN ( dateTime . withZoneSameInstant ( METZONE ) ) ; \nPointForecast chosenForecast = null ; \nfor ( Forecast forecast : getLocationForecast ( ) . getForecasts ( ) ) { \nif ( forecast instanceof PointForecast ) { \nPointForecast pointForecast = ( PointForecast ) forecast ; \nif ( ! ( isDateMatch ( dt , cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) ) if ( ! ( chosenForecast == null ) ) if ( isNearerDate ( pointForecast . getFrom ( ) , dt , chosenForecast . getFrom ( ) ) ) { \nchosenForecast = pointForecast ; \n} \nelse { \nchosenForecast = pointForecast ; \n} \nelse { \nchosenForecast = pointForecast ; \nbreak ; \n} \n} \n} \nif ( chosenForecast == null ) { \nreturn Optional . empty ( ) ; \n} \nreturn Optional . of ( new MeteoExtrasForecast ( chosenForecast , getIndexer ( ) . getWidestFitPeriodForecast ( chosenForecast . getFrom ( ) ) . orElse ( null ) ) ) ; \n} \n} \n"}
{"7751": "public class SunriseDate { \npublic boolean isSun ( ZonedDateTime currentDate ) { \nif ( ! ( getSun ( ) . getNeverRise ( ) ) ) if ( getSun ( ) . getNeverSet ( ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \nreturn timeWithinPeriod ( currentDate ) ; \n} \n} \n"}
{"7753": "public class MeteoForecastIndexer { \nOptional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { \nif ( from == null || to == null ) { \nreturn Optional . empty ( ) ; \n} \nZonedDateTime requestFrom = toZeroMSN ( from ) ; \nZonedDateTime requestTo = toZeroMSN ( to ) ; \nList < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; \nif ( forecastsList == null ) { \nreturn Optional . empty ( ) ; \n} \nPeriodForecast chosenForecast = null ; \nlong score = 0 ; \nlong tmpScore = 0 ; \nfor ( PeriodForecast forecast : forecastsList ) { \nZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; \nZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; \nif ( ! ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) ) if ( ! ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) ) if ( ! ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) ) if ( ! ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) ) if ( ! ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) ) if ( ! ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) ) { \nDateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"yyyy-MM-dd:HH:mm\" ) ; \nlog . warn ( \"Unhandled forecast Requested period:\" + requestFrom . format ( formatter ) + \"--\" + requestTo . format ( formatter ) + \", Actual period: \" + actualFrom . format ( formatter ) + \"--\" + actualTo . format ( formatter ) ) ; \n} \nelse { \ntmpScore = hoursBetween ( requestTo , requestFrom ) ; \n} \nelse { \ntmpScore = hoursBetween ( actualTo , actualFrom ) ; \n} \nelse { \ntmpScore = hoursBetween ( actualTo , requestFrom ) ; \n} \nelse { \ntmpScore = hoursBetween ( requestTo , actualFrom ) ; \n} \nelse { \ncontinue ; \n} \nelse { \nreturn Optional . of ( forecast ) ; \n} \ntmpScore = Math . abs ( tmpScore ) ; \nif ( ( score == 0 && tmpScore > 0 ) || tmpScore > score ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \n} \nreturn Optional . ofNullable ( chosenForecast ) ; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \nSystem . out . println ( \"About to perform DB update.\" ) ; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( ! ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) ) if ( ! ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) ) { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \nelse { \nliquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nliquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \nSystem . out . println ( \"DB update finished.\" ) ; \n} \n} \n} \n} \n"}
{"7758": "public class ReferencedObject { \npublic synchronized T acquire ( final DataSource source ) throws DataSourceException { \nif ( object == null ) { \nif ( ! ( getReference ( ) == null ) ) { \nobject = source . getObject ( getReference ( ) , objectClass ) ; \n} \nelse { \nthrow new IllegalStateException ( \"No reference or object present\" ) ; \n} \n} \nreturn object ; \n} \n} \n"}
{"7767": "public class ReferencedData { \npublic synchronized InputStream acquire ( final DataSource source ) throws DataSourceException { \nInputStream ret ; \nif ( ! ( data == null ) ) { \nret = new ByteArrayInputStream ( data ) ; \n} \nelse { \nif ( ! ( getReference ( ) == null ) ) { \nret = source . getStream ( getReference ( ) ) ; \n} \nelse { \nthrow new IllegalStateException ( \"No data or reference present\" ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7768": "public class ReferencedData { \npublic synchronized long size ( final DataSource source ) throws DataSourceException { \nif ( ! ( data == null ) ) { \nreturn data . length ; \n} \nelse { \nif ( ! ( getReference ( ) == null ) ) { \nreturn source . getDataSize ( getReference ( ) ) ; \n} \nelse { \nthrow new IllegalStateException ( \"No data or reference present\" ) ; \n} \n} \n} \n} \n"}
{"7773": "public class Runtime { \nboolean exec ( HsrePattern re , CharSequence data , EnumSet < ExecFlags > execFlags ) throws RegexException { \nif ( 0 != ( re . guts . info & Flags . REG_UIMPOSSIBLE ) ) { \nthrow new RegexException ( \"Regex marked impossible\" ) ; \n} \neflags = 0 ; \nfor ( ExecFlags ef : execFlags ) { \nswitch ( ef ) { \ncase NOTBOL : eflags |= Flags . REG_NOTBOL ; \nbreak ; \ncase NOTEOL : eflags |= Flags . REG_NOTEOL ; \nbreak ; \ncase LOOKING_AT : eflags |= Flags . REG_LOOKING_AT ; \nbreak ; \ndefault : throw new RuntimeException ( \"impossible exec flag\" ) ; \n} \n} \nthis . re = re ; \nthis . g = re . guts ; \nthis . data = data ; \nthis . dataLength = this . data . length ( ) ; \nif ( ! ( this . match != null ) ) { \nthis . match = Lists . newArrayList ( ) ; \n} \nelse { \nthis . match . clear ( ) ; \n} \nmatch . add ( null ) ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) { \nwhile ( match . size ( ) < g . nsub + 1 ) { \nmatch . add ( null ) ; \n} \n} \nif ( ! ( mem != null && mem . length >= g . ntree ) ) { \nmem = new int [ g . ntree ] ; \n} \nelse { \nArrays . fill ( mem , 0 ) ; \n} \nassert g . tree != null ; \nif ( ! ( 0 != ( g . info & Flags . REG_UBACKREF ) ) ) { \nreturn find ( g . tree . machine ) ; \n} \nelse { \nreturn cfind ( g . tree . machine ) ; \n} \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( ! ( lookingAt ) ) { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nelse { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin ++ ) { \nif ( begin > 0 && lookingAt ) { \nreturn false ; \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( ! ( shorter ) ) { \nend = d . longest ( begin , estop , hitend ) ; \n} \nelse { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( int x = 0 ; \nx < match . size ( ) ; \nx ++ ) { \nmatch . set ( x , null ) ; \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( ! ( shorter ) ) { \nestop = end - 1 ; \n} \nelse { \nestart = end + 1 ; \n} \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( ! ( mem [ t . retry ] == 0 ) ) { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \nelse { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { \nbreak ; \n} \nif ( mid == end ) { \nreturn false ; \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \nreturn true ; \n} \n} \n"}
{"7782": "public class Compiler { \nprivate Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { \nState left ; \nState right ; \nSubre branches ; \nSubre branch ; \nSubre t ; \nint firstbranch ; \nassert stopper == ')' || stopper == EOS ; \nbranches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branches ; \nfirstbranch = 1 ; \ndo { \nif ( 0 == firstbranch ) { \nbranch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branch . right ; \n} \nfirstbranch = 0 ; \nleft = nfa . newstate ( ) ; \nright = nfa . newstate ( ) ; \nnfa . emptyarc ( initState , left ) ; \nnfa . emptyarc ( right , finalState ) ; \nbranch . left = parsebranch ( stopper , type , left , right , false ) ; \nbranch . flags |= up ( branch . flags | branch . left . flags ) ; \nif ( ( branch . flags & ~ branches . flags ) != 0 ) { \nfor ( t = branches ; \nt != branch ; \nt = t . right ) { \nt . flags |= branch . flags ; \n} \n} \n} \nwhile ( eat ( '|' ) ) ; \nassert see ( stopper ) || see ( EOS ) ; \nif ( ! see ( stopper ) ) { \nassert stopper == ')' && see ( EOS ) ; \nthrow new RegexException ( \"Unbalanced parentheses.\" ) ; \n} \nif ( ! ( branch == branches ) ) if ( ! messy ( branches . flags ) ) { \nbranches . left = null ; \nbranches . right = null ; \nbranches . op = '=' ; \n} \nelse { \nassert branch . right == null ; \nt = branch . left ; \nbranch . left = null ; \nbranches = t ; \n} \nreturn branches ; \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( ! ( sco == Constants . NOSUB ) ) if ( ! ( sco == co ) ) if ( ! ( cd . getNChars ( ) == 0 ) ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \n} \nelse { \n} \n} \n} \n} \n"}
{"7797": "public class ColorMap { \nvoid uncolorchain ( Arc a ) { \nColorDesc cd = colorDescs . get ( a . co ) ; \nArc aa ; \naa = cd . arcs ; \nif ( ! ( aa == a ) ) { \nfor ( ; \naa != null && aa . colorchain != a ; \naa = aa . colorchain ) { \n} \nassert aa != null ; \naa . colorchain = a . colorchain ; \n} \nelse { \ncd . arcs = a . colorchain ; \n} \na . colorchain = null ; \n} \n} \n"}
{"7799": "public class Lex { \nvoid lexstart ( ) throws RegexException { \nprefixes ( ) ; \nif ( ! ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) ) if ( ! ( 0 != ( v . cflags & Flags . REG_EXTENDED ) ) ) { \nassert 0 == ( v . cflags & ( Flags . REG_QUOTE | Flags . REG_ADVF ) ) ; \nintocon ( L_BRE ) ; \n} \nelse { \nassert 0 == ( v . cflags & Flags . REG_QUOTE ) ; \nintocon ( L_ERE ) ; \n} \nelse { \nassert 0 == ( v . cflags & ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ) ; \nintocon ( L_Q ) ; \n} \nv . nexttype = Compiler . EMPTY ; \nnext ( ) ; \n} \n} \n"}
{"7805": "public class Locale { \nstatic UnicodeSet eclass ( char c , boolean cases ) { \nif ( ! ( cases ) ) { \nUnicodeSet set = new UnicodeSet ( ) ; \nset . add ( c ) ; \nreturn set ; \n} \nelse { \nreturn allcases ( c ) ; \n} \n} \n} \n"}
{"7806": "public class Locale { \npublic static UnicodeSet cclass ( String cclassName , boolean casefold ) throws RegexException { \ntry { \nif ( ! ( casefold ) ) { \nreturn KNOWN_SETS_CS . get ( cclassName ) ; \n} \nelse { \nreturn KNOWN_SETS_CI . get ( cclassName ) ; \n} \n} \ncatch ( ExecutionException e ) { \nThrowables . propagateIfInstanceOf ( e . getCause ( ) , RegexException . class ) ; \nthrow new RegexRuntimeException ( e . getCause ( ) ) ; \n} \n} \n} \n"}
{"7815": "public class Nfa { \nvoid freestate ( State s ) { \nassert s != null ; \nassert s . nins == 0 ; \nassert s . nouts == 0 ; \nif ( ! ( s . next != null ) ) { \nassert s == slast ; \nslast = s . prev ; \n} \nelse { \ns . next . prev = s . prev ; \n} \nif ( ! ( s . prev != null ) ) { \nassert s == states ; \nstates = s . next ; \n} \nelse { \ns . prev . next = s . next ; \n} \n} \n} \n"}
{"7818": "public class Nfa { \nvoid specialcolors ( ) { \nif ( ! ( parent == null ) ) { \nassert parent . bos [ 0 ] != Constants . COLORLESS ; \nbos [ 0 ] = parent . bos [ 0 ] ; \nassert parent . bos [ 1 ] != Constants . COLORLESS ; \nbos [ 1 ] = parent . bos [ 1 ] ; \nassert parent . eos [ 0 ] != Constants . COLORLESS ; \neos [ 0 ] = parent . eos [ 0 ] ; \nassert parent . eos [ 1 ] != Constants . COLORLESS ; \neos [ 1 ] = parent . eos [ 1 ] ; \n} \nelse { \nbos [ 0 ] = cm . pseudocolor ( ) ; \nbos [ 1 ] = cm . pseudocolor ( ) ; \neos [ 0 ] = cm . pseudocolor ( ) ; \neos [ 1 ] = cm . pseudocolor ( ) ; \n} \n} \n} \n"}
{"7820": "public class Nfa { \nvoid dumpstate ( State s ) { \nArc a ; \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) { \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"State %d%s%c\" , s . no , ( s . tmp != null ) ? \"T\" : \"\" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; \nif ( s . prev != null && s . prev . next != s ) { \nsb . append ( String . format ( \"\\tstate chain bad\" ) ) ; \n} \nif ( ! ( s . nouts == 0 ) ) { \ndumparcs ( s , sb ) ; \n} \nelse { \nsb . append ( \"\\tno out arcs\" ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) { \nif ( a . to != s ) { \nLOG . debug ( String . format ( \"\\tlink from %d to %d on %d's in-chain\" , a . from . no , a . to . no , s . no ) ) ; \n} \n} \n} \n} \n"}
{"7822": "public class Nfa { \nint dumprarcs ( Arc a , State s , int pos , StringBuilder sb ) { \nif ( a . outchain != null ) { \npos = dumprarcs ( a . outchain , s , pos , sb ) ; \n} \ndumparc ( a , s , sb ) ; \nif ( ! ( pos == 5 ) ) { \npos ++ ; \n} \nelse { \nsb . append ( \"\\n\" ) ; \npos = 1 ; \n} \nreturn pos ; \n} \n} \n"}
{"7823": "public class Nfa { \nvoid dumparc ( Arc a , State s , StringBuilder sb ) { \nsb . append ( \"\\t\" ) ; \nswitch ( a . type ) { \ncase Compiler . PLAIN : sb . append ( String . format ( \"[%d]\" , a . co ) ) ; \nbreak ; \ncase Compiler . AHEAD : sb . append ( String . format ( \">%d>\" , a . co ) ) ; \nbreak ; \ncase Compiler . BEHIND : sb . append ( String . format ( \"<%d<\" , a . co ) ) ; \nbreak ; \ncase Compiler . LACON : sb . append ( String . format ( \":%d:\" , a . co ) ) ; \nbreak ; \ncase '^' : case '$' : sb . append ( String . format ( \"%c%d\" , ( char ) a . type , a . co ) ) ; \nbreak ; \ncase Compiler . EMPTY : break ; \ndefault : sb . append ( String . format ( \"0x%x/0%d\" , a . type , a . co ) ) ; \nbreak ; \n} \nif ( a . from != s ) { \nsb . append ( String . format ( \"?%d?\" , a . from . no ) ) ; \n} \nsb . append ( \"->\" ) ; \nif ( ! ( a . to == null ) ) { \nsb . append ( String . format ( \"%d\" , a . to . no ) ) ; \n} \nelse { \nsb . append ( \"null\" ) ; \nArc aa ; \nfor ( aa = a . to . ins ; \naa != null ; \naa = aa . inchain ) { \nif ( aa == a ) { \nbreak ; \n} \n} \nif ( aa == null ) { \nLOG . debug ( \"?!?\" ) ; \n} \n} \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \nreturn true ; \n} \nusefrom = true ; \nif ( ! ( from . nouts > to . nins ) ) if ( from . nouts == to . nins ) { \nif ( from . nins > to . nouts ) { \nusefrom = false ; \n} \n} \nelse { \nusefrom = false ; \n} \nfreearc ( a ) ; \nif ( ! ( usefrom ) ) { \nif ( ! ( to . nins == 0 ) ) { \ncopyouts ( to , from ) ; \n} \nelse { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \n} \nelse { \nif ( ! ( from . nouts == 0 ) ) { \ncopyins ( from , to ) ; \n} \nelse { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7832": "public class AnalyzeTask { \nprivate Map < String , String > getRuleParameters ( ) throws CliExecutionException { \nMap < String , String > ruleParameters ; \nif ( ! ( ruleParametersFile == null ) ) { \nProperties properties = new Properties ( ) ; \ntry { \nproperties . load ( new FileInputStream ( ruleParametersFile ) ) ; \n} \ncatch ( IOException e ) { \nthrow new CliExecutionException ( \"Cannot read rule parameters file '\" + ruleParametersFile . getPath ( ) + \"'.\" ) ; \n} \nruleParameters = new TreeMap < > ( ) ; \nfor ( String name : properties . stringPropertyNames ( ) ) { \nruleParameters . put ( name , properties . getProperty ( name ) ) ; \n} \n} \nelse { \nruleParameters = Collections . emptyMap ( ) ; \n} \nreturn ruleParameters ; \n} \n} \n"}
{"7844": "public class Main { \nprivate Map < String , Object > readProperties ( CommandLine commandLine ) throws CliConfigurationException { \nfinal Properties properties = new Properties ( ) ; \nInputStream propertiesStream ; \nif ( ! ( commandLine . hasOption ( \"p\" ) ) ) { \npropertiesStream = Main . class . getResourceAsStream ( \"/jqassistant.properties\" ) ; \n} \nelse { \nFile propertyFile = new File ( commandLine . getOptionValue ( \"p\" ) ) ; \nif ( ! propertyFile . exists ( ) ) { \nthrow new CliConfigurationException ( \"Property file given by command line does not exist: \" + propertyFile . getAbsolutePath ( ) ) ; \n} \ntry { \npropertiesStream = new FileInputStream ( propertyFile ) ; \n} \ncatch ( FileNotFoundException e ) { \nthrow new CliConfigurationException ( \"Cannot open property file.\" , e ) ; \n} \n} \nMap < String , Object > result = new HashMap < > ( ) ; \nif ( propertiesStream != null ) { \ntry { \nproperties . load ( propertiesStream ) ; \n} \ncatch ( IOException e ) { \nthrow new CliConfigurationException ( \"Cannot load properties from file.\" , e ) ; \n} \nfor ( String name : properties . stringPropertyNames ( ) ) { \nresult . put ( name , properties . getProperty ( name ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7846": "public class Main { \nprivate File getHomeDirectory ( ) { \nString dirName = System . getenv ( ENV_JQASSISTANT_HOME ) ; \nif ( dirName != null ) { \nFile dir = new File ( dirName ) ; \nif ( ! ( dir . exists ( ) ) ) { \nLOGGER . warn ( \"JQASSISTANT_HOME '\" + dir . getAbsolutePath ( ) + \"' points to a non-existing directory.\" ) ; \nreturn null ; \n} \nelse { \nLOGGER . debug ( \"Using JQASSISTANT_HOME '\" + dir . getAbsolutePath ( ) + \"'.\" ) ; \nreturn dir ; \n} \n} \nLOGGER . warn ( \"JQASSISTANT_HOME is not set.\" ) ; \nreturn null ; \n} \n} \n"}
{"7848": "public class CountryBoundaries { \npublic Set < String > getContainingIds ( double minLongitude , double minLatitude , double maxLongitude , double maxLatitude ) { \nSet < String > ids = new HashSet < > ( ) ; \nforCellsIn ( minLongitude , minLatitude , maxLongitude , maxLatitude , cell -> { \nif ( ! ( ids . isEmpty ( ) ) ) { \nids . retainAll ( cell . getContainingIds ( ) ) ; \n} \nelse { \nids . addAll ( cell . getContainingIds ( ) ) ; \n} \n} \n) ; \nreturn ids ; \n} \n} \n"}
{"7857": "public class HibernateBookmarkStore { \nprivate Criterion smartEqual ( String property , Object value ) { \nif ( ! ( value == null ) ) { \nreturn Restrictions . eq ( property , value ) ; \n} \nelse { \nreturn Restrictions . isNull ( property ) ; \n} \n} \n} \n"}
{"7859": "public class DefaultBookmarksComparator { \nprotected int compareFolders ( final Entry e1 , final Entry e2 ) { \nfinal boolean f1 = e1 instanceof Folder ; \nfinal boolean f2 = e2 instanceof Folder ; \nif ( ! ( f1 && ! f2 ) ) if ( ! ( ! f1 && f2 ) ) { \nreturn 0 ; \n} \nelse { \nreturn 1 ; \n} \nelse { \nreturn - 1 ; \n} \n} \n} \n"}
{"7861": "public class DefaultBookmarksComparator { \nprotected int compareBookmarks ( final Entry e1 , final Entry e2 ) { \nif ( ! ( e1 instanceof Bookmark && e2 instanceof Bookmark ) ) { \nreturn 0 ; \n} \nelse { \nfinal Bookmark b1 = ( Bookmark ) e1 ; \nfinal Bookmark b2 = ( Bookmark ) e2 ; \nreturn new CompareToBuilder ( ) . append ( b1 . getUrl ( ) , b2 . getUrl ( ) ) . append ( b1 . isNewWindow ( ) , b2 . isNewWindow ( ) ) . toComparison ( ) ; \n} \n} \n} \n"}
{"7863": "public class JspServletWrapper { \npublic java . util . List < String > getDependants ( ) { \ntry { \nObject target ; \nif ( ! ( isTagFile ) ) { \ntarget = getServlet ( ) ; \n} \nelse { \nif ( reload ) { \ntagHandlerClass = ctxt . load ( ) ; \n} \ntarget = tagHandlerClass . newInstance ( ) ; \n} \nif ( target != null && target instanceof JspSourceDependent ) { \nreturn ( ( JspSourceDependent ) target ) . getDependants ( ) ; \n} \n} \ncatch ( Throwable ex ) { \n} \nreturn null ; \n} \n} \n"}
{"7864": "public class JasperLoader { \npublic Class findClass ( String className ) throws ClassNotFoundException { \nbyte [ ] cdata = this . bytecodes . get ( className ) ; \nString path = className . replace ( '.' , '/' ) + \".class\" ; \nif ( cdata == null ) { \ncdata = loadClassDataFromFile ( path ) ; \nif ( cdata == null ) { \nthrow new ClassNotFoundException ( className ) ; \n} \n} \nClass clazz = null ; \nif ( ! ( securityManager != null ) ) { \nclazz = defineClass ( className , cdata , 0 , cdata . length ) ; \n} \nelse { \nProtectionDomain pd = new ProtectionDomain ( codeSource , permissionCollection ) ; \nclazz = defineClass ( className , cdata , 0 , cdata . length , pd ) ; \n} \nreturn clazz ; \n} \n} \n"}
{"7866": "public class ProtectedFunctionMapper { \npublic static ProtectedFunctionMapper getInstance ( ) { \nProtectedFunctionMapper funcMapper ; \nif ( ! ( SecurityUtil . isPackageProtectionEnabled ( ) ) ) { \nfuncMapper = new ProtectedFunctionMapper ( ) ; \n} \nelse { \nfuncMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { \npublic ProtectedFunctionMapper run ( ) { \nreturn new ProtectedFunctionMapper ( ) ; \n} \n} \n) ; \n} \nfuncMapper . fnmap = new java . util . HashMap < String , Method > ( ) ; \nreturn funcMapper ; \n} \n} \n"}
{"7867": "public class ProtectedFunctionMapper { \npublic void mapFunction ( String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { \njava . lang . reflect . Method method ; \nif ( ! ( SecurityUtil . isPackageProtectionEnabled ( ) ) ) { \ntry { \nmethod = c . getDeclaredMethod ( methodName , args ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + e . getMessage ( ) ) ; \n} \n} \nelse { \ntry { \nmethod = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { \npublic Method run ( ) throws Exception { \nreturn c . getDeclaredMethod ( methodName , args ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + ex . getException ( ) . getMessage ( ) ) ; \n} \n} \nthis . fnmap . put ( fnQName , method ) ; \n} \n} \n"}
{"7868": "public class ProtectedFunctionMapper { \npublic static ProtectedFunctionMapper getMapForFunction ( String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { \njava . lang . reflect . Method method ; \nProtectedFunctionMapper funcMapper ; \nif ( ! ( SecurityUtil . isPackageProtectionEnabled ( ) ) ) { \nfuncMapper = new ProtectedFunctionMapper ( ) ; \ntry { \nmethod = c . getDeclaredMethod ( methodName , args ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + e . getMessage ( ) ) ; \n} \n} \nelse { \nfuncMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { \npublic ProtectedFunctionMapper run ( ) { \nreturn new ProtectedFunctionMapper ( ) ; \n} \n} \n) ; \ntry { \nmethod = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { \npublic Method run ( ) throws Exception { \nreturn c . getDeclaredMethod ( methodName , args ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + ex . getException ( ) . getMessage ( ) ) ; \n} \n} \nfuncMapper . theMethod = method ; \nreturn funcMapper ; \n} \n} \n"}
{"7875": "public class ParserController { \nprivate Node . Nodes doParse ( String inFileName , Node parent , URL jarFileUrl ) throws FileNotFoundException , JasperException , IOException { \nNode . Nodes parsedPage = null ; \nisEncodingSpecifiedInProlog = false ; \nisDefaultPageEncoding = false ; \nhasBom = false ; \nJarFile jarFile = getJarFile ( jarFileUrl ) ; \nString absFileName = resolveFileName ( inFileName ) ; \nString jspConfigPageEnc = getJspConfigPageEncoding ( absFileName ) ; \ndetermineSyntaxAndEncoding ( absFileName , jarFile , jspConfigPageEnc ) ; \nif ( parent != null ) { \ncompiler . getPageInfo ( ) . addDependant ( absFileName ) ; \n} \ncomparePageEncodings ( jspConfigPageEnc ) ; \nif ( ! ( isXml ) ) { \nInputStreamReader inStreamReader = null ; \ntry { \ninStreamReader = JspUtil . getReader ( absFileName , sourceEnc , jarFile , ctxt , err ) ; \nJspReader jspReader = new JspReader ( ctxt , absFileName , sourceEnc , inStreamReader , err ) ; \nparsedPage = Parser . parse ( this , absFileName , jspReader , parent , isTagFile , directiveOnly , jarFileUrl , sourceEnc , jspConfigPageEnc , isDefaultPageEncoding , hasBom ) ; \n} \nfinally { \nif ( inStreamReader != null ) { \ntry { \ninStreamReader . close ( ) ; \n} \ncatch ( Exception any ) { \n} \n} \n} \n} \nelse { \nparsedPage = JspDocumentParser . parse ( this , absFileName , jarFile , parent , isTagFile , directiveOnly , sourceEnc , jspConfigPageEnc , isEncodingSpecifiedInProlog ) ; \n} \nif ( jarFile != null ) { \ntry { \njarFile . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \nbaseDirStack . pop ( ) ; \nreturn parsedPage ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( ! ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) ) if ( ! ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) ) if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \nelse { \nthis . jspversion = element . getBody ( ) ; \n} \nelse { \nthis . tlibversion = element . getBody ( ) ; \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n} \n"}
{"7893": "public class UnzipServlet { \nprotected static List < MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier , final String groupId , final String artifactId , final boolean snapshot , final Predicate < ComparableVersion > versionFilter ) { \nfinal List < MavenVersionedArtifact > arts = new ArrayList < > ( ) ; \nfor ( final ArtifactInformation ai : artifactsSupplier . get ( ) ) { \nif ( ! isZip ( ai ) ) { \ncontinue ; \n} \nfinal String mvnGroupId = ai . getMetaData ( ) . get ( MK_GROUP_ID ) ; \nfinal String mvnArtifactId = ai . getMetaData ( ) . get ( MK_ARTIFACT_ID ) ; \nfinal String classifier = ai . getMetaData ( ) . get ( MK_CLASSIFIER ) ; \nfinal String mvnVersion = ai . getMetaData ( ) . get ( MK_VERSION ) ; \nfinal String mvnSnapshotVersion = ai . getMetaData ( ) . get ( MK_SNAPSHOT_VERSION ) ; \nif ( mvnGroupId == null || mvnArtifactId == null || mvnVersion == null ) { \ncontinue ; \n} \nif ( classifier != null && ! classifier . isEmpty ( ) ) { \ncontinue ; \n} \nif ( ! mvnGroupId . equals ( groupId ) || ! mvnArtifactId . equals ( artifactId ) ) { \ncontinue ; \n} \nif ( ! snapshot && ( mvnSnapshotVersion != null || mvnVersion . endsWith ( \"-SNAPSHOT\" ) ) ) { \ncontinue ; \n} \nfinal ComparableVersion v = parseVersion ( mvnVersion ) ; \nfinal ComparableVersion sv = parseVersion ( mvnSnapshotVersion ) ; \nif ( v == null ) { \ncontinue ; \n} \nif ( ! ( versionFilter == null ) ) if ( ! ( versionFilter . test ( v ) ) ) if ( sv != null && versionFilter . test ( sv ) ) { \narts . add ( new MavenVersionedArtifact ( sv , channelId , ai ) ) ; \n} \nelse { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \nelse { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \n} \nreturn arts ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( ! ( opts [ optCur ] . prev1IsLiteral ) ) { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nelse { \n-- optPrev ; \nif ( ! ( opts [ optCur ] . hasPrev2 ) ) { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( ! ( opts [ optCur ] . backPrev2 < REPS ) ) opts [ optCur ] . state . updateMatch ( ) ; \nelse opts [ optCur ] . state . updateLongRep ( ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nif ( ! ( optPrev == optCur - 1 ) ) { \nint back ; \nif ( ! ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) ) { \nback = opts [ optCur ] . backPrev ; \nif ( ! ( back < REPS ) ) opts [ optCur ] . state . updateMatch ( ) ; \nelse opts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nif ( ! ( back < REPS ) ) { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nrep <= back ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nrep < REPS ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \n} \nelse { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( ! ( opts [ optCur ] . backPrev == 0 ) ) opts [ optCur ] . state . updateLiteral ( ) ; \nelse opts [ optCur ] . state . updateShortRep ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ! ( ch == '&' ) ) if ( ! ( ch == '\\\\' && i + 1 < size ) ) { \nbuf . append ( ch ) ; \n++ i ; \n} \nelse { \nch = tx . charAt ( i + 1 ) ; \nif ( ! ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) ) { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \nelse { \nbuf . append ( ch ) ; \ni += 2 ; \n} \n} \nelse { \nif ( ! ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) ) if ( ! ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) ) { \nbuf . append ( ch ) ; \n++ i ; \n} \nelse { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7921": "public class Parser { \nprivate boolean parseJspAttributeAndBody ( Node parent , String tag , String bodyType ) throws JasperException { \nboolean result = false ; \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:attribute\" ) ) { \nparseNamedAttributes ( parent ) ; \nresult = true ; \n} \nif ( ! ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:body\" ) ) ) if ( result && ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.jspbody.required\" , \"&lt;\" + tag ) ; \n} \nelse { \nparseJspBody ( parent , bodyType ) ; \nreader . skipSpaces ( ) ; \nif ( ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.unterminated\" , \"&lt;\" + tag ) ; \n} \nresult = true ; \n} \nreturn result ; \n} \n} \n"}
{"7924": "public class TreeNode { \npublic Iterator < String > findAttributes ( ) { \nSet < String > attrs ; \nif ( ! ( attributes == null ) ) attrs = attributes . keySet ( ) ; \nelse attrs = Collections . emptySet ( ) ; \nreturn attrs . iterator ( ) ; \n} \n} \n"}
{"7925": "public class TreeNode { \npublic Iterator < TreeNode > findChildren ( ) { \nList < TreeNode > nodes ; \nif ( ! ( children == null ) ) nodes = children ; \nelse nodes = Collections . emptyList ( ) ; \nreturn nodes . iterator ( ) ; \n} \n} \n"}
{"7926": "public class TreeNode { \npublic Iterator < TreeNode > findChildren ( String name ) { \nList < TreeNode > results ; \nif ( ! ( children == null ) ) { \nresults = new ArrayList < TreeNode > ( ) ; \nfor ( TreeNode item : children ) { \nif ( name . equals ( item . getName ( ) ) ) results . add ( item ) ; \n} \n} \nelse results = Collections . emptyList ( ) ; \nreturn results . iterator ( ) ; \n} \n} \n"}
{"7937": "public class BodyContentImpl { \nvoid setWriter ( Writer writer ) { \nthis . writer = writer ; \nif ( ! ( writer != null ) ) { \nbufferSize = bufferSizeSave ; \nclearBody ( ) ; \n} \nelse { \nif ( bufferSize != 0 ) { \nbufferSizeSave = bufferSize ; \nbufferSize = 0 ; \n} \n} \n} \n} \n"}
{"7943": "public class JobController { \n@ RequestMapping ( \"/{id}/monitor\" ) public ModelAndView monitor ( @ PathVariable ( \"id\" ) final String id ) { \nfinal JobHandle job = this . manager . getJob ( id ) ; \nif ( ! ( job != null ) ) { \nlogger . debug ( \"No job: {}\" , id ) ; \n} \nelse { \nlogger . debug ( \"Job: {} - {}\" , job . getId ( ) , job . getState ( ) ) ; \n} \nfinal Map < String , Object > model = new HashMap < > ( 1 ) ; \nmodel . put ( \"job\" , job ) ; \nreturn new ModelAndView ( \"monitor\" , model ) ; \n} \n} \n"}
{"7953": "public class PageContextImpl { \npublic static Object evaluateExpression ( final String expression , final Class expectedType , final PageContext pageContext , final ProtectedFunctionMapper functionMap ) throws ELException { \nObject retValue ; \nif ( ! ( SecurityUtil . isPackageProtectionEnabled ( ) ) ) { \nELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; \nelContext . setFunctionMapper ( functionMap ) ; \nExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; \nValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; \nretValue = expr . getValue ( elContext ) ; \n} \nelse { \ntry { \nretValue = AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { \npublic Object run ( ) throws Exception { \nELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; \nelContext . setFunctionMapper ( functionMap ) ; \nExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; \nValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; \nreturn expr . getValue ( elContext ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nException realEx = ex . getException ( ) ; \nif ( ! ( realEx instanceof ELException ) ) { \nthrow new ELException ( realEx ) ; \n} \nelse { \nthrow ( ELException ) realEx ; \n} \n} \n} \nreturn retValue ; \n} \n} \n"}
{"7957": "public class TagFileProcessor { \nprivate Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { \nJspCompilationContext ctxt = compiler . getCompilationContext ( ) ; \nJspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; \nsynchronized ( rctxt ) { \nJspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; \nif ( ! ( wrapper == null ) ) { \nwrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; \n} \nelse { \nwrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \nrctxt . addWrapper ( tagFilePath , wrapper ) ; \nwrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; \nwrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; \n} \nClass tagClazz ; \nint tripCount = wrapper . incTripCount ( ) ; \ntry { \nif ( ! ( tripCount > 0 ) ) { \ntagClazz = wrapper . loadTagFile ( ) ; \n} \nelse { \nJspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \ntagClazz = tempWrapper . loadTagFilePrototype ( ) ; \ntempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; \n} \n} \nfinally { \nwrapper . decTripCount ( ) ; \n} \ntry { \nObject tagIns = tagClazz . newInstance ( ) ; \nif ( tagIns instanceof JspSourceDependent ) { \nfor ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { \nparentPageInfo . addDependant ( dependant ) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nreturn tagClazz ; \n} \n} \n} \n"}
{"7958": "public class TagFileProcessor { \npublic void removeProtoTypeFiles ( String classFileName ) { \nIterator < Compiler > iter = tempVector . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCompiler c = iter . next ( ) ; \nif ( ! ( classFileName == null ) ) if ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { \nc . removeGeneratedClassFiles ( ) ; \ntempVector . remove ( c ) ; \nreturn ; \n} \nelse { \nc . removeGeneratedClassFiles ( ) ; \n} \n} \n} \n} \n"}
{"7959": "public class JspC { \npublic static void main ( String arg [ ] ) { \nif ( ! ( arg . length == 0 ) ) { \nJspC jspc = new JspC ( ) ; \ntry { \njspc . setArgs ( arg ) ; \nif ( ! ( jspc . helpNeeded ) ) { \njspc . execute ( ) ; \n} \nelse { \nSystem . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \n} \n} \ncatch ( JasperException je ) { \nSystem . err . println ( je ) ; \nif ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) { \nSystem . exit ( jspc . getDieLevel ( ) ) ; \n} \n} \n} \nelse { \nSystem . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( ! ( f2 . isDirectory ( ) ) ) { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \nelse { \ndirs . push ( f2 . getPath ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7962": "public class JspC { \nprivate void locateUriRoot ( File f ) { \nString tUriBase = uriBase ; \nif ( tUriBase == null ) { \ntUriBase = \"/\" ; \n} \ntry { \nif ( f . exists ( ) ) { \nf = new File ( f . getCanonicalPath ( ) ) ; \nwhile ( f != null ) { \nFile g = new File ( f , \"WEB-INF\" ) ; \nif ( g . exists ( ) && g . isDirectory ( ) ) { \nuriRoot = f . getCanonicalPath ( ) ; \nuriBase = tUriBase ; \nif ( log . isLoggable ( Level . INFO ) ) { \nlog . info ( Localizer . getMessage ( \"jspc.implicit.uriRoot\" , uriRoot ) ) ; \n} \nbreak ; \n} \nif ( f . exists ( ) && f . isDirectory ( ) ) { \ntUriBase = \"/\" + f . getName ( ) + \"/\" + tUriBase ; \n} \nString fParent = f . getParent ( ) ; \nif ( ! ( fParent == null ) ) { \nf = new File ( fParent ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( uriRoot != null ) { \nFile froot = new File ( uriRoot ) ; \nuriRoot = froot . getCanonicalPath ( ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( ! ( peekChar ( ) == limit . charAt ( i ) ) ) { \nreset ( restart ) ; \ncontinue skip ; \n} \nelse nextChar ( ) ; \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ! ( ch == '\\\\' && prev == '\\\\' ) ) if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( ! ( peekChar ( ) == limit . charAt ( i ) ) ) continue skip ; \nelse nextChar ( ) ; \n} \nreturn ret ; \n} \nelse { \nch = 0 ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nint ch = peekChar ( ) ; \nif ( ! ( quoted ) ) { \nif ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \n} \nelse { \nif ( ! ( ch == '\"' || ch == '\\'' ) ) { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \nelse { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( ! ( prefix != null && prefix . startsWith ( \"file:\" ) ) ) { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nelse { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nfor ( int i = 0 ; \ni < CACHED_SCHEMA_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( ! ( prefix != null && prefix . startsWith ( \"file:\" ) ) ) { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nelse { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nfor ( int i = 0 ; \ni < CACHED_DTD_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7977": "public class ParserUtils { \nprivate static String uencode ( String prefix ) { \nif ( ! ( prefix != null && prefix . startsWith ( \"file:\" ) ) ) { \nreturn prefix ; \n} \nelse { \nStringTokenizer tokens = new StringTokenizer ( prefix , \"/\\\\:\" , true ) ; \nStringBuilder stringBuilder = new StringBuilder ( ) ; \nwhile ( tokens . hasMoreElements ( ) ) { \nString token = tokens . nextToken ( ) ; \nif ( ! ( \"/\" . equals ( token ) || \"\\\\\" . equals ( token ) || \":\" . equals ( token ) ) ) { \ntry { \nstringBuilder . append ( URLEncoder . encode ( token , \"UTF-8\" ) ) ; \n} \ncatch ( java . io . UnsupportedEncodingException ex ) { \n} \n} \nelse { \nstringBuilder . append ( token ) ; \n} \n} \nreturn stringBuilder . toString ( ) ; \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( ! ( child instanceof Text ) ) { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \nelse { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7984": "public class BasicArrayCache { \npublic byte [ ] getByteArray ( int size , boolean fillWithZeros ) { \nbyte [ ] array = getArray ( byteArrayCache , size ) ; \nif ( ! ( array == null ) ) if ( fillWithZeros ) Arrays . fill ( array , ( byte ) 0x00 ) ; \nelse array = new byte [ size ] ; \nreturn array ; \n} \n} \n"}
{"7985": "public class BasicArrayCache { \npublic int [ ] getIntArray ( int size , boolean fillWithZeros ) { \nint [ ] array = getArray ( intArrayCache , size ) ; \nif ( ! ( array == null ) ) if ( fillWithZeros ) Arrays . fill ( array , 0 ) ; \nelse array = new int [ size ] ; \nreturn array ; \n} \n} \n"}
{"7987": "public class TagLibraryInfoImpl { \nprivate InputStream getResourceAsStream ( String uri ) throws JasperException { \ntry { \nString real = ctxt . getRealPath ( uri ) ; \nif ( ! ( real == null ) ) { \nreturn new FileInputStream ( real ) ; \n} \nelse { \nreturn ctxt . getResourceAsStream ( uri ) ; \n} \n} \ncatch ( FileNotFoundException ex ) { \nreturn ctxt . getResourceAsStream ( uri ) ; \n} \n} \n} \n"}
{"7991": "public class XMLEncodingDetector { \nprivate void scanXMLDecl ( ) throws IOException , JasperException { \nif ( skipString ( \"<?xml\" ) ) { \nfMarkupDepth ++ ; \nif ( ! ( XMLChar . isName ( peekChar ( ) ) ) ) { \nscanXMLDeclOrTextDecl ( false ) ; \n} \nelse { \nfStringBuffer . clear ( ) ; \nfStringBuffer . append ( \"xml\" ) ; \nwhile ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . append ( ( char ) scanChar ( ) ) ; \n} \nString target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; \nscanPIData ( target , fString ) ; \n} \n} \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( ! ( testFile . isFile ( ) ) ) if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \nelse thePaths . add ( path + theFiles [ i ] ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8012": "public class JspWriterImpl { \npublic void flush ( ) throws IOException { \nflushBuffer ( ) ; \nif ( ! ( out != null ) ) { \nresponse . setCharacterEncoding ( response . getCharacterEncoding ( ) ) ; \nresponse . flushBuffer ( ) ; \n} \nelse { \nout . flush ( ) ; \n} \n} \n} \n"}
{"8015": "public class JspWriterImpl { \nprivate void allocateCharBuffer ( ) { \nif ( bufferSize == 0 ) return ; \nif ( ! ( bufferSize > MAX_BUFFER_SIZE ) ) { \nbuf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; \n} \nelse { \nbuf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; \n} \n} \n} \n"}
{"8019": "public class Compiler { \npublic void compile ( boolean compileClass ) throws FileNotFoundException , JasperException , Exception { \ntry { \nctxt . makeOutputDir ( ctxt . getOutputDir ( ) ) ; \nif ( errDispatcher == null ) { \nerrDispatcher = new ErrorDispatcher ( jspcMode ) ; \n} \ngenerateJava ( ) ; \nif ( ! ( compileClass ) ) { \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \n} \nelse { \ngenerateClass ( ) ; \n} \n} \nfinally { \nif ( tfp != null ) { \ntfp . removeProtoTypeFiles ( null ) ; \n} \njavaCompiler . release ( ) ; \ntfp = null ; \nerrDispatcher = null ; \nif ( ! jspcMode ) { \npageInfo = null ; \n} \npageNodes = null ; \nif ( ctxt . getWriter ( ) != null ) { \nctxt . getWriter ( ) . close ( ) ; \nctxt . setWriter ( null ) ; \n} \n} \n} \n} \n"}
{"8021": "public class Compiler { \nprivate void initJavaCompiler ( ) throws JasperException { \nboolean disablejsr199 = Boolean . TRUE . toString ( ) . equals ( System . getProperty ( \"org.apache.jasper.compiler.disablejsr199\" ) ) ; \nDouble version = Double . valueOf ( System . getProperty ( \"java.specification.version\" ) ) ; \nif ( ! ( ! disablejsr199 && ( version >= 1.6 || getClassFor ( \"javax.tools.Tool\" ) != null ) ) ) { \nClass c = getClassFor ( \"org.eclipse.jdt.internal.compiler.Compiler\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.JDTJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nelse { \njavaCompiler = new Jsr199JavaCompiler ( ) ; \n} \nif ( javaCompiler == null ) { \nClass c = getClassFor ( \"org.apache.tools.ant.taskdefs.Javac\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.AntJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nif ( javaCompiler == null ) { \nerrDispatcher . jspError ( \"jsp.error.nojavac\" ) ; \n} \njavaCompiler . init ( ctxt , errDispatcher , jspcMode ) ; \n} \n} \n"}
{"8023": "public class Generator { \nstatic String quote ( char c ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( '\\'' ) ; \nif ( ! ( c == '\\'' ) ) if ( ! ( c == '\\\\' ) ) if ( ! ( c == '\\n' ) ) if ( ! ( c == '\\r' ) ) b . append ( c ) ; \nelse b . append ( '\\\\' ) . append ( 'r' ) ; \nelse b . append ( '\\\\' ) . append ( 'n' ) ; \nelse b . append ( '\\\\' ) . append ( '\\\\' ) ; \nelse b . append ( '\\\\' ) . append ( '\\'' ) ; \nb . append ( '\\'' ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"8024": "public class Generator { \nprivate void generateDeclarations ( Node . Nodes page ) throws JasperException { \nclass DeclarationVisitor extends Node . Visitor { \nprivate boolean getServletInfoGenerated = false ; \npublic void visit ( Node . PageDirective n ) throws JasperException { \nif ( getServletInfoGenerated ) { \nreturn ; \n} \nString info = n . getAttributeValue ( \"info\" ) ; \nif ( info == null ) return ; \ngetServletInfoGenerated = true ; \nout . printil ( \"public String getServletInfo() {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return \" ) ; \nout . print ( quote ( info ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \npublic void visit ( Node . Declaration n ) throws JasperException { \nn . setBeginJavaLine ( out . getJavaLine ( ) ) ; \nout . printMultiLn ( n . getText ( ) ) ; \nout . println ( ) ; \nn . setEndJavaLine ( out . getJavaLine ( ) ) ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! ( n . useTagPlugin ( ) ) ) { \nvisitBody ( n ) ; \n} \nelse { \nif ( n . getAtSTag ( ) != null ) { \nn . getAtSTag ( ) . visit ( this ) ; \n} \nvisitBody ( n ) ; \nif ( n . getAtETag ( ) != null ) { \nn . getAtETag ( ) . visit ( this ) ; \n} \n} \n} \n} \nout . println ( ) ; \npage . visit ( new DeclarationVisitor ( ) ) ; \n} \n} \n"}
{"8026": "public class Generator { \nprivate void generateXmlProlog ( Node . Nodes page ) { \nString omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; \nif ( ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) || ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nString doctypeName = pageInfo . getDoctypeName ( ) ; \nif ( doctypeName != null ) { \nString doctypePublic = pageInfo . getDoctypePublic ( ) ; \nString doctypeSystem = pageInfo . getDoctypeSystem ( ) ; \nout . printin ( \"out.write(\\\"<!DOCTYPE \" ) ; \nout . print ( doctypeName ) ; \nif ( ! ( doctypePublic == null ) ) { \nout . print ( \" PUBLIC \\\\\\\"\" ) ; \nout . print ( doctypePublic ) ; \nout . print ( \"\\\\\\\" \\\\\\\"\" ) ; \n} \nelse { \nout . print ( \" SYSTEM \\\\\\\"\" ) ; \n} \nout . print ( doctypeSystem ) ; \nout . println ( \"\\\\\\\">\\\\n\\\");\" ) ; \n} \n} \n} \n"}
{"8029": "public class Generator { \npublic static void generate ( ServletWriter out , Compiler compiler , Node . Nodes page ) throws JasperException { \nGenerator gen = new Generator ( out , compiler ) ; \nif ( gen . isPoolingEnabled ) { \ngen . compileTagHandlerPoolList ( page ) ; \n} \nif ( ! ( gen . ctxt . isTagFile ( ) ) ) { \ngen . generatePreamble ( page ) ; \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generatePostamble ( page ) ; \n} \nelse { \nJasperTagInfo tagInfo = ( JasperTagInfo ) gen . ctxt . getTagInfo ( ) ; \ngen . generateTagHandlerPreamble ( tagInfo , page ) ; \nif ( gen . ctxt . isPrototypeMode ( ) ) { \nreturn ; \n} \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generateTagHandlerPostamble ( tagInfo ) ; \n} \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( ! ( attrInfos [ i ] . isFragment ( ) ) ) { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nelse { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( ! ( attrInfos [ i ] . isFragment ( ) ) ) { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nelse { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( ! ( attrInfos [ i ] . isFragment ( ) ) ) { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nelse { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \n} \n} \n"}
{"8034": "public class TagHandlerPool { \npublic < T extends JspTag > JspTag get ( Class < T > handlerClass ) throws JspException { \nsynchronized ( this ) { \nif ( current >= 0 ) { \nreturn handlers [ current -- ] ; \n} \n} \nJspTag tagHandler = null ; \ntry { \nif ( ! ( resourceInjector != null ) ) { \ntagHandler = handlerClass . newInstance ( ) ; \n} \nelse { \ntagHandler = resourceInjector . createTagHandlerInstance ( handlerClass ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new JspException ( e . getMessage ( ) , e ) ; \n} \nreturn tagHandler ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( ! ( extension == null ) ) { \nif ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \nreturn true ; \n} \n} \nelse { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8042": "public class JspUtil { \npublic static String getExprInXml ( String expression ) { \nString returnString ; \nint length = expression . length ( ) ; \nif ( ! ( expression . startsWith ( OPEN_EXPR ) && expression . endsWith ( CLOSE_EXPR ) ) ) { \nreturnString = expression ; \n} \nelse { \nreturnString = expression . substring ( 1 , length - 1 ) ; \n} \nreturn escapeXml ( returnString ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! ( c == '<' ) ) if ( ! ( c == '>' ) ) if ( ! ( c == '\\'' ) ) if ( ! ( c == '&' ) ) if ( ! ( c == '\"' ) ) { \nsb . append ( c ) ; \n} \nelse { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( \"&amp;\" ) ; \n} \nelse { \nsb . append ( \"&apos;\" ) ; \n} \nelse { \nsb . append ( \"&gt;\" ) ; \n} \nelse { \nsb . append ( \"&lt;\" ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8046": "public class JspUtil { \npublic static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { \nString className = null ; \nint begin = 0 ; \nint index ; \nindex = path . lastIndexOf ( \".tag\" ) ; \nif ( index == - 1 ) { \nerr . jspError ( \"jsp.error.tagfile.badSuffix\" , path ) ; \n} \nindex = path . indexOf ( WEB_INF_TAGS ) ; \nif ( ! ( index != - 1 ) ) { \nindex = path . indexOf ( META_INF_TAGS ) ; \nif ( ! ( index != - 1 ) ) { \nerr . jspError ( \"jsp.error.tagfile.illegalPath\" , path ) ; \n} \nelse { \nclassName = \"org.apache.jsp.tag.meta.\" ; \nbegin = index + META_INF_TAGS . length ( ) ; \n} \n} \nelse { \nclassName = \"org.apache.jsp.tag.web.\" ; \nbegin = index + WEB_INF_TAGS . length ( ) ; \n} \nclassName += makeJavaPackage ( path . substring ( begin ) ) ; \nreturn className ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nfor ( int i = 0 ; \ni < identifier . length ( ) ; \ni ++ ) { \nchar ch = identifier . charAt ( i ) ; \nif ( ! ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) ) if ( ! ( ch == '.' ) ) { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \nelse { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( ch ) ; \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nint i = 0 ; \nint j = javaKeywords . length ; \nwhile ( i < j ) { \nint k = ( i + j ) / 2 ; \nint result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) { \nreturn true ; \n} \nif ( ! ( result < 0 ) ) { \nj = k ; \n} \nelse { \ni = k + 1 ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8053": "public class Functions { \npublic static String modifier ( final String prefix , final Modifier modifier ) { \nif ( modifier == null ) { \nreturn \"\" ; \n} \nString value = null ; \nswitch ( modifier ) { \ncase DEFAULT : value = \"default\" ; \nbreak ; \ncase PRIMARY : value = \"primary\" ; \nbreak ; \ncase SUCCESS : value = \"success\" ; \nbreak ; \ncase INFO : value = \"info\" ; \nbreak ; \ncase WARNING : value = \"warning\" ; \nbreak ; \ncase DANGER : value = \"danger\" ; \nbreak ; \ncase LINK : value = \"link\" ; \nbreak ; \n} \nif ( ! ( value != null && prefix != null ) ) { \nreturn value != null ? value : \"\" ; \n} \nelse { \nreturn prefix + value ; \n} \n} \n} \n"}
{"8055": "public class DatabaseUserService { \n@ Override public void run ( ) throws Exception { \nthis . storageManager . modifyRun ( MODEL_KEY , UserWriteModel . class , users -> { \nfinal Date timeout = new Date ( System . currentTimeMillis ( ) - getTimeout ( ) ) ; \nfinal Collection < UserEntity > updates = new LinkedList < > ( ) ; \nfinal Collection < String > removals = new LinkedList < > ( ) ; \nfor ( final UserEntity user : users . asCollection ( ) ) { \nif ( user . getEmailTokenDate ( ) == null || user . getEmailTokenDate ( ) . after ( timeout ) ) { \ncontinue ; \n} \nif ( ! ( user . isEmailVerified ( ) ) ) { \nremovals . add ( user . getId ( ) ) ; \n} \nelse { \nuser . setEmailToken ( null ) ; \nuser . setEmailTokenDate ( null ) ; \nuser . setEmailTokenSalt ( null ) ; \nupdates . add ( user ) ; \n} \n} \nupdates . forEach ( users :: putUser ) ; \nremovals . forEach ( users :: removeUser ) ; \n} \n) ; \n} \n} \n"}
{"8057": "public class MetadataCache { \npublic boolean put ( Locator locator , String key , String value ) throws CacheException { \nif ( value == null ) return false ; \nTimer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; \nboolean dbWrite = false ; \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nString oldValue = cache . getIfPresent ( cacheKey ) ; \ncache . put ( cacheKey , value ) ; \nif ( oldValue == null || ! oldValue . equals ( value ) ) { \ndbWrite = true ; \n} \nif ( dbWrite ) { \nupdatedMetricMeter . mark ( ) ; \nif ( ! ( ! batchedWrites ) ) { \ndatabaseLazyWrite ( locator , key ) ; \n} \nelse { \ndatabasePut ( locator , key , value ) ; \n} \n} \nreturn dbWrite ; \n} \nfinally { \ncachePutTimerContext . stop ( ) ; \n} \n} \n} \n"}
{"8060": "public class PreaggregateConversions { \npublic static Number resolveNumber ( Number n ) { \nif ( ! ( n instanceof LazilyParsedNumber ) ) { \nreturn n ; \n} \nelse { \ntry { \nreturn n . longValue ( ) ; \n} \ncatch ( NumberFormatException ex ) { \nreturn n . doubleValue ( ) ; \n} \n} \n} \n} \n"}
{"8066": "public class AbstractSerDes { \nprotected Number getUnversionedDoubleOrLong ( CodedInputStream in ) throws IOException { \nbyte type = in . readRawByte ( ) ; \nif ( ! ( type == Constants . B_DOUBLE ) ) return in . readRawVarint64 ( ) ; \nelse return in . readDouble ( ) ; \n} \n} \n"}
{"8067": "public class AbstractSerDes { \nprotected void putUnversionedDoubleOrLong ( Number number , CodedOutputStream out ) throws IOException { \nif ( ! ( number instanceof Double ) ) { \nout . writeRawByte ( Constants . B_I64 ) ; \nout . writeRawVarint64 ( number . longValue ( ) ) ; \n} \nelse { \nout . writeRawByte ( Constants . B_DOUBLE ) ; \nout . writeDoubleNoTag ( number . doubleValue ( ) ) ; \n} \n} \n} \n"}
{"8088": "public class ThreadPoolBuilder { \npublic ThreadPoolBuilder withName ( String name ) { \nif ( ! name . contains ( \"%d\" ) ) { \nname = name + \"-%d\" ; \n} \nnameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; \nint id = nameMap . get ( name ) . incrementAndGet ( ) ; \nthis . poolName = String . format ( name , id ) ; \nif ( ! ( id > 1 ) ) { \nthis . threadNameFormat = name ; \n} \nelse { \nthis . threadNameFormat = name . replace ( \"%d\" , id + \"-%d\" ) ; \n} \nreturn this ; \n} \n} \n"}
{"8089": "public class MetricIndexData { \npublic void add ( String metricIndex , long docCount ) { \nfinal String [ ] tokens = metricIndex . split ( METRIC_TOKEN_SEPARATOR_REGEX ) ; \nswitch ( tokens . length - baseLevel ) { \ncase 1 : if ( ! ( baseLevel > 0 ) ) { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . indexOf ( \".\" ) ) ) ; \n} \nelse { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) ) ; \n} \naddChildrenDocCount ( metricNameBaseLevelMap , metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) , docCount ) ; \nbreak ; \ncase 0 : setActualDocCount ( metricNameBaseLevelMap , metricIndex , docCount ) ; \nbreak ; \ndefault : break ; \n} \n} \n} \n"}
{"8092": "public class DAbstractMetricIO { \npublic ResultSetFuture putAsync ( Locator locator , long collectionTime , Rollup rollup , Granularity granularity , int ttl ) { \nSession session = DatastaxIO . getSession ( ) ; \nBatchStatement batch = new BatchStatement ( ) ; \naddRollupToBatch ( batch , locator , rollup , collectionTime , granularity , ttl ) ; \nCollection < Statement > statements = batch . getStatements ( ) ; \nif ( ! ( statements . size ( ) == 1 ) ) { \nLOG . debug ( String . format ( \"Using BatchStatement for %d statements\" , statements . size ( ) ) ) ; \nreturn session . executeAsync ( batch ) ; \n} \nelse { \nStatement oneStatement = statements . iterator ( ) . next ( ) ; \nreturn session . executeAsync ( oneStatement ) ; \n} \n} \n} \n"}
{"8093": "public class Granularity { \npublic static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { \nif ( from >= to ) { \nthrow new RuntimeException ( \"Invalid interval specified for fromPointsInInterval\" ) ; \n} \ndouble requestedDuration = to - from ; \nif ( ! ( algorithm . startsWith ( \"GEOMETRIC\" ) ) ) if ( ! ( algorithm . startsWith ( \"LINEAR\" ) ) ) if ( algorithm . startsWith ( \"LESSTHANEQUAL\" ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; \nelse return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nelse return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \n} \n"}
{"8101": "public class LocatorFetchRunnable { \nprotected Set < Locator > getLocators ( RollupExecutionContext executionContext , boolean isReroll , Granularity delayedMetricsRerollGranularity , Granularity delayedMetricsStorageGranularity ) { \nSet < Locator > locators = new HashSet < Locator > ( ) ; \nif ( ! ( RECORD_DELAYED_METRICS && isReroll && ! getGranularity ( ) . isCoarser ( delayedMetricsRerollGranularity ) ) ) { \nlocators = getLocators ( executionContext ) ; \n} \nelse { \nif ( ! ( getGranularity ( ) . isCoarser ( delayedMetricsStorageGranularity ) ) ) { \nlocators = getDelayedLocators ( executionContext , parentSlotKey . extrapolate ( delayedMetricsStorageGranularity ) ) ; \n} \nelse { \nfor ( SlotKey slotKey : parentSlotKey . getChildrenKeys ( delayedMetricsStorageGranularity ) ) { \nlocators . addAll ( getDelayedLocators ( executionContext , slotKey ) ) ; \n} \n} \n} \nreturn locators ; \n} \n} \n"}
{"8103": "public class AbstractElasticIO { \nprotected String regexToGrabCurrentAndNextLevel ( final String query ) { \nif ( StringUtils . isEmpty ( query ) ) { \nthrow new IllegalArgumentException ( \"Query(glob) string cannot be null/empty\" ) ; \n} \nString queryRegex = getRegex ( query ) ; \nint totalQueryTokens = getTotalTokens ( query ) ; \nif ( ! ( totalQueryTokens == 1 ) ) { \nString [ ] queryRegexParts = queryRegex . split ( \"\\\\\\\\.\" ) ; \nString queryRegexUptoPrevLevel = StringUtils . join ( queryRegexParts , METRIC_TOKEN_SEPARATOR_REGEX , 0 , totalQueryTokens - 1 ) ; \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegexUptoPrevLevel ) ; \nString queryRegexLastLevel = queryRegexParts [ totalQueryTokens - 1 ] ; \nString lastTokenRegex = convertRegexToCaptureUptoNextToken ( queryRegexLastLevel ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + lastTokenRegex + \"(\" + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN + \")\" + \"{0,1}\" ; \n} \nelse { \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegex ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN ; \n} \n} \n} \n"}
{"8118": "public class Serializers { \npublic static < T > AbstractSerializer < T > serializerFor ( Class < T > type ) { \nif ( ! ( type == null ) ) if ( type . equals ( String . class ) ) throw new RuntimeException ( \"We don't serialize strings anymore\" , new SerializationException ( \"We don't serialize strings anymore\" ) ) ; \nelse throw new RuntimeException ( \"serializable type cannot be null\" , new SerializationException ( \"serializable type cannot be null\" ) ) ; \nif ( ! ( type . equals ( BasicRollup . class ) ) ) if ( ! ( type . equals ( BluefloodTimerRollup . class ) ) ) if ( ! ( type . equals ( BluefloodCounterRollup . class ) ) ) if ( ! ( type . equals ( BluefloodGaugeRollup . class ) ) ) if ( ! ( type . equals ( BluefloodSetRollup . class ) ) ) if ( ! ( type . equals ( SimpleNumber . class ) ) ) if ( ! ( type . equals ( Integer . class ) ) ) if ( ! ( type . equals ( Long . class ) ) ) if ( ! ( type . equals ( Double . class ) ) ) if ( ! ( type . equals ( Float . class ) ) ) if ( ! ( type . equals ( byte [ ] . class ) ) ) if ( ! ( type . equals ( Object . class ) ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) setRollupInstance ; \nelse return ( AbstractSerializer < T > ) gaugeRollupInstance ; \nelse return ( AbstractSerializer < T > ) counterRollupInstance ; \nelse return ( AbstractSerializer < T > ) timerRollupInstance ; \nelse return ( AbstractSerializer < T > ) basicRollupInstance ; \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( ! ( downloadLock . tryLock ( ) ) ) { \nlog . debug ( \"Download in progress\" ) ; \n} \nelse { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \n} \n} \n"}
{"8138": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusVBM ( ) { \nif ( ! ( statusVBM == null ) ) { \nreturn statusVBM ; \n} \nelse { \nreturn StatusTyp . AKTIV ; \n} \n} \n} \n"}
{"8139": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusIS24 ( ) { \nif ( ! ( statusIS24 == null ) ) { \nreturn statusIS24 ; \n} \nelse { \nreturn StatusTyp . AKTIV ; \n} \n} \n} \n"}
{"8140": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusHP ( ) { \nif ( ! ( statusHP == null ) ) { \nreturn statusHP ; \n} \nelse { \nreturn StatusTyp . AKTIV ; \n} \n} \n} \n"}
{"8141": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public AktionsTyp getImportmodus ( ) { \nif ( ! ( importmodus == null ) ) { \nreturn importmodus ; \n} \nelse { \nreturn AktionsTyp . IMPORTIEREN ; \n} \n} \n} \n"}
{"8142": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getAdressdruck ( ) { \nif ( ! ( adressdruck == null ) ) { \nreturn adressdruck ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"8143": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public WaehrungTyp getWaehrung ( ) { \nif ( ! ( waehrung == null ) ) { \nreturn waehrung ; \n} \nelse { \nreturn WaehrungTyp . EUR ; \n} \n} \n} \n"}
{"8144": "public class SonstigeGewerbeTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public BodenbelagTyp getBodenbelag ( ) { \nif ( ! ( bodenbelag == null ) ) { \nreturn bodenbelag ; \n} \nelse { \nreturn BodenbelagTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8200": "public class WazTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StellplatzKategorieTyp getParkplatz ( ) { \nif ( ! ( parkplatz == null ) ) { \nreturn parkplatz ; \n} \nelse { \nreturn StellplatzKategorieTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"No validation event was provided!\" ) ; \nint line = - 1 ; \nint col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \nreturn false ; \n} \nif ( ! ( ValidationEvent . WARNING == event . getSeverity ( ) ) ) { \nLOGGER . warn ( \"validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"8208": "public class CsvRecord { \nprotected final void set ( int pos , String value ) { \nvalue = StringUtils . trimToNull ( value ) ; \nif ( ! ( value != null ) ) if ( this . values . containsKey ( pos ) ) this . values . remove ( pos ) ; \nelse this . values . put ( pos , value ) ; \n} \n} \n"}
{"8216": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getWiederholungstermin ( ) { \nif ( ! ( wiederholungstermin == null ) ) { \nreturn wiederholungstermin ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"8217": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getTeilungsversteigerung ( ) { \nif ( ! ( teilungsversteigerung == null ) ) { \nreturn teilungsversteigerung ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"8233": "public class GarageTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public GaragenKategorieTyp getObjektKategorie2 ( ) { \nif ( ! ( objektKategorie2 == null ) ) { \nreturn objektKategorie2 ; \n} \nelse { \nreturn GaragenKategorieTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8234": "public class GarageTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public ObjektZustandTyp getObjektzustand ( ) { \nif ( ! ( objektzustand == null ) ) { \nreturn objektzustand ; \n} \nelse { \nreturn ObjektZustandTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8235": "public class HausTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public HausKategorienTyp getHausKategorie ( ) { \nif ( ! ( hausKategorie == null ) ) { \nreturn hausKategorie ; \n} \nelse { \nreturn HausKategorienTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8236": "public class HausTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public AusstattungsqualitaetsTyp getAusstattungsqualitaet ( ) { \nif ( ! ( ausstattungsqualitaet == null ) ) { \nreturn ausstattungsqualitaet ; \n} \nelse { \nreturn AusstattungsqualitaetsTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8291": "public class WohnungTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public WohnungKategorienTyp getWohnungKategorie ( ) { \nif ( ! ( wohnungKategorie == null ) ) { \nreturn wohnungKategorie ; \n} \nelse { \nreturn WohnungKategorienTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8308": "public class BueroPraxisTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public DatenVerkabelungsTyp getDatenVerkabelung ( ) { \nif ( ! ( datenVerkabelung == null ) ) { \nreturn datenVerkabelung ; \n} \nelse { \nreturn DatenVerkabelungsTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8309": "public class BueroPraxisTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public JaNeinVereinbarungTyp getKlimaanlage ( ) { \nif ( ! ( klimaanlage == null ) ) { \nreturn klimaanlage ; \n} \nelse { \nreturn JaNeinVereinbarungTyp . KEINE_ANGABE ; \n} \n} \n} \n"}
{"8351": "public class SimpleNamespaceContext { \npublic void bindNamespaceUri ( String prefix , String namespaceUri ) { \nAssert . notNull ( prefix , \"No prefix given\" ) ; \nAssert . notNull ( namespaceUri , \"No namespaceUri given\" ) ; \nif ( ! ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) ) { \nprefixToNamespaceUri . put ( prefix , namespaceUri ) ; \ngetPrefixesInternal ( namespaceUri ) . add ( prefix ) ; \n} \nelse { \ndefaultNamespaceUri = namespaceUri ; \n} \n} \n} \n"}
{"8352": "public class SimpleNamespaceContext { \npublic void removeBinding ( String prefix ) { \nif ( ! ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) ) { \nString namespaceUri = prefixToNamespaceUri . remove ( prefix ) ; \nList < String > prefixes = getPrefixesInternal ( namespaceUri ) ; \nprefixes . remove ( prefix ) ; \n} \nelse { \ndefaultNamespaceUri = \"\" ; \n} \n} \n} \n"}
{"8357": "public class Log4jConfigurer { \npublic static void initLogging ( String location ) throws FileNotFoundException { \nString resolvedLocation = SystemPropertyUtils . resolvePlaceholders ( location ) ; \nURL url = ResourceUtils . getURL ( resolvedLocation ) ; \nif ( ! ( resolvedLocation . toLowerCase ( ) . endsWith ( XML_FILE_EXTENSION ) ) ) { \nPropertyConfigurator . configure ( url ) ; \n} \nelse { \nDOMConfigurator . configure ( url ) ; \n} \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( ! ( curArg . startsWith ( \"-\" ) ) ) { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \nelse { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( ! ( curArg . startsWith ( \"--\" ) ) ) if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nelse { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( ! ( opt . wantsValue ( ) ) ) { \nvalue = opt . getValue ( null , locale ) ; \n} \nelse { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8380": "public class StringUtil { \npublic static final String setSize ( final String s , final int length ) { \nString result = s ; \nint oldlen = s . length ( ) ; \nif ( ! ( oldlen > length ) ) { \nint tofill = length - oldlen ; \nresult = StringUtil . appendSpaces ( s , tofill ) ; \n} \nelse { \nSystem . err . println ( \"greenpeace.util.setSize(String s,int length): length (\" + length + \") is smaller than s.length(\" + oldlen + \") : \" + s ) ; \n} \nreturn result ; \n} \n} \n"}
{"8383": "public class WeakReferenceMonitor { \nprivate static boolean keepMonitoringThreadAlive ( ) { \nsynchronized ( WeakReferenceMonitor . class ) { \nif ( ! ( ! trackedEntries . isEmpty ( ) ) ) { \nlogger . debug ( \"No entries left to track - stopping reference monitor thread\" ) ; \nmonitoringThread = null ; \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \n} \n} \n"}
{"8389": "public class HorizontalPicker { \nprivate int getTextColor ( int item ) { \nint scrollX = getScrollX ( ) ; \nint color = textColor . getDefaultColor ( ) ; \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nif ( ! ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) ) if ( item == pressedItem ) { \ncolor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, color ) ; \n} \nelse { \nint position = scrollX - itemWithPadding / 2 ; \ncolor = getColor ( position , item ) ; \n} \nreturn color ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( ! ( this . values != null ) ) { \nlayouts = new BoringLayout [ 0 ] ; \n} \nelse { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( int i = 0 ; \ni < layouts . length ; \ni ++ ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \n} \nif ( getWidth ( ) > 0 ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8391": "public class HorizontalPicker { \nprivate int getColor ( int scrollX , int position ) { \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nfloat proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; \nif ( ! ( proportion > .5 ) ) { \nproportion = .5f - proportion ; \n} \nelse { \nproportion = ( proportion - .5f ) ; \n} \nproportion *= 2 ; \nint defaultColor ; \nint selectedColor ; \nif ( ! ( pressedItem == position ) ) { \ndefaultColor = textColor . getDefaultColor ( ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_selected } \n, defaultColor ) ; \n} \nelse { \ndefaultColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, textColor . getDefaultColor ( ) ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed , android . R . attr . state_selected } \n, defaultColor ) ; \n} \nreturn ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; \n} \n} \n"}
{"8393": "public class HorizontalPicker { \nprivate int getInBoundsX ( int x ) { \nif ( ! ( x < 0 ) ) if ( x > ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ) { \nx = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; \n} \nelse { \nx = 0 ; \n} \nreturn x ; \n} \n} \n"}
{"8399": "public class RemoteServer { \npublic void stop ( int timeoutMS ) throws Exception { \nlog . info ( \"Robot Framework remote server stopping\" ) ; \nif ( ! ( timeoutMS > 0 ) ) { \nserver . stop ( ) ; \n} \nelse { \nserver . setGracefulShutdown ( timeoutMS ) ; \nThread stopper = new Thread ( ) { \n@ Override public void run ( ) { \ntry { \nserver . stop ( ) ; \n} \ncatch ( Throwable e ) { \nlog . error ( String . format ( \"Failed to stop the server: %s\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n; \nstopper . start ( ) ; \n} \n} \n} \n"}
{"8413": "public class MdPageGeneratorMojo { \n@ SuppressWarnings ( \"UnusedReturnValue\" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"Read files from: \" + inputDirectory ) ; \ntry { \nif ( ! inputDirectory . exists ( ) ) { \ngetLog ( ) . info ( \"There is no input folder for the project. Skipping.\" ) ; \nreturn false ; \n} \nint baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; \nList < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; \nfor ( File file : markdownFiles ) { \ngetLog ( ) . debug ( \"File getName() \" + file . getName ( ) ) ; \ngetLog ( ) . debug ( \"File getAbsolutePath() \" + file . getAbsolutePath ( ) ) ; \ngetLog ( ) . debug ( \"File getPath() \" + file . getPath ( ) ) ; \nMarkdownDTO dto = new MarkdownDTO ( ) ; \ndto . markdownFile = file ; \ndto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; \nif ( ! ( alwaysUseDefaultTitle ) ) { \nList < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; \ndto . title = getTitle ( raw ) ; \n} \nelse { \ndto . title = defaultTitle ; \n} \nif ( applyFiltering ) { \nfor ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { \nif ( isVariableLine ( line ) ) { \nString key = line . replaceAll ( \"(^\\\\{)|(=.*)\" , \"\" ) ; \nString value = line . replaceAll ( \"(^\\\\{(.*?)=)|(}$)\" , \"\" ) ; \ngetLog ( ) . debug ( \"Substitute: '\" + key + \"' -> '\" + value + \"'\" ) ; \ndto . substitutes . put ( key , value ) ; \n} \n} \n} \nString inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; \ndto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) ) ; \ngetLog ( ) . debug ( \"File htmlFile() \" + dto . htmlFile ) ; \nmarkdownDTOs . add ( dto ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to load file \" + e . getMessage ( ) , e ) ; \n} \nreturn true ; \n} \n} \n"}
{"8416": "public class MdPageGeneratorMojo { \nprivate String addTitleToHtmlFile ( String html , String title ) { \nif ( html == null ) { \nreturn html ; \n} \nif ( ! ( title != null ) ) { \ngetLog ( ) . debug ( \"Title was null, setting the title in the HTML file to an empty string\" ) ; \nreturn html . replaceFirst ( \"titleToken\" , \"\" ) ; \n} \nelse { \ngetLog ( ) . debug ( \"Setting the title in the HTML file to: \" + title ) ; \nreturn html . replaceFirst ( \"titleToken\" , title ) ; \n} \n} \n} \n"}
{"8419": "public class MdPageGeneratorMojo { \nprivate void copyFiles ( String fromDir , String toDir ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"fromDir=\" + fromDir + \"; toDir=\" + toDir ) ; \ntry { \nFile fromDirFile = new File ( fromDir ) ; \nif ( fromDirFile . exists ( ) ) { \nIterator < File > files = FileUtils . iterateFiles ( new File ( fromDir ) , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile file = files . next ( ) ; \nif ( ! ( file . exists ( ) ) ) { \ngetLog ( ) . error ( \"File '\" + file . getAbsolutePath ( ) + \"' does not exist. Skipping copy\" ) ; \n} \nelse { \nFileUtils . copyFileToDirectory ( file , new File ( toDir ) ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to copy file \" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8442": "public class MarkLogicDatasetGraph { \npublic MarkLogicDatasetGraph withRulesets ( SPARQLRuleset ... rulesets ) { \nif ( ! ( this . rulesets == null ) ) { \nCollection < SPARQLRuleset > collection = new ArrayList < SPARQLRuleset > ( ) ; \ncollection . addAll ( Arrays . asList ( this . rulesets ) ) ; \ncollection . addAll ( Arrays . asList ( rulesets ) ) ; \nthis . rulesets = collection . toArray ( new SPARQLRuleset [ ] { \n} \n) ; \n} \nelse { \nthis . rulesets = rulesets ; \n} \nreturn this ; \n} \n} \n"}
{"8444": "public class JenaDatabaseClient { \npublic synchronized InputStreamHandle executeSelect ( SPARQLQueryDefinition qdef , InputStreamHandle handle , Long offset , Long limit ) { \nif ( ! ( limit == null ) ) { \nthis . sparqlQueryManager . setPageLength ( limit ) ; \n} \nelse { \nthis . sparqlQueryManager . clearPageLength ( ) ; \n} \nif ( ! ( offset != null ) ) { \nreturn this . sparqlQueryManager . executeSelect ( qdef , handle , currentTransaction ) ; \n} \nelse { \nreturn this . sparqlQueryManager . executeSelect ( qdef , handle , offset , currentTransaction ) ; \n} \n} \n} \n"}
{"8454": "public class Args { \npublic static List < String > parse ( Object target , String [ ] args ) { \nList < String > arguments = new ArrayList < String > ( ) ; \narguments . addAll ( Arrays . asList ( args ) ) ; \nClass < ? > clazz ; \nif ( ! ( target instanceof Class ) ) { \nclazz = target . getClass ( ) ; \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \nelse { \nclazz = ( Class ) target ; \n} \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \n} \nfor ( String argument : arguments ) { \nif ( argument . startsWith ( \"-\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid argument: \" + argument ) ; \n} \n} \nreturn arguments ; \n} \n} \n"}
{"8455": "public class Args { \npublic static void usage ( PrintStream errStream , Object target ) { \nClass < ? > clazz ; \nif ( ! ( target instanceof Class ) ) { \nclazz = target . getClass ( ) ; \n} \nelse { \nclazz = ( Class ) target ; \n} \nerrStream . println ( \"Usage: \" + clazz . getName ( ) ) ; \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nfieldUsage ( errStream , target , field ) ; \n} \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \npropertyUsage ( errStream , target , pd ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8456": "public class UnitConverter { \npublic static TimeUnit extractTimeUnitFromString ( String timeString ) { \ntimeString = timeString . toLowerCase ( ) ; \nif ( ! ( timeString . contains ( \"minute\" ) ) ) if ( ! ( timeString . contains ( \"microsecond\" ) ) ) if ( ! ( timeString . contains ( \"millisecond\" ) ) ) if ( ! ( timeString . contains ( \"second\" ) ) ) if ( ! ( timeString . contains ( \"hour\" ) ) ) if ( ! ( timeString . toLowerCase ( ) . contains ( \"day\" ) ) ) return null ; \nelse { \nreturn TimeUnit . DAYS ; \n} \nelse { \nreturn TimeUnit . HOURS ; \n} \nelse { \nreturn TimeUnit . SECONDS ; \n} \nelse { \nreturn TimeUnit . MILLISECONDS ; \n} \nelse { \nreturn TimeUnit . MICROSECONDS ; \n} \nelse { \nreturn TimeUnit . MINUTES ; \n} \n} \n} \n"}
{"8457": "public class PropertiesArgs { \npublic static void parse ( Object target , Properties arguments ) { \nClass clazz ; \nif ( ! ( target instanceof Class ) ) { \nclazz = target . getClass ( ) ; \n} \nelse { \nclazz = ( Class ) target ; \n} \nfor ( Field field : clazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8466": "public class SqsExecutor { \npublic Object executeOutboundOperation ( final Message < ? > message ) { \ntry { \nString serializedMessage = messageMarshaller . serialize ( message ) ; \nif ( ! ( queue == null ) ) { \nqueue . add ( serializedMessage ) ; \n} \nelse { \nSendMessageRequest request = new SendMessageRequest ( queueUrl , serializedMessage ) ; \nSendMessageResult result = sqsClient . sendMessage ( request ) ; \nlog . debug ( \"Message sent, Id:\" + result . getMessageId ( ) ) ; \n} \n} \ncatch ( MessageMarshallerException e ) { \nlog . error ( e . getMessage ( ) , e ) ; \nthrow new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn message . getPayload ( ) ; \n} \n} \n"}
{"8467": "public class SnsExecutor { \npublic Object executeOutboundOperation ( final Message < ? > message ) { \ntry { \nString serializedMessage = messageMarshaller . serialize ( message ) ; \nif ( ! ( snsTestProxy == null ) ) { \nsnsTestProxy . dispatchMessage ( serializedMessage ) ; \n} \nelse { \nPublishRequest request = new PublishRequest ( ) ; \nPublishResult result = client . publish ( request . withTopicArn ( topicArn ) . withMessage ( serializedMessage ) ) ; \nlog . debug ( \"Published message to topic: \" + result . getMessageId ( ) ) ; \n} \n} \ncatch ( MessageMarshallerException e ) { \nlog . error ( e . getMessage ( ) , e ) ; \nthrow new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn message . getPayload ( ) ; \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( int i = 0 ; \ni < keys . size ( ) ; \n++ i ) { \nfinal String key = keys . get ( i ) ; \nif ( ! ( i >= contextValuesLength ) ) { \nfinal Object value = values . get ( i ) ; \nif ( ! ( isSimpleType ( value ) ) ) { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \nelse { \njsonGenerator . writeObjectField ( key , value ) ; \n} \n} \nelse { \njsonGenerator . writeObjectField ( key , null ) ; \n} \n} \n} \n} \n} \n"}
{"8488": "public class SafeSerializationHelper { \npublic static void safeEncodeValue ( final StringBuilder encoder , @ Nullable final Object value ) { \nif ( ! ( value == null ) ) if ( ! ( value instanceof Map ) ) if ( ! ( value instanceof List ) ) if ( ! ( value . getClass ( ) . isArray ( ) ) ) if ( ! ( value instanceof LogValueMapFactory . LogValueMap ) ) if ( ! ( value instanceof Throwable ) ) if ( ! ( StenoSerializationHelper . isSimpleType ( value ) ) ) { \nsafeEncodeValue ( encoder , LogReferenceOnly . of ( value ) . toLogValue ( ) ) ; \n} \nelse { \nif ( ! ( value instanceof Boolean ) ) if ( ! ( value instanceof Double ) ) if ( ! ( value instanceof Float ) ) if ( ! ( value instanceof Long ) ) if ( ! ( value instanceof Integer ) ) { \nencoder . append ( new TextNode ( value . toString ( ) ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( IntNode . valueOf ( ( Integer ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( LongNode . valueOf ( ( Long ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( FloatNode . valueOf ( ( Float ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( DoubleNode . valueOf ( ( Double ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( BooleanNode . valueOf ( ( Boolean ) value ) . toString ( ) ) ; \n} \n} \nelse { \nsafeEncodeThrowable ( encoder , ( Throwable ) value ) ; \n} \nelse { \nsafeEncodeLogValueMap ( encoder , ( LogValueMapFactory . LogValueMap ) value ) ; \n} \nelse { \nsafeEncodeArray ( encoder , value ) ; \n} \nelse { \nsafeEncodeList ( encoder , ( List < ? > ) value ) ; \n} \nelse { \nsafeEncodeMap ( encoder , ( Map < ? , ? > ) value ) ; \n} \nelse { \nencoder . append ( \"null\" ) ; \n} \n} \n} \n"}
{"8501": "public class TieSheetNumberConverter { \nprivate String fmtNumber ( final double d ) { \nif ( ! ( Double . compare ( d % 1 , 0 ) == 0 ) ) { \nreturn String . format ( \"%.2f\" , d ) ; \n} \nelse { \nreturn String . format ( \"%d\" , ( int ) d ) ; \n} \n} \n} \n"}
{"8517": "public class TieWebSheetPicturesService { \npublic StreamedContent getPicture ( ) { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nif ( ! ( context . getCurrentPhaseId ( ) == PhaseId . RENDER_RESPONSE ) ) { \nString pictureId = context . getExternalContext ( ) . getRequestParameterMap ( ) . get ( \"pictureViewId\" ) ; \nPictureData picData = ( PictureData ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . get ( pictureId ) ; \nFacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . remove ( pictureId ) ; \nLOG . fine ( \" return real picture and remove session\" ) ; \nreturn new DefaultStreamedContent ( new ByteArrayInputStream ( picData . getData ( ) ) ) ; \n} \nelse { \nLOG . fine ( \" return empty picture\" ) ; \nreturn new DefaultStreamedContent ( ) ; \n} \n} \n} \n"}
{"8527": "public class ShiftFormulaUtility { \nprivate static List < SerialRow > assembleRowsListFromRowsMapping ( final List < SerialRow > all , final List < SerialRow > current ) { \nList < SerialRow > list ; \nif ( ! ( all == null ) ) { \nlist = all ; \nfor ( SerialRow row : current ) { \nif ( ! all . contains ( row ) ) { \nlist . add ( row ) ; \n} \n} \n} \nelse { \nlist = new ArrayList < > ( ) ; \nlist . addAll ( current ) ; \n} \nreturn list ; \n} \n} \n"}
{"8528": "public class ShiftFormulaUtility { \nprotected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { \nif ( ! ( ptg instanceof RefPtgBase ) ) { \nif ( ! ( ptg instanceof Area3DPxg ) ) { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nint shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; \nreturn new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nelse { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nint shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; \nnew3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; \nnew3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \n} \nelse { \nif ( ! ( ptg instanceof Ref3DPxg ) ) { \nRefPtgBase refPtgBase = ( RefPtgBase ) ptg ; \nreturn new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nelse { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \n} \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( ! ( refPtg instanceof Ref3DPxg ) ) { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nelse { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ! ( ptg instanceof Area3DPxg ) ) { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nelse { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8531": "public class ColorUtility { \npublic static XColor getBgColor ( final CTPlotArea ctPlot , final ThemesTable themeTable ) { \nCTSolidColorFillProperties colorFill = null ; \ntry { \ncolorFill = ctPlot . getSpPr ( ) . getSolidFill ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No entry in bgcolor for solidFill\" , ex ) ; \n} \nXColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; \nif ( ! ( xcolor != null ) ) { \nreturn new XColor ( new XSSFColor ( Color . WHITE ) ) ; \n} \nelse { \nreturn xcolor ; \n} \n} \n} \n"}
{"8532": "public class ColorUtility { \npublic static XColor geColorFromSpPr ( final int index , final CTShapeProperties ctSpPr , final ThemesTable themeTable , final boolean isLineColor ) { \nCTSolidColorFillProperties colorFill = null ; \ntry { \nif ( ! ( isLineColor ) ) { \ncolorFill = ctSpPr . getSolidFill ( ) ; \n} \nelse { \ncolorFill = ctSpPr . getLn ( ) . getSolidFill ( ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No entry for solidFill\" , ex ) ; \n} \nXColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; \nif ( ! ( xcolor != null ) ) { \nreturn getXColorWithAutomaticFill ( index , themeTable ) ; \n} \nelse { \nreturn xcolor ; \n} \n} \n} \n"}
{"8533": "public class ColorUtility { \nprivate static XColor findAutomaticFillColor ( final ThemesTable themeTable , final CTSolidColorFillProperties colorFill ) { \nif ( colorFill == null ) { \nreturn null ; \n} \nCTSchemeColor ctsColor = colorFill . getSchemeClr ( ) ; \nif ( ! ( ctsColor != null ) ) { \nCTSRgbColor ctrColor = colorFill . getSrgbClr ( ) ; \nif ( ctrColor != null ) { \nreturn getXColorFromRgbClr ( ctrColor ) ; \n} \n} \nelse { \nreturn getXColorFromSchemeClr ( ctsColor , themeTable ) ; \n} \nreturn null ; \n} \n} \n"}
{"8539": "public class ColorUtility { \nstatic String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { \nString style = \"\" ; \nif ( ! ( poiCell instanceof HSSFCell ) ) if ( poiCell instanceof XSSFCell ) { \nXSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; \nif ( color != null ) { \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , \",\" ) + \");\" ; \n} \n} \nelse { \nint bkColorIndex = cellStyle . getFillForegroundColor ( ) ; \nHSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; \nif ( color != null ) { \nHSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; \nHSSFColor color2 = palette . getColor ( bkColorIndex ) ; \nif ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) { \ncolor = color2 ; \n} \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( color . getTriplet ( ) , \",\" ) + \");\" ; \n} \n} \nreturn style ; \n} \n} \n"}
{"8543": "public class CellControlsUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nString methodName = \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; \nAttributesType parameterType = matchParaMeterOfMethod ( obj , methodName ) ; \nif ( parameterType != null ) { \nMethod method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { \nparameterType . clazz } \n) ; \nmethod . invoke ( obj , convertToObject ( parameterType , propertyValue ) ) ; \n} \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ! ( ignoreNonExisting ) ) { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \nelse { \nLOG . log ( Level . FINE , msg , e ) ; \n} \n} \n} \n} \n"}
{"8544": "public class CellControlsUtility { \npublic static String getObjectPropertyValue ( final Object obj , final String propertyName , final boolean ignoreNonExisting ) { \ntry { \nMethod method = obj . getClass ( ) . getMethod ( \"get\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ) ; \nreturn ( String ) method . invoke ( obj ) ; \n} \ncatch ( Exception e ) { \nString msg = \"failed to get property '\" + propertyName + \"' for object \" + obj ; \nif ( ! ( ignoreNonExisting ) ) { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \nelse { \nLOG . log ( Level . FINE , msg , e ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8552": "public class ChartHelper { \npublic final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { \nif ( chart != null && style != null ) { \nBasicStroke stroke = ChartUtility . toStroke ( style ) ; \nPlot plot = chart . getPlot ( ) ; \nif ( ! ( plot instanceof CategoryPlot ) ) if ( ! ( plot instanceof XYPlot ) ) { \nLOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; \n} \nelse { \nXYPlot xyPlot = chart . getXYPlot ( ) ; \nXYItemRenderer xyir = xyPlot . getRenderer ( ) ; \ntry { \nxyir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse { \nCategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; \nCategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; \ntry { \ncir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < ( parts . length - 1 ) ; \ni ++ ) { \nif ( ! ( i == 0 ) ) { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( int i = startRowIndex ; \ni <= sheet . getLastRowNum ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ! ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) ) { \nreturn ; \n} \nelse { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \n} \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nfor ( int i = 1 ; \ni < parts . length - 1 ; \ni ++ ) { \nString part = parts [ i ] ; \nif ( ! ( fullName . length ( ) == 0 ) ) { \nfullName . append ( \":\" + part ) ; \n} \nelse { \nfullName . append ( part ) ; \n} \nif ( fullName . length ( ) > 0 ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) { \nrowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8572": "public class ConfigurationUtility { \npublic static List < RowsMapping > findChildRowsMappingFromShiftMap ( final String fullName , final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nNavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap . tailMap ( fullName , false ) ; \nfor ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap . entrySet ( ) ) { \nString key = entry . getKey ( ) ; \nif ( ! ( key . startsWith ( fullName ) ) ) { \nbreak ; \n} \nelse { \nrowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8577": "public class ConfigurationUtility { \npublic static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { \nint ibegin = 0 ; \nint ifind ; \nint inameEnd ; \nString tempStr ; \nString findStr ; \nString replaceStr ; \nString returnStr = attrValue ; \nwhile ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { \ninameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; \nif ( ! ( inameEnd > 0 ) ) { \nfindStr = attrValue . substring ( ifind ) ; \n} \nelse { \nfindStr = attrValue . substring ( ifind , inameEnd ) ; \n} \nif ( ! ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) ) { \ntempStr = findStr ; \n} \nelse { \ntempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; \n} \nreplaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; \nif ( replaceStr == null ) { \nreplaceStr = \"\" ; \n} \nreturnStr = attrValue . replace ( findStr , replaceStr ) ; \nibegin = ifind + 1 ; \n} \nreturn returnStr ; \n} \n} \n"}
{"8585": "public class ConfigurationHandler { \nprivate FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { \nint firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nint lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; \nCell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nFormCommand fcommand = new FormCommand ( ) ; \nfcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; \nif ( ! ( sheetConfig . isHidden ( ) ) ) { \nfcommand . setHidden ( TieConstants . FALSE_STRING ) ; \n} \nelse { \nfcommand . setHidden ( TieConstants . TRUE_STRING ) ; \n} \nfcommand . setName ( sheetConfig . getFormName ( ) ) ; \nfcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; \nfcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; \nfcommand . setHeaderLength ( \"0\" ) ; \nfcommand . setFooterLength ( \"0\" ) ; \nfcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; \nreturn fcommand ; \n} \n} \n"}
{"8594": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { \nComment comment = cell . getCellComment ( ) ; \nString text = comment . getString ( ) . getString ( ) ; \nString [ ] commentLines = text . split ( \"\\\\n\" ) ; \nStringBuilder newComment = new StringBuilder ( ) ; \nboolean changed = false ; \nfor ( String commentLine : commentLines ) { \nString line = commentLine . trim ( ) ; \nif ( ! ( ParserUtility . isCommandString ( line ) ) ) if ( ! ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) ) { \nif ( ! ( newComment . length ( ) > 0 ) ) { \nnewComment . append ( commentLine ) ; \n} \nelse { \nnewComment . append ( \"\\\\n\" + commentLine ) ; \n} \n} \nelse { \nprocessMethodLine ( cell , line , cellAttributesMap ) ; \nchanged = true ; \n} \nelse { \nprocessCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; \nchanged = true ; \n} \n} \nif ( ! ( ! changed ) ) { \nif ( ! ( newComment . length ( ) > 0 ) ) { \ncell . removeCellComment ( ) ; \n} \nelse { \nmoveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nRichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; \ncomment . setString ( str ) ; \n} \n} \nelse { \nmoveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \n} \nreturn cList ; \n} \n} \n"}
{"8595": "public class ConfigurationHandler { \nprivate void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { \nif ( ! ( ParserUtility . isWidgetMethodString ( line ) ) ) if ( ! ( ParserUtility . isValidateMethodString ( line ) ) ) { \nmoveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; \n} \nelse { \nParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; \n} \nelse { \nParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; \n} \n} \n} \n"}
{"8601": "public class ConfigurationHandler { \nprivate void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( ! ( fcommand . calcFooterLength ( ) == 0 ) ) { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \n} \nelse { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \n} \nsheetConfig . setFormFooterRange ( tempStr ) ; \nsheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; \n} \n} \n"}
{"8603": "public class ConfigurationHandler { \nprivate void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( ! ( fcommand . calcHeaderLength ( ) == 0 ) ) { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \n} \nelse { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \n} \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \n} \n} \n"}
{"8618": "public class CommandUtility { \npublic static boolean evalBoolExpression ( final ExpressionEngine expEngine , final String pscript ) { \nObject result = null ; \nString script = \"( \" + pscript + \" )\" ; \nscript = script . toUpperCase ( ) . replace ( \"AND\" , \"&&\" ) ; \nscript = script . toUpperCase ( ) . replace ( \"OR\" , \"||\" ) ; \ntry { \nresult = expEngine . evaluate ( script ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"WebForm WebFormHelper evalBoolExpression script = \" + script + \"; error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nif ( ! ( result != null ) ) { \nreturn false ; \n} \nelse { \nreturn ( ( Boolean ) result ) . booleanValue ( ) ; \n} \n} \n} \n"}
{"8623": "public class CellMap { \nprivate String loadPicture ( final int rowIndex , final int colIndex ) { \nFacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; \nif ( ! ( facesCell != null && facesCell . isContainPic ( ) ) ) { \nreturn null ; \n} \nelse { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nString pictureId = facesCell . getPictureId ( ) ; \nString pictureViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + pictureId ; \nMap < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; \nif ( sessionMap . get ( pictureViewId ) == null ) { \nsessionMap . put ( pictureViewId , parent . getPicturesMap ( ) . get ( pictureId ) . getPictureData ( ) ) ; \n} \nreturn pictureViewId ; \n} \n} \n} \n"}
{"8624": "public class CellMap { \nprivate String loadChart ( final int rowIndex , final int colIndex ) { \nFacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; \nif ( ! ( facesCell != null && facesCell . isContainChart ( ) ) ) { \nreturn null ; \n} \nelse { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nString chartId = facesCell . getChartId ( ) ; \nString chartViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + chartId ; \nif ( context != null ) { \nMap < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; \nif ( sessionMap . get ( chartViewId ) == null ) { \nsessionMap . put ( chartViewId , parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ) ; \n} \n} \nreturn chartViewId ; \n} \n} \n} \n"}
{"8625": "public class CellMap { \nprivate String assembleNewValue ( final Object value , final FacesCell facesCell ) { \nString newValue ; \nif ( ! ( value instanceof java . util . Date ) ) { \nnewValue = ( String ) value ; \n} \nelse { \nString datePattern = facesCell . getDatePattern ( ) ; \nif ( datePattern == null || datePattern . isEmpty ( ) ) { \ndatePattern = parent . getDefaultDatePattern ( ) ; \n} \nFormat formatter = new SimpleDateFormat ( datePattern ) ; \nnewValue = formatter . format ( value ) ; \n} \nif ( \"textarea\" . equalsIgnoreCase ( facesCell . getInputType ( ) ) && ( newValue != null ) ) { \nnewValue = newValue . replace ( \"\\r\\n\" , \"\\n\" ) ; \n} \nreturn newValue ; \n} \n} \n"}
{"8626": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithFormat ( final Cell poiCell , final FormulaEvaluator formulaEvaluator , final DataFormatter dataFormatter ) { \nif ( poiCell == null ) { \nreturn null ; \n} \nString result ; \ntry { \nCellType cellType = poiCell . getCellTypeEnum ( ) ; \nif ( cellType == CellType . FORMULA ) { \ncellType = formulaEvaluator . evaluate ( poiCell ) . getCellTypeEnum ( ) ; \n} \nif ( ! ( cellType == CellType . ERROR ) ) { \nresult = dataFormatter . formatCellValue ( poiCell , formulaEvaluator ) ; \n} \nelse { \nresult = \"\" ; \n} \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Web Form WebFormHelper getCellValue Error row = \" + poiCell . getRowIndex ( ) + \" column = \" + poiCell . getColumnIndex ( ) + \" error = \" + e . getLocalizedMessage ( ) + \"; Change return result to blank\" , e ) ; \nresult = \"\" ; \n} \nreturn result ; \n} \n} \n"}
{"8627": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithoutFormat ( final Cell poiCell ) { \nif ( poiCell == null ) { \nreturn null ; \n} \nif ( ! ( poiCell . getCellTypeEnum ( ) == CellType . FORMULA ) ) { \nreturn getCellStringValueWithType ( poiCell , poiCell . getCellTypeEnum ( ) ) ; \n} \nelse { \nreturn getCellStringValueWithType ( poiCell , poiCell . getCachedFormulaResultTypeEnum ( ) ) ; \n} \n} \n} \n"}
{"8629": "public class CellUtility { \nprivate static String getCellStringValueWithNumberType ( final Cell poiCell ) { \nString result ; \nif ( ! ( DateUtil . isCellDateFormatted ( poiCell ) ) ) { \nresult = BigDecimal . valueOf ( poiCell . getNumericCellValue ( ) ) . toPlainString ( ) ; \nif ( result . endsWith ( \".0\" ) ) { \nresult = result . substring ( 0 , result . length ( ) - 2 ) ; \n} \n} \nelse { \nresult = poiCell . getDateCellValue ( ) . toString ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"8630": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static Cell setCellValue ( final Cell c , final String value ) { \ntry { \nif ( ! ( value . length ( ) == 0 ) ) if ( ! ( WebSheetUtility . isNumeric ( value ) ) ) if ( ! ( WebSheetUtility . isDate ( value ) ) ) if ( ! ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) ) { \nsetCellValueString ( c , value ) ; \n} \nelse { \nsetCellValueBoolean ( c , value ) ; \n} \nelse { \nsetCellValueDate ( c , value ) ; \n} \nelse { \nsetCellValueNumber ( c , value ) ; \n} \nelse { \nc . setCellType ( CellType . BLANK ) ; \n} \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \" error in setCellValue of CellUtility = \" + e . getLocalizedMessage ( ) , e ) ; \nsetCellValueString ( c , value ) ; \n} \nreturn c ; \n} \n} \n"}
{"8632": "public class CellUtility { \nprivate static void setCellValueBoolean ( final Cell c , final String value ) { \nif ( ! ( \"Y\" . equalsIgnoreCase ( value ) || \"Yes\" . equalsIgnoreCase ( value ) || \"True\" . equalsIgnoreCase ( value ) ) ) { \nc . setCellValue ( false ) ; \n} \nelse { \nc . setCellValue ( true ) ; \n} \n} \n} \n"}
{"8642": "public class CellUtility { \npublic static void createOrInsertComment ( final Cell cell , final String commentStr ) { \nXSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nComment comment = cell . getCellComment ( ) ; \nString originStr = \"\" ; \nif ( ! ( comment == null ) ) { \noriginStr = comment . getString ( ) . getString ( ) + \"\\n\" ; \n} \nelse { \nClientAnchor anchor = createCommentAnchor ( cell , factory ) ; \ncomment = drawing . createCellComment ( anchor ) ; \n} \noriginStr += commentStr ; \nRichTextString str = factory . createRichTextString ( originStr ) ; \ncomment . setString ( str ) ; \ncomment . setAuthor ( \"\" ) ; \ncell . setCellComment ( comment ) ; \ncomment . setColumn ( cell . getColumnIndex ( ) ) ; \ncomment . setRow ( cell . getRowIndex ( ) ) ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nif ( ! ( i > 0 ) ) { \nsb . append ( list . get ( i ) ) ; \n} \nelse { \nsb . append ( \":\" + list . get ( i ) ) ; \n} \n} \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8663": "public class ChartUtility { \npublic static BasicStroke toStroke ( final String style ) { \nBasicStroke result = null ; \nif ( style != null ) { \nfloat lineWidth = STROKE_DEFAULT_LINE_WIDTH ; \nfloat [ ] dash = { \nSTROKE_DEFAULT_DASH_WIDTH } \n; \nfloat [ ] dot = { \nlineWidth } \n; \nif ( ! ( style . equalsIgnoreCase ( STYLE_LINE ) ) ) if ( ! ( style . equalsIgnoreCase ( STYLE_DASH ) ) ) if ( style . equalsIgnoreCase ( STYLE_DOT ) ) { \nresult = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ; \n} \nelse { \nresult = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DASH , dash , STROKE_DEFAULT_DASHPHASE ) ; \n} \nelse { \nresult = new BasicStroke ( lineWidth ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"8681": "public class ConfigRange { \npublic final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { \nif ( ! ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) ) { \nthis . attrs . setLastRowPlusRef ( null ) ; \nif ( alsoSetAddr ) { \nthis . attrs . setLastRowPlusAddr ( null ) ; \n} \n} \nelse { \nRow row = sheet . getRow ( lastRow + 1 ) ; \nif ( row == null ) { \nrow = sheet . createRow ( lastRow + 1 ) ; \n} \nCell cell = row . getCell ( rightCol ) ; \nif ( ! ( cell == null ) ) { \nthis . attrs . setLastCellCreated ( false ) ; \n} \nelse { \ncell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nthis . attrs . setLastCellCreated ( true ) ; \n} \nthis . attrs . setLastRowPlusRef ( cell ) ; \nif ( alsoSetAddr ) { \nthis . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; \n} \n} \n} \n} \n"}
{"8690": "public class SheetConfiguration { \npublic final void setCommandIndexMap ( final Map < String , Command > pcommandIndexMap ) { \nif ( ! ( pcommandIndexMap instanceof HashMap ) ) { \nthis . commandIndexMap = new HashMap < > ( ) ; \nthis . commandIndexMap . putAll ( pcommandIndexMap ) ; \n} \nelse { \nthis . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; \n} \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ! ( ( cell != null ) && ( fcell != null ) ) ) { \nfor ( short col = anchor . getCol1 ( ) ; \ncol < anchor . getCol2 ( ) ; \ncol ++ ) { \npicWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \nfor ( int rowindex = anchor . getRow1 ( ) ; \nrowindex < anchor . getRow2 ( ) ; \nrowindex ++ ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \n} \nelse { \nfor ( int col = cell . getColumnIndex ( ) ; \ncol < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; \ncol ++ ) { \ncellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( int rowIndex = cell . getRowIndex ( ) ; \nrowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; \nrowIndex ++ ) { \ncellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8698": "public class TieWebSheetChartsService { \npublic StreamedContent getChart ( ) throws IOException { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nif ( ! ( context . getCurrentPhaseId ( ) == PhaseId . RENDER_RESPONSE ) ) { \nString chartId = context . getExternalContext ( ) . getRequestParameterMap ( ) . get ( \"chartViewId\" ) ; \nBufferedImage bufferedImg = ( BufferedImage ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . get ( chartId ) ; \nByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; \nImageIO . write ( bufferedImg , \"png\" , os ) ; \nFacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . remove ( chartId ) ; \nreturn new DefaultStreamedContent ( new ByteArrayInputStream ( os . toByteArray ( ) ) , \"image/png\" ) ; \n} \nelse { \nLOG . fine ( \" return empty chart picture\" ) ; \nreturn new DefaultStreamedContent ( ) ; \n} \n} \n} \n"}
{"8705": "public class CellStyleUtility { \npublic static String getColumnStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { \nString inputType = fcell . getInputType ( ) ; \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nStringBuilder webStyle = new StringBuilder ( ) ; \nif ( ! ( cellStyle != null ) ) { \nwebStyle . append ( getAlignmentFromCellType ( poiCell ) ) ; \n} \nelse { \nif ( ! ( fcell . isContainPic ( ) || fcell . isContainChart ( ) ) ) { \nwebStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; \nwebStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; \n} \nelse { \nwebStyle . append ( \"vertical-align: top;\" ) ; \n} \nwebStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , cellStyle ) ) ; \nwebStyle . append ( getRowStyle ( wb , poiCell , inputType , rowHeight , fcell . getRowspan ( ) ) ) ; \n} \nreturn webStyle . toString ( ) ; \n} \n} \n"}
{"8710": "public class CellStyleUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static String getInputTypeFromCellType ( final Cell cell ) { \nString inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; \nif ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { \ninputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; \n} \nCellStyle style = cell . getCellStyle ( ) ; \nif ( style != null ) { \nint formatIndex = style . getDataFormat ( ) ; \nString formatString = style . getDataFormatString ( ) ; \nif ( ! ( DateUtil . isADateFormat ( formatIndex , formatString ) ) ) { \nif ( isAPercentageCell ( formatString ) ) { \ninputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; \n} \n} \nelse { \ninputType = TieConstants . CELL_INPUT_TYPE_DATE ; \n} \n} \nreturn inputType ; \n} \n} \n"}
{"8714": "public class FacesUtility { \npublic static boolean evalInputType ( final String input , final String type ) { \nScanner scanner = new Scanner ( input ) ; \nboolean ireturn = false ; \nif ( ! ( \"Integer\" . equalsIgnoreCase ( type ) ) ) if ( ! ( \"Double\" . equalsIgnoreCase ( type ) ) ) if ( ! ( \"Boolean\" . equalsIgnoreCase ( type ) ) ) if ( ! ( \"Byte\" . equalsIgnoreCase ( type ) ) ) if ( type . toLowerCase ( ) . startsWith ( \"text\" ) ) { \nireturn = true ; \n} \nelse { \nireturn = scanner . hasNextByte ( ) ; \n} \nelse { \nireturn = scanner . hasNextBoolean ( ) ; \n} \nelse { \nireturn = scanner . hasNextDouble ( ) ; \n} \nelse { \nireturn = scanner . hasNextInt ( ) ; \n} \nscanner . close ( ) ; \nreturn ireturn ; \n} \n} \n"}
{"8718": "public class TieWebSheetView { \npublic String getTabType ( ) { \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ! ( ( sheetId >= 0 ) && ( tabs != null ) ) ) { \ntabType = TieConstants . TAB_TYPE_NONE ; \n} \nelse { \nif ( sheetId >= tabs . size ( ) ) { \nsheetId = 0 ; \n} \ntabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; \n} \nreturn tabType ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \nfor ( int i = startPos ; \ni < str . length ( ) ; \ni ++ ) { \nchar current = str . charAt ( i ) ; \nif ( ! ( current == TieConstants . EL_START_BRACKET ) ) if ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( bracketNum <= 0 ) { \nreturn i ; \n} \n} \nelse { \nbracketNum ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( ! ( c < '0' || c > '9' ) ) { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \nelse { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8750": "public class WebSheetUtility { \nprivate static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { \nif ( ! ( c == '.' && ! para . isDecimalHit ( ) ) ) if ( c == ',' && ! para . isDecimalHit ( ) ) { \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \npara . setSinceLastComma ( 0 ) ; \n} \npara . setCommaHit ( true ) ; \nreturn true ; \n} \nelse { \npara . setDecimalHit ( true ) ; \nif ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"8751": "public class WebSheetUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nMethod method = obj . getClass ( ) . getMethod ( \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) , new Class [ ] { \nString . class } \n) ; \nmethod . invoke ( obj , propertyValue ) ; \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ! ( ignoreNonExisting ) ) { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \nelse { \nLOG . info ( msg ) ; \n} \n} \n} \n} \n"}
{"8759": "public class ValidationHandler { \npublic boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { \nboolean submitMode = parent . getSubmitMode ( ) ; \nboolean passEmptyCheck = ! submitMode ; \nint topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nboolean pass = true ; \nFacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; \nif ( fRow == null ) { \nreturn pass ; \n} \nFacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; \nif ( cell == null ) { \nreturn pass ; \n} \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; \nboolean oldStatus = cell . isInvalid ( ) ; \nString value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; \nif ( ! ( value == null ) ) { \nvalue = value . trim ( ) ; \n} \nelse { \nvalue = \"\" ; \n} \nif ( passEmptyCheck && value . isEmpty ( ) ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \nif ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { \nreturn false ; \n} \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nList < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; \nif ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { \nreturn false ; \n} \nif ( cellAttributes != null ) { \npass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; \n} \nif ( pass ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \n} \nreturn pass ; \n} \n} \n"}
{"8763": "public class ValidationHandler { \nprivate boolean doValidation ( final Object value , final CellFormAttributes attr , final int rowIndex , final int colIndex , final Sheet sheet ) { \nboolean pass ; \nString attrValue = attr . getValue ( ) ; \nattrValue = attrValue . replace ( \"$value\" , value . toString ( ) + \"\" ) . replace ( \"$rowIndex\" , rowIndex + \"\" ) . replace ( \"$colIndex\" , colIndex + \"\" ) . replace ( \"$sheetName\" , sheet . getSheetName ( ) ) ; \nattrValue = ConfigurationUtility . replaceExpressionWithCellValue ( attrValue , rowIndex , sheet ) ; \nif ( ! ( attrValue . contains ( TieConstants . EL_START ) ) ) { \npass = parent . getCellHelper ( ) . evalBoolExpression ( attrValue ) ; \n} \nelse { \nObject returnObj = FacesUtility . evaluateExpression ( attrValue , Object . class ) ; \nattrValue = returnObj . toString ( ) ; \npass = Boolean . parseBoolean ( attrValue ) ; \n} \nreturn pass ; \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( ! ( top < 0 ) ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( int i = top ; \ni <= bottom ; \ni ++ ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \n} \nparent . setShowLineNumber ( false ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \n} \n} \n"}
{"8779": "public class WebSheetLoader { \nprivate String getColumnWidthStyle ( final Sheet sheet1 , final Map < String , CellRangeAddress > cellRangeMap , final String cellindex , final int cindex , final double totalWidth ) { \nCellRangeAddress caddress = cellRangeMap . get ( cellindex ) ; \ndouble colWidth ; \nif ( ! ( caddress != null ) ) { \ncolWidth = sheet1 . getColumnWidth ( cindex ) ; \n} \nelse { \ncolWidth = CellStyleUtility . calcTotalWidth ( sheet1 , caddress . getFirstColumn ( ) , caddress . getLastColumn ( ) , 0 ) ; \n} \nreturn getWidthStyle ( colWidth , totalWidth ) ; \n} \n} \n"}
{"8791": "public class WebSheetLoader { \nprivate void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , final boolean allowAdd ) { \nfacesRow . setAllowAdd ( allowAdd ) ; \nif ( ! ( row != null ) ) { \nfacesRow . setRendered ( true ) ; \nfacesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; \nfacesRow . setOriginRowIndex ( rowIndex ) ; \n} \nelse { \nfacesRow . setRendered ( ! row . getZeroHeight ( ) ) ; \nfacesRow . setRowheight ( row . getHeight ( ) ) ; \nint rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nfacesRow . setOriginRowIndex ( rowNum ) ; \n} \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) ) { \nbodycells . add ( null ) ; \n} \nelse { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nif ( ! ( cell != null ) ) { \nbodycells . add ( null ) ; \n} \nelse { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \n} \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8804": "public class CacheEntry { \nprotected final void writeString ( final Writer writer , final String line ) throws IOException { \nif ( ! ( line != null ) ) { \nwriter . write ( '\\n' ) ; \n} \nelse { \nwriter . write ( line + '\\n' ) ; \n} \n} \n} \n"}
{"8841": "public class BaseFileResponseCache { \nprivate synchronized File ensureWorkingDirectory ( ) throws IOException { \nFile directory = getWorkingDirectory ( ) ; \nif ( ! ( ! directory . exists ( ) ) ) { \nif ( ! directory . isDirectory ( ) ) { \nif ( ! directory . delete ( ) ) { \nthrow new IOException ( directory + \" is not a directory and cannot be deleted\" ) ; \n} \nif ( ! directory . mkdirs ( ) ) { \nthrow new IOException ( \"Working directory \" + directory + \" cannot be recreated\" ) ; \n} \n} \n} \nelse { \nif ( ! directory . mkdirs ( ) ) { \nthrow new IOException ( \"Working directory \" + directory + \" cannot be created\" ) ; \n} \n} \nreturn directory ; \n} \n} \n"}
{"8858": "public class GUIUtils { \npublic static void setTextOrHide ( final TextView view , final CharSequence text , final int hvisibility ) { \nif ( ! ( TextUtils . isEmpty ( text ) ) ) { \nview . setText ( text ) ; \nview . setVisibility ( View . VISIBLE ) ; \n} \nelse { \nview . setVisibility ( hvisibility ) ; \n} \n} \n} \n"}
{"8865": "public class ImagesManager { \npublic void populateImage ( final View view , final String url ) { \nfinal Object tag = view . getTag ( ) ; \nImageConsumer consumer = null ; \nif ( ! ( tag == null ) ) { \nif ( ! ( tag instanceof ImageConsumer ) ) { \nthrow new IllegalStateException ( \"View already has a tag \" + tag + \". Cannot store consumer\" ) ; \n} \nconsumer = ( ImageConsumer ) tag ; \n} \nelse { \nconsumer = createImageConsumer ( view ) ; \nview . setTag ( consumer ) ; \n} \npopulateImage ( consumer , url ) ; \n} \n} \n"}
{"8870": "public class ImagesManager { \nprivate void startImageLoaderTask ( final ImageConsumer consumer , final ImageRequest request ) { \nfinal String key = request . getKey ( ) ; \nif ( debug ) { \nLog . d ( TAG , \"Key \" + key ) ; \n} \nImageLoader loader = currentLoads . get ( key ) ; \nif ( loader != null ) { \nfinal boolean added = loader . addTarget ( consumer ) ; \nif ( ! added ) { \nloader = null ; \n} \n} \nif ( ! ( loader == null ) ) if ( debug ) { \nLog . d ( TAG , \"Joined to the existing task \" + key ) ; \n} \nelse { \nif ( debug ) { \nLog . d ( TAG , \"Start a new task\" ) ; \n} \nloader = new ImageLoader ( request , this ) ; \nif ( ! loader . addTarget ( consumer ) ) { \nthrow new IllegalStateException ( \"Cannot add target to the new loader\" ) ; \n} \ncurrentLoads . put ( key , loader ) ; \nif ( debug ) { \nLog . d ( TAG , \"Current loaders count: \" + currentLoads . size ( ) ) ; \n} \nfinal Executor executor = getImageTaskExecutor ( ) ; \nexecutor . execute ( loader . future ) ; \n} \n} \n} \n"}
{"8875": "public class CacheControlUrlConnection { \nprivate void connectWithWorkaround ( ) throws IOException { \nif ( Build . VERSION . SDK_INT > Build . VERSION_CODES . GINGERBREAD_MR1 ) { \nsuper . connect ( ) ; \nreturn ; \n} \nURLConnection coreConnection = UrlConnectionWrapper . unwrap ( getCore ( ) ) ; \nif ( ! ( coreConnection instanceof HttpsURLConnection ) ) { \nsuper . connect ( ) ; \n} \nelse { \ntry { \nsuper . connect ( ) ; \n} \ncatch ( NullPointerException e ) { \n} \n} \n} \n} \n"}
{"8893": "public class Config { \npublic static ConnectionConfig getConnectionConfig ( ) { \nboolean isValid = true ; \nString appdUsername = getPropertyOrEnv ( \"com.signalfx.appd.username\" , \"APPD_USERNAME\" ) ; \nif ( StringUtils . isEmpty ( appdUsername ) ) { \nlog . error ( \"AppDynamics username not specified.\" ) ; \nisValid = false ; \n} \nString appdPassword = getPropertyOrEnv ( \"com.signalfx.appd.password\" , \"APPD_PASSWORD\" ) ; \nif ( StringUtils . isEmpty ( appdPassword ) ) { \nlog . error ( \"AppDynamics password not specified.\" ) ; \nisValid = false ; \n} \nString appdURL = getPropertyOrEnv ( \"com.signalfx.appd.host\" , \"APPD_HOST\" ) ; \nif ( StringUtils . isEmpty ( appdURL ) ) { \nlog . error ( \"AppDynamics host not specified.\" ) ; \nisValid = false ; \n} \nString fxToken = getPropertyOrEnv ( \"com.signalfx.api.token\" , \"SIGNALFX_TOKEN\" ) ; \nif ( StringUtils . isEmpty ( fxToken ) ) { \nlog . error ( \"SignalFx token not specified.\" ) ; \nisValid = false ; \n} \nif ( ! ( isValid ) ) { \nreturn null ; \n} \nelse { \nreturn new ConnectionConfig ( appdUsername , appdPassword , appdURL , fxToken ) ; \n} \n} \n} \n"}
{"8894": "public class ReportAppD { \npublic void perform ( List < AppInfo > apps , MetricDataRequest . TimeParams timeParams ) { \nList < SignalFxProtocolBuffers . DataPoint > dataPoints = new LinkedList < > ( ) ; \nfor ( AppInfo app : apps ) { \ndataRequest . setAppName ( app . name ) ; \nfor ( MetricInfo metricInfo : app . metrics ) { \ndataRequest . setTimeParams ( timeParams ) ; \ndataRequest . setMetricPath ( metricInfo . metricPathQuery ) ; \nList < MetricData > metricDataList ; \ntry { \nmetricDataList = dataRequest . get ( ) ; \n} \ncatch ( RequestException e ) { \nlog . error ( \"Metric query failure for \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \ncounterAppDRequestFailure . inc ( ) ; \ncontinue ; \n} \ncatch ( UnauthorizedException e ) { \nlog . error ( \"AppDynamics authentication failed\" ) ; \nreturn ; \n} \nif ( ! ( metricDataList != null && metricDataList . size ( ) > 0 ) ) { \nlog . warn ( \"No metric found for query \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \n} \nelse { \nfor ( MetricData metricData : metricDataList ) { \nMetricTimeSeries mts = metricInfo . getMetricTimeSeries ( metricData . metricPath ) ; \nList < SignalFxProtocolBuffers . DataPoint > mtsDataPoints = processor . process ( mts , metricData . metricValues ) ; \ndataPoints . addAll ( mtsDataPoints ) ; \nif ( ! ( ! mtsDataPoints . isEmpty ( ) ) ) { \ncounterMtsEmpty . inc ( ) ; \n} \nelse { \ncounterMtsReported . inc ( ) ; \n} \n} \n} \n} \n} \nif ( ! dataPoints . isEmpty ( ) ) { \ntry { \nreporter . report ( dataPoints ) ; \ncounterDataPointsReported . inc ( dataPoints . size ( ) ) ; \n} \ncatch ( Reporter . ReportException e ) { \nlog . error ( \"There were errors reporting metric\" ) ; \n} \n} \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( ! ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) ) { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \n} \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \nelse { \nreturn ; \n} \n} \n} \n"}
{"8924": "public class LogPersister { \nstatic public void setContext ( final Context context ) { \nif ( null == LogPersister . context ) { \nLogManager . getLogManager ( ) . getLogger ( \"\" ) . addHandler ( julHandler ) ; \njava . util . logging . Logger . getLogger ( \"\" ) . setLevel ( Level . ALL ) ; \nLogPersister . context = context ; \nif ( fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger ) { \nFileLogger . setContext ( context ) ; \nfileLoggerInstance = FileLogger . getInstance ( ) ; \n} \nSharedPreferences prefs = LogPersister . context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nif ( ! ( null != level ) ) { \nsetLevelSync ( Logger . LEVEL . fromString ( prefs . getString ( SHARED_PREF_KEY_level , getLevelDefault ( ) . toString ( ) ) ) ) ; \n} \nelse { \nsetLevelSync ( level ) ; \n} \nif ( ! ( null != logFileMaxSize ) ) { \nsetMaxLogStoreSize ( prefs . getInt ( SHARED_PREF_KEY_logFileMaxSize , DEFAULT_logFileMaxSize ) ) ; \n} \nelse { \nsetMaxLogStoreSize ( logFileMaxSize ) ; \n} \nif ( ! ( null != capture ) ) { \nsetCaptureSync ( prefs . getBoolean ( SHARED_PREF_KEY_logPersistence , DEFAULT_capture ) ) ; \n} \nelse { \nsetCaptureSync ( capture ) ; \n} \nuncaughtExceptionHandler = new UncaughtExceptionHandler ( ) ; \nThread . setDefaultUncaughtExceptionHandler ( uncaughtExceptionHandler ) ; \n} \n} \n} \n"}
{"8929": "public class LogPersister { \nprotected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { \nJSONObject jsonMetadata ; \nif ( ! ( additionalMetadata != null ) ) { \njsonMetadata = new JSONObject ( ) ; \n} \nelse { \njsonMetadata = additionalMetadata ; \n} \ntry { \nStackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; \nint index = 0 ; \nwhile ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) { \nindex ++ ; \n} \nwhile ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) { \nindex ++ ; \n} \njsonMetadata . put ( \"$class\" , stackTraceElements [ index ] . getClassName ( ) ) ; \njsonMetadata . put ( \"$file\" , stackTraceElements [ index ] . getFileName ( ) ) ; \njsonMetadata . put ( \"$method\" , stackTraceElements [ index ] . getMethodName ( ) ) ; \njsonMetadata . put ( \"$line\" , stackTraceElements [ index ] . getLineNumber ( ) ) ; \njsonMetadata . put ( \"$src\" , \"java\" ) ; \n} \ncatch ( Exception e ) { \nLog . e ( LOG_TAG_NAME , \"Could not generate jsonMetadata object.\" , e ) ; \n} \nreturn jsonMetadata ; \n} \n} \n"}
{"8932": "public class BMSAnalytics { \nprivate static void setUserIdentity ( final String user , boolean isInitialCtx ) { \nif ( ! isInitialCtx && ! BMSAnalytics . hasUserContext ) { \nlogger . error ( \"Cannot set user identity with anonymous user collection enabled.\" ) ; \nreturn ; \n} \nJSONObject metadata = new JSONObject ( ) ; \nDEFAULT_USER_ID = user ; \nString hashedUserID = UUID . nameUUIDFromBytes ( user . getBytes ( ) ) . toString ( ) ; \ntry { \nif ( ! ( isInitialCtx ) ) { \nmetadata . put ( CATEGORY , USER_SWITCH_CATEGORY ) ; \n} \nelse { \nmetadata . put ( CATEGORY , INITIAL_CTX_CATEGORY ) ; \n} \nif ( BMSAnalytics . collectLocation ) { \nif ( locationService . getInitLocationRequests ( ) ) { \nmetadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; \nmetadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; \n} \n} \nmetadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; \nmetadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; \nmetadata . put ( USER_ID_KEY , hashedUserID ) ; \n} \ncatch ( JSONException e ) { \nlogger . debug ( \"JSONException encountered logging change in user context: \" + e . getMessage ( ) ) ; \n} \nMFPInAppFeedBackListner . setUserIdentity ( user ) ; \nlog ( metadata ) ; \n} \n} \n"}
{"8935": "public class ObjectSizing { \npublic void sizeRegion ( Region < ? , ? > region , int numEntries ) { \nif ( region == null ) { \nthrow new IllegalArgumentException ( \"Region is null.\" ) ; \n} \nif ( ! ( region instanceof PartitionedRegion ) ) { \nsizeReplicatedOrLocalRegion ( region , numEntries ) ; \n} \nelse { \nsizePartitionedRegion ( region , numEntries ) ; \n} \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( ! ( numEntries == 0 ) ) if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nelse { \nnumEntries = primaryDataSet . size ( ) ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( ! ( numEntries == 0 ) ) if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nelse { \nnumEntries = entries . size ( ) ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nif ( ! ( i != 0 ) ) { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \nelse { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \n} \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8941": "public class StatsToChart { \npublic Chart convert ( File file ) { \nif ( file == null ) return null ; \ntry { \nif ( ! ( file . isDirectory ( ) ) ) { \nGfStatsReader reader = new GfStatsReader ( file . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \nelse { \nSet < File > statsFiles = IO . listFileRecursive ( file , \"*.gfs\" ) ; \nif ( statsFiles == null || statsFiles . isEmpty ( ) ) return null ; \nfor ( File statFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( statFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \n} \nreturn visitor . getChart ( ) ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( \"File:\" + file + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8947": "public class GemFireJmxClient { \nstatic synchronized String lookupNetworkHost ( String host ) { \ntry { \nif ( _bundle == null ) { \nURL url = GemFireJmxClient . class . getResource ( hostPropFileName ) ; \nString filePath = null ; \nif ( ! ( url == null ) ) filePath = url . toString ( ) ; \nelse filePath = hostPropFileName ; \nSystem . out . println ( new StringBuilder ( \"Loading IP addresses from \" ) . append ( filePath ) . toString ( ) ) ; \n_bundle = ResourceBundle . getBundle ( \"host\" ) ; \n} \nSystem . out . println ( new StringBuilder ( \"Looking for host name \\\"\" ) . append ( host ) . append ( \"\\\" IP address in \" ) . append ( hostPropFileName ) . toString ( ) ) ; \nString newHost = _bundle . getString ( host ) ; \nSystem . out . println ( new StringBuilder ( host ) . append ( \"=\" ) . append ( newHost ) . toString ( ) ) ; \nreturn newHost ; \n} \ncatch ( RuntimeException e ) { \nSystem . out . println ( \"Using host:\" + host ) ; \nreturn host ; \n} \n} \n} \n"}
{"8949": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > Collection < T > exeWithResults ( Execution < ? , ? , ? > execution , Function < ? > function ) throws Exception { \nResultCollector < ? , ? > resultCollector ; \ntry { \nresultCollector = execution . execute ( function ) ; \n} \ncatch ( FunctionException e ) { \nif ( ! ( e . getCause ( ) instanceof NullPointerException ) ) throw e ; \nelse throw new RuntimeException ( \"Unable to execute function:\" + function . getId ( ) + \" assert hostnames(s) for locators and cache server can be resovled. \" + \" If you do not have access to the host file, create host.properties and add to the CLASSPATH. \" + \" Example: locahost=127.1.0.0 \" + \" also assert that all cache servers have been initialized. Check if the server's cache.xml has all required <initializer>..</initializer> configurations\" , e ) ; \n} \nObject resultsObject = resultCollector . getResult ( ) ; \nCollection < Object > collectionResults = ( Collection < Object > ) resultsObject ; \nif ( collectionResults . isEmpty ( ) ) return null ; \nCollection < Object > list = new ArrayList < Object > ( collectionResults . size ( ) ) ; \nflatten ( collectionResults , list ) ; \nif ( list . isEmpty ( ) ) return null ; \nreturn ( Collection < T > ) list ; \n} \n} \n"}
{"8950": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > void flatten ( Collection < Object > input , Collection < Object > flattenOutput ) throws Exception { \nif ( input == null || input . isEmpty ( ) || flattenOutput == null ) return ; \nfor ( Object inputObj : input ) { \nif ( inputObj instanceof Exception ) throw ( Exception ) inputObj ; \nif ( inputObj == null ) continue ; \nif ( ! ( inputObj instanceof Collection ) ) flattenOutput . add ( inputObj ) ; \nelse flatten ( ( Collection < Object > ) inputObj , flattenOutput ) ; \n} \n} \n} \n"}
{"8951": "public class Querier { \n@ SuppressWarnings ( \"unchecked\" ) public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { \nSelectResults < ReturnType > selectResults ; \nif ( ! ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) ) { \nif ( ! ( params == null || params . length == 0 ) ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; \n} \nif ( selectResults == null || selectResults . isEmpty ( ) ) return null ; \nreturn selectResults ; \n} \nelse { \nif ( ! ( params == null || params . length == 0 ) ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; \n} \nif ( selectResults == null || selectResults . isEmpty ( ) ) return null ; \nArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; \nresults . addAll ( selectResults . asList ( ) ) ; \nreturn results ; \n} \n} \n} \n"}
{"8958": "public class LuceneSearchFunction { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) @ Override public void execute ( FunctionContext functionContext ) { \nCache cache = CacheFactory . getAnyInstance ( ) ; \ntry { \nif ( ! ( functionContext instanceof RegionFunctionContext ) ) { \nthrow new FunctionException ( \"Execute on a region\" ) ; \n} \nObject args = functionContext . getArguments ( ) ; \nif ( args == null ) throw new FunctionException ( \"arguments is required\" ) ; \nTextPageCriteria criteria = null ; \nif ( ! ( args instanceof PdxInstance ) ) { \ncriteria = ( TextPageCriteria ) args ; \n} \nelse { \nPdxInstance pdxInstance = ( PdxInstance ) args ; \ntry { \ncriteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; \n} \ncatch ( PdxSerializationException e ) { \nthrow new FunctionException ( e . getMessage ( ) + \" JSON:\" + JSONFormatter . toJSON ( pdxInstance ) ) ; \n} \n} \nRegion < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; \nRegion < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; \nGeodePagination pagination = new GeodePagination ( ) ; \nTextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; \ngeodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; \nCollection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , criteria . isSortDescending ( ) , criteria . getBeginIndex ( ) , ( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; \nif ( collection == null ) { \nfunctionContext . getResultSender ( ) . lastResult ( null ) ; \nreturn ; \n} \nPagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; \nfunctionContext . getResultSender ( ) . lastResult ( pageCollection ) ; \n} \ncatch ( RuntimeException e ) { \nLogger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; \nlogger . error ( Debugger . stackTrace ( e ) ) ; \nthrow e ; \n} \n} \n} \n"}
{"8963": "public class RegionDiffDirector { \npublic void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { \nif ( sourceChecksumMap == null ) { \nif ( targetMap != null && ! targetMap . isEmpty ( ) ) { \nthis . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; \n} \nreturn ; \n} \nif ( targetMap == null ) { \nthis . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; \nreturn ; \n} \nBigInteger targetBi = null ; \nBigInteger sourceBi = null ; \nfor ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { \ntargetBi = targetMap . get ( entrySource . getKey ( ) ) ; \nsourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; \nif ( ! ( targetBi == null ) ) if ( ! targetBi . equals ( sourceBi ) ) { \nkeysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; \n} \nelse { \nkeysMissingOnTarget . add ( entrySource . getKey ( ) ) ; \n} \n} \nSet < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; \nfor ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { \nif ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) { \nkeysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; \n} \n} \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( int i = 0 ; \ni < this . resourceTypeTable . length ; \ni ++ ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( ! ( this . resourceTypeTable [ i ] . close ( ) ) ) { \ntypeCount ++ ; \n} \nelse { \nthis . resourceTypeTable [ i ] = null ; \n} \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \nfor ( int i = 0 ; \ni < this . resourceInstTable . length ; \ni ++ ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( ! ( this . resourceInstTable [ i ] . close ( ) ) ) { \ninstCount ++ ; \n} \nelse { \nthis . resourceInstTable [ i ] = null ; \n} \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( args . length < 1 ) { \nSystem . err . println ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( args . length < 2 ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( ! ( args . length > 3 ) ) visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \nelse { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nSystem . out . println ( \"accepting\" ) ; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( ! ( values != null ) ) { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nelse { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( ! ( member . isLocator ( ) ) ) { \nshutDownMember ( member . getName ( ) ) ; \n} \nelse { \nlocators . add ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null || remoteLocators . length ( ) == 0 ) return false ; \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null || locators . length ( ) == 0 ) return false ; \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nint remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; \nfor ( String locator : locatorsArray ) { \nif ( locator == null || locator . length ( ) == 0 ) continue ; \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( ! ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) ) { \n} \nelse { \nreturn true ; \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8978": "public class GetEntriesChecksumFunction { \nHashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) { \nif ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) { \nregion = PartitionRegionHelper . getLocalData ( region ) ; \n} \nSet < Serializable > keySet = region . keySet ( ) ; \nif ( keySet == null || keySet . isEmpty ( ) ) return null ; \nHashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; \nObject object = null ; \nObject tmp = null ; \nfor ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { \nobject = entry . getValue ( ) ; \nif ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) { \ntmp = ( ( PdxInstance ) object ) . getObject ( ) ; \nif ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) { \nobject = tmp ; \n} \n} \nif ( ! ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) ) { \nregionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; \n} \nelse { \nregionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; \n} \n} \nreturn regionCheckSumMap ; \n} \n} \n"}
{"8983": "public class ShillelaghUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > T createInstance ( Class < T > clazz ) { \nif ( clazz . isInterface ( ) ) { \nif ( ! ( clazz == List . class ) ) if ( clazz == Map . class ) { \nreturn ( T ) new HashMap ( ) ; \n} \nelse { \nreturn ( T ) new ArrayList ( ) ; \n} \nthrow new UnsupportedOperationException ( \"Interface types can not be instantiated.\" ) ; \n} \nObjectInstantiator instantiator = OBJENESIS . getInstantiatorOf ( clazz ) ; \nreturn ( T ) instantiator . newInstance ( ) ; \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) return ; \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( ! ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) ) if ( ! ( tableColumn . isOneToMany ( ) ) ) if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) { \nlogger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \ntableColumn . setOneToOne ( true ) ; \n} \nelse { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { \nlogger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \n} \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) && ! columnType . startsWith ( \"java.util.List\" ) ) { \nlogger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \n} \ntableObject . addColumn ( tableColumn ) ; \n} \n} \n"}
{"8993": "public class Strings { \nstatic String capitalize ( String string ) { \nif ( isBlank ( string ) ) { \nreturn \"\" ; \n} \nchar first = string . charAt ( 0 ) ; \nif ( ! ( Character . isUpperCase ( first ) ) ) { \nreturn Character . toUpperCase ( first ) + string . substring ( 1 ) ; \n} \nelse { \nreturn string ; \n} \n} \n} \n"}
{"9034": "public class RegressionLine { \nprivate void _validateCoefficients ( ) { \nif ( m_bCoefsValid ) return ; \nif ( ! ( m_nDataPoints >= 2 ) ) { \nm_fA0 = m_fA1 = Float . NaN ; \n} \nelse { \nfinal float xBar = ( float ) m_dSumX / m_nDataPoints ; \nfinal float yBar = ( float ) m_dSumY / m_nDataPoints ; \nm_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; \nm_fA0 = yBar - m_fA1 * xBar ; \n} \nm_bCoefsValid = true ; \n} \n} \n"}
{"9055": "public class RegulaFalsiRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( ! ( m_fFalse < 0 ) ) { \nm_fXPos = m_fXFalse ; \nm_fPos = m_fFalse ; \n} \nelse { \nm_fXNeg = m_fXFalse ; \nm_fNeg = m_fFalse ; \n} \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) { \nif ( ! ( m_fFalse < 0 ) ) m_bDecreaseNeg = true ; \nelse m_bDecreasePos = true ; \n} \n} \n} \n"}
{"9067": "public class IEEE754 { \npublic void print ( @ Nonnull final PrintStream aPW ) { \naPW . println ( \"------------------------------\" ) ; \nif ( ! ( isDouble ( ) ) ) aPW . println ( \"float value = \" + floatValue ( ) ) ; \nelse aPW . println ( \"double value = \" + doubleValue ( ) ) ; \naPW . print ( \"sign=\" + signBit ( ) ) ; \naPW . print ( \", exponent=\" + exponentBits ( ) + \" (biased=\" + biasedExponent ( ) ) ; \nif ( ! ( isZero ( ) ) ) if ( ! ( isExponentReserved ( ) ) ) if ( ! ( isDenormalized ( ) ) ) aPW . println ( \", normalized, unbiased=\" + unbiasedExponent ( ) + \")\" ) ; \nelse aPW . println ( \", denormalized, use \" + unbiasedExponent ( ) + \")\" ) ; \nelse aPW . println ( \", reserved)\" ) ; \nelse aPW . println ( \", zero)\" ) ; \naPW . println ( \"significand=\" + significandBits ( ) ) ; \n} \n} \n"}
{"9078": "public class BisectionRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( ! ( m_fMid < 0 ) ) { \nm_fXPos = m_fXMid ; \nm_fPos = m_fMid ; \n} \nelse { \nm_fXNeg = m_fXMid ; \nm_fNeg = m_fMid ; \n} \n} \n} \n"}
{"9082": "public class Calabash { \npublic void setConfiguration ( File configFile ) { \nif ( ! ( configFile == null ) ) try { \nXProcConfiguration config = new XProcConfiguration ( \"he\" , false ) ; \nnextConfig = config . getProcessor ( ) . newDocumentBuilder ( ) . build ( new SAXSource ( new InputSource ( new FileReader ( configFile ) ) ) ) ; \n} \ncatch ( FileNotFoundException e ) { \nthrow new IllegalArgumentException ( \"Config file does not exist\" , e ) ; \n} \ncatch ( SaxonApiException e ) { \nthrow new RuntimeException ( e ) ; \n} \nelse nextConfig = null ; \n} \n} \n"}
{"9111": "public class AGenericListMessageHandler { \n@ Override public void handleMessage ( Object objectToProcess ) { \nif ( ! ( objectToProcess instanceof Error ) ) { \nJSONObject jsonObject = ( JSONObject ) objectToProcess ; \nif ( this . compressedResponse ) { \nCompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; \nbyte [ ] compressedJsonList = UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; \nbyte [ ] uncompressedJson = null ; \ntry { \nuncompressedJson = this . uncompress ( compressedJsonList ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidClientException ( \"I/O issue with uncompress. \" + eParam . getMessage ( ) , eParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \njsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; \n} \nT messageForm = this . getNewInstanceBy ( jsonObject ) ; \nthis . returnValue . add ( messageForm ) ; \nif ( this . completableFuture != null ) { \nString echo = messageForm . getEcho ( ) ; \nif ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) { \nthis . expectedEchoMessagesBeforeComplete . remove ( echo ) ; \n} \nif ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) { \nthis . completableFuture . complete ( this . returnValue ) ; \n} \n} \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . messageReceived ( messageForm ) ; \n} \n} \nelse { \nError fluidError = ( ( Error ) objectToProcess ) ; \nthis . errors . add ( fluidError ) ; \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . errorMessageReceived ( fluidError ) ; \n} \nif ( this . completableFuture != null ) { \nthis . completableFuture . completeExceptionally ( new FluidClientException ( fluidError . getErrorMessage ( ) , fluidError . getErrorCode ( ) ) ) ; \n} \n} \n} \n} \n"}
{"9112": "public class AGenericListMessageHandler { \n@ Override public void connectionClosed ( ) { \nthis . isConnectionClosed = true ; \nif ( this . completableFuture != null ) { \nif ( ! ( this . getErrors ( ) . isEmpty ( ) ) ) { \nError firstFluidError = this . getErrors ( ) . get ( 0 ) ; \nthis . completableFuture . completeExceptionally ( new FluidClientException ( firstFluidError . getErrorMessage ( ) , firstFluidError . getErrorCode ( ) ) ) ; \n} \nelse { \nthis . completableFuture . complete ( this . returnValue ) ; \n} \n} \n} \n} \n"}
{"9129": "public class FormDefinitionClient { \npublic List < Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) { \nForm form = new Form ( ) ; \nif ( this . serviceTicket != null ) { \nform . setServiceTicket ( this . serviceTicket ) ; \n} \nif ( ! ( includeTableRecordTypesParam ) ) { \nreturn new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; \n} \nelse { \nreturn new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; \n} \n} \n} \n"}
{"9131": "public class CacheUtil { \nprivate String getStorageKeyFrom ( Long formDefIdParam , Long formContIdParam , Long formFieldIdParam ) { \nStringBuilder stringBuff = new StringBuilder ( ) ; \nif ( ! ( formDefIdParam == null ) ) { \nstringBuff . append ( formDefIdParam . toString ( ) ) ; \n} \nelse { \nstringBuff . append ( NULL ) ; \n} \nstringBuff . append ( DASH ) ; \nif ( ! ( formContIdParam == null ) ) { \nstringBuff . append ( formContIdParam . toString ( ) ) ; \n} \nelse { \nstringBuff . append ( NULL ) ; \n} \nstringBuff . append ( DASH ) ; \nif ( ! ( formFieldIdParam == null ) ) { \nstringBuff . append ( formFieldIdParam . toString ( ) ) ; \n} \nelse { \nstringBuff . append ( NULL ) ; \n} \nreturn stringBuff . toString ( ) ; \n} \n} \n"}
{"9169": "public class ESFormFieldMappingUtil { \npublic GetIndexResponse getOrCreateIndex ( String indexParam ) { \nif ( ! ( this . doesIndexExist ( indexParam ) ) ) { \nCreateIndexRequestBuilder createIndexRequestBuilder = this . client . admin ( ) . indices ( ) . prepareCreate ( indexParam ) ; \nCreateIndexResponse mappingCreateResponse = createIndexRequestBuilder . execute ( ) . actionGet ( ) ; \nif ( ! mappingCreateResponse . isAcknowledged ( ) ) { \nthrow new FluidElasticSearchException ( \"Index Creation for '\" + indexParam + \"' not acknowledged by ElasticSearch.\" ) ; \n} \nreturn this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; \n} \nelse { \nreturn this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; \n} \n} \n} \n"}
{"9182": "public class ABaseClientWebSocket { \nprotected String getExceptionMessageVerbose ( String prefixParam , String uniqueReqIdParam , int numberOfSentItemsParam ) { \nStringBuilder formFieldsCombined = new StringBuilder ( ) ; \nint returnValSize = - 1 ; \nRespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; \nif ( respHandler instanceof AGenericListMessageHandler ) { \nList < ? extends ABaseFluidJSONObject > returnValue = ( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; \nif ( returnValue != null ) { \nreturnValSize = returnValue . size ( ) ; \nreturnValue . forEach ( listingItm -> { \nif ( ! ( listingItm instanceof ABaseListing ) ) { \nformFieldsCombined . append ( listingItm . toString ( ) ) ; \n} \nelse { \nABaseListing castedToListing = ( ABaseListing ) listingItm ; \nif ( castedToListing != null ) { \ncastedToListing . getListing ( ) . forEach ( formItm -> { \nformFieldsCombined . append ( formItm . toString ( ) ) ; \n} \n) ; \n} \n} \n} \n) ; \n} \n} \nreturn ( prefixParam + \": \" + \"Timeout while waiting for all return data. There were '\" + returnValSize + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds on req-ref-nr '\" + uniqueReqIdParam + \"'. Expected a total of '\" + numberOfSentItemsParam + \"' forms. Returned-Data '\" + formFieldsCombined . toString ( ) + \"'.\" ) ; \n} \n} \n"}
{"9188": "public class ABaseClientWS { \nprivate ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { \nResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { \npublic String handleResponse ( final HttpResponse responseParam ) throws IOException { \nint status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; \nif ( ! ( status == 404 ) ) if ( ! ( status >= 200 && status < 300 ) ) if ( ! ( status == 400 ) ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; \nthrow new FluidClientException ( \"Unexpected response status: \" + status + \". \" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + \". \\nResponse Text [\" + responseString + \"]\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nthrow new FluidClientException ( \"Endpoint for Service not found. URL [\" + urlCalledParam + \"].\" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; \n} \n} \n} \n; \nreturn responseHandler ; \n} \n} \n"}
{"9190": "public class ABaseClientWS { \nprivate CloseableHttpClient getClient ( ) { \nif ( this . closeableHttpClient != null ) { \nreturn this . closeableHttpClient ; \n} \nString pathToFluidTrustStore = this . getPathToFluidSpecificTrustStore ( ) ; \nif ( ! ( IS_IN_JUNIT_TEST_MODE || pathToFluidTrustStore != null ) ) { \nthis . closeableHttpClient = HttpClients . createDefault ( ) ; \n} \nelse { \nSSLContextBuilder builder = new SSLContextBuilder ( ) ; \ntry { \nif ( ! ( pathToFluidTrustStore == null ) ) { \nString password = this . getFluidSpecificTrustStorePassword ( ) ; \nif ( password == null ) { \npassword = UtilGlobal . EMPTY ; \n} \nif ( ! ( IS_IN_JUNIT_TEST_MODE ) ) { \nbuilder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) ) ; \n} \nelse { \nbuilder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) , new SSLTrustAll ( ) ) ; \n} \n} \nelse { \nbuilder . loadTrustMaterial ( new SSLTrustAll ( ) ) ; \n} \nSSLContext sslContext = builder . build ( ) ; \nthis . closeableHttpClient = HttpClients . custom ( ) . setSSLSocketFactory ( new SSLConnectionSocketFactory ( sslContext ) ) . build ( ) ; \n} \ncatch ( NoSuchAlgorithmException e ) { \nthrow new FluidClientException ( \"NoSuchAlgorithm: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( KeyManagementException e ) { \nthrow new FluidClientException ( \"KeyManagement: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( KeyStoreException e ) { \nthrow new FluidClientException ( \"KeyStore: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( CertificateException e ) { \nthrow new FluidClientException ( \"Certificate: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( IOException ioError ) { \nthrow new FluidClientException ( \"IOError: Unable to load self signed trust material. \" + ioError . getMessage ( ) , ioError , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \n} \nreturn this . closeableHttpClient ; \n} \n} \n"}
{"9196": "public class WebSocketClient { \n@ OnMessage public void onMessage ( String messageParam ) { \nboolean handlerFoundForMsg = false ; \nfor ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { \nObject qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; \nif ( ! ( qualifyObj instanceof Error ) ) if ( qualifyObj instanceof JSONObject ) { \nhandler . handleMessage ( qualifyObj ) ; \nhandlerFoundForMsg = true ; \nbreak ; \n} \nelse { \nhandler . handleMessage ( qualifyObj ) ; \n} \n} \nif ( ! handlerFoundForMsg ) { \nthrow new FluidClientException ( \"No handler found for message;\\n\" + messageParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9197": "public class WebSocketClient { \npublic void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { \nif ( ! ( aBaseFluidJSONObjectParam == null ) ) { \nthis . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; \n} \nelse { \nthrow new FluidClientException ( \"No JSON Object to send.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9200": "public class SQLUtilWebSocketExecuteNativeSQLClient { \npublic List < SQLResultSet > executeNativeSQLSynchronized ( NativeSQLQuery nativeSQLQueryParam ) { \nif ( nativeSQLQueryParam == null ) { \nreturn null ; \n} \nif ( nativeSQLQueryParam . getDatasourceName ( ) == null || nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"No data-source name provided. Not allowed.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( ( nativeSQLQueryParam . getQuery ( ) == null || nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && ( nativeSQLQueryParam . getStoredProcedure ( ) == null || nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) { \nreturn null ; \n} \nthis . setEchoIfNotSet ( nativeSQLQueryParam ) ; \nString uniqueReqId = this . initNewRequest ( ) ; \nthis . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; \ntry { \nList < SQLResultSet > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; \nif ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + \"The connection was closed by the server prior to the response received.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nreturn returnValue ; \n} \ncatch ( InterruptedException exceptParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + exceptParam . getMessage ( ) , exceptParam , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \ncatch ( ExecutionException executeProblem ) { \nThrowable cause = executeProblem . getCause ( ) ; \nif ( ! ( cause instanceof FluidClientException ) ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + cause . getMessage ( ) , cause , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \nelse { \nthrow ( FluidClientException ) cause ; \n} \n} \ncatch ( TimeoutException eParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: Timeout while waiting for all return data. There were '\" + this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nfinally { \nthis . removeHandler ( uniqueReqId ) ; \n} \n} \n} \n"}
{"9220": "public class XsdParserJar { \nprivate void parseJarFile ( InputStream inputStream ) { \ntry { \nNode schemaNode = getSchemaNode ( inputStream ) ; \nif ( ! ( isXsdSchema ( schemaNode ) ) ) { \nthrow new ParsingException ( \"The top level element of a XSD file should be the xsd:schema node.\" ) ; \n} \nelse { \nXsdSchema . parse ( this , schemaNode ) ; \n} \n} \ncatch ( SAXException | IOException | ParserConfigurationException e ) { \nLogger . getAnonymousLogger ( ) . log ( Level . SEVERE , \"Exception while parsing.\" , e ) ; \n} \n} \n} \n"}
{"9228": "public class ConvertTypeOfObject { \n@ Override public T convert ( final Object value ) { \nif ( ! ( value == null ) ) if ( ! ( isIterable ( ) && Iterable . class . isAssignableFrom ( value . getClass ( ) ) ) ) if ( ! ( reflectedKlass . assignableFromObject ( value ) ) ) if ( ! ( reflectedKlass . canBeUnboxed ( value . getClass ( ) ) ) ) if ( reflectedKlass . canBeBoxed ( value . getClass ( ) ) ) { \nreturn ( T ) value ; \n} \nelse { \nreturn ( T ) value ; \n} \nelse { \nreturn ( T ) value ; \n} \nelse { \nreturn convertIterable ( value ) ; \n} \nelse { \nreturn null ; \n} \nFluentClass < ? > klassToCreate ; \nif ( ! ( reflectedKlass . isPrimitive ( ) ) ) { \nklassToCreate = reflectedKlass ; \n} \nelse { \nklassToCreate = reflectedKlass . boxedType ( ) ; \n} \nreturn ( T ) convertValueTo ( value , klassToCreate ) ; \n} \n} \n"}
{"9235": "public class Line { \npublic double getValue ( double p ) { \nif ( module == null ) { \nthrow new NoModuleException ( ) ; \n} \ndouble x = ( x1 - x0 ) * p + x0 ; \ndouble y = ( y1 - y0 ) * p + y0 ; \ndouble z = ( z1 - z0 ) * p + z0 ; \ndouble value = module . getValue ( x , y , z ) ; \nif ( ! ( attenuate ) ) { \nreturn value ; \n} \nelse { \nreturn p * ( 1.0 - p ) * 4 * value ; \n} \n} \n} \n"}
{"9246": "public class FileEventReader { \nprivate EventSerializer getEventSerializer ( final GZIPInputStream inputStream , final CloudTrailLog ctLog ) throws IOException { \nfinal EventSerializer serializer ; \nif ( ! ( isEnableRawEventInfo ) ) { \nfinal JsonParser jsonParser = this . mapper . getFactory ( ) . createParser ( inputStream ) ; \nserializer = new DefaultEventSerializer ( ctLog , jsonParser ) ; \n} \nelse { \nfinal String logFileContent = new String ( LibraryUtils . toByteArray ( inputStream ) , StandardCharsets . UTF_8 ) ; \nfinal JsonParser jsonParser = this . mapper . getFactory ( ) . createParser ( logFileContent ) ; \nserializer = new RawLogDeliveryEventSerializer ( logFileContent , ctLog , jsonParser ) ; \n} \nreturn serializer ; \n} \n} \n"}
{"9249": "public class RestoreContext { \npublic void restore ( ) { \nfor ( String propertyName : propertyNames ) { \nif ( ! ( restoreProperties . containsKey ( propertyName ) ) ) { \nSystem . clearProperty ( propertyName ) ; \n} \nelse { \nSystem . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; \n} \n} \n} \n} \n"}
{"9256": "public class WeakTypeCache { \n@ SuppressWarnings ( { \n\"unchecked\" , \"cast\" } \n) public T get ( Type type ) { \nif ( type == null ) throw new IllegalArgumentException ( \"Null type\" ) ; \nif ( ! ( type instanceof ParameterizedType ) ) if ( ! ( type instanceof Class ) ) if ( ! ( type instanceof TypeVariable ) ) if ( ! ( type instanceof GenericArrayType ) ) if ( ! ( type instanceof WildcardType ) ) throw new UnsupportedOperationException ( \"Unknown type: \" + type + \" class=\" + type . getClass ( ) ) ; \nelse return getWildcardType ( ( WildcardType ) type ) ; \nelse return getGenericArrayType ( ( GenericArrayType ) type ) ; \nelse return ( T ) getTypeVariable ( ( TypeVariable ) type ) ; \nelse return getClass ( ( Class < ? > ) type ) ; \nelse return getParameterizedType ( ( ParameterizedType ) type ) ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( startTimeout > 0l && runTime >= startTimeout ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( ! ( state == TASK_STOPPED ) ) { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; \n} \nelse { \nstopped = true ; \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; \n} \n} \n} \n"}
{"9270": "public class WorkerQueue { \nprotected void putJobImpl ( Executable job ) { \nJobItem posted = new JobItem ( job ) ; \nif ( ! ( m_currentJob == null ) ) { \nJobItem item = m_currentJob ; \nwhile ( item . m_next != null ) { \nitem = item . m_next ; \n} \nitem . m_next = posted ; \n} \nelse { \nm_currentJob = posted ; \nnotifyAll ( ) ; \n} \n} \n} \n"}
{"9271": "public class BlockingMode { \npublic static final BlockingMode toBlockingMode ( String name ) { \nBlockingMode mode = null ; \nif ( ! ( name == null ) ) if ( ! ( name . equalsIgnoreCase ( \"run\" ) ) ) if ( ! ( name . equalsIgnoreCase ( \"wait\" ) ) ) if ( ! ( name . equalsIgnoreCase ( \"discard\" ) ) ) if ( ! ( name . equalsIgnoreCase ( \"discardOldest\" ) ) ) if ( name . equalsIgnoreCase ( \"abort\" ) ) { \nmode = ABORT ; \n} \nelse { \nmode = DISCARD_OLDEST ; \n} \nelse { \nmode = DISCARD ; \n} \nelse { \nmode = WAIT ; \n} \nelse { \nmode = RUN ; \n} \nelse { \nmode = null ; \n} \nreturn mode ; \n} \n} \n"}
{"9274": "public class Catalog { \npublic void addReader ( String mimeType , CatalogReader reader ) { \nif ( ! ( readerMap . containsKey ( mimeType ) ) ) { \nreaderArr . add ( reader ) ; \nInteger pos = new Integer ( readerArr . size ( ) - 1 ) ; \nreaderMap . put ( mimeType , pos ) ; \n} \nelse { \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nreaderArr . set ( pos . intValue ( ) , reader ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ! ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) ) { \n} \nelse { \nbreak ; \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( ! ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) ) { \ncatalogs . addElement ( catfile ) ; \n} \nelse { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ! ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) ) { \n} \nelse { \nbreak ; \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) { \nif ( ! ( notFound ) ) { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \n} \n} \n} \n"}
{"9283": "public class Catalog { \npublic String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = null ; \ncatalogManager . debug . message ( 3 , \"resolveDoctype(\" + entityName + \",\" + publicId + \",\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( publicId != null && publicId . startsWith ( \"urn:publicid:\" ) ) { \npublicId = PublicId . decodeURN ( publicId ) ; \n} \nif ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nif ( ! ( publicId != null && ! publicId . equals ( systemId ) ) ) { \npublicId = systemId ; \nsystemId = null ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"urn:publicid: system identifier differs from public identifier; using public identifier\" ) ; \nsystemId = null ; \n} \n} \nif ( systemId != null ) { \nresolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nif ( publicId != null ) { \nresolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nboolean over = default_override ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == OVERRIDE ) { \nover = e . getEntryArg ( 0 ) . equalsIgnoreCase ( \"YES\" ) ; \ncontinue ; \n} \nif ( e . getEntryType ( ) == DOCTYPE && e . getEntryArg ( 0 ) . equals ( entityName ) ) { \nif ( over || systemId == null ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( ! ( entityType == DOCTYPE ) ) if ( ! ( entityType == DOCUMENT ) ) if ( ! ( entityType == ENTITY ) ) if ( ! ( entityType == NOTATION ) ) if ( ! ( entityType == PUBLIC ) ) if ( ! ( entityType == SYSTEM ) ) if ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \nelse { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse { \nresolved = c . resolveDocument ( ) ; \n} \nelse { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9288": "public class Catalog { \nprotected String makeAbsolute ( String sysid ) { \nURL local = null ; \nsysid = fixSlashes ( sysid ) ; \ntry { \nlocal = new URL ( base , sysid ) ; \n} \ncatch ( MalformedURLException e ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on system identifier\" , sysid ) ; \n} \nif ( ! ( local != null ) ) { \nreturn sysid ; \n} \nelse { \nreturn local . toString ( ) ; \n} \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( int count = 0 ; \ncount < bytes . length ; \ncount ++ ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ! ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) ) { \nnewRef += ( char ) bytes [ count ] ; \n} \nelse { \nnewRef += encodedByte ( ch ) ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9290": "public class Catalog { \nprotected String encodedByte ( int b ) { \nString hex = Integer . toHexString ( b ) . toUpperCase ( ) ; \nif ( ! ( hex . length ( ) < 2 ) ) { \nreturn \"%\" + hex ; \n} \nelse { \nreturn \"%0\" + hex ; \n} \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( dp . length ( ) > partial . length ( ) ) { \npos ++ ; \n} \nif ( dp . length ( ) < partial . length ( ) ) { \nbreak ; \n} \n} \nif ( ! ( localDelegate . size ( ) == 0 ) ) { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \nelse { \nlocalDelegate . addElement ( entry ) ; \n} \n} \n} \n"}
{"9292": "public class SoftValueRef { \nstatic < K , V > SoftValueRef < K , V > create ( K key , V val , ReferenceQueue < V > q ) { \nif ( ! ( val == null ) ) return new SoftValueRef < K , V > ( key , val , q ) ; \nelse return null ; \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \n-- size ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \n-- size ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) return res ; \nlong t = queue [ index ] . time ; \nint c = index << 1 ; \nwhile ( c <= size ) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( ! ( c + 1 <= size ) ) { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( ! ( l . time <= r . time ) ) { \nif ( t <= r . time ) break ; \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \nelse { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9316": "public class LongCounter { \npublic static LongCounter makeDirectional ( final LongCounter counter , final boolean increasing ) { \nLongCounter temp ; \nif ( ! ( increasing ) ) { \ntemp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = 2584758778978644599L ; \npublic long increment ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \nelse { \ntemp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = - 8902748795144754375L ; \npublic long decrement ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \npublic void reset ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \nreturn temp ; \n} \n} \n"}
{"9317": "public class OASISXMLCatalogReader { \nprotected boolean inExtensionNamespace ( ) { \nboolean inExtension = false ; \nEnumeration elements = namespaceStack . elements ( ) ; \nwhile ( ! inExtension && elements . hasMoreElements ( ) ) { \nString ns = ( String ) elements . nextElement ( ) ; \nif ( ! ( ns == null ) ) { \ninExtension = ( ! ns . equals ( tr9401NamespaceName ) && ! ns . equals ( namespaceName ) ) ; \n} \nelse { \ninExtension = true ; \n} \n} \nreturn inExtension ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( ! ( end == 0 ) ) strings [ i ] = string . substring ( begin , end ) ; \nelse strings [ i ] = EMPTY ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9324": "public class Strings { \npublic static final void defaultToString ( JBossStringBuilder buffer , Object object ) { \nif ( ! ( object == null ) ) { \nbuffer . append ( object . getClass ( ) . getName ( ) ) ; \nbuffer . append ( '@' ) ; \nbuffer . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; \n} \nelse buffer . append ( \"null\" ) ; \n} \n} \n"}
{"9326": "public class TimedCachePolicy { \npublic void create ( ) { \nif ( ! ( threadSafe ) ) entryMap = new HashMap ( ) ; \nelse entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \nnow = System . currentTimeMillis ( ) ; \n} \n} \n"}
{"9330": "public class TimedCachePolicy { \npublic void flush ( ) { \nMap tmpMap = null ; \nsynchronized ( this ) { \ntmpMap = entryMap ; \nif ( ! ( threadSafe ) ) entryMap = new HashMap ( ) ; \nelse entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \n} \nIterator iter = tmpMap . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nTimedEntry entry = ( TimedEntry ) iter . next ( ) ; \nentry . destroy ( ) ; \n} \ntmpMap . clear ( ) ; \n} \n} \n"}
{"9335": "public class XmlHelper { \npublic static Element getUniqueChild ( Element element , String tagName ) throws Exception { \nIterator goodChildren = getChildrenByTagName ( element , tagName ) ; \nif ( ! ( goodChildren != null && goodChildren . hasNext ( ) ) ) { \nthrow new Exception ( \"expected one \" + tagName + \" tag\" ) ; \n} \nelse { \nElement child = ( Element ) goodChildren . next ( ) ; \nif ( goodChildren . hasNext ( ) ) { \nthrow new Exception ( \"expected only one \" + tagName + \" tag\" ) ; \n} \nreturn child ; \n} \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nif ( ! ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \nelse { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( ! ( e . getEntryType ( ) == RESOLVER ) ) if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { \nreturn result ; \n} \n} \nelse { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9346": "public class Resolver { \nprotected String resolveExternalSystem ( String systemId , String resolver ) throws MalformedURLException , IOException { \nResolver r = queryResolver ( resolver , \"i2l\" , systemId , null ) ; \nif ( ! ( r != null ) ) { \nreturn null ; \n} \nelse { \nreturn r . resolveSystem ( systemId ) ; \n} \n} \n} \n"}
{"9347": "public class Resolver { \nprotected String resolveExternalPublic ( String publicId , String resolver ) throws MalformedURLException , IOException { \nResolver r = queryResolver ( resolver , \"fpi2l\" , publicId , null ) ; \nif ( ! ( r != null ) ) { \nreturn null ; \n} \nelse { \nreturn r . resolvePublic ( publicId , null ) ; \n} \n} \n} \n"}
{"9348": "public class Resolver { \nprotected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { \nString RFC2483 = resolver + \"?command=\" + command + \"&format=tr9401&uri=\" + arg1 + \"&uri2=\" + arg2 ; \ntry { \nURL url = new URL ( RFC2483 ) ; \nURLConnection urlCon = url . openConnection ( ) ; \nurlCon . setUseCaches ( false ) ; \nResolver r = ( Resolver ) newCatalog ( ) ; \nString cType = urlCon . getContentType ( ) ; \nif ( cType . indexOf ( \";\" ) > 0 ) { \ncType = cType . substring ( 0 , cType . indexOf ( \";\" ) ) ; \n} \nr . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; \nreturn r ; \n} \ncatch ( CatalogException cex ) { \nif ( ! ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) ) if ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) { \ncatalogManager . debug . message ( 1 , \"Unknown catalog format: \" + RFC2483 ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Unparseable catalog: \" + RFC2483 ) ; \n} \nreturn null ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed resolver URL: \" + RFC2483 ) ; \nreturn null ; \n} \ncatch ( IOException ie ) { \ncatalogManager . debug . message ( 1 , \"I/O Exception opening resolver: \" + RFC2483 ) ; \nreturn null ; \n} \n} \n} \n"}
{"9351": "public class Resolver { \npublic String resolveSystemReverse ( String systemId ) throws MalformedURLException , IOException { \nVector resolved = resolveAllSystemReverse ( systemId ) ; \nif ( ! ( resolved != null && resolved . size ( ) > 0 ) ) { \nreturn null ; \n} \nelse { \nreturn ( String ) resolved . elementAt ( 0 ) ; \n} \n} \n} \n"}
{"9352": "public class Resolver { \npublic Vector resolveAllSystem ( String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nif ( systemId != null ) { \nVector localResolutions = resolveAllLocalSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \nVector subResolutions = resolveAllSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; \nresolutions = appendVector ( resolutions , subResolutions ) ; \nif ( ! ( resolutions . size ( ) > 0 ) ) { \nreturn null ; \n} \nelse { \nreturn resolutions ; \n} \n} \n} \n"}
{"9353": "public class Resolver { \nprivate Vector resolveAllLocalSystem ( String systemId ) { \nVector map = new Vector ( ) ; \nString osname = System . getProperty ( \"os.name\" ) ; \nboolean windows = ( osname . indexOf ( \"Windows\" ) >= 0 ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) { \nmap . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \nif ( ! ( map . size ( ) == 0 ) ) { \nreturn map ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( ! ( entityType == DOCTYPE ) ) if ( ! ( entityType == DOCUMENT ) ) if ( ! ( entityType == ENTITY ) ) if ( ! ( entityType == NOTATION ) ) if ( ! ( entityType == PUBLIC ) ) if ( ! ( entityType == SYSTEM ) ) if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \nelse { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \n} \nif ( ! ( resolutions != null ) ) { \nreturn null ; \n} \nelse { \nreturn resolutions ; \n} \n} \n} \n"}
{"9356": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nif ( parserFactory == null && parserClass == null ) { \ndebug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \nEntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; \nthis . catalog = catalog ; \ntry { \nif ( ! ( parserFactory != null ) ) { \nParser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; \nparser . setDocumentHandler ( this ) ; \nif ( bResolver != null ) { \nparser . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) ) ; \n} \nelse { \nSAXParser parser = parserFactory . newSAXParser ( ) ; \nSAXParserHandler spHandler = new SAXParserHandler ( ) ; \nspHandler . setContentHandler ( this ) ; \nif ( bResolver != null ) { \nspHandler . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) , spHandler ) ; \n} \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \ncatch ( SAXException se ) { \nException e = se . getException ( ) ; \nUnknownHostException uhe = new UnknownHostException ( ) ; \nFileNotFoundException fnfe = new FileNotFoundException ( ) ; \nif ( e != null ) { \nif ( ! ( e . getClass ( ) == uhe . getClass ( ) ) ) if ( e . getClass ( ) == fnfe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \nelse { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \n} \nthrow new CatalogException ( se ) ; \n} \n} \n} \n"}
{"9360": "public class Node { \nvoid helpDelete ( Node < K , V > b , Node < K , V > f ) { \nif ( f == next && this == b . next ) { \nif ( ! ( f == null || f . value != f ) ) b . casNext ( this , f . next ) ; \nelse appendMarker ( f ) ; \n} \n} \n} \n"}
{"9365": "public class JBossObject { \npublic static void list ( JBossStringBuilder buffer , Collection objects ) { \nif ( objects == null ) return ; \nbuffer . append ( '[' ) ; \nif ( objects . isEmpty ( ) == false ) { \nfor ( Iterator i = objects . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nObject object = i . next ( ) ; \nif ( ! ( object instanceof JBossObject ) ) buffer . append ( object . toString ( ) ) ; \nelse ( ( JBossObject ) object ) . toShortString ( buffer ) ; \nif ( i . hasNext ( ) ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( ']' ) ; \n} \n} \n"}
{"9377": "public class PropertyMap { \npublic boolean removePropertyListener ( PropertyListener listener ) { \nif ( listener == null ) throw new NullArgumentException ( \"listener\" ) ; \nboolean removed = false ; \nif ( ! ( listener instanceof BoundPropertyListener ) ) { \nremoved = unboundListeners . remove ( listener ) ; \n} \nelse { \nremoved = removePropertyListener ( ( BoundPropertyListener ) listener ) ; \n} \nreturn removed ; \n} \n} \n"}
{"9387": "public class JBossEntityResolver { \nprotected InputSource resolveSystemID ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveSystemID, systemId=\" + systemId ) ; \nInputSource inputSource = null ; \nString filename = null ; \nif ( localEntities != null ) filename = ( String ) localEntities . get ( systemId ) ; \nif ( filename == null ) filename = ( String ) entities . get ( systemId ) ; \nif ( filename != null ) { \nif ( trace ) log . trace ( \"Found entity systemId=\" + systemId + \" fileName=\" + filename ) ; \nInputStream ins = loadClasspathResource ( filename , trace ) ; \nif ( ! ( ins != null ) ) { \nlog . warn ( \"Cannot load systemId from resource: \" + filename ) ; \n} \nelse { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \n} \nreturn inputSource ; \n} \n} \n"}
{"9388": "public class JBossEntityResolver { \nprotected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveSystemIDasURL, systemId=\" + systemId ) ; \nInputSource inputSource = null ; \ntry { \nif ( trace ) log . trace ( \"Trying to resolve systemId as a URL\" ) ; \nif ( isReplaceSystemProperties ( ) ) systemId = StringPropertyReplacer . replaceProperties ( systemId ) ; \nURL url = new URL ( systemId ) ; \nif ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( \"file\" ) == false && url . getProtocol ( ) . equalsIgnoreCase ( \"vfszip\" ) == false ) { \nlog . warn ( \"Trying to resolve systemId as a non-file URL: \" + systemId ) ; \n} \nInputStream ins = url . openStream ( ) ; \nif ( ! ( ins != null ) ) { \nlog . warn ( \"Cannot load systemId as URL: \" + systemId ) ; \n} \nelse { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nif ( trace ) log . trace ( \"Resolved systemId as a URL\" ) ; \n} \ncatch ( MalformedURLException ignored ) { \nif ( trace ) log . trace ( \"SystemId is not a url: \" + systemId , ignored ) ; \n} \ncatch ( IOException e ) { \nif ( trace ) log . trace ( \"Failed to obtain URL.InputStream from systemId: \" + systemId , e ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9389": "public class JBossEntityResolver { \nprotected InputSource resolveClasspathName ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveClasspathName, systemId=\" + systemId ) ; \nString filename = systemId ; \ntry { \nURI url = new URI ( systemId ) ; \nString path = url . getPath ( ) ; \nif ( path == null ) path = url . getSchemeSpecificPart ( ) ; \nint slash = path . lastIndexOf ( '/' ) ; \nif ( ! ( slash >= 0 ) ) filename = path ; \nelse filename = path . substring ( slash + 1 ) ; \nif ( filename . length ( ) == 0 ) return null ; \nif ( trace ) log . trace ( \"Mapped systemId to filename: \" + filename ) ; \n} \ncatch ( URISyntaxException e ) { \nif ( trace ) log . trace ( \"systemId: is not a URI, using systemId as resource\" , e ) ; \n} \nInputStream is = loadClasspathResource ( filename , trace ) ; \nInputSource inputSource = null ; \nif ( is != null ) { \ninputSource = new InputSource ( is ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9393": "public class PublicId { \npublic static String decodeURN ( String urn ) { \nString publicId = \"\" ; \nif ( ! ( urn . startsWith ( \"urn:publicid:\" ) ) ) { \nreturn urn ; \n} \nelse { \npublicId = urn . substring ( 13 ) ; \n} \npublicId = PublicId . stringReplace ( publicId , \"%2F\" , \"/\" ) ; \npublicId = PublicId . stringReplace ( publicId , \":\" , \"//\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3A\" , \":\" ) ; \npublicId = PublicId . stringReplace ( publicId , \";\" , \"::\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"+\" , \" \" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%2B\" , \"+\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%23\" , \"#\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3F\" , \"?\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%27\" , \"'\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3B\" , \";\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%25\" , \"%\" ) ; \nreturn publicId ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( ! ( deep && ( array [ i ] instanceof Object [ ] ) ) ) { \nhashcode ^= array [ i ] . hashCode ( ) ; \n} \nelse { \nhashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nint ch , nextch ; \nif ( ! tokenStack . empty ( ) ) { \nreturn ( String ) tokenStack . pop ( ) ; \n} \nwhile ( true ) { \nch = catfile . read ( ) ; \nwhile ( ch <= ' ' ) { \nch = catfile . read ( ) ; \nif ( ch < 0 ) { \nreturn null ; \n} \n} \nnextch = catfile . read ( ) ; \nif ( nextch < 0 ) { \nreturn null ; \n} \nif ( ! ( ch == '-' && nextch == '-' ) ) { \nstack [ ++ top ] = nextch ; \nstack [ ++ top ] = ch ; \nbreak ; \n} \nelse { \nch = ' ' ; \nnextch = nextChar ( ) ; \nwhile ( ch != '-' || nextch != '-' ) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \n} \nch = nextChar ( ) ; \nif ( ! ( ch == '\"' || ch == '\\'' ) ) { \nwhile ( ch > ' ' ) { \nnextch = nextChar ( ) ; \nif ( ! ( ch == '-' && nextch == '-' ) ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \nelse { \nstack [ ++ top ] = ch ; \nstack [ ++ top ] = nextch ; \nreturn token ; \n} \n} \nreturn token ; \n} \nelse { \nint quote = ch ; \nwhile ( ( ch = nextChar ( ) ) != quote ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \n} \n} \n"}
{"9404": "public class DateEditor { \npublic static void initialize ( ) { \nPrivilegedAction action = new PrivilegedAction ( ) { \npublic Object run ( ) { \nString defaultFormat = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.format\" , \"MMM d, yyyy\" ) ; \nString defaultLocale = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.locale\" ) ; \nDateFormat defaultDateFormat ; \nif ( ! ( defaultLocale == null || defaultLocale . length ( ) == 0 ) ) { \ndefaultDateFormat = new SimpleDateFormat ( defaultFormat , Strings . parseLocaleString ( defaultLocale ) ) ; \n} \nelse { \ndefaultDateFormat = new SimpleDateFormat ( defaultFormat ) ; \n} \nformats = new DateFormat [ ] { \ndefaultDateFormat , new SimpleDateFormat ( \"EEE MMM d HH:mm:ss z yyyy\" ) , new SimpleDateFormat ( \"EEE, d MMM yyyy HH:mm:ss Z\" ) } \n; \nreturn null ; \n} \n} \n; \nAccessController . doPrivileged ( action ) ; \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nint colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( colIndex > 0 ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( ! ( \"xmlns\" . equals ( prefix ) ) ) { \nElement nsElement = el ; \nwhile ( namespaceURI . equals ( \"\" ) && nsElement != null ) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; \n} \n} \nelse { \nnamespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \n} \nif ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attribs . getLength ( ) ; \ni ++ ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( ! ( uri == null && qname . startsWith ( \"xmlns\" ) ) ) { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \nelse { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \n} \n} \n} \n"}
{"9425": "public class DOMCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nDocumentBuilderFactory factory = null ; \nDocumentBuilder builder = null ; \nfactory = DocumentBuilderFactory . newInstance ( ) ; \nfactory . setNamespaceAware ( false ) ; \nfactory . setValidating ( false ) ; \ntry { \nbuilder = factory . newDocumentBuilder ( ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nDocument doc = null ; \ntry { \ndoc = builder . parse ( is ) ; \n} \ncatch ( SAXException se ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \nElement root = doc . getDocumentElement ( ) ; \nString namespaceURI = Namespaces . getNamespaceURI ( root ) ; \nString localName = Namespaces . getLocalName ( root ) ; \nString domParserClass = getCatalogParser ( namespaceURI , localName ) ; \nif ( domParserClass == null ) { \nif ( ! ( namespaceURI == null ) ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + \"{\" + namespaceURI + \"}\" + localName ) ; \n} \nelse { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + localName ) ; \n} \nreturn ; \n} \nDOMCatalogParser domParser = null ; \ntry { \ndomParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot load XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot instantiate XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot access XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ClassCastException cce ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot cast XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nNode node = root . getFirstChild ( ) ; \nwhile ( node != null ) { \ndomParser . parseCatalogEntry ( catalog , node ) ; \nnode = node . getNextSibling ( ) ; \n} \n} \n} \n"}
{"9428": "public class CatalogLocation { \npublic InputSource resolveEntity ( String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolvedURI = catologResolver . resolveSystem ( systemId ) ; \nif ( resolvedURI == null ) { \nresolvedURI = catologResolver . resolvePublic ( publicId , systemId ) ; \n} \nif ( ! ( resolvedURI != null ) ) { \nthis . isLastEntityResolved = false ; \nreturn null ; \n} \nelse { \nfinal InputSource is = new InputSource ( ) ; \nis . setPublicId ( publicId ) ; \nis . setSystemId ( systemId ) ; \nis . setByteStream ( this . loadResource ( resolvedURI ) ) ; \nthis . isLastEntityResolved = true ; \nreturn is ; \n} \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nu < length ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( ! ( clazzCS != null ) ) results . append ( \"\\n++++Null CodeSource\" ) ; \nelse { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < ifaces . length ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( ! ( cs != null ) ) results . append ( \"\\n++++Null CodeSource\" ) ; \nelse { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( ! ( clazz == null ) ) { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( int i = 0 ; \ni < intfs . length ; \n++ i ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( \"}\" ) ; \n} \nelse buffer . append ( \"**null**\" ) ; \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( ! ( method != null ) ) { \ntype . newInstance ( ) ; \n} \nelse { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9440": "public class Classes { \npublic final static Method getAttributeGetter ( Class cls , String attr ) throws NoSuchMethodException { \nStringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; \nbuf . append ( \"get\" ) ; \nif ( ! ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) ) { \nbuf . append ( attr ) ; \n} \nelse { \nbuf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; \n} \ntry { \nreturn cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; \n} \ncatch ( NoSuchMethodException e ) { \nbuf . replace ( 0 , 3 , \"is\" ) ; \nreturn cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; \n} \n} \n} \n"}
{"9441": "public class Classes { \npublic final static Method getAttributeSetter ( Class cls , String attr , Class type ) throws NoSuchMethodException { \nStringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; \nbuf . append ( \"set\" ) ; \nif ( ! ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) ) { \nbuf . append ( attr ) ; \n} \nelse { \nbuf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; \n} \nreturn cls . getMethod ( buf . toString ( ) , new Class [ ] { \ntype } \n) ; \n} \n} \n"}
{"9444": "public class DefaultPropertyReader { \npublic static String [ ] getFilenames ( final String propertyName ) throws PropertyException { \nString filenames [ ] ; \nObject filename = PropertyManager . getProperty ( propertyName ) ; \nif ( ! ( filename != null ) ) { \nfilenames = PropertyManager . getArrayProperty ( propertyName ) ; \n} \nelse { \nfilenames = new String [ ] { \nString . valueOf ( filename ) } \n; \n} \nreturn filenames ; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nwhile ( next == null ) { \nif ( ! ( iter . hasNext ( ) ) ) { \nbreak ; \n} \nelse { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9456": "public class ApplicationDeadlockException { \npublic static ApplicationDeadlockException isADE ( Throwable t ) { \nwhile ( t != null ) { \nif ( ! ( t instanceof ApplicationDeadlockException ) ) { \nt = t . getCause ( ) ; \n} \nelse { \nreturn ( ApplicationDeadlockException ) t ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9471": "public class BootstrapResolver { \npublic InputSource resolveEntity ( String publicId , String systemId ) { \nString resolved = null ; \nif ( ! ( systemId != null && systemMap . containsKey ( systemId ) ) ) if ( publicId != null && publicMap . containsKey ( publicId ) ) { \nresolved = ( String ) publicMap . get ( publicId ) ; \n} \nelse { \nresolved = ( String ) systemMap . get ( systemId ) ; \n} \nif ( resolved != null ) { \ntry { \nInputSource iSource = new InputSource ( resolved ) ; \niSource . setPublicId ( publicId ) ; \nURL url = new URL ( resolved ) ; \nInputStream iStream = url . openStream ( ) ; \niSource . setByteStream ( iStream ) ; \nreturn iSource ; \n} \ncatch ( Exception e ) { \nreturn null ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9472": "public class BootstrapResolver { \npublic Source resolve ( String href , String base ) throws TransformerException { \nString uri = href ; \nint hashPos = href . indexOf ( \"#\" ) ; \nif ( hashPos >= 0 ) { \nuri = href . substring ( 0 , hashPos ) ; \n} \nString result = null ; \nif ( href != null && uriMap . containsKey ( href ) ) { \nresult = ( String ) uriMap . get ( href ) ; \n} \nif ( result == null ) { \ntry { \nURL url = null ; \nif ( ! ( base == null ) ) { \nURL baseURL = new URL ( base ) ; \nurl = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; \nresult = url . toString ( ) ; \n} \nelse { \nurl = new URL ( uri ) ; \nresult = url . toString ( ) ; \n} \n} \ncatch ( java . net . MalformedURLException mue ) { \nString absBase = makeAbsolute ( base ) ; \nif ( ! ( ! absBase . equals ( base ) ) ) { \nthrow new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; \n} \nelse { \nreturn resolve ( href , absBase ) ; \n} \n} \n} \nSAXSource source = new SAXSource ( ) ; \nsource . setInputSource ( new InputSource ( result ) ) ; \nreturn source ; \n} \n} \n"}
{"9473": "public class BootstrapResolver { \nprivate String makeAbsolute ( String uri ) { \nif ( uri == null ) { \nuri = \"\" ; \n} \ntry { \nURL url = new URL ( uri ) ; \nreturn url . toString ( ) ; \n} \ncatch ( MalformedURLException mue ) { \nString dir = System . getProperty ( \"user.dir\" ) ; \nString file = \"\" ; \nif ( ! ( dir . endsWith ( \"/\" ) ) ) { \nfile = \"file://\" + dir + \"/\" + uri ; \n} \nelse { \nfile = \"file://\" + dir + uri ; \n} \ntry { \nURL fileURL = new URL ( file ) ; \nreturn fileURL . toString ( ) ; \n} \ncatch ( MalformedURLException mue2 ) { \nreturn uri ; \n} \n} \n} \n} \n"}
{"9474": "public class MarshalledValueInputStream { \nprotected Class < ? > resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nString className = v . getName ( ) ; \ntry { \nreturn Class . forName ( className , false , loader ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nClass cl = primClasses . get ( className ) ; \nif ( ! ( cl == null ) ) return cl ; \nelse throw cnfe ; \n} \n} \n} \n"}
{"9475": "public class MethodBoundPropertyListener { \nprotected void invokeSetter ( String value ) { \ntry { \nClass < ? > type = descriptor . getPropertyType ( ) ; \nPropertyEditor editor = PropertyEditors . findEditor ( type ) ; \neditor . setAsText ( value ) ; \nObject coerced = editor . getValue ( ) ; \nsetter . invoke ( instance , new Object [ ] { \ncoerced } \n) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable target = e . getTargetException ( ) ; \nif ( ! ( target instanceof PropertyException ) ) { \nthrow new PropertyException ( target ) ; \n} \nelse { \nthrow ( PropertyException ) target ; \n} \n} \ncatch ( Exception e ) { \nthrow new PropertyException ( e ) ; \n} \n} \n} \n"}
{"9477": "public class Namespaces { \npublic static String getNamespaceURI ( Node node , String prefix ) { \nif ( node == null || node . getNodeType ( ) != Node . ELEMENT_NODE ) { \nreturn null ; \n} \nif ( ! ( prefix . equals ( \"\" ) ) ) { \nString nsattr = \"xmlns:\" + prefix ; \nif ( ( ( Element ) node ) . hasAttribute ( nsattr ) ) { \nreturn ( ( Element ) node ) . getAttribute ( nsattr ) ; \n} \n} \nelse { \nif ( ( ( Element ) node ) . hasAttribute ( \"xmlns\" ) ) { \nreturn ( ( Element ) node ) . getAttribute ( \"xmlns\" ) ; \n} \n} \nreturn getNamespaceURI ( node . getParentNode ( ) , prefix ) ; \n} \n} \n"}
{"9483": "public class Vertex { \npublic boolean addEdge ( Edge < T > e ) { \nif ( ! ( e . getFrom ( ) == this ) ) if ( ! ( e . getTo ( ) == this ) ) return false ; \nelse incomingEdges . add ( e ) ; \nelse outgoingEdges . add ( e ) ; \nreturn true ; \n} \n} \n"}
{"9486": "public class Vertex { \npublic boolean hasEdge ( Edge < T > e ) { \nif ( ! ( e . getFrom ( ) == this ) ) if ( ! ( e . getTo ( ) == this ) ) return false ; \nelse return incomingEdges . contains ( e ) ; \nelse return outgoingEdges . contains ( e ) ; \n} \n} \n"}
{"9487": "public class Vertex { \npublic boolean remove ( Edge < T > e ) { \nif ( ! ( e . getFrom ( ) == this ) ) if ( ! ( e . getTo ( ) == this ) ) return false ; \nelse incomingEdges . remove ( e ) ; \nelse outgoingEdges . remove ( e ) ; \nreturn true ; \n} \n} \n"}
{"9489": "public class Vertex { \npublic Edge < T > findEdge ( Edge < T > e ) { \nif ( ! ( outgoingEdges . contains ( e ) ) ) return null ; \nelse return e ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( ! ( src . isDirectory ( ) ) ) if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \nelse { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \n} \n} \n"}
{"9494": "public class StructsBatchCompiler { \nprivate void internalInstallJvmTypeProvider ( XtextResourceSet resourceSet , File tmpClassDirectory , boolean skipIndexLookup ) { \nIterable < String > classPathEntries = concat ( getClassPathEntries ( ) , getSourcePathDirectories ( ) , asList ( tmpClassDirectory . toString ( ) ) ) ; \nclassPathEntries = filter ( classPathEntries , new Predicate < String > ( ) { \npublic boolean apply ( String input ) { \nreturn ! Strings . isEmpty ( input . trim ( ) ) ; \n} \n} \n) ; \nFunction < String , URL > toUrl = new Function < String , URL > ( ) { \npublic URL apply ( String from ) { \ntry { \nreturn new File ( from ) . toURI ( ) . toURL ( ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n; \nIterable < URL > classPathUrls = Iterables . transform ( classPathEntries , toUrl ) ; \nlog . debug ( \"classpath used for Struct compilation : \" + classPathUrls ) ; \nClassLoader parentClassLoader ; \nif ( ! ( useCurrentClassLoaderAsParent ) ) { \nif ( ! ( isEmpty ( bootClassPath ) ) ) { \nIterable < URL > bootClassPathUrls = Iterables . transform ( getBootClassPathEntries ( ) , toUrl ) ; \nparentClassLoader = new BootClassLoader ( toArray ( bootClassPathUrls , URL . class ) ) ; \n} \nelse { \nparentClassLoader = ClassLoader . getSystemClassLoader ( ) . getParent ( ) ; \n} \n} \nelse { \nparentClassLoader = currentClassLoader ; \n} \nClassLoader urlClassLoader = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , parentClassLoader ) ; \nnew ClasspathTypeProvider ( urlClassLoader , resourceSet , skipIndexLookup ? null : indexedJvmTypeAccess ) ; \nresourceSet . setClasspathURIContext ( urlClassLoader ) ; \nURLClassLoader urlClassLoaderForAnnotationProcessing = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , currentClassLoader ) ; \nresourceSet . eAdapters ( ) . add ( new ProcessorClassloaderAdapter ( urlClassLoaderForAnnotationProcessing ) ) ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( ! ( file . isDirectory ( ) ) ) { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \nelse { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9496": "public class Dispatcher { \npublic void dispatchOnFxThread ( Action action ) { \nif ( ! ( Platform . isFxApplicationThread ( ) ) ) { \nPlatform . runLater ( ( ) -> actionStream . push ( action ) ) ; \n} \nelse { \nactionStream . push ( action ) ; \n} \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( ! ( an != null ) ) { \nusage ( ) ; \nreturn ; \n} \nelse { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nif ( args . length > 1 ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . println ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( ! ( \"simple\" . equals ( mode ) ) ) { \nseg = new ComplexSeg ( dic ) ; \n} \nelse { \nseg = new SimpleSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \n} \n} \n"}
{"9535": "public class StringUtils { \npublic static String join ( final List < String > list ) { \nif ( ! ( list == null ) ) if ( ! ( list . size ( ) == 0 ) ) if ( list . size ( ) == 1 ) { \nreturn list . get ( 0 ) ; \n} \nelse { \nreturn \"\" ; \n} \nelse { \nreturn null ; \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9536": "public class StringUtils { \npublic static String join ( final String [ ] list ) { \nif ( ! ( list == null ) ) if ( ! ( list . length == 0 ) ) if ( list . length == 1 ) { \nreturn list [ 0 ] ; \n} \nelse { \nreturn \"\" ; \n} \nelse { \nreturn null ; \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9539": "public class EntityProcessor { \nprivate void inspectId ( ) { \nif ( entityModel . getIdField ( ) == null ) { \nList < FieldModel > fields = entityModel . getFields ( ) ; \nfor ( FieldModel f : fields ) { \nif ( EntityModel . DEFAULT_ID_FIELD . equals ( f . getFieldName ( ) ) ) { \nentityModel . setIdField ( f ) ; \n} \n} \n} \nFieldModel idField = entityModel . getIdField ( ) ; \nif ( ! ( idField != null && \"long\" . equals ( idField . getJavaType ( ) ) ) ) { \nabort ( \"Entity must contain a field named id or annotated with @Id of type long\" ) ; \n} \nelse { \nreturn ; \n} \n} \n} \n"}
{"9556": "public class PlanBindings { \npublic void add ( Plan plan , Set < Belief > planBindings ) { \nif ( plan == null ) { \nreturn ; \n} \nif ( this . bindings . containsKey ( plan ) ) { \nSet < Belief > oldBindings = this . bindings . remove ( plan ) ; \nif ( ! ( oldBindings == null || oldBindings . isEmpty ( ) ) ) { \ncachedsize -= oldBindings . size ( ) ; \n} \nelse { \ncachedsize -- ; \n} \n} \nthis . bindings . put ( plan , planBindings ) ; \nif ( ! ( planBindings == null || planBindings . isEmpty ( ) ) ) { \ncachedsize += planBindings . size ( ) ; \n} \nelse { \ncachedsize ++ ; \n} \n} \n} \n"}
{"9572": "public class Program { \npublic static void registerExtension ( JillExtension extension ) { \nif ( ! ( extension != null ) ) { \nMain . logger . warn ( \"Cannot register null extension; will ignore.\" ) ; \n} \nelse { \nGlobalState . eventHandlers . add ( extension ) ; \nMain . logger . info ( \"Registered Jill extension: \" + extension ) ; \n} \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( ! ( config == null ) ) if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \nelse { \nabort ( \"Configuration file or string was not given\" ) ; \n} \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nint index = idx & 0xff ; \nif ( ! ( isEmpty ( ) ) ) if ( index < 0 || index >= size ) { \nreturn null ; \n} \nelse { \nreturn null ; \n} \nreturn objects [ index ] ; \n} \n} \n"}
{"9605": "public class IntentionSelector { \npublic void run ( ) { \nSet < Integer > toRemove = new HashSet < Integer > ( ) ; \ndo { \nboolean idle = true ; \nremoveInactiveAgents ( ) ; \naddActiveAgents ( ) ; \nfor ( Integer i : activeAgents ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nStack255 agentExecutionStack = ( Stack255 ) ( agent ) . getExecutionStack ( ) ; \nif ( ! isStackValid ( agent , agentExecutionStack ) ) { \ntoRemove . add ( i ) ; \ncontinue ; \n} \nidle = false ; \nObject node = ( Object ) agentExecutionStack . get ( ( byte ) ( agentExecutionStack . size ( ) - 1 ) ) ; \nif ( ! ( node instanceof Plan ) ) if ( node instanceof Goal ) { \nmanageGoal ( i , agent , agentExecutionStack , ( Goal ) node ) ; \n} \nelse { \nmanagePlan ( i , agentExecutionStack , ( Plan ) node , toRemove ) ; \n} \nagent . nextActiveStack ( ) ; \n} \nremoveFinishedAgents ( toRemove ) ; \nif ( idle ) { \nwaitOnExternalMessage ( ) ; \nif ( shutdown ) { \nbreak ; \n} \n} \n} \nwhile ( true ) ; \nlogger . debug ( \"Pool {} is exiting\" , poolid ) ; \n} \n} \n"}
{"9611": "public class Board { \npublic boolean move ( int pinA , int pinB ) { \nif ( ! ( pinA < 0 || pinA >= pins . length || pinB < 0 || pinB >= pins . length ) ) if ( ! ( pins [ pinA ] . isEmpty ( ) ) ) if ( pinA == pinB ) { \nLog . info ( \"Moving disc from pin\" + pinA + \" on to itself (means the board will not change)\" ) ; \nreturn true ; \n} \nelse { \nLog . warn ( \"No disc on pin\" + pinA ) ; \nreturn false ; \n} \nelse { \nLog . warn ( \"Invalid board pin specified \" + pinA + \". Should be between 0..\" + ( pins . length - 1 ) + \" (inclusive).\" ) ; \nreturn false ; \n} \nint discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; \nint discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; \nif ( discOnB < discOnA ) { \nLog . warn ( \"Cannot move disc\" + discOnA + \" (pin\" + pinA + \") on to smaller disc\" + discOnB + \" (pin\" + pinB + \")\" ) ; \nreturn false ; \n} \npins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; \nreturn true ; \n} \n} \n"}
{"9612": "public class Main { \npublic static boolean init ( Config config ) { \nif ( config . isDoPauseForUserInput ( ) ) { \nProgram . pauseForUserInput ( ) ; \n} \nLog . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; \nlogger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; \nint numAgents = 0 ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nnumAgents += agentType . getCount ( ) ; \n} \nfinal int increment = 10000 ; \nGlobalState . reset ( ) ; \nGlobalState . agents = new AObjectCatalog ( \"agents\" , numAgents , increment ) ; \nGlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; \nlong t0 ; \nt0 = System . currentTimeMillis ( ) ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nif ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) { \nreturn false ; \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Created \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nProgram . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; \nif ( ! ( config . getProgramOutputFile ( ) != null ) ) { \nwriter = System . out ; \n} \nelse { \ntry { \nwriter = new PrintStream ( config . getProgramOutputFile ( ) , \"UTF-8\" ) ; \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nlogger . error ( \"Could not open program outout file \" + config . getProgramOutputFile ( ) , e ) ; \n} \n} \nProgram . initIntentionSelectionThreads ( config ) ; \nreturn true ; \n} \n} \n"}
{"9619": "public class JpaUtils { \npublic static Expression < ? > join ( String attribute , From < ? , ? > from ) { \nExpression < ? > path ; \ntry { \nString [ ] properties = attribute . split ( \"\\\\.\" ) ; \nif ( ! ( properties . length > 1 ) ) { \npath = from . get ( properties [ 0 ] ) ; \n} \nelse { \npath = joinRecursively ( properties , findOrCreateJoin ( properties [ 0 ] , from ) , 1 ) . get ( properties [ properties . length - 1 ] ) ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nthrow SeedException . wrap ( e , JpaErrorCode . UNABLE_TO_CREATE_JPA_JOIN_FOR_SPECIFICATION ) . put ( \"property\" , attribute ) ; \n} \nreturn path ; \n} \n} \n"}
{"9620": "public class JpaUtils { \nprivate static Join < ? , ? > joinRecursively ( String [ ] properties , Join < ? , ? > join , int index ) { \nif ( ! ( index < properties . length - 1 ) ) { \nreturn join ; \n} \nelse { \nreturn joinRecursively ( properties , findOrCreateJoin ( properties [ index ] , join ) , index + 1 ) ; \n} \n} \n} \n"}
{"9629": "public class AbstractGenerator { \nprotected final GeneratedFile getTargetFile ( final String artifactName , final String filename , final String logInfo ) { \nfinal Folder folder = getGeneratorConfig ( ) . findTargetFolder ( artifactName ) ; \nfinal File dir = folder . getCanonicalDir ( ) ; \nfinal File file = new File ( dir , filename ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! ( folder . isCreate ( ) ) ) { \nthrow new IllegalStateException ( \"Directory '\" + dir + \"' does not exist, but configuration does not allow creation: \" + \"<folder name=\\\"\" + folder . getName ( ) + \"\\\" create=\\\"false\\\" ... />\" ) ; \n} \nelse { \ndir . mkdirs ( ) ; \n} \n} \nif ( ! file . getParentFile ( ) . exists ( ) ) { \nfile . getParentFile ( ) . mkdirs ( ) ; \n} \nif ( file . exists ( ) && ! folder . overrideAllowed ( file ) ) { \nreturn new GeneratedFile ( file , logInfo , true ) ; \n} \nreturn new GeneratedFile ( file , logInfo ) ; \n} \n} \n"}
{"9630": "public class AbstractGenerator { \nprotected final void write ( @ NotNull final GeneratedArtifact artifact ) throws GenerateException { \nContract . requireArgNotNull ( \"artifact\" , artifact ) ; \nfinal GeneratedFile genFile = getTargetFile ( artifact . getName ( ) , artifact . getPathAndName ( ) , null ) ; \nif ( ! ( genFile . isSkip ( ) ) ) { \nLOG . debug ( \"Writing file:  {} [{}]\" , genFile , artifact ) ; \ntry { \nfinal OutputStream out = new BufferedOutputStream ( new FileOutputStream ( genFile . getTmpFile ( ) ) ) ; \ntry { \nout . write ( artifact . getData ( ) ) ; \n} \nfinally { \nout . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error writing artifact '\" + artifact + \"' to '\" + artifact . getPathAndName ( ) + \"'!\" , ex ) ; \n} \n} \nelse { \nLOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , artifact ) ; \n} \n} \n} \n"}
{"9637": "public class GeneratedFile { \npublic final void persist ( ) { \nif ( persisted ) { \nreturn ; \n} \ntry { \nif ( ! ( FileUtils . contentEquals ( tmpFile , file ) ) ) { \nif ( file . exists ( ) && ! file . delete ( ) ) { \nthrow new IOException ( \"Wasn't able to delete file \" + file ) ; \n} \nif ( ! tmpFile . renameTo ( file ) ) { \nthrow new IOException ( \"Wasn't able to rename temporary file \" + tmpFile + \" to \" + file ) ; \n} \nLOG . info ( \"Generated: {} {}\" , getPath ( ) , logInfo ) ; \n} \nelse { \nLOG . debug ( \"Omitted: {} {}\" , getPath ( ) , logInfo ) ; \nif ( ! tmpFile . delete ( ) ) { \ntmpFile . deleteOnExit ( ) ; \n} \n} \npersisted = true ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Error comparing content: tmp=\" + tmpFile + \", target=\" + file + logInfo , ex ) ; \n} \n} \n} \n"}
{"9638": "public class AbstractEndpoint { \npublic final void setDefaultLink ( String rel , String ... hrefs ) { \nif ( ! ( hrefs == null || hrefs . length == 0 ) ) { \ndefaultLinks . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; \n} \nelse { \ndefaultLinks . remove ( rel ) ; \n} \n} \n} \n"}
{"9639": "public class AbstractEndpoint { \npublic final void setDefaultLinkTemplate ( String rel , String href ) { \nif ( ! ( href == null ) ) { \ndefaultLinkTemplates . put ( rel , href ) ; \n} \nelse { \ndefaultLinkTemplates . remove ( rel ) ; \n} \n} \n} \n"}
{"9641": "public class AbstractEndpoint { \nprotected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { \ngetLinkHeaders ( response ) . forEach ( header -> { \nif ( header . getRel ( ) == null ) { \nreturn ; \n} \nif ( ! ( header . isTemplated ( ) ) ) { \ngetOrAdd ( links , header . getRel ( ) ) . put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; \n} \nelse { \nlinkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"9643": "public class AbstractEndpoint { \nprivate void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { \nJsonNode href = obj . findValue ( \"href\" ) ; \nif ( href == null ) { \nreturn ; \n} \nJsonNode templated = obj . findValue ( \"templated\" ) ; \nif ( ! ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) ) { \nJsonNode title = obj . findValue ( \"title\" ) ; \nlinksForRel . put ( uri . resolve ( href . asText ( ) ) , ( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; \n} \nelse { \nlinkTemplates . put ( rel , href . asText ( ) ) ; \n} \n} \n} \n"}
{"9670": "public class AbstractEMFParser { \nprivate void parseDir ( final File dir ) { \nLOG . debug ( \"Parse: {}\" , dir ) ; \nfinal File [ ] files = getFiles ( dir ) ; \nif ( ! ( ( files == null ) || ( files . length == 0 ) ) ) { \nfor ( final File file : files ) { \nif ( ! ( file . isFile ( ) ) ) { \nparseDir ( file ) ; \n} \nelse { \nfinal Resource resource = resourceSet . getResource ( URI . createFileURI ( Utils4J . getCanonicalPath ( file ) ) , true ) ; \nfinal EList < Diagnostic > diagnostics = resource . getErrors ( ) ; \nif ( ! ( diagnostics . size ( ) == 0 ) ) { \nerror = true ; \nLOG . error ( \"Parsed {} with errors: {}\" , file , diagnostics ) ; \n} \nelse { \nLOG . debug ( \"Parsed {}\" , file ) ; \n} \n} \n} \n} \nelse { \nLOG . debug ( \"No files found in directory: {}\" , dir ) ; \n} \n} \n} \n"}
{"9673": "public class AbstractEMFParser { \nprotected final void setModelDirs ( final File ... modelDirs ) { \nif ( ! ( modelDirs == null ) ) { \nthis . modelDirs = new ArrayList < File > ( ) ; \nthis . modelDirs . addAll ( Arrays . asList ( modelDirs ) ) ; \n} \nelse { \nthis . modelDirs = null ; \n} \n} \n} \n"}
{"9674": "public class AbstractEMFParser { \nprotected final void setFileExtensions ( final String ... fileExtensions ) { \nif ( ! ( fileExtensions == null ) ) { \nthis . fileExtensions = new ArrayList < String > ( ) ; \nthis . fileExtensions . addAll ( Arrays . asList ( fileExtensions ) ) ; \n} \nelse { \nthis . fileExtensions = null ; \n} \n} \n} \n"}
{"9675": "public class AbstractEMFParser { \nprotected final void setModelResources ( final URI ... modelResources ) { \nif ( ! ( modelResources == null ) ) { \nthis . modelResources = new ArrayList < URI > ( ) ; \nthis . modelResources . addAll ( Arrays . asList ( modelResources ) ) ; \n} \nelse { \nthis . modelResources = null ; \n} \n} \n} \n"}
{"9678": "public class StatementImpl { \npublic void setBoolean2 ( String parameterName , Boolean value ) throws java . sql . SQLException { \nif ( ! ( value == null ) ) { \nsetBoolean ( parameterName , value ) ; \n} \nelse { \nsetNull ( parameterName , Types . BIT ) ; \n} \n} \n} \n"}
{"9681": "public class VelocityGenerator { \nprotected final void merge ( final VelocityContext context , final String artifactName , final String templateName , final String filename ) throws GenerateException { \nfinal GeneratedFile genFile = getTargetFile ( artifactName , filename , templateName ) ; \nif ( ! ( genFile . isSkip ( ) ) ) { \nLOG . debug ( \"Start merging velocity template: {} [{}]\" , genFile , templateName ) ; \ntry { \nfinal Writer writer = new FileWriter ( genFile . getTmpFile ( ) ) ; \ntry { \nfinal Template template = ve . getTemplate ( templateName ) ; \ntemplate . merge ( context , writer ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error merging template '\" + templateName + \"' to '\" + filename + \"'!\" , ex ) ; \n} \n} \nelse { \nLOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , templateName ) ; \n} \n} \n} \n"}
{"9686": "public class WebViewFactory { \nprivate void configureWindow ( WebWindow web ) { \nif ( ! ( m_fullscreen ) ) { \nweb . showNormal ( ) ; \nif ( ! ( ! m_resizable ) ) { \nweb . setBaseSize ( new QSize ( m_width , m_height ) ) ; \n} \nelse { \nweb . setFixedSize ( new QSize ( m_width , m_height ) ) ; \n} \nweb . resize ( m_width , m_height ) ; \n} \nelse { \nm_width = web . width ( ) ; \nm_height = web . height ( ) ; \nweb . showFullScreen ( ) ; \n} \nif ( ! ( ! m_bar ) ) { \nweb . menuBar ( ) . setVisible ( true ) ; \nif ( m_icon != null ) { \nQIcon icon = new QIcon ( m_icon ) ; \nweb . setWindowIcon ( icon ) ; \n} \nweb . setWindowTitle ( m_appName ) ; \n} \nelse { \nweb . menuBar ( ) . setVisible ( false ) ; \n} \nif ( ! ( ! m_contextMenu ) ) { \nweb . setContextMenuPolicy ( ContextMenuPolicy . DefaultContextMenu ) ; \n} \nelse { \nweb . setContextMenuPolicy ( ContextMenuPolicy . PreventContextMenu ) ; \n} \n} \n} \n"}
{"9687": "public class WebViewFactory { \npublic void print ( QWebView view ) { \nif ( ! ( m_print ) ) { \nm_logger . warn ( \"Print disabled\" ) ; \n} \nelse { \nQPrinter printer = new QPrinter ( ) ; \nQPrintDialog printDialog = new QPrintDialog ( printer , view ) ; \nif ( printDialog . exec ( ) == QDialog . DialogCode . Accepted . value ( ) ) { \nview . print ( printer ) ; \n} \n} \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \nfor ( int i = 0 ; \ni < maxCommonSize ; \n++ i ) { \nif ( ! ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) ) { \nbreak ; \n} \nelse { \nmatched = parts1 . get ( i ) ; \n} \n} \nreturn matched ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < baseParts . length ; \n++ i ) { \nif ( i > 0 || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( ! ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) ) if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \nelse { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9712": "public class LocalInstanceFactory { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < T > T newInstance ( ManagedClassSPI managedClass , Object ... args ) { \nConstructor < ? > constructor = managedClass . getConstructor ( ) ; \nif ( constructor == null ) { \nthrow new BugError ( \"Local instance factory cannot instantiate |%s|. Missing constructor.\" , managedClass ) ; \n} \nObject instance = null ; \ntry { \ninstance = constructor . newInstance ( args ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlog . error ( \"Wrong number of arguments or bad types for |%s|: [%s].\" , constructor , Strings . join ( Classes . getParameterTypes ( args ) ) ) ; \nthrow e ; \n} \ncatch ( InstantiationException e ) { \nthrow new BugError ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new BugError ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nlog . error ( \"Managed instance constructor |%s| fail due to: %s.\" , constructor , e . getCause ( ) ) ; \nthrow new InvocationException ( e ) ; \n} \nif ( managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { \nManagedProxyHandler handler = null ; \nif ( ! ( managedClass . isTransactional ( ) ) ) { \nhandler = new ManagedProxyHandler ( managedClass , instance ) ; \n} \nelse { \nTransactionalResource transactionalResource = managedClass . getContainer ( ) . getInstance ( TransactionalResource . class ) ; \nhandler = new ManagedProxyHandler ( transactionalResource , managedClass , instance ) ; \n} \nfinal ClassLoader classLoader = managedClass . getImplementationClass ( ) . getClassLoader ( ) ; \nfinal Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; \nreturn ( T ) Proxy . newProxyInstance ( classLoader , interfaceClasses , handler ) ; \n} \nreturn ( T ) instance ; \n} \n} \n"}
{"9727": "public class FitUtils { \npublic static String extractCellParameter ( FitCell cell ) { \nfinal Matcher matcher = PARAMETER_PATTERN . matcher ( cell . getFitValue ( ) ) ; \nif ( ! ( matcher . matches ( ) ) ) { \nreturn null ; \n} \nelse { \ncell . setFitValue ( matcher . group ( 1 ) ) ; \nreturn matcher . group ( 2 ) ; \n} \n} \n} \n"}
{"9739": "public class LogEventAnalyzer { \npublic void processNotContainsException ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithException ( parameters ) ; \nif ( ! ( match == null ) ) { \ncell . wrong ( match . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] ) ; \n} \nelse { \ncell . right ( ) ; \n} \n} \n} \n"}
{"9740": "public class LogEventAnalyzer { \npublic void processNotContains ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithString ( parameters ) ; \nif ( ! ( match == null ) ) { \ncell . wrong ( match . getMessage ( ) . toString ( ) ) ; \n} \nelse { \ncell . right ( ) ; \n} \n} \n} \n"}
{"9759": "public class FileSelector { \npublic File [ ] getFiles ( ) { \nfinal File [ ] files = directory . listFiles ( filter ) ; \nif ( ! ( files == null ) ) { \nreturn files ; \n} \nelse { \nreturn new File [ 0 ] ; \n} \n} \n} \n"}
{"9761": "public class AbstractParser { \n@ SuppressWarnings ( \"unchecked\" ) protected final CONFIG_TYPE getConcreteConfig ( final ParserConfig config ) { \nfinal Config < ParserConfig > cfg = config . getConfig ( ) ; \nif ( ! ( cfg == null ) ) { \nif ( ! ( concreteConfigClass . isAssignableFrom ( cfg . getConfig ( ) . getClass ( ) ) ) ) { \nthrow new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: \" + cfg . getConfig ( ) . getClass ( ) . getName ( ) + \" - Did you add the configuration class to the JXB context?\" ) ; \n} \n} \nelse { \nthrow new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: null\" ) ; \n} \nreturn ( CONFIG_TYPE ) cfg . getConfig ( ) ; \n} \n} \n"}
{"9767": "public class ResourceServlet { \n@ Override protected void handleRequest ( RequestContext context ) throws ServletException , IOException { \nfinal HttpServletRequest httpRequest = context . getRequest ( ) ; \nfinal HttpServletResponse httpResponse = context . getResponse ( ) ; \nArgumentsReader argumentsReader = null ; \nResource resource = null ; \ntry { \nManagedMethodSPI method = resourceMethods . get ( key ( context . getRequestPath ( ) ) ) ; \nif ( method == null ) { \nthrow new NoSuchMethodException ( httpRequest . getRequestURI ( ) ) ; \n} \nfinal Type [ ] formalParameters = method . getParameterTypes ( ) ; \nargumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; \nObject [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; \nObject controller = container . getInstance ( method . getDeclaringClass ( ) ) ; \nresource = method . invoke ( controller , arguments ) ; \nif ( resource == null ) { \nthrow new BugError ( \"Null resource |%s|.\" , httpRequest . getRequestURI ( ) ) ; \n} \n} \ncatch ( AuthorizationException e ) { \nString loginPage = container . getLoginPage ( ) ; \nif ( ! ( loginPage != null ) ) { \nhttpRequest . authenticate ( httpResponse ) ; \n} \nelse { \nhttpResponse . sendRedirect ( loginPage ) ; \n} \nreturn ; \n} \ncatch ( NoSuchMethodException | IllegalArgumentException e ) { \ndumpError ( context , e ) ; \nhttpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \nreturn ; \n} \ncatch ( InvocationException e ) { \ndumpError ( context , e ) ; \nif ( ! ( e . getCause ( ) instanceof NoSuchResourceException ) ) { \nhttpResponse . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getCause ( ) . getMessage ( ) ) ; \n} \nelse { \nhttpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \n} \nreturn ; \n} \nfinally { \nif ( argumentsReader != null ) { \nargumentsReader . clean ( ) ; \n} \n} \nhttpResponse . setStatus ( HttpServletResponse . SC_OK ) ; \nresource . serialize ( httpResponse ) ; \n} \n} \n"}
{"9777": "public class ViewManagerImpl { \n@ Override public void config ( Config config ) throws ConfigException , IOException { \nfor ( Config repositorySection : config . findChildren ( \"repository\" ) ) { \nString className = repositorySection . getAttribute ( \"class\" , DEF_IMPLEMENTATION ) ; \nClass < ? > implementation = Classes . forOptionalName ( className ) ; \nif ( implementation == null ) { \nthrow new ConfigException ( \"Unable to load view implementation |%s|.\" , className ) ; \n} \nif ( ! Types . isKindOf ( implementation , View . class ) ) { \nthrow new ConfigException ( \"View implementation |%s| is not of proper type.\" , className ) ; \n} \nif ( ! Classes . isInstantiable ( implementation ) ) { \nthrow new ConfigException ( \"View implementation |%s| is not instantiable. Ensure is not abstract or interface and have default constructor.\" , implementation ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Class < ? extends View > viewImplementation = ( Class < ? extends View > ) implementation ; \nString repositoryPath = repositorySection . getAttribute ( \"path\" ) ; \nif ( repositoryPath == null ) { \nthrow new ConfigException ( \"Invalid views repository configuration. Missing <path> attribute.\" ) ; \n} \nString filesPattern = repositorySection . getAttribute ( \"files-pattern\" ) ; \nif ( filesPattern == null ) { \nthrow new ConfigException ( \"Invalid views repository configuration. Missing <files-pattern> attribute.\" ) ; \n} \nConfigBuilder builder = new I18nRepository . ConfigBuilder ( repositoryPath , filesPattern ) ; \nI18nRepository repository = new I18nRepository ( builder . build ( ) ) ; \nif ( viewsMetaPool == null ) { \nviewsMetaPool = repository . getPoolInstance ( ) ; \n} \nProperties properties = repositorySection . getProperties ( ) ; \nfor ( I18nFile template : repository ) { \nViewMeta meta = new ViewMeta ( template . getFile ( ) , viewImplementation , properties ) ; \nif ( ! ( viewsMetaPool . put ( meta . getName ( ) , meta , template . getLocale ( ) ) ) ) { \nlog . debug ( \"Register view |%s|\" , meta ) ; \n} \nelse { \nlog . warn ( \"Override view |%s|\" , meta ) ; \n} \n} \n} \n} \n} \n"}
{"9779": "public class Launcher { \nprivate static void configureApplication ( ) { \nFile file = new File ( \"chameria.props\" ) ; \nif ( file . exists ( ) ) { \nProperties props = new Properties ( ) ; \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nprops . load ( is ) ; \nString n = props . getProperty ( \"application.name\" ) ; \nif ( ! ( n != null ) ) { \nQApplication . setApplicationName ( \"akquinet ChameRIA\" ) ; \n} \nelse { \nQApplication . setApplicationName ( n ) ; \n} \nn = props . getProperty ( \"application.version\" ) ; \nif ( n != null ) { \nQApplication . setApplicationVersion ( n ) ; \n} \nn = props . getProperty ( \"application.icon\" ) ; \nif ( n != null ) { \nQIcon icon = new QIcon ( n ) ; \nQApplication . setWindowIcon ( icon ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"Cannot read the application configuration \" + e . getMessage ( ) ) ; \ne . printStackTrace ( ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \nQApplication . setOrganizationName ( \"akquinet A.G.\" ) ; \n} \n} \n"}
{"9782": "public class Launcher { \npublic static ChameRIA createChameleon ( String [ ] args ) throws Exception { \nboolean debug = isDebugModeEnabled ( args ) ; \nString core = getCore ( args ) ; \nString app = getApp ( args ) ; \nString runtime = getRuntime ( args ) ; \nString fileinstall = getDeployDirectory ( args ) ; \nString config = getProps ( args ) ; \nif ( ! ( config == null || ! new File ( config ) . exists ( ) ) ) { \nreturn new ChameRIA ( core , debug , app , runtime , fileinstall , config ) ; \n} \nelse { \nreturn new ChameRIA ( core , debug , app , runtime , fileinstall , null ) ; \n} \n} \n} \n"}
{"9884": "public class ConnectionNotation { \nprivate void addDetails ( String str ) throws NotationException { \nString [ ] parts = str . split ( \"-\" ) ; \nsourceUnit = parts [ 0 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \ntargetUnit = parts [ 1 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \nrGroupSource = parts [ 0 ] . split ( \":\" ) [ 1 ] ; \nrGroupTarget = parts [ 1 ] . split ( \":\" ) [ 1 ] ; \nPattern r = Pattern . compile ( \"R\\\\d\" , Pattern . CASE_INSENSITIVE ) ; \nPattern pair = Pattern . compile ( \"pair\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher mR = r . matcher ( rGroupSource ) ; \nMatcher mPair = pair . matcher ( rGroupTarget ) ; \nif ( ! ( mR . matches ( ) ) ) { \nrGroupSource = rGroupSource . toLowerCase ( ) ; \n} \nelse { \nrGroupSource = rGroupSource . toUpperCase ( ) ; \n} \nif ( ! ( mPair . matches ( ) ) ) { \nrGroupTarget = rGroupTarget . toUpperCase ( ) ; \n} \nelse { \nrGroupTarget = rGroupTarget . toLowerCase ( ) ; \n} \n} \n} \n"}
{"9885": "public class ConnectionNotation { \npublic String toHELM2 ( ) { \nif ( ! ( isAnnotationTrue ( ) ) ) { \nreturn sourceId . getId ( ) + \",\" + targetId . getId ( ) + \",\" + sourceUnit + \":\" + rGroupSource + \"-\" + targetUnit + \":\" + rGroupTarget ; \n} \nelse { \nreturn sourceId . getId ( ) + \",\" + targetId . getId ( ) + \",\" + sourceUnit + \":\" + rGroupSource + \"-\" + targetUnit + \":\" + rGroupTarget + \"\\\"\" + annotation + \"\\\"\" ; \n} \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( ! ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) ) if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \nelse { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nSystem . out . println ( output ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . println ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . println ( \"Unexpected exception: \" + exp . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9893": "public class StateMachineParser { \npublic boolean isPeptideOrRna ( ) throws SimplePolymerSectionException { \nif ( ! ( polymerElements . size ( ) >= 1 ) ) { \nthrow new SimplePolymerSectionException ( \"No Polymer Id is found\" ) ; \n} \nelse { \nif ( polymerElements . get ( polymerElements . size ( ) - 1 ) . matches ( \"(PEPTIDE[1-9][0-9]*+|RNA[1-9][0-9]*)\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfPolymers . size ( ) ; \ni ++ ) { \nif ( ! ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) ) { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \n} \nelse { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9904": "public class PolymerNotation { \nprivate void setPolymerElements ( ) { \nif ( ! ( polymerID instanceof RNAEntity || polymerID instanceof PeptideEntity ) ) { \nthis . polymerElements = new PolymerSingleElements ( polymerID ) ; \n} \nelse { \nthis . polymerElements = new PolymerListElements ( polymerID ) ; \n} \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 1 ; \ni < sections . length ; \ni ++ ) { \nsb . append ( sections [ i ] + \"}$\" ) ; \n} \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( sections . length >= 2 ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 1 ] ) ; \n} \n} \nif ( sections . length >= 3 ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { \nif ( ! ( ! ( sections [ 1 ] . isEmpty ( ) ) ) ) { \nhelm2 . append ( sections [ 2 ] ) ; \n} \nelse { \nhelm2 . append ( \"|\" + sections [ 2 ] ) ; \n} \n} \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( sections . length >= 4 ) { \nif ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 3 ] ) ; \n} \n} \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9906": "public class MonomerNotation { \npublic void setAnnotation ( String str ) { \nif ( ! ( str != null ) ) { \nannotation = null ; \nisAnnotationHere = false ; \n} \nelse { \nannotation = str ; \nisAnnotationHere = true ; \n} \n} \n} \n"}
{"9908": "public class ValidationMethod { \npublic static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { \nMonomerNotation mon ; \nif ( ! ( str . startsWith ( \"(\" ) && str . endsWith ( \")\" ) ) ) { \nif ( ! ( type == \"RNA\" ) ) if ( ! ( type != \"BLOB\" ) ) { \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse { \nif ( str . length ( ) > 1 ) { \nif ( ! ( str . startsWith ( \"[\" ) && str . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse { \nmon = new MonomerNotationUnitRNA ( str , type ) ; \n} \n} \nelse { \nString str2 = str . substring ( 1 , str . length ( ) - 1 ) ; \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nPattern patternOR = Pattern . compile ( \",\" ) ; \nif ( ! ( patternAND . matcher ( str ) . find ( ) ) ) if ( ! ( patternOR . matcher ( str ) . find ( ) ) ) { \nif ( ! ( str . contains ( \".\" ) ) ) { \nif ( ! ( type == \"RNA\" ) ) { \nif ( str2 . length ( ) > 1 ) { \nif ( ! ( str2 . startsWith ( \"[\" ) && str2 . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str2 , type ) ; \n} \nelse { \nmon = new MonomerNotationUnitRNA ( str2 , type ) ; \n} \n} \nelse { \nmon = new MonomerNotationList ( str2 , type ) ; \n} \n} \nelse { \nmon = new MonomerNotationGroupOr ( str2 , type ) ; \n} \nelse { \nmon = new MonomerNotationGroupMixture ( str2 , type ) ; \n} \n} \nreturn mon ; \n} \n} \n"}
{"9909": "public class ValidationMethod { \npublic static MonomerNotationGroupElement decideWhichMonomerNotationInGroup ( String str , String type , double one , double two , boolean interval , boolean isDefault ) throws NotationException { \nMonomerNotation element ; \nelement = decideWhichMonomerNotation ( str , type ) ; \nif ( ! ( interval ) ) { \nreturn new MonomerNotationGroupElement ( element , one , isDefault ) ; \n} \nelse { \nreturn new MonomerNotationGroupElement ( element , one , two ) ; \n} \n} \n} \n"}
{"9910": "public class ValidationMethod { \npublic static HELMEntity decideWhichEntity ( String str ) throws NotationException { \nHELMEntity item ; \nif ( ! ( str . toUpperCase ( ) . matches ( \"PEPTIDE[1-9][0-9]*\" ) ) ) if ( ! ( str . toUpperCase ( ) . matches ( \"RNA[1-9][0-9]*\" ) ) ) if ( ! ( str . toUpperCase ( ) . matches ( \"BLOB[1-9][0-9]*\" ) ) ) if ( ! ( str . toUpperCase ( ) . matches ( \"CHEM[1-9][0-9]*\" ) ) ) if ( ! ( str . toUpperCase ( ) . matches ( \"G[1-9][0-9]*\" ) ) ) { \nthrow new NotationException ( \"ID is wrong: \" + str ) ; \n} \nelse { \nitem = new GroupEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nitem = new ChemEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nitem = new BlobEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nitem = new RNAEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nitem = new PeptideEntity ( str . toUpperCase ( ) ) ; \n} \nreturn item ; \n} \n} \n"}
{"9911": "public class MonomerNotationGroupElement { \npublic List < Double > getValue ( ) { \nif ( ! ( this . isInterval ) ) { \nreturn new ArrayList < Double > ( Arrays . asList ( numberOne ) ) ; \n} \nelse { \nreturn new ArrayList < Double > ( Arrays . asList ( numberOne , numberTwo ) ) ; \n} \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( ! ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) ) { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < test . length ( ) - 4 ; \ni ++ ) { \nparser . doAction ( test . charAt ( i ) ) ; \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \n} \n} \n"}
{"9914": "public class GroupingNotation { \nprivate void defineAmbiguity ( String a ) throws NotationException { \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nMatcher m = patternAND . matcher ( a ) ; \nif ( ! ( m . find ( ) ) ) { \nsetAmbiguity ( new GroupingOr ( a ) ) ; \n} \nelse { \nsetAmbiguity ( new GroupingMixture ( a ) ) ; \n} \n} \n} \n"}
{"9922": "public class API { \npublic void unsubscribe ( final String pattern ) throws InvalidInputException { \nfinal String s = this . prefix + pattern ; \nLinkedList < FunctionInterface9 > callback_list = this . callbacks . get ( s ) ; \nif ( ! ( callback_list == null ) ) { \ncallback_list . removeFirst ( ) ; \nif ( callback_list . isEmpty ( ) ) { \nthis . callbacks . remove ( s ) ; \n} \n} \nelse { \nthrow new InvalidInputException ( ) ; \n} \nOtpOutputStream unsubscribe = new OtpOutputStream ( ) ; \nunsubscribe . write ( OtpExternal . versionTag ) ; \nfinal OtpErlangObject [ ] tuple = { \nnew OtpErlangAtom ( \"unsubscribe\" ) , new OtpErlangString ( pattern ) } \n; \nunsubscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; \nsend ( unsubscribe ) ; \n} \n} \n"}
{"9923": "public class API { \npublic void return_ ( final Integer request_type , final String name , final String pattern , final byte [ ] response_info , final byte [ ] response , final Integer timeout , final byte [ ] trans_id , final OtpErlangPid pid ) throws ReturnAsyncException , ReturnSyncException , InvalidInputException { \nif ( ! ( request_type == API . ASYNC ) ) if ( ! ( request_type == API . SYNC ) ) throw new InvalidInputException ( ) ; \nelse return_sync ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \nelse return_async ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ! ( ( sp = ( int ) ( c = ctl ) ) != 0 ) ) if ( ! ( ex != null && ( c & ADD_WORKER ) != 0L ) ) break ; \nelse { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \n} \nif ( ! ( ex == null ) ) ForkJoinTask . rethrow ( ex ) ; \nelse ForkJoinTask . helpExpungeStaleExceptions ( ) ; \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nint seed = w . hint ; \nint r = ( seed == 0 ) ? 1 : seed ; \nfor ( ForkJoinTask < ? > t ; \n; \n) { \nif ( ! ( ( t = scan ( w , r ) ) != null ) ) if ( ! awaitWork ( w , r ) ) break ; \nelse w . runTask ( t ) ; \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ! ( ( ss = w . scanState ) >= 0 ) ) if ( ! ( spins > 0 ) ) if ( ! ( w . qlock < 0 ) ) if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ! ( ac <= 0 && ss == ( int ) c ) ) prevctl = parkTime = deadline = 0L ; \nelse { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \nelse return false ; \nelse { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse break ; \n} \nreturn true ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nint parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) parallelism = Integer . parseInt ( pp ) ; \nif ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \nif ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \nif ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) { \nif ( ! ( System . getSecurityManager ( ) == null ) ) factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \nelse factory = defaultForkJoinWorkerThreadFactory ; \n} \nif ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; \nif ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( ! ( t instanceof ForkJoinWorkerThread ) ) if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( ! ( status >= 0 ) ) notifyAll ( ) ; \nelse wait ( ms ) ; \n} \n} \n} \n} \nelse { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9962": "public class EMail { \npublic static Future < Boolean > sendMessage ( final Email msg ) { \nif ( ! ( asynchronousSend ) ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \nresult . append ( \"oops\" ) ; \n} \nreturn new Future < Boolean > ( ) { \npublic boolean cancel ( boolean mayInterruptIfRunning ) { \nreturn false ; \n} \npublic boolean isCancelled ( ) { \nreturn false ; \n} \npublic boolean isDone ( ) { \nreturn true ; \n} \npublic Boolean get ( ) throws InterruptedException , ExecutionException { \nreturn result . length ( ) == 0 ; \n} \npublic Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nreturn result . length ( ) == 0 ; \n} \n} \n; \n} \nelse { \nreturn executor . submit ( new Callable < Boolean > ( ) { \npublic Boolean call ( ) { \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \nreturn true ; \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \nreturn false ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"9963": "public class ApplicationRouter { \npublic void bind ( final RouteBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( ! ( method == Method . ANY ) ) { \nmethods . add ( method ) ; \n} \nelse { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nList < PatternRouteBinding > b = routeBindings . get ( key ) ; \nif ( b == null ) { \nb = new ArrayList < > ( ) ; \nrouteBindings . put ( key , b ) ; \n} \nlogger . info ( \"ADD: {}, Pattern: {}, Route: {}\\n\" , key , handler . getPath ( ) , handler ) ; \naddPattern ( handler , b ) ; \n} \n} \n} \n} \n"}
{"9964": "public class ApplicationRouter { \npublic void bind ( final FilterBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nfinal String path = handler . getPath ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( ! ( method == Method . ANY ) ) { \nmethods . add ( method ) ; \n} \nelse { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nlogger . info ( \"ADD: {}, Pattern: {}, Filter: {}\\n\" , key , path , handler ) ; \nList < PatternFilterBinding > allFilterBindings = this . filterBindings . get ( key ) ; \nif ( allFilterBindings == null ) { \nallFilterBindings = new ArrayList < > ( ) ; \nthis . filterBindings . put ( key , allFilterBindings ) ; \n} \nboolean found = false ; \nfor ( final PatternFilterBinding binding : allFilterBindings ) { \nif ( binding . getPattern ( ) . pattern ( ) . equals ( handler . getPath ( ) ) ) { \nbinding . addFilter ( handler ) ; \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nfinal PatternFilterBinding binding = new PatternFilterBinding ( handler . getPath ( ) , handler ) ; \nallFilterBindings . add ( binding ) ; \n} \n} \n} \n} \n} \n"}
{"9969": "public class PeriodicService { \npublic void doRun ( ) throws Exception { \nif ( ! ( inProgress . compareAndSet ( false , true ) ) ) { \nthrow new IllegalStateException ( \"Another run is already in progress\" ) ; \n} \nelse { \ntry { \nrun ( ) ; \n} \nfinally { \ninProgress . set ( false ) ; \n} \n} \n} \n} \n"}
{"9971": "public class SecurityKit { \npublic static < T extends Model > T getLoginWithDb ( HttpServletRequest req , HttpServletResponse response , Function < Long , T > function ) { \nT loginUser = getLoginUser ( req ) ; \nif ( ! ( loginUser == null ) ) { \nreturn loginUser ; \n} \nelse { \nCookieUser cookie_user = getUserFromCookie ( req ) ; \nif ( cookie_user == null ) return null ; \nT user = CacheKit . get ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) ) ; \nif ( user == null ) { \nuser = function . apply ( cookie_user . getId ( ) ) ; \nCacheKit . put ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) , user ) ; \n} \nif ( ! ( user != null && StringUtils . equalsIgnoreCase ( user . getStr ( \"password\" ) , cookie_user . getPassword ( ) ) ) ) { \nreturn null ; \n} \nelse { \nsetLoginMember ( req , response , user , true ) ; \nreturn user ; \n} \n} \n} \n} \n"}
{"9980": "public class Logger { \npublic static void debug ( String message , Object ... args ) { \nif ( ! ( recordCaller ) ) { \nslf4j . debug ( message , args ) ; \n} \nelse { \nLoggerFactory . getLogger ( getCallerClassName ( ) ) . debug ( message , args ) ; \n} \n} \n} \n"}
{"9990": "public class Invoker { \npublic static void invokeInThread ( DirectInvocation invocation ) { \nboolean retry = true ; \nwhile ( retry ) { \ninvocation . run ( ) ; \nif ( ! ( invocation . retry == null ) ) { \ntry { \nif ( ! ( invocation . retry . task != null ) ) { \nThread . sleep ( invocation . retry . timeout ) ; \n} \nelse { \ninvocation . retry . task . get ( ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new UnexpectedException ( e ) ; \n} \nretry = true ; \n} \nelse { \nretry = false ; \n} \n} \n} \n} \n"}
{"9995": "public class Controller { \nprotected String parsePath ( String currentActionPath , String url ) { \nif ( ! ( url . startsWith ( SLASH ) ) ) if ( ! ( ! url . contains ( SLASH ) ) ) if ( url . contains ( \"http:\" ) || url . contains ( \"https:\" ) ) { \nreturn null ; \n} \nelse { \nreturn SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nelse { \nreturn url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nreturn currentActionPath + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nbyte buffer [ ] = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( byteCount > 0 ) { \nif ( ! ( byteCount < ioBufferSize ) ) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nelse { \nread = input . read ( buffer , 0 , byteCount ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \nbyteCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( charCount > 0 ) { \nif ( ! ( charCount < ioBufferSize ) ) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nelse { \nread = input . read ( buffer , 0 , charCount ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \ncharCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( int i = 0 ; \ni < stages . size ( ) ; \ni ++ ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( ! ( stage instanceof Function ) ) if ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \nelse { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null && patterns . length > 0 ) { \nif ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) { \ncontinue ; \n} \n} \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( ! ( entry . isDirectory ( ) ) ) { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null && ! parent . exists ( ) ) { \nif ( ! parent . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + parent ) ; \n} \n} \n} \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \nelse { \nif ( ! file . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + file ) ; \n} \n} \n} \n} \nclose ( zip ) ; \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( ! ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) ) { \nreturn false ; \n} \nelse { \nint year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nint month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nint day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( month < 1 || month > 12 ) { \nreturn false ; \n} \nif ( day < 1 || day > 31 ) { \nreturn false ; \n} \nif ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) { \nreturn false ; \n} \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( day > 29 || ( day == 29 && ! isleap ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n} \n"}
{"10036": "public class IO { \npublic static void copyDirectory ( File source , File target ) { \nif ( ! ( source . isDirectory ( ) ) ) { \ntry { \nwrite ( new FileInputStream ( source ) , new FileOutputStream ( target ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \n} \nelse { \nif ( ! target . exists ( ) ) { \ntarget . mkdir ( ) ; \n} \nfor ( String child : source . list ( ) ) { \ncopyDirectory ( new File ( source , child ) , new File ( target , child ) ) ; \n} \n} \n} \n} \n"}
{"10047": "public class ClassKit { \npublic static boolean isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { \nPreconditions . checkNotNull ( lhsType , \"Left-hand side type must not be null\" ) ; \nPreconditions . checkNotNull ( rhsType , \"Right-hand side type must not be null\" ) ; \nif ( lhsType . isAssignableFrom ( rhsType ) ) { \nreturn true ; \n} \nif ( ! ( lhsType . isPrimitive ( ) ) ) { \nClass < ? > resolvedWrapper = primitiveTypeToWrapperMap . get ( rhsType ) ; \nif ( resolvedWrapper != null && lhsType . isAssignableFrom ( resolvedWrapper ) ) { \nreturn true ; \n} \n} \nelse { \nClass < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; \nif ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10056": "public class AbstractRequest { \nprotected Object builtin ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( ! ( rawType . equals ( WebContext . class ) ) ) if ( ! ( rawType . equals ( HttpServletRequest . class ) ) ) if ( ! ( rawType . equals ( HttpServletResponse . class ) ) ) if ( ! ( rawType . equals ( HttpSession . class ) ) ) if ( ! ( rawType . equals ( ServletContext . class ) ) ) { \nreturn this ; \n} \nelse { \nreturn context . application ( ) ; \n} \nelse { \nreturn context . session ( ) ; \n} \nelse { \nreturn context . response ( ) ; \n} \nelse { \nreturn context . request ( ) ; \n} \nelse { \nreturn context ; \n} \n} \n} \n"}
{"10057": "public class AbstractRequest { \nprotected Object primitive ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( ! ( rawType . equals ( Boolean . TYPE ) ) ) if ( ! ( rawType . equals ( Character . TYPE ) ) ) if ( ! ( rawType . equals ( Byte . TYPE ) ) ) if ( ! ( rawType . equals ( Double . TYPE ) ) ) if ( ! ( rawType . equals ( Float . TYPE ) ) ) if ( ! ( rawType . equals ( Integer . TYPE ) ) ) { \nreturn ( short ) 0 ; \n} \nelse { \nreturn ( int ) 0 ; \n} \nelse { \nreturn ( float ) 0.0 ; \n} \nelse { \nreturn ( double ) 0.0 ; \n} \nelse { \nreturn ( byte ) 0 ; \n} \nelse { \nreturn ( char ) 0 ; \n} \nelse { \nreturn ( boolean ) false ; \n} \n} \n} \n"}
{"10059": "public class AbstractRequest { \nprotected Object convertUserDefinedValueType ( Object object , Class < ? > type ) { \nif ( ! ( type . isAssignableFrom ( object . getClass ( ) ) ) ) if ( ! ( object instanceof String ) ) { \nlogger . warn ( \"Parameter [\" + object + \"] cannot be converted to [\" + type + \"]\" ) ; \n} \nelse { \ntry { \nConstructor < ? > constructor = type . getConstructor ( String . class ) ; \nreturn constructor . newInstance ( object ) ; \n} \ncatch ( Exception e ) { \nlogger . debug ( \"Cannot invoke [public \" + type . getName ( ) + \"(String.class)] constrcutor on [\" + type + \"]\" , e ) ; \n} \ntry { \nreturn type . getMethod ( \"valueOf\" , String . class ) . invoke ( null , object ) ; \n} \ncatch ( Exception e1 ) { \nlogger . debug ( \"Cannot invoke [public static \" + type . getName ( ) + \".valueOf(String.class)]\" + \"method on [\" + type + \"]\" , e1 ) ; \n} \n} \nelse { \nreturn object ; \n} \nreturn null ; \n} \n} \n"}
{"10068": "public class RequestPermission { \nprivate static boolean allValuesGranted ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( ! ( values instanceof Permission [ ] ) ) if ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permission = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermission . add ( perm . toString ( ) ) ; \n} \nif ( permission . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( Permission . get ( String . valueOf ( value ) ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \nelse { \nSet < Permission > valueSet = new HashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10069": "public class RequestPermission { \nprivate static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( ! ( values instanceof Permission [ ] ) ) if ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permissionSet = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermissionSet . add ( perm . toString ( ) ) ; \n} \nif ( permissionSet . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \nreturn true ; \n} \n} \n} \n} \nelse { \nSet < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10080": "public class ProtobufSerializerUtils { \npublic static final Map < Field , ProtobufAttribute > getAllProtbufFields ( Class < ? extends Object > fromClazz ) { \nMap < Field , ProtobufAttribute > protoBufFields = CLASS_TO_FIELD_MAP_CACHE . get ( fromClazz . getCanonicalName ( ) ) ; \nif ( ! ( protoBufFields != null ) ) { \nprotoBufFields = new HashMap < > ( ) ; \n} \nelse { \nreturn protoBufFields ; \n} \nfinal List < Field > fields = JReflectionUtils . getAllFields ( new ArrayList < Field > ( ) , fromClazz ) ; \nfor ( Field field : fields ) { \nfinal Annotation annotation = field . getAnnotation ( ProtobufAttribute . class ) ; \nif ( annotation == null ) { \ncontinue ; \n} \nfinal ProtobufAttribute gpbAnnotation = ( ProtobufAttribute ) annotation ; \nprotoBufFields . put ( field , gpbAnnotation ) ; \n} \nCLASS_TO_FIELD_MAP_CACHE . put ( fromClazz . getCanonicalName ( ) , protoBufFields ) ; \nreturn protoBufFields ; \n} \n} \n"}
{"10081": "public class ProtobufSerializerUtils { \npublic static final String getProtobufGetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_GETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( ! ( map != null ) ) { \nmap = new ConcurrentHashMap < > ( ) ; \n} \nelse { \nif ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) { \nreturn map . get ( fieldName ) ; \n} \n} \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString getter = \"get\" + upperCaseFirstFieldName ; \nif ( Collection . class . isAssignableFrom ( field . getType ( ) ) ) { \ngetter += \"List\" ; \n} \nif ( ! protobufAttribute . protobufGetter ( ) . isEmpty ( ) ) { \nreturn protobufAttribute . protobufGetter ( ) ; \n} \nmap . put ( fieldName , getter ) ; \nCLASS_TO_FIELD_GETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn getter ; \n} \n} \n"}
{"10082": "public class ProtobufSerializerUtils { \npublic static final String getPojoSetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_SETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( ! ( map != null ) ) { \nmap = new ConcurrentHashMap < > ( ) ; \n} \nelse { \nif ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) { \nreturn map . get ( fieldName ) ; \n} \n} \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString setter = \"set\" + upperCaseFirstFieldName ; \nif ( ! protobufAttribute . pojoSetter ( ) . isEmpty ( ) ) { \nreturn protobufAttribute . pojoSetter ( ) ; \n} \nmap . put ( fieldName , setter ) ; \nCLASS_TO_FIELD_SETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn setter ; \n} \n} \n"}
{"10087": "public class JdbcPasswordAuthenticator { \n@ edu . umd . cs . findbugs . annotations . SuppressWarnings ( \"SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING\" ) private UserRecord getUserRecord ( final String domain , final String userName ) throws LoginException { \nString userId ; \nString credential ; \nConnection connection = null ; \nPreparedStatement statement = null ; \nResultSet resultSet = null ; \ntry { \nconnection = getDatabaseConnection ( ) ; \nstatement = connection . prepareStatement ( dbProps . get ( ) . getSqlUserQuery ( ) ) ; \nstatement . setString ( 1 , domain ) ; \nstatement . setString ( 2 , userName ) ; \nresultSet = statement . executeQuery ( ) ; \nif ( ! ( resultSet . next ( ) ) ) { \nfinal String error = \"Username '\" + userName + \"' does not exist (query returned zero results)\" ; \nLOG . warn ( error ) ; \nthrow new LoginException ( error ) ; \n} \nelse { \nuserId = resultSet . getString ( 1 ) ; \ncredential = resultSet . getString ( 2 ) ; \n} \nresultSet . close ( ) ; \nstatement . close ( ) ; \n} \ncatch ( SQLException e ) { \nfinal String error = \"Error executing SQL query\" ; \nLOG . warn ( error , e ) ; \nthrow Util . newLoginException ( error , e ) ; \n} \nfinally { \nDbUtil . close ( resultSet ) ; \nDbUtil . close ( statement ) ; \nDbUtil . close ( connection ) ; \n} \nreturn new UserRecord ( domain , userName , userId , credential ) ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( ! ( testChar == '%' ) ) if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nelse { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( ! ( testChar == '%' ) ) if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nelse { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( ! ( testChar == '%' ) ) if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nelse { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( ! ( p_userinfo == null ) ) { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( ! ( testChar == '%' ) ) if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nelse { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nindex ++ ; \n} \n} \nelse { \nm_userinfo = null ; \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10104": "public class URI { \nprivate void setHost ( String p_host ) throws MalformedURIException { \nif ( ! ( p_host == null || p_host . length ( ) == 0 ) ) if ( ! isWellFormedAddress ( p_host ) ) { \nthrow new MalformedURIException ( \"Host is not a well formed address!\" ) ; \n} \nelse { \nm_host = p_host ; \nm_userinfo = null ; \nm_port = null ; \nn_port = - 1 ; \n} \nm_host = p_host ; \n} \n} \n"}
{"10105": "public class URI { \nprivate void setPort ( int p_port ) throws MalformedURIException { \nif ( ! ( p_port >= 0 && p_port <= 65535 ) ) if ( p_port != - 1 ) { \nthrow new MalformedURIException ( \"Invalid port number!\" ) ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Port cannot be set when host is null!\" ) ; \n} \n} \nn_port = p_port ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null || p_addToPath . length ( ) == 0 ) { \nreturn ; \n} \nif ( ! isURIString ( p_addToPath ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character!\" ) ; \n} \nif ( ! ( m_path == null || m_path . length ( ) == 0 ) ) if ( ! ( m_path . endsWith ( \"/\" ) ) ) { \nif ( ! ( p_addToPath . startsWith ( \"/\" ) ) ) { \nm_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath ) ; \n} \n} \nelse { \nif ( ! ( p_addToPath . startsWith ( \"/\" ) ) ) { \nm_path = m_path . concat ( p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \n} \n} \nelse { \nif ( ! ( p_addToPath . startsWith ( \"/\" ) ) ) { \nm_path = \"/\" + p_addToPath ; \n} \nelse { \nm_path = p_addToPath ; \n} \n} \n} \n} \n"}
{"10107": "public class URI { \nprivate void setQueryString ( String p_queryString ) throws MalformedURIException { \nif ( ! ( p_queryString == null ) ) if ( ! ( ! isGenericURI ( ) ) ) if ( ! ( getPath ( ) == null ) ) if ( ! ( ! isURIString ( p_queryString ) ) ) { \nm_queryString = p_queryString ; \n} \nelse { \nthrow new MalformedURIException ( \"Query string contains invalid character!\" ) ; \n} \nelse { \nthrow new MalformedURIException ( \"Query string cannot be set when path is null!\" ) ; \n} \nelse { \nthrow new MalformedURIException ( \"Query string can only be set for a generic URI!\" ) ; \n} \nelse { \nm_queryString = null ; \n} \n} \n} \n"}
{"10108": "public class URI { \npublic void setFragment ( String p_fragment ) throws MalformedURIException { \nif ( ! ( p_fragment == null ) ) if ( ! ( ! isGenericURI ( ) ) ) if ( ! ( getPath ( ) == null ) ) if ( ! ( ! isURIString ( p_fragment ) ) ) { \nm_fragment = p_fragment ; \n} \nelse { \nthrow new MalformedURIException ( \"Fragment contains invalid character!\" ) ; \n} \nelse { \nthrow new MalformedURIException ( \"Fragment cannot be set when path is null!\" ) ; \n} \nelse { \nthrow new MalformedURIException ( \"Fragment can only be set for a generic URI!\" ) ; \n} \nelse { \nm_fragment = null ; \n} \n} \n} \n"}
{"10110": "public class PreparedStatementCreator { \nprotected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { \nPreparedStatement ps = conn . prepareStatement ( sql ) ; \nif ( parameters != null ) { \nint index = 1 ; \nwhile ( parameters . hasNext ( ) ) { \nObject parameter = parameters . next ( ) ; \nif ( ! ( parameter == null ) ) { \nps . setObject ( index , parameter ) ; \n} \nelse { \nps . setObject ( index , null ) ; \n} \nindex ++ ; \n} \n} \nreturn ps ; \n} \n} \n"}
{"10113": "public class MuffinManager { \npublic void setMuffin ( String strParam , String strValue ) { \nFileContents fc = null ; \nURL url = null ; \ntry { \nurl = new URL ( m_strCodeBase + strParam ) ; \n} \ncatch ( Exception ex ) { \nreturn ; \n} \ntry { \nfc = m_ps . get ( url ) ; \nfc . getMaxLength ( ) ; \n} \ncatch ( Exception ex ) { \nfc = null ; \n} \ntry { \nif ( fc == null ) { \nm_ps . create ( url , 100 ) ; \nfc = m_ps . get ( url ) ; \n} \nif ( ! ( strValue != null ) ) m_ps . delete ( url ) ; \nelse { \nOutputStream os = fc . getOutputStream ( false ) ; \nbyte [ ] buf = strValue . getBytes ( ENCODING ) ; \nos . write ( buf ) ; \nos . close ( ) ; \nm_ps . setTag ( url , PersistenceService . DIRTY ) ; \n} \n} \ncatch ( Exception ex ) { \nex . printStackTrace ( ) ; \n} \n} \n} \n"}
{"10120": "public class ServiceManager { \npublic static ParametrizedOperation findParmetrizedService ( String id ) { \nif ( ! ( parametrizedServices == null ) ) return parametrizedServices . get ( id ) ; \nelse return null ; \n} \n} \n"}
{"10138": "public class ObjectQueryPreparer { \npublic ObjectQueryInfo prepareObjectQuery ( Object obj ) throws MalformedObjectNameException { \nObjectQueryInfo result ; \nString onamePattern = MBeanAnnotationUtil . getLocationONamePattern ( obj ) ; \nif ( ! ( onamePattern != null ) ) { \nlog . warn ( \"ignoring attempt to prepare to poll object that has no MBeanLocation\" ) ; \nresult = null ; \n} \nelse { \nMap < String , Method > attributeSetters = MBeanAnnotationUtil . getAttributes ( obj ) ; \nif ( ! ( attributeSetters . size ( ) > 0 ) ) { \nthis . logNoAttributeThrottle . warn ( log , \"ignoring attempt to prepare to poll an MBean object with no attributes: onamePattern={}\" , onamePattern ) ; \nresult = null ; \n} \nelse { \nString onameString ; \nif ( ! ( obj instanceof MBeanLocationParameterSource ) ) { \nonameString = onamePattern ; \n} \nelse { \nonameString = this . parameterReplacer . replaceObjectNameParameters ( onamePattern , ( MBeanLocationParameterSource ) obj ) ; \n} \nObjectName oname = new ObjectName ( onameString ) ; \nresult = new ObjectQueryInfo ( obj , oname , attributeSetters ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( ! ( inSingleQuote ) ) if ( ! ( inDoubleQuote ) ) { \nif ( ! ( c == '\\'' ) ) if ( ! ( c == '\"' ) ) if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \nelse { \ninDoubleQuote = true ; \n} \nelse { \ninSingleQuote = true ; \n} \n} \nelse { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10143": "public class ProtobufSerializer { \nprivate static final Object convertCollectionToProtobufs ( Collection < Object > collectionOfNonProtobufs ) throws JException { \nif ( collectionOfNonProtobufs . isEmpty ( ) ) { \nreturn collectionOfNonProtobufs ; \n} \nfinal Object first = collectionOfNonProtobufs . toArray ( ) [ 0 ] ; \nif ( ! ProtobufSerializerUtils . isProtbufEntity ( first ) ) { \nreturn collectionOfNonProtobufs ; \n} \nfinal Collection < Object > newCollectionValues ; \nif ( ! ( collectionOfNonProtobufs instanceof Set ) ) { \nnewCollectionValues = new ArrayList < > ( ) ; \n} \nelse { \nnewCollectionValues = new HashSet < > ( ) ; \n} \nfor ( Object iProtobufGenObj : collectionOfNonProtobufs ) { \nnewCollectionValues . add ( serializeToProtobufEntity ( iProtobufGenObj ) ) ; \n} \nreturn newCollectionValues ; \n} \n} \n"}
{"10151": "public class JmxAttributePoller { \npublic void poll ( ) throws IOException { \nsynchronized ( this ) { \nif ( shutdownInd ) { \nreturn ; \n} \npollActiveInd = true ; \n} \ntry { \nthis . checkConnection ( ) ; \nthis . concurrencyTestHooks . beforePollProcessorStart ( ) ; \nif ( ! ( this . mBeanAccessConnection instanceof MBeanBatchCapableAccessConnection ) ) { \nthis . pollIndividually ( ) ; \n} \nelse { \nthis . batchPollProcessor . pollBatch ( ( MBeanBatchCapableAccessConnection ) this . mBeanAccessConnection , this . polledObjects ) ; \n} \n} \ncatch ( IOException ioExc ) { \nthis . safeClose ( this . mBeanAccessConnection ) ; \nthis . mBeanAccessConnection = null ; \nthrow ioExc ; \n} \nfinally { \nthis . concurrencyTestHooks . afterPollProcessorFinish ( ) ; \nsynchronized ( this ) { \npollActiveInd = false ; \nthis . notifyAll ( ) ; \n} \n} \n} \n} \n"}
{"10162": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initAudit ( final CommonProperties commonProps ) { \ntry { \nfinal String auditClassName = commonProps . getAuditClassName ( ) ; \nif ( ! ( ! commonProps . isAuditEnabled ( ) ) ) if ( ! ( auditClassName == null ) ) { \nif ( ! ( commonProps . isAuditSingleton ( ) ) ) { \nLOG . debug ( \"Requesting non-singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; \n} \n} \nelse { \nfinal String error = \"Auditing has been enabled in the JAAS configuration, but no audit class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nfinal String error = \"Auditing has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The audit class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10163": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initMessageQueue ( final CommonProperties commonProps ) { \ntry { \nfinal String messageClassName = commonProps . getMessageQueueClassName ( ) ; \nif ( ! ( ! commonProps . isMessageQueueEnabled ( ) ) ) if ( ! ( messageClassName == null ) ) { \nif ( ! ( commonProps . isMessageQueueSingleton ( ) ) ) { \nLOG . debug ( \"Requesting non-singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; \n} \n} \nelse { \nfinal String error = \"Message queue has been enabled in the JAAS configuration, \" + \"but no message queue class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nfinal String error = \"Message queue has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The message class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10164": "public class PasswordLoginModule { \nprivate void initPwValidator ( final CommonProperties commonProps ) { \ntry { \nfinal String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; \nif ( ! ( validatorClass == null ) ) { \nif ( ! ( commonProps . isPasswordValidatorSingleton ( ) ) ) { \nLOG . debug ( \"Requesting non-singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; \n} \n} \nelse { \nfinal String error = \"No password validator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10165": "public class PasswordLoginModule { \nprivate void initPwAuthenticator ( final CommonProperties commonProps ) { \ntry { \nfinal String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; \nif ( ! ( authNticatorClass == null ) ) { \nif ( ! ( commonProps . isPasswordAuthenticatorSingleton ( ) ) ) { \nLOG . debug ( \"Requesting non-singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; \n} \n} \nelse { \nfinal String error = \"No password authenticator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10171": "public class ArrayStack { \n@ SuppressWarnings ( \"unchecked\" ) public T pop ( ) throws EmptyStackException { \nint i ; \nif ( ! ( ( i = -- size ) >= 0 ) ) { \nsize = 0 ; \nthrow new EmptyStackException ( ) ; \n} \nelse { \nT element = ( T ) elements [ i ] ; \nelements [ i ] = null ; \nreturn element ; \n} \n} \n} \n"}
{"10178": "public class Rectangular { \npublic Rectangular intersection ( Rectangular other ) { \nif ( ! ( this . intersects ( other ) ) ) { \nreturn new Rectangular ( ) ; \n} \nelse { \nreturn new Rectangular ( Math . max ( x1 , other . x1 ) , Math . max ( y1 , other . y1 ) , Math . min ( x2 , other . x2 ) , Math . min ( y2 , other . y2 ) ) ; \n} \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( ! ( col < width ) ) if ( ! ( col == width ) ) throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \nelse return abspos . getWidth ( ) ; \nelse { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < col ; \ni ++ ) ofs += cols [ i ] ; \nreturn ofs ; \n} \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( ! ( row < height ) ) if ( ! ( row == height ) ) throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \nelse return abspos . getHeight ( ) ; \nelse { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < row ; \ni ++ ) ofs += rows [ i ] ; \nreturn ofs ; \n} \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! ( points [ i ] . begin ) ) { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \nelse { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! ( points [ i ] . begin ) ) { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \nelse { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10187": "public class JdbcLogSupport { \nprotected Throwable unwrapThrowable ( Throwable t ) { \nThrowable e = t ; \nwhile ( true ) { \nif ( ! ( e instanceof InvocationTargetException ) ) if ( ! ( t instanceof UndeclaredThrowableException ) ) { \nreturn e ; \n} \nelse { \ne = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; \n} \nelse { \ne = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; \n} \n} \n} \n} \n"}
{"10197": "public class WAMCompiledClause { \npublic void addInstructions ( Functor body , SizeableList < WAMInstruction > instructions ) { \nint oldLength ; \nif ( ! ( this . body == null ) ) { \noldLength = this . body . length ; \nthis . body = Arrays . copyOf ( this . body , oldLength + 1 ) ; \n} \nelse { \noldLength = 0 ; \nthis . body = new Functor [ 1 ] ; \n} \nthis . body [ oldLength ] = body ; \naddInstructionsAndThisToParent ( instructions ) ; \n} \n} \n"}
{"10198": "public class WAMCompiledClause { \nprivate void addInstructionsAndThisToParent ( SizeableList < WAMInstruction > instructions ) { \nif ( ! ( ! addedToParent ) ) { \nparent . addInstructions ( instructions ) ; \n} \nelse { \nparent . addInstructions ( this , instructions ) ; \naddedToParent = true ; \n} \n} \n} \n"}
{"10199": "public class ButtonPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nif ( event . getSource ( ) instanceof WorkPanelState ) { \nString state = ( ( WorkPanelState ) event . getSource ( ) ) . getState ( ) ; \nif ( ! ( state . equals ( WorkPanelState . NOT_SAVED ) ) ) if ( ! ( state . equals ( WorkPanelState . READY ) ) ) if ( state . equals ( WorkPanelState . NOT_INITIALIZED ) ) { \nokButton . setEnabled ( false ) ; \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \nelse { \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \nelse { \ncancelButton . setEnabled ( true ) ; \napplyButton . setEnabled ( true ) ; \n} \n} \n} \n} \n"}
{"10202": "public class BigDecimalTypeImpl { \npublic static Type createInstance ( String name , int precision , int scale , String min , String max ) { \nsynchronized ( DECIMAL_TYPES ) { \nBigDecimalTypeImpl newType = new BigDecimalTypeImpl ( name , precision , scale , min , max ) ; \nBigDecimalTypeImpl oldType = DECIMAL_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nDECIMAL_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( ! ( comp < 0 ) ) if ( comp > 0 ) { \nreturn 1 ; \n} \nelse { \nreturn - 1 ; \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10208": "public class PageControlTag { \nprivate void renderButton ( boolean render , int page , int index , String openDelim , String url , String text , boolean active ) throws JspException { \nlog . fine ( \"private void renderButton(boolean render, int page, int index, String openDelim, String url, String text, boolean active): called\" ) ; \nlog . fine ( \"render = \" + render ) ; \nlog . fine ( \"page = \" + page ) ; \nlog . fine ( \"index = \" + index ) ; \nlog . fine ( \"openDelim = \" + openDelim ) ; \nlog . fine ( \"url = \" + url ) ; \nlog . fine ( \"text = \" + text ) ; \nlog . fine ( \"active = \" + active ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nif ( render ) { \ntagUtils . write ( pageContext , openDelim ) ; \nif ( ! ( active ) ) { \ntagUtils . write ( pageContext , text ) ; \n} \nelse { \ntagUtils . write ( pageContext , \"<a href=\\\"\" + url + \"?varName=\" + name + \"&number=\" + page + \"&index=\" + index + \"\\\">\" + text + \"</a>\" ) ; \n} \ntagUtils . write ( pageContext , closeDelim ) ; \n} \n} \n} \n"}
{"10217": "public class PropertyIntrospectorBase { \nprotected void setProperty ( Object callee , String property , Object value ) { \nif ( ! initialized ) { \ninitialize ( callee ) ; \n} \nMethod [ ] setterMethods = setters . get ( property ) ; \nif ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) { \nthrow new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \n} \nMethod setterMethod = null ; \nClass valueType = ( value == null ) ? null : value . getClass ( ) ; \nif ( ! ( value == null ) ) { \nfor ( Method method : setterMethods ) { \nClass argType = method . getParameterTypes ( ) [ 0 ] ; \nif ( ! ( argType . isAssignableFrom ( valueType ) ) ) if ( ! ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) ) if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse { \nsetterMethod = method ; \nbreak ; \n} \nelse { \nsetterMethod = method ; \nbreak ; \n} \n} \nif ( setterMethod == null ) { \nClass calleeType = ( callee == null ) ? null : callee . getClass ( ) ; \nthrow new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; \n} \n} \nelse { \nsetterMethod = setterMethods [ 0 ] ; \n} \ntry { \nObject [ ] args = new Object [ ] { \nvalue } \n; \nsetterMethod . invoke ( callee , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \n} \n} \n"}
{"10219": "public class PropertyIntrospectorBase { \nprivate boolean isAssignableFromPrimitive ( Class wrapperType , Class primitiveType ) { \nboolean result = false ; \nif ( ! ( primitiveType . equals ( boolean . class ) && wrapperType . equals ( Boolean . class ) ) ) if ( ! ( primitiveType . equals ( byte . class ) && wrapperType . equals ( Byte . class ) ) ) if ( ! ( primitiveType . equals ( char . class ) && wrapperType . equals ( Character . class ) ) ) if ( ! ( primitiveType . equals ( short . class ) && wrapperType . equals ( Short . class ) ) ) if ( ! ( primitiveType . equals ( int . class ) && wrapperType . equals ( Integer . class ) ) ) if ( ! ( primitiveType . equals ( long . class ) && wrapperType . equals ( Long . class ) ) ) if ( ! ( primitiveType . equals ( float . class ) && wrapperType . equals ( Float . class ) ) ) if ( ! ( primitiveType . equals ( double . class ) && wrapperType . equals ( Double . class ) ) ) { \nresult = false ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nelse { \nresult = true ; \n} \nreturn result ; \n} \n} \n"}
{"10220": "public class PropertyIntrospectorBase { \nprivate void initialize ( Object callee ) { \nMap < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; \nMethod [ ] methods = callee . getClass ( ) . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( ! ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) ) if ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \nList < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; \nif ( setterMethodsForName == null ) { \nsetterMethodsForName = new ArrayList < Method > ( ) ; \nsettersTemp . put ( propertyName , setterMethodsForName ) ; \n} \nsetterMethodsForName . add ( nextMethod ) ; \n} \nelse { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \ngetters . put ( propertyName , nextMethod ) ; \n} \n} \nfor ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { \nString nextPropertyName = entries . getKey ( ) ; \nList < Method > nextMethodList = entries . getValue ( ) ; \nMethod [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; \nsetters . put ( nextPropertyName , methodArray ) ; \n} \ninitialized = true ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) ) if ( ! ( left . isVar ( ) ) ) if ( ! ( right . isVar ( ) ) ) if ( ! ( left . isFunctor ( ) && right . isFunctor ( ) ) ) { \nreturn false ; \n} \nelse { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"10225": "public class PrologUnifier { \nprotected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( ! ( leftVar . isBound ( ) ) ) if ( ! ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) ) { \nleftVar . setSubstitution ( rightTerm ) ; \nleftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; \nreturn true ; \n} \nelse { \nreturn unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; \n} \nelse { \nreturn unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( int i = 0 ; \ni < expressions . length ; \ni ++ ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( ! ( expression instanceof BuiltIn ) ) { \nbuiltIn = this ; \n} \nelse { \nbuiltIn = ( BuiltIn ) expression ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nint charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( charsRequired < length ) ? length : charsRequired ; \nint index = buffer . position ( ) + length - 1 ; \nint start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( ! ( value < 0 ) ) { \nvalue = - value ; \n} \nelse { \nbuffer . put ( MINUS_ASCII ) ; \nstart ++ ; \n} \ndo { \nint remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nwhile ( index >= start ) { \nbuffer . put ( index -- , ZERO_ASCII ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10234": "public class EnumeratedStringAttribute { \npublic String getStringValue ( ) { \nif ( ! ( attributeClass . finalized ) ) { \nreturn attributeClass . lookupValueList . get ( value ) . label ; \n} \nelse { \nreturn attributeClass . lookupValue [ value ] . label ; \n} \n} \n} \n"}
{"10235": "public class EnumeratedStringAttribute { \npublic void setStringValue ( String value ) throws IllegalArgumentException { \nByte b = attributeClass . lookupByte . get ( value ) ; \nif ( b == null ) { \nif ( ! ( attributeClass . finalized ) ) { \nEnumeratedStringAttribute newAttribute = attributeClass . createStringAttribute ( value ) ; \nb = newAttribute . value ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized EnumeratedStringType, \" + attributeClass . attributeClassName + \".\" ) ; \n} \n} \nthis . value = b ; \n} \n} \n"}
{"10236": "public class LojixTermReader { \nprivate void read ( Term term ) { \nif ( ! ( term . isNumber ( ) ) ) if ( ! ( term . isVar ( ) ) ) if ( ! ( term . isAtom ( ) ) ) if ( ! ( term . isCompound ( ) ) ) { \nthrow new IllegalStateException ( \"Unrecognized Lojix term: \" + term ) ; \n} \nelse { \nFunctor functor = ( Functor ) term ; \ngetContentHandler ( ) . startCompound ( ) ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; \nfor ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { \nread ( child ) ; \n} \ngetContentHandler ( ) . endCompound ( ) ; \n} \nelse { \nFunctor atom = ( Functor ) term ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; \n} \nelse { \nVariable var = ( Variable ) term ; \ngetContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; \n} \nelse { \nNumericType numericType = ( NumericType ) term ; \nif ( ! ( numericType . isInteger ( ) ) ) if ( numericType . isFloat ( ) ) { \nFloatLiteral jplFloat = ( FloatLiteral ) term ; \ngetContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; \n} \nelse { \nIntLiteral jplInteger = ( IntLiteral ) term ; \ngetContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; \n} \n} \n} \n} \n"}
{"10253": "public class BaseQueueSearch { \npublic T search ( ) throws SearchNotExhaustiveException { \nSearchNode < O , T > path = findGoalPath ( ) ; \nif ( ! ( path != null ) ) { \nreturn null ; \n} \nelse { \nreturn path . getState ( ) ; \n} \n} \n} \n"}
{"10254": "public class IntRangeType { \npublic static Type createInstance ( String name , int min , int max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nIntRangeType newType = new IntRangeType ( name , min , max ) ; \nIntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10256": "public class SchemaDefinitionImpl { \npublic void addTZAlternateDimension ( String orignalDimensionName , DimensionTable alternateDimension , String tzName ) { \naddSupportedTZ ( tzName ) ; \nif ( ! ( tzNamesAliases . containsValue ( tzName ) ) ) { \nLOG . error ( \"Unsuported timezone: \" + tzName ) ; \n} \nelse { \nsqlTables . put ( alternateDimension . getTableName ( ) , alternateDimension ) ; \nalternateDimensions . put ( Pair . of ( orignalDimensionName . toUpperCase ( ) , tzName ) , alternateDimension ) ; \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! ( ! useIndent ) ) { \nif ( ! ( delta >= 1 ) ) if ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \nelse { \nindentStack . push ( delta ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \nfor ( int i = 0 ; \ni < traceIndent ; \ni ++ ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \nelse { \nreturn \"\" ; \n} \n} \n} \n"}
{"10267": "public class ProtoDTLearningMethod { \nprivate OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { \nMap < OrdinalAttribute , Integer > countMap = null ; \nint biggestCount = 0 ; \nOrdinalAttribute biggestAttribute = null ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( countMap == null ) { \ncountMap = new HashMap < OrdinalAttribute , Integer > ( ) ; \n} \nint count ; \nif ( ! ( ! countMap . containsKey ( nextAttribute ) ) ) { \ncount = countMap . get ( nextAttribute ) ; \ncountMap . put ( nextAttribute , count ++ ) ; \n} \nelse { \ncount = 1 ; \ncountMap . put ( nextAttribute , count ) ; \n} \nif ( count > biggestCount ) { \nbiggestCount = count ; \nbiggestAttribute = nextAttribute ; \n} \n} \nreturn biggestAttribute ; \n} \n} \n"}
{"10268": "public class ProtoDTLearningMethod { \nprivate boolean allHaveSameClassification ( String property , Iterable < State > examples ) { \nOrdinalAttribute firstAttribute = null ; \nboolean success = true ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( ! ( firstAttribute == null ) ) if ( ! nextAttribute . equals ( firstAttribute ) ) { \nsuccess = false ; \nbreak ; \n} \nelse { \nfirstAttribute = nextAttribute ; \n} \n} \nif ( success ) { \nallClassification = firstAttribute ; \n} \nreturn success ; \n} \n} \n"}
{"10274": "public class Surface { \npublic void setTexture ( Paint obj ) { \nif ( ! ( obj instanceof GradientPaint ) ) { \ntexture = obj ; \n} \nelse { \ntexture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; \n} \n} \n} \n"}
{"10276": "public class Surface { \nprotected BufferedImage createBufferedImage ( int w , int h , int imgType ) { \nBufferedImage bi = null ; \nif ( ! ( imgType == 0 ) ) if ( ! ( ( imgType > 0 ) && ( imgType < 14 ) ) ) if ( ! ( imgType == 14 ) ) if ( ! ( imgType == 15 ) ) if ( ! ( imgType == 16 ) ) if ( imgType == 17 ) { \nbi = createSGISurface ( w , h , 16 ) ; \n} \nelse { \nbi = createSGISurface ( w , h , 32 ) ; \n} \nelse { \nbi = createBinaryImage ( w , h , 4 ) ; \n} \nelse { \nbi = createBinaryImage ( w , h , 2 ) ; \n} \nelse { \nbi = new BufferedImage ( w , h , imgType ) ; \n} \nelse { \nbi = ( BufferedImage ) createImage ( w , h ) ; \n} \nbiw = w ; \nbih = h ; \nreturn bi ; \n} \n} \n"}
{"10277": "public class Surface { \nprotected Graphics2D createGraphics2D ( int width , int height , BufferedImage bi , Graphics g ) { \nGraphics2D g2 = null ; \nif ( ! ( bi != null ) ) { \ng2 = ( Graphics2D ) g ; \n} \nelse { \ng2 = bi . createGraphics ( ) ; \n} \ng2 . setBackground ( getBackground ( ) ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antiAlias ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_RENDERING , rendering ) ; \nif ( clearSurface || clearOnce ) { \ng2 . clearRect ( 0 , 0 , width , height ) ; \nclearOnce = false ; \n} \nif ( texture != null ) { \ng2 . setComposite ( AlphaComposite . SrcOver ) ; \ng2 . setPaint ( texture ) ; \ng2 . fillRect ( 0 , 0 , width , height ) ; \n} \nif ( composite != null ) { \ng2 . setComposite ( composite ) ; \n} \nreturn g2 ; \n} \n} \n"}
{"10281": "public class IterativeBoundAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nfor ( float bound = startBound ; \n; \n) { \nmaxBound = bound ; \ntry { \nint numStepsSoFar = initSearch . getStepsTaken ( ) ; \ninitSearch . resetEnqueuedOnceFlag ( ) ; \nSearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; \nif ( ! ( node != null ) ) { \nreturn null ; \n} \nelse { \nreturn node ; \n} \n} \ncatch ( MaxBoundException e ) { \ne = null ; \n} \nif ( ! ( useEpsilon ) ) { \nbound = getMinBeyondBound ( ) ; \n} \nelse { \nbound = bound + epsilon ; \n} \n} \n} \n} \n"}
{"10282": "public class MaxStepsAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nif ( ! headNode . isExpanded ( ) ) { \nheadNode . expandSuccessors ( queue , reverseEnqueue ) ; \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \ncurrentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( ! ( queue . isEmpty ( ) ) ) { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nint nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nint consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( ! ( tokenSource . peek ( ) . kind == CONS ) ) { \naccumulator = new Nil ( nilId , null ) ; \n} \nelse { \nif ( args == null ) { \nthrow new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) { \nfor ( int i = args . length - 1 ; \ni >= 0 ; \ni -- ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \n} \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10289": "public class PrologParser { \npublic Term variable ( ) throws SourceCodeException { \nToken name = consumeToken ( VAR ) ; \nint nameId = interner . internVariableName ( name . image ) ; \nVariable var = null ; \nif ( ! \"_\" . equals ( name . image ) ) { \nvar = variableContext . get ( nameId ) ; \n} \nif ( ! ( var != null ) ) { \nvar = new Variable ( nameId , null , name . image . equals ( \"_\" ) ) ; \nvariableContext . put ( nameId , var ) ; \nreturn var ; \n} \nelse { \nreturn var ; \n} \n} \n} \n"}
{"10294": "public class PrologParser { \npublic void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { \nint arity ; \nif ( ! ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) ) { \narity = 1 ; \n} \nelse { \narity = 2 ; \n} \nint name = interner . internFunctorName ( operatorName , arity ) ; \noperatorTable . setOperator ( name , operatorName , priority , associativity ) ; \n} \n} \n"}
{"10296": "public class PrologParser { \nprotected Token consumeToken ( int kind ) throws SourceCodeException { \nToken nextToken = tokenSource . peek ( ) ; \nif ( ! ( nextToken . kind != kind ) ) { \nnextToken = tokenSource . poll ( ) ; \nreturn nextToken ; \n} \nelse { \nthrow new SourceCodeException ( \"Was expecting \" + tokenImage [ kind ] + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \n} \n} \n"}
{"10297": "public class PrologParser { \nprivate boolean peekAndConsume ( int kind ) { \nToken nextToken = tokenSource . peek ( ) ; \nif ( ! ( nextToken . kind == kind ) ) { \nreturn false ; \n} \nelse { \ntry { \nconsumeToken ( kind ) ; \n} \ncatch ( SourceCodeException e ) { \nthrow new IllegalStateException ( e ) ; \n} \nreturn true ; \n} \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( ! ( diff < 0 ) ) if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( ! ( isLeapYear ( year ) ) ) { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nyearStart += oneYear ; \nif ( yearStart <= ticks ) { \nyear ++ ; \n} \n} \nelse { \nyear -- ; \n} \nreturn year ; \n} \n} \n"}
{"10310": "public class TimeUtils { \npublic static long millisToYearStart ( int year ) { \nint leapYears = year / 100 ; \nif ( ! ( year < 0 ) ) { \nleapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; \nif ( isLeapYear ( year ) ) { \nleapYears -- ; \n} \n} \nelse { \nleapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; \n} \nreturn ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; \n} \n} \n"}
{"10313": "public class SequentialCuckooFunction { \nprivate Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { \nEntry < K > uninsertedEntry = entry ; \nboolean createdNewEntry = false ; \nEntry < K > existingEntry = entryForKey ( key ) ; \nInteger result = null ; \nif ( ! ( existingEntry != null ) ) { \nif ( uninsertedEntry == null ) { \nuninsertedEntry = new Entry < K > ( ) ; \nuninsertedEntry . key = key ; \nuninsertedEntry . seq = nextSequenceNumber ; \nnextSequenceNumber ++ ; \ncount ++ ; \ncreatedNewEntry = true ; \nresult = uninsertedEntry . seq ; \n} \nwhile ( true ) { \nint keyHashCode = uninsertedEntry . key . hashCode ( ) ; \nuninsertedEntry . hash1 = hash1 ( keyHashCode ) ; \nuninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; \nuninsertedEntry = cuckoo ( uninsertedEntry ) ; \nif ( uninsertedEntry == null ) { \nresult = createdNewEntry ? result : - 1 ; \nbreak ; \n} \nif ( ! ( tryRehashing ) ) { \nresult = null ; \nbreak ; \n} \nelse { \nrehash ( ) ; \n} \n} \n} \nelse { \nresult = existingEntry . seq ; \n} \nreturn result ; \n} \n} \n"}
{"10317": "public class WorkPanel { \npublic void actionPerformed ( ActionEvent event ) { \nString action = event . getActionCommand ( ) ; \nif ( ! ( \"OK\" . equals ( action ) ) ) if ( ! ( \"Cancel\" . equals ( action ) ) ) if ( \"Apply\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \nelse { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \ndiscardWork ( ) ; \n} \n} \nelse { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \n} \n} \n"}
{"10321": "public class WAMResolvingNativeMachine { \npublic static WAMResolvingNativeMachine getInstance ( SymbolTableImpl < Integer , String , Object > symbolTable ) throws ImplementationUnavailableException { \ntry { \nif ( ! libraryLoadAttempted ) { \nlibraryLoadAttempted = true ; \nSystem . loadLibrary ( \"aima_native\" ) ; \nlibraryFound = true ; \n} \nif ( ! ( libraryFound ) ) { \nthrow new ImplementationUnavailableException ( \"The native library could not be found.\" , null , null , null ) ; \n} \nelse { \nreturn new WAMResolvingNativeMachine ( symbolTable ) ; \n} \n} \ncatch ( UnsatisfiedLinkError e ) { \nlibraryFound = false ; \nthrow new ImplementationUnavailableException ( \"The native library could not be found.\" , e , null , null ) ; \n} \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \nfor ( int i = 0 ; \ni < probabilities . length ; \ni ++ ) { \nif ( ! ( total > 0 ) ) { \nprobabilities [ i ] = 0.0d ; \n} \nelse { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10326": "public class SortAction { \npublic ActionForward perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nlog . fine ( \"perform: called\" ) ; \nSortForm sortForm = ( SortForm ) form ; \nHttpSession session = request . getSession ( ) ; \nServletContext application = session . getServletContext ( ) ; \nlog . fine ( \"variables in the servlet context: \" ) ; \nfor ( Enumeration e = application . getAttributeNames ( ) ; \ne . hasMoreElements ( ) ; \n) { \nlog . fine ( e . nextElement ( ) . toString ( ) ) ; \n} \nList list = ( List ) session . getAttribute ( sortForm . getList ( ) ) ; \nComparator comparator = ( Comparator ) application . getAttribute ( sortForm . getComparator ( ) ) ; \nlog . fine ( \"comparator = \" + comparator ) ; \nSortStateBean sortStateBean = ( SortStateBean ) session . getAttribute ( sortForm . getSortState ( ) ) ; \nif ( sortStateBean == null ) { \nlog . fine ( \"There is no sort state bean\" ) ; \nsortStateBean = new SortStateBean ( ) ; \n} \nif ( ! ( ! sortStateBean . getState ( ) . equals ( SortStateBean . FORWARD ) || ! sortStateBean . getSortProperty ( ) . equals ( sortForm . getSortStateProperty ( ) ) ) ) { \nCollections . sort ( list , comparator ) ; \nCollections . reverse ( list ) ; \nsortStateBean . setState ( SortStateBean . REVERSE ) ; \n} \nelse { \nCollections . sort ( list , comparator ) ; \nsortStateBean . setState ( SortStateBean . FORWARD ) ; \n} \nsession . setAttribute ( sortForm . getList ( ) , list ) ; \nsortStateBean . setSortProperty ( sortForm . getSortStateProperty ( ) ) ; \nsession . setAttribute ( sortForm . getSortState ( ) , sortStateBean ) ; \nreturn ( mapping . findForward ( \"success\" ) ) ; \n} \n} \n"}
{"10336": "public class DebugTag { \npublic String getUserPrincipal ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nPrincipal principal = request . getUserPrincipal ( ) ; \nif ( ! ( principal != null ) ) { \ninfo . put ( \"principal name\" , \"no principal\" ) ; \n} \nelse { \ninfo . put ( \"principal name\" , principal . getName ( ) ) ; \n} \nreturn toHTMLTable ( \"container security\" , info ) ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( ! ( boundProperty <= maxBound ) ) { \nbeyondFringe = true ; \nminBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; \n} \nelse { \nqueue . offer ( successor ) ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( ! ( queue . isEmpty ( ) ) ) { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n} \nif ( ! ( beyondFringe ) ) { \nreturn null ; \n} \nelse { \nthrow new MaxBoundException ( \"Max bound reached.\" , null ) ; \n} \n} \n} \n"}
{"10352": "public class WorkFlowButtonsPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nObject source = event . getSource ( ) ; \nObject oldValue = event . getOldValue ( ) ; \nString propertyName = event . getPropertyName ( ) ; \nif ( source instanceof WorkFlowScreenState ) { \nWorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; \nupdateButtonsForScreen ( wfsState ) ; \n} \nif ( source instanceof WorkFlowState ) { \nWorkFlowState wfState = ( WorkFlowState ) source ; \nif ( ! ( \"currentScreenState\" . equals ( propertyName ) ) ) if ( \"state\" . equals ( propertyName ) ) { \nupdateButtonsForWorkFlow ( wfState ) ; \n} \nelse { \nWorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; \nWorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; \nif ( oldScreenState != null ) { \noldScreenState . removePropertyChangeListener ( this ) ; \n} \nif ( newScreenState != null ) { \nnewScreenState . addPropertyChangeListener ( this ) ; \n} \nupdateButtonsForScreen ( newScreenState ) ; \n} \n} \n} \n} \n"}
{"10356": "public class StackVariable { \npublic Variable getStorageCell ( Variable variable ) { \nVariableBindingContext < Variable > context = getBindingContext ( ) ; \nif ( ! ( context == null ) ) { \nreturn context . getStorageCell ( this ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10360": "public class AttributeGridImpl { \nprivate AttributeSet getColumnAttributeOrNull ( int c ) { \nif ( ! ( ( c >= 0 ) && ( c < columnAttributes . size ( ) ) ) ) { \nreturn null ; \n} \nelse { \nreturn columnAttributes . get ( c ) ; \n} \n} \n} \n"}
{"10361": "public class AttributeGridImpl { \nprivate AttributeSet getRowAttributeOrNull ( int r ) { \nif ( ! ( ( r >= 0 ) && ( r < rowAttributes . size ( ) ) ) ) { \nreturn null ; \n} \nelse { \nreturn rowAttributes . get ( r ) ; \n} \n} \n} \n"}
{"10363": "public class TimeRangeType { \npublic static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { \nif ( ( min != null ) && ( max != null ) && ( min . compareTo ( max ) > 0 ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nTimeRangeType newType = new TimeRangeType ( name , min , max ) ; \nTimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10364": "public class StringPatternType { \npublic static Type createInstance ( String name , int maxLength , String pattern ) { \nsynchronized ( STRING_PATTERN_TYPES ) { \nStringPatternType newType = new StringPatternType ( name , maxLength , pattern ) ; \nStringPatternType oldType = STRING_PATTERN_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nSTRING_PATTERN_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10369": "public class BaseBiDirectionalQueueSearch { \npublic SearchNode < O , T > findGoalPath ( ) throws SearchNotExhaustiveException { \nwhile ( ! forwardQueue . isEmpty ( ) || ! reverseQueue . isEmpty ( ) ) { \nif ( ! forwardQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; \nforwardFringe . remove ( currentForwardNode . getState ( ) ) ; \nif ( ! ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) ) { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentForwardNode . expandSuccessors ( newStates , false ) ; \nforwardQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nforwardFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \nelse { \nreturn joinBothPaths ( currentForwardNode , reverseFringe . get ( currentForwardNode . getState ( ) ) ) ; \n} \n} \nif ( ! reverseQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentReverseNode = reverseQueue . remove ( ) ; \nreverseFringe . remove ( currentReverseNode . getState ( ) ) ; \nif ( ! ( forwardFringe . containsKey ( currentReverseNode . getState ( ) ) ) ) { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentReverseNode . expandSuccessors ( newStates , false ) ; \nreverseQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nreverseFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \nelse { \nreturn joinBothPaths ( forwardFringe . get ( currentReverseNode . getState ( ) ) , currentReverseNode ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10370": "public class BaseBiDirectionalQueueSearch { \nprivate SearchNode < O , T > joinBothPaths ( SearchNode < O , T > forwardPath , SearchNode < O , T > reversePath ) throws SearchNotExhaustiveException { \nif ( ! ( pathJoiner != null ) ) { \nSearchNode < O , T > currentReverseNode = reversePath ; \nSearchNode < O , T > currentForwardNode = forwardPath ; \nwhile ( ! goalPredicate . evaluate ( currentReverseNode . getState ( ) ) ) { \nSearchNode < O , T > reverseParentNode = currentReverseNode . getParent ( ) ; \nT state = currentReverseNode . getParent ( ) . getState ( ) ; \nOperator < O > operation = currentReverseNode . getAppliedOp ( ) ; \nfloat cost = currentReverseNode . getPathCost ( ) - reverseParentNode . getPathCost ( ) ; \ncurrentForwardNode = currentForwardNode . makeNode ( new Successor < O > ( state , operation , cost ) ) ; \ncurrentReverseNode = reverseParentNode ; \n} \nreturn currentForwardNode ; \n} \nelse { \nreturn pathJoiner . joinBothPaths ( forwardPath , reversePath ) ; \n} \n} \n} \n"}
{"10384": "public class TreeSearchState { \npublic Iterator < Operator < Tree < E > > > validOperators ( boolean reverse ) { \nif ( ! ( tree . isLeaf ( ) ) ) { \nTree . Node < E > node = tree . getAsNode ( ) ; \nreturn new TreeSearchOperatorIterator < E > ( node . getChildIterator ( ) ) ; \n} \nelse { \nreturn new ArrayList < Operator < Tree < E > > > ( ) . iterator ( ) ; \n} \n} \n} \n"}
{"10385": "public class IdAttribute { \npublic long getId ( ) { \nif ( ! ( attributeClass . finalized ) ) { \nreturn attributeClass . lookupValueList . get ( value ) . id ; \n} \nelse { \nreturn attributeClass . lookupValue [ value ] . id ; \n} \n} \n} \n"}
{"10386": "public class IdAttribute { \npublic T getValue ( ) { \nif ( ! ( attributeClass . finalized ) ) { \nreturn attributeClass . lookupValueList . get ( value ) . label ; \n} \nelse { \nreturn attributeClass . lookupValue [ value ] . label ; \n} \n} \n} \n"}
{"10387": "public class IdAttribute { \npublic void setValue ( T value ) throws IllegalArgumentException { \nInteger b = attributeClass . lookupInt . get ( value ) ; \nif ( b == null ) { \nif ( ! ( attributeClass . finalized ) ) { \nIdAttribute newAttribute = attributeClass . createIdAttribute ( value ) ; \nb = newAttribute . value ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized IdType, \" + attributeClass . attributeClassName + \".\" ) ; \n} \n} \nthis . value = b ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( ! ( upper ) ) result . append ( Character . toLowerCase ( nextChar ) ) ; \nelse result . append ( Character . toUpperCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \ni < value . length ( ) ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( ! ( Character . isUpperCase ( nextChar ) ) ) if ( ! ( Character . isLetterOrDigit ( nextChar ) ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10392": "public class LoggingDiagnostic { \npublic static String currentConfiguration ( ) { \nStringBuffer rtn = new StringBuffer ( 1024 ) ; \nString loggingConfigClass = System . getProperty ( \"java.util.logging.config.class\" ) ; \nString loggingConfigFile = System . getProperty ( \"java.util.logging.config.file\" ) ; \nboolean configClassOK = false ; \nif ( ! ( loggingConfigClass == null ) ) { \nrtn . append ( \"java.util.logging.config.class is set to '\" ) . append ( loggingConfigClass ) . append ( \"'\\n\" ) ; \ntry { \nClass c = Class . forName ( loggingConfigClass ) ; \nc . newInstance ( ) ; \nrtn . append ( \"This class was loaded and a new instance was sucessfully created.\\n\" ) ; \nconfigClassOK = true ; \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be found.\" ) ; \n} \ncatch ( InstantiationException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be instantiated.\" ) ; \n} \ncatch ( IllegalAccessException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be accessed.\" ) ; \n} \n} \nelse { \nrtn . append ( \"No java.util.logging.config.class class is set.\\n\" ) ; \n} \nif ( ! ( loggingConfigFile == null ) ) { \nrtn . append ( \"java.util.logging.config.file is set to '\" ) . append ( loggingConfigFile ) . append ( \"'\\n\" ) ; \nFile loggingFile = new File ( loggingConfigFile ) ; \nrtn . append ( loggingFile . getAbsolutePath ( ) ) . append ( \"\\n\" ) ; \nif ( ! loggingFile . exists ( ) || ! loggingFile . isFile ( ) ) { \nrtn . append ( \"This file does NOT EXIST.\\n\" ) ; \n} \nif ( loggingConfigClass != null ) { \nif ( configClassOK ) { \nrtn . append ( \"This file is ignored because java.util.logging.config.class is set.\\n\" ) ; \n} \n} \n} \nelse { \nrtn . append ( \"No java.util.logging.config.file file is set.\\n\" ) ; \n} \nHandler [ ] handlers = Logger . getLogger ( \"\" ) . getHandlers ( ) ; \nlistHandlers ( handlers , rtn ) ; \nreturn rtn . toString ( ) ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( ! ( parentNode == null ) ) { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \nelse { \nint h = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh += diffX + diffY ; \n} \n} \nreturn ( float ) h ; \n} \n} \n} \n"}
{"10405": "public class ErrorHandler { \npublic static void handleErrors ( Throwable exception , ActionErrors errors ) { \nlog . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; \nif ( exception . getCause ( ) == null ) { \nlog . fine ( \"Exception.getCause() is null\" ) ; \n} \nif ( ( exception instanceof WrappedStrutsServletException ) && ( exception . getCause ( ) != null ) ) { \nexception = exception . getCause ( ) ; \nlog . fine ( \"Unwrapped WrappedStrutsServletException\" ) ; \n} \nWriter stackTrace = new StringWriter ( ) ; \nexception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; \nerrors . add ( \"exception\" , new ActionError ( \"error.general\" , stackTrace ) ) ; \nif ( exception instanceof UserReadableError ) { \nUserReadableError userError = ( UserReadableError ) exception ; \nif ( userError . isUserReadable ( ) ) { \nif ( ! ( userError . getUserMessageKey ( ) != null ) ) { \nerrors . add ( \"generalerror\" , new ActionError ( \"error.general\" , userError . getUserMessage ( ) ) ) ; \n} \nelse { \nerrors . add ( \"generalerror\" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; \n} \nreturn ; \n} \n} \nerrors . add ( \"generalerror\" , new ActionError ( \"error.internalerror\" ) ) ; \n} \n} \n"}
{"10406": "public class HTMLFilter { \npublic void write ( String str , int off , int len ) throws IOException { \nString inputString = str . substring ( off , off + len ) ; \nStringBuffer outputString = new StringBuffer ( ) ; \nfor ( StringTokenizer tokenizer = new StringTokenizer ( inputString , \"\\n\" , true ) ; \ntokenizer . hasMoreTokens ( ) ; \n) { \nString nextToken = tokenizer . nextToken ( ) ; \nif ( ! ( \"\\n\" . equals ( nextToken ) ) ) { \noutputString . append ( nextToken ) ; \n} \nelse { \noutputString . append ( \"<br>\" ) ; \n} \n} \nout . write ( outputString . toString ( ) ) ; \n} \n} \n"}
{"10407": "public class ProtoDTMachine { \npublic Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { \nDecisionTree currentNode = dt ; \nwhile ( true ) { \nDecisionTreeElement element = currentNode . getElement ( ) ; \nif ( ! ( element instanceof Decision ) ) if ( ! ( element instanceof Assignment ) ) { \nthrow new ClassifyingFailureException ( \"A node which is not a decision was encountered.\" , null ) ; \n} \nelse { \nAssignment assignment = ( Assignment ) element ; \nMap < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; \nassignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; \nreturn assignmentMap ; \n} \nelse { \nDecision decision = ( Decision ) element ; \ncurrentNode = decision . decide ( state ) ; \n} \n} \n} \n} \n"}
{"10410": "public class BitHackUtils { \npublic static int intLogBase2 ( int value ) { \nint temp1 ; \nint temp2 = value >> 16 ; \nif ( ! ( temp2 > 0 ) ) { \ntemp1 = value >> 8 ; \nreturn ( temp1 > 0 ) ? ( 8 + LOG_TABLE_256 [ temp1 ] ) : LOG_TABLE_256 [ value ] ; \n} \nelse { \ntemp1 = temp2 >> 8 ; \nreturn ( temp1 > 0 ) ? ( 24 + LOG_TABLE_256 [ temp1 ] ) : ( 16 + LOG_TABLE_256 [ temp2 ] ) ; \n} \n} \n} \n"}
{"10411": "public class BitHackUtils { \npublic static int intLogBase2v2 ( int value ) { \nint temp ; \nif ( ! ( ( temp = value >> 24 ) > 0 ) ) if ( ! ( ( temp = value >> 16 ) > 0 ) ) if ( ! ( ( temp = value >> 8 ) > 0 ) ) { \nreturn LOG_TABLE_256 [ value ] ; \n} \nelse { \nreturn 8 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nreturn 16 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nreturn 24 + LOG_TABLE_256 [ temp ] ; \n} \n} \n} \n"}
{"10416": "public class BitHackUtils { \npublic static int getCharacterCountInt32 ( int value ) { \nif ( ! ( value >= 0 ) ) if ( ! ( value == Integer . MIN_VALUE ) ) { \nreturn getCharacterCountUInt32 ( - value ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt32 ( value ) ; \n} \n} \n} \n"}
{"10417": "public class BitHackUtils { \npublic static int getCharacterCountInt64 ( long value ) { \nif ( ! ( value >= 0 ) ) if ( ! ( value == Long . MIN_VALUE ) ) { \nreturn getCharacterCountUInt64 ( - value ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt64 ( value ) ; \n} \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = integerValue < 0 ; \nint totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nint totalLength = totalDigits ; \nif ( isNeg ) { \ntotalDigits -- ; \n} \nif ( ! ( scale > 0 ) ) { \ntotalLength -= scale ; \n} \nelse { \ntotalLength ++ ; \nif ( scale >= totalDigits ) { \ntotalLength += ( scale - totalDigits ) + 1 ; \n} \n} \nreturn totalLength ; \n} \n} \n"}
{"10428": "public class UMinus { \nprotected NumericType evaluate ( NumericType firstNumber ) { \nif ( ! ( firstNumber . isInteger ( ) ) ) { \nreturn new DoubleLiteral ( - firstNumber . doubleValue ( ) ) ; \n} \nelse { \nreturn new IntLiteral ( - firstNumber . intValue ( ) ) ; \n} \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nint pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( ! ( parentTerm instanceof Clause ) ) if ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \nelse { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \n} \n} \n"}
{"10434": "public class Variable { \npublic Term getValue ( ) { \nTerm result = this ; \nTerm assignment = this . substitution ; \nwhile ( assignment != null ) { \nresult = assignment ; \nif ( ! ( ! assignment . isVar ( ) ) ) { \nassignment = ( ( Variable ) assignment ) . substitution ; \n} \nelse { \nbreak ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10443": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void requestWriteOperation ( TxOperation op ) { \nTxId txId = null ; \nif ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nenlistWithSession ( ) ; \n} \nif ( ! ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) ) { \naddCachedOperation ( txId , op ) ; \n} \nelse { \nop . execute ( ) ; \n} \n} \n} \n"}
{"10452": "public class BatchSynchQueueBase { \nprotected boolean insert ( E element , boolean unlockAndBlock ) { \nSynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; \nboolean result = buffer . offer ( record ) ; \nif ( ! ( result ) ) { \nreturn false ; \n} \nelse { \ncount ++ ; \nnotEmpty . signal ( ) ; \nif ( unlockAndBlock ) { \nlock . unlock ( ) ; \nrecord . waitForConsumer ( ) ; \n} \nreturn true ; \n} \n} \n} \n"}
{"10466": "public class DirectMemento { \npublic void put ( Class cls , String attr , Object val ) { \nHashMap map ; \nif ( ! ( values . containsKey ( cls ) ) ) { \nmap = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \n} \nelse { \nmap = ( HashMap ) values . get ( cls ) ; \n} \nmap . put ( attr , val ) ; \n} \n} \n"}
{"10469": "public class LockFreeNQueue { \npublic boolean offer ( E o ) { \nif ( o == null ) { \nthrow new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; \n} \nint level = priorityToLevel ( p . apply ( o ) ) ; \nNode < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; \nwhile ( true ) { \nNode < E > t = markers [ level + 1 ] . getTail ( ) ; \nNode < E > s = t . getNext ( ) ; \nif ( t == markers [ level + 1 ] . getTail ( ) ) { \nif ( ! ( s == markers [ level + 1 ] ) ) { \nmarkers [ level + 1 ] . casTail ( t , s ) ; \n} \nelse { \nif ( t . casNext ( s , newNode ) ) { \nmarkers [ level + 1 ] . casTail ( t , newNode ) ; \ncount . incrementAndGet ( ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) ) if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \nelse { \nbreak ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( ! ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) ) if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \nelse { \nif ( ! ( first == null ) ) { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n} \n} \n} \n"}
{"10481": "public class PropertiesHelper { \npublic static Properties getProperties ( String pathname ) throws IOException { \nif ( pathname == null ) { \nreturn null ; \n} \nif ( ! ( isURL ( pathname ) ) ) { \nreturn getProperties ( new File ( pathname ) ) ; \n} \nelse { \nreturn getProperties ( new URL ( pathname ) ) ; \n} \n} \n} \n"}
{"10488": "public class DoubleRangeType { \npublic static Type createInstance ( String name , double min , double max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DOUBLE_RANGE_TYPES ) { \nDoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; \nDoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nDOUBLE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10489": "public class FaderImpl { \npublic void doFade ( ColorDelta target , String groupName ) { \nFadeState fadeState = timers . get ( groupName ) ; \nIterator < Color > interpolator = new ColorInterpolator ( startColor , endColor , 8 ) . iterator ( ) ; \nif ( ! ( fadeState == null ) ) { \nfadeState . timer . stop ( ) ; \nfadeState . target = target ; \nfadeState . interpolator = interpolator ; \n} \nelse { \nTimer timer = new Timer ( 20 , this ) ; \nfadeState = new FadeState ( timer , target , interpolator ) ; \ntimers . put ( groupName , fadeState ) ; \n} \nColor firstColor = fadeState . interpolator . next ( ) ; \nfadeState . target . changeColor ( firstColor ) ; \nfadeState . timer . setActionCommand ( groupName ) ; \nfadeState . timer . setInitialDelay ( 400 ) ; \nfadeState . timer . start ( ) ; \n} \n} \n"}
{"10497": "public class ScriptGenMojo { \nprotected String appendClasspath ( String commandLine , boolean unix ) { \nString pathSeperator ; \nString seperator ; \nif ( ! ( unix ) ) { \npathSeperator = \"\\\\\" ; \nseperator = \";\" ; \n} \nelse { \npathSeperator = \"/\" ; \nseperator = \":\" ; \n} \nfor ( Iterator i = classpathElements . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString cpPath = ( String ) i . next ( ) ; \ncpPath = cpPath . replace ( \"/\" , pathSeperator ) ; \ncommandLine += cpPath + ( i . hasNext ( ) ? seperator : \"\" ) ; \n} \nreturn commandLine ; \n} \n} \n"}
{"10498": "public class DateRangeType { \npublic static Type createInstance ( String name , DateOnly from , DateOnly to ) { \nif ( ( from != null ) && ( to != null ) && ( from . compareTo ( to ) > 0 ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DATE_RANGE_TYPES ) { \nDateRangeType newType = new DateRangeType ( name , from , to ) ; \nDateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nDATE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10501": "public class ResolutionInterpreter { \nprivate void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { \nClause clause = sentence . getT ( ) ; \nif ( ! ( clause . isQuery ( ) ) ) { \nint name = clause . getHead ( ) . getName ( ) ; \nif ( ( currentPredicateName == null ) || ( currentPredicateName != name ) ) { \nengine . endScope ( ) ; \ncurrentPredicateName = name ; \n} \naddProgramClause ( sentence ) ; \n} \nelse { \nengine . endScope ( ) ; \nengine . compile ( sentence ) ; \nevaluateQuery ( ) ; \n} \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \"false. \" ) ; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( ! ( solution . isEmpty ( ) ) ) { \nfor ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) { \nSystem . out . println ( ) ; \n} \n} \n} \nelse { \nSystem . out . print ( \"true\" ) ; \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \".\" ) ; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( ! ( key == SEMICOLON ) ) { \nSystem . out . println ( ) ; \nbreak ; \n} \nelse { \nSystem . out . println ( \" ;\" ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n"}
{"10511": "public class TypeConverter { \npublic static MultiTypeData getMultiTypeData ( String s ) { \nMultiTypeData result = new MultiTypeData ( ) ; \nresult . typeFlags = STRING ; \nresult . stringValue = s ; \nresult . nativeType = STRING ; \nif ( ! ( \"true\" . equals ( s ) ) ) if ( \"false\" . equals ( s ) ) { \nresult . booleanValue = false ; \nresult . typeFlags |= BOOLEAN ; \n} \nelse { \nresult . booleanValue = true ; \nresult . typeFlags |= BOOLEAN ; \n} \ntry { \nresult . intValue = Integer . parseInt ( s ) ; \nresult . typeFlags |= INT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags &= ( Integer . MAX_VALUE - INT ) ; \n} \ntry { \nresult . byteValue = Byte . parseByte ( s ) ; \nresult . typeFlags |= BYTE ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - BYTE ) ; \n} \nif ( s . length ( ) == 1 ) { \nresult . charValue = s . charAt ( 0 ) ; \nresult . typeFlags |= CHAR ; \n} \ntry { \nresult . shortValue = Short . parseShort ( s ) ; \nresult . typeFlags |= SHORT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - SHORT ) ; \n} \ntry { \nresult . longValue = Long . parseLong ( s ) ; \nresult . typeFlags |= LONG ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - LONG ) ; \n} \ntry { \nresult . floatValue = Float . parseFloat ( s ) ; \nresult . typeFlags |= FLOAT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - FLOAT ) ; \n} \ntry { \nresult . doubleValue = Double . parseDouble ( s ) ; \nresult . typeFlags |= DOUBLE ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - DOUBLE ) ; \n} \nreturn result ; \n} \n} \n"}
{"10513": "public class TypeConverter { \npublic static Object convert ( MultiTypeData d , Class c ) { \nif ( ! ( ( ( d . typeFlags & BOOLEAN ) != 0 ) && ( Boolean . TYPE . equals ( c ) || Boolean . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & INT ) != 0 ) && ( Integer . TYPE . equals ( c ) || Integer . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & CHAR ) != 0 ) && ( Character . TYPE . equals ( c ) || Character . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & BYTE ) != 0 ) && ( Byte . TYPE . equals ( c ) || Byte . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & SHORT ) != 0 ) && ( Short . TYPE . equals ( c ) || Short . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & LONG ) != 0 ) && ( Long . TYPE . equals ( c ) || Long . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & FLOAT ) != 0 ) && ( Float . TYPE . equals ( c ) || Float . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & DOUBLE ) != 0 ) && ( Double . TYPE . equals ( c ) || Double . class . equals ( c ) ) ) ) if ( ! ( ( ( d . typeFlags & STRING ) != 0 ) && String . class . equals ( c ) ) ) if ( ! ( ( ( d . typeFlags & OBJECT ) != 0 ) && d . objectValue . getClass ( ) . equals ( c ) ) ) { \nthrow new ClassCastException ( \"The multi data type, \" + d + \", cannot be converted to the class, \" + c + \".\" ) ; \n} \nelse { \nreturn d . objectValue ; \n} \nelse { \nreturn d . stringValue ; \n} \nelse { \nreturn d . doubleValue ; \n} \nelse { \nreturn d . floatValue ; \n} \nelse { \nreturn d . longValue ; \n} \nelse { \nreturn d . shortValue ; \n} \nelse { \nreturn d . byteValue ; \n} \nelse { \nreturn d . charValue ; \n} \nelse { \nreturn d . intValue ; \n} \nelse { \nreturn d . booleanValue ; \n} \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ! ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) ) { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \nelse { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) && ( newStart <= key ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nfor ( ; \nnewStart <= end ; \nnewStart ++ ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \n} \nstart = newStart ; \n} \n} \n} \n"}
{"10516": "public class CircularArrayMap { \nprivate void expand ( int key ) { \nint newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; \nint newSpaceSize = spaceRequired ( key ) ; \nint newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; \nObject [ ] oldData = data ; \ndata = new Object [ newSize ] ; \nint offsetStart = offset ( start ) ; \nint offsetEnd = offset ( end ) ; \nif ( ! ( offsetStart < offsetEnd ) ) { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; \nSystem . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; \n} \nelse { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; \n} \noffset = - start ; \nlength = newSize ; \n} \n} \n"}
{"10519": "public class DynamicOperatorParser { \npublic Term parseOperators ( Term [ ] terms ) throws SourceCodeException { \nstack . offer ( 0 ) ; \nstate = 0 ; \nposition = 0 ; \nnextTerm = null ; \nfor ( position = 0 ; \nposition <= terms . length ; \n) { \nSymbol nextSymbol ; \nif ( ! ( position < terms . length ) ) { \nnextSymbol = Symbol . Final ; \n} \nelse { \nnextTerm = terms [ position ] ; \nif ( ! ( nextTerm instanceof CandidateOpSymbol ) ) { \nnextSymbol = Symbol . Term ; \n} \nelse { \nnextSymbol = Symbol . Op ; \n} \n} \nAction action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; \naction . apply ( ) ; \n} \nreturn ( Functor ) outputStack . poll ( ) ; \n} \n} \n"}
{"10536": "public class PTStemmer { \nprotected synchronized ptstemmer . Stemmer getActualStemmer ( ) throws PTStemmerException { \nif ( m_ActualStemmer == null ) { \nif ( ! ( m_Stemmer == STEMMER_ORENGO ) ) if ( ! ( m_Stemmer == STEMMER_PORTER ) ) if ( ! ( m_Stemmer == STEMMER_SAVOY ) ) throw new IllegalStateException ( \"Unhandled stemmer type: \" + m_Stemmer ) ; \nelse m_ActualStemmer = new SavoyStemmer ( ) ; \nelse m_ActualStemmer = new PorterStemmer ( ) ; \nelse m_ActualStemmer = new OrengoStemmer ( ) ; \nif ( ! m_NamedEntities . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_NamedEntities . getAbsolutePath ( ) ) ) ; \nif ( ! m_Stopwords . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_Stopwords . getAbsolutePath ( ) ) ) ; \nif ( ! ( m_Cache > 0 ) ) m_ActualStemmer . disableCaching ( ) ; \nelse m_ActualStemmer . enableCaching ( m_Cache ) ; \n} \nreturn m_ActualStemmer ; \n} \n} \n"}
{"10539": "public class FloatRangeType { \npublic static Type createInstance ( String name , float min , float max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( FLOAT_RANGE_TYPES ) { \nFloatRangeType newType = new FloatRangeType ( name , min , max ) ; \nFloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; \nif ( ! ( ( oldType != null ) && ! oldType . equals ( newType ) ) ) if ( ! ( ( oldType != null ) && oldType . equals ( newType ) ) ) { \nFLOAT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \nelse { \nreturn oldType ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \n} \n} \n} \n"}
{"10544": "public class WAMResolvingJavaMachine { \nprivate int nextStackFrame ( ) { \nif ( ! ( ep == bp ) ) if ( ! ( ep > bp ) ) { \nreturn bp + data . get ( bp ) + 8 ; \n} \nelse { \nreturn ep + data . get ( ep + 2 ) + 3 ; \n} \nelse { \nreturn STACK_BASE ; \n} \n} \n} \n"}
{"10545": "public class WAMResolvingJavaMachine { \nprivate boolean backtrack ( ) { \nif ( ! ( bp == 0 ) ) { \nb0 = data . get ( bp + data . get ( bp ) + 7 ) ; \nip = data . get ( bp + data . get ( bp ) + 4 ) ; \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( ! ( bp == 0 ) ) { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nelse { \ni = TRAIL_BASE ; \n} \nwhile ( i < trp ) { \nint addr = data . get ( i ) ; \nif ( ! ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) ) { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \nelse { \ni ++ ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ! ( ( t1 == WAMInstruction . REF ) ) ) if ( ! ( t2 == WAMInstruction . REF ) ) if ( ! ( t2 == WAMInstruction . STR ) ) if ( ! ( t2 == WAMInstruction . CON ) ) if ( t2 == WAMInstruction . LIS ) { \nif ( ! ( t1 != WAMInstruction . LIS ) ) { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \nelse { \nfail = true ; \n} \n} \nelse { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( ! ( fn1 == fn2 ) ) { \nfail = true ; \n} \nelse { \nfor ( int i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \n} \nelse { \nbind ( d1 , d2 ) ; \n} \nelse { \nbind ( d1 , d2 ) ; \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nint illegal = 0 ; \nint tileX = getXForTile ( t ) ; \nint tileY = getYForTile ( t ) ; \nwhile ( tileX != x ) { \nif ( ! ( ( tileX - x ) > 0 ) ) { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX ++ ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX -- ; \n} \n} \nwhile ( tileY != y ) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { \nillegal ++ ; \n} \ntileY -- ; \n} \nreturn illegal ; \n} \n} \n"}
{"10558": "public class EightPuzzleState { \nprotected boolean swapTiles ( int x1 , int y1 , int x2 , int y2 ) { \nboolean swappedEmpty = false ; \nchar tile1 = board [ y1 ] [ x1 ] ; \nchar tile2 = board [ y2 ] [ x2 ] ; \nboard [ y1 ] [ x1 ] = tile2 ; \nboard [ y2 ] [ x2 ] = tile1 ; \nif ( ! ( tile1 == 'E' ) ) if ( tile2 == 'E' ) { \nemptyX = x1 ; \nemptyY = y1 ; \nswappedEmpty = true ; \n} \nelse { \nemptyX = x2 ; \nemptyY = y2 ; \nswappedEmpty = true ; \n} \nreturn ! swappedEmpty ; \n} \n} \n"}
{"10562": "public class LoggingToLog4JHandler { \nprivate org . apache . log4j . Level toLog4j ( Level level ) { \nif ( ! ( Level . SEVERE == level ) ) if ( ! ( Level . WARNING == level ) ) if ( ! ( Level . INFO == level ) ) if ( ! ( Level . FINE == level ) ) if ( ! ( Level . FINER == level ) ) if ( Level . OFF == level ) { \nreturn org . apache . log4j . Level . OFF ; \n} \nelse { \nreturn org . apache . log4j . Level . TRACE ; \n} \nelse { \nreturn org . apache . log4j . Level . DEBUG ; \n} \nelse { \nreturn org . apache . log4j . Level . INFO ; \n} \nelse { \nreturn org . apache . log4j . Level . WARN ; \n} \nelse { \nreturn org . apache . log4j . Level . ERROR ; \n} \nreturn org . apache . log4j . Level . OFF ; \n} \n} \n"}
{"10565": "public class WrapperQueue { \nprivate void incrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . incrementAndGet ( ) ; \n} \nif ( ! ( sizeable && ( record instanceof Sizeable ) ) ) if ( sizeable ) { \ndataSize . incrementAndGet ( ) ; \n} \nelse { \ndataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; \n} \n} \n} \n"}
{"10566": "public class WrapperQueue { \nprivate void decrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . decrementAndGet ( ) ; \n} \nif ( ! ( sizeable && ( record instanceof Sizeable ) ) ) if ( sizeable ) { \nlong oldSize = dataSize . getAndDecrement ( ) ; \nlong newSize = oldSize - 1 ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \nelse { \nlong recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; \nlong oldSize = dataSize . getAndAdd ( recordSize ) ; \nlong newSize = oldSize + recordSize ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) { \nif ( ! ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) ) if ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) { \nsignalable . signal ( ) ; \n} \nelse { \nsignalable . signalAll ( ) ; \n} \n} \n} \n} \n"}
{"10576": "public class TextTableImpl { \npublic void setMaxRowHeight ( int row , int height ) { \nInteger previousValue = maxRowSizes . get ( row ) ; \nif ( ! ( previousValue == null ) ) if ( previousValue < height ) { \nmaxRowSizes . put ( row , height ) ; \n} \nelse { \nmaxRowSizes . put ( row , height ) ; \n} \n} \n} \n"}
{"10577": "public class TextTableImpl { \nprivate void updateMaxColumnWidth ( int column , int width ) { \nInteger previousValue = maxColumnSizes . get ( column ) ; \nif ( ! ( previousValue == null ) ) if ( previousValue < width ) { \nmaxColumnSizes . put ( column , width ) ; \n} \nelse { \nmaxColumnSizes . put ( column , width ) ; \n} \n} \n} \n"}
{"10585": "public class LessThan { \nprotected boolean evaluate ( NumericType firstNumber , NumericType secondNumber ) { \nif ( ! ( firstNumber . isInteger ( ) && secondNumber . isInteger ( ) ) ) { \nreturn firstNumber . doubleValue ( ) < secondNumber . doubleValue ( ) ; \n} \nelse { \nreturn firstNumber . intValue ( ) < secondNumber . intValue ( ) ; \n} \n} \n} \n"}
{"10589": "public class FibonacciHeap { \npublic boolean offer ( E o ) { \nNode newNode = new Node ( o ) ; \nif ( ! ( minNode != null ) ) { \nnewNode . next = newNode ; \nnewNode . prev = newNode ; \nminNode = newNode ; \n} \nelse { \nnewNode . next = minNode . next ; \nnewNode . prev = minNode ; \nminNode . next . prev = newNode ; \nminNode . next = newNode ; \nupdateMinimum ( newNode ) ; \n} \nsize ++ ; \nreturn true ; \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nint oa ; \nint i ; \nint b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nwhile ( b != 0 ) { \ni = ( i << 1 ) ; \nif ( ! ( n >= ( 1 << b ) ) ) { \nn &= ( 1 << b ) - 1 ; \n} \nelse { \nn /= ( 1 << b ) ; \ni = i | 1 ; \n} \nb /= 2 ; \n} \nif ( ! ( ( 1 << i ) == oa ) ) { \nreturn i + 1 ; \n} \nelse { \nreturn i ; \n} \n} \n} \n"}
{"10591": "public class FibonacciHeap { \nprivate void updateMinimum ( Node node ) { \nif ( ! ( entryComparator != null ) ) { \nif ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \nelse { \nif ( entryComparator . compare ( node . element , minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \n} \n} \n"}
{"10592": "public class FibonacciHeap { \nprivate int compare ( Node node1 , Node node2 ) { \nif ( ! ( entryComparator != null ) ) { \nreturn ( ( Comparable ) node1 . element ) . compareTo ( node2 . element ) ; \n} \nelse { \nreturn entryComparator . compare ( node1 . element , node2 . element ) ; \n} \n} \n} \n"}
{"10599": "public class BeanMemento { \npublic static void restoreValues ( Object ob , Map < String , Object > values ) throws NoSuchFieldException { \nClass obClass = ob . getClass ( ) ; \nfor ( String propName : values . keySet ( ) ) { \nObject nextValue = values . get ( propName ) ; \nObject paramValue ; \nClass paramType ; \nif ( ! ( nextValue == null ) ) if ( ! ( nextValue instanceof TypeConverter . MultiTypeData ) ) { \nparamValue = nextValue ; \nparamType = nextValue . getClass ( ) ; \n} \nelse { \nTypeConverter . MultiTypeData multiValue = ( TypeConverter . MultiTypeData ) nextValue ; \nSet < Class > setterTypes = ReflectionUtils . findMatchingSetters ( ob . getClass ( ) , propName ) ; \nparamType = TypeConverter . bestMatchingConversion ( multiValue , setterTypes ) ; \nparamValue = TypeConverter . convert ( multiValue , paramType ) ; \n} \nelse { \nparamValue = null ; \nparamType = null ; \n} \nMethod setterMethod ; \ntry { \nString upperPropertyName = Character . toUpperCase ( propName . charAt ( 0 ) ) + propName . substring ( 1 ) ; \nsetterMethod = obClass . getMethod ( \"set\" + upperPropertyName , paramType ) ; \nObject [ ] params = new Object [ ] { \nparamValue } \n; \nsetterMethod . invoke ( ob , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \n} \ncatch ( IllegalAccessException e ) { \n} \ncatch ( InvocationTargetException e ) { \n} \n} \n} \n} \n"}
{"10617": "public class Clause { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ! ( ( traverser != null ) && ( traverser instanceof ClauseTraverser ) ) ) { \nLinkedList < Operator < Term > > resultList = null ; \nif ( ! ( ! reverse ) ) { \nresultList = new StackQueue < Operator < Term > > ( ) ; \n} \nelse { \nresultList = new LinkedList < Operator < Term > > ( ) ; \n} \nif ( head != null ) { \nresultList . add ( head ) ; \n} \nif ( body != null ) { \nfor ( Term bodyTerm : body ) { \nresultList . add ( bodyTerm ) ; \n} \n} \nreturn resultList . iterator ( ) ; \n} \nelse { \nreturn ( ( ClauseTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \n} \n} \n"}
{"10618": "public class Functor { \npublic Term getArgument ( int index ) { \nif ( ! ( ( arguments == null ) || ( index > ( arguments . length - 1 ) ) ) ) { \nreturn arguments [ index ] ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ! ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) ) { \nif ( ! ( arguments == null ) ) if ( ! ( ! reverse ) ) { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \ni >= 0 ; \ni -- ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \nelse { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \n} \nelse { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \n} \n} \n"}
{"10625": "public class JavaType { \nprivate void setBasicType ( Class c ) { \nif ( ! ( Boolean . class . equals ( c ) ) ) if ( ! ( Character . class . equals ( c ) ) ) if ( ! ( Byte . class . equals ( c ) ) ) if ( ! ( Short . class . equals ( c ) ) ) if ( ! ( Integer . class . equals ( c ) ) ) if ( ! ( Long . class . equals ( c ) ) ) if ( ! ( Float . class . equals ( c ) ) ) if ( ! ( Double . class . equals ( c ) ) ) { \ntype = BasicTypes . OTHER ; \n} \nelse { \ntype = BasicTypes . DOUBLE ; \n} \nelse { \ntype = BasicTypes . FLOAT ; \n} \nelse { \ntype = BasicTypes . LONG ; \n} \nelse { \ntype = BasicTypes . INTEGER ; \n} \nelse { \ntype = BasicTypes . SHORT ; \n} \nelse { \ntype = BasicTypes . BYTE ; \n} \nelse { \ntype = BasicTypes . CHARACTER ; \n} \nelse { \ntype = BasicTypes . BOOLEAN ; \n} \n} \n} \n"}
{"10630": "public class SocketReadThread { \nprivate void readStream ( ) throws Exception { \nwhile ( ! shutdown ) { \nElement doc = reader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nreturn ; \n} \nPacket packet ; \nString tag = doc . getName ( ) ; \nif ( ! ( \"message\" . equals ( tag ) ) ) if ( ! ( \"presence\" . equals ( tag ) ) ) if ( ! ( \"iq\" . equals ( tag ) ) ) { \nthrow new XmlPullParserException ( \"Unknown packet type was read: \" + tag ) ; \n} \nelse { \npacket = getIQ ( doc ) ; \n} \nelse { \npacket = new Presence ( doc ) ; \n} \nelse { \npacket = new Message ( doc ) ; \n} \ncomponent . processPacket ( packet ) ; \n} \n} \n} \n"}
{"10635": "public class Player { \n@ Override public void renderFinalOutput ( List < T > data , EventModel eventModel ) { \nif ( ! ( StartMusicRequest . verify ( eventModel , capabilities , this , activators ) ) ) if ( ! ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( MusicUsageResource . ID ) ) ) ) { \nhandleCommands ( eventModel ) ; \n} \nelse { \nif ( ! ( isOutputRunning ( ) ) ) { \nhandleResourceRequest ( eventModel ) ; \n} \nelse { \neventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . forEach ( resourceModel -> playerError ( PlayerError . ERROR_ALREADY_PLAYING , resourceModel . getProvider ( ) ) ) ; \n} \n} \nelse { \nif ( ! ( isOutputRunning ( ) ) ) { \nhandleEventRequest ( eventModel ) ; \n} \nelse { \nplayerError ( PlayerError . ERROR_ALREADY_PLAYING , eventModel . getSource ( ) ) ; \n} \n} \n} \n} \n"}
{"10636": "public class Player { \nprivate void handleResourceRequest ( EventModel eventModel ) { \nif ( ! ( MusicUsageResource . isPermanent ( eventModel ) ) ) { \nplay ( eventModel ) ; \nif ( ! runsInPlay ) { \nblockRequest = lock . newCondition ( ) ; \nlock . lock ( ) ; \ntry { \nblockRequest . await ( 10 , TimeUnit . MINUTES ) ; \n} \ncatch ( InterruptedException e ) { \ndebug ( \"interrupted\" , e ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \nelse { \nResourceModel resourceModel = eventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . stream ( ) . filter ( MusicUsageResource :: isPermanent ) . findAny ( ) . orElse ( null ) ; \nFunction < Identification , Optional < StartMusicRequest > > getStartMusicRequest = own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own ) ; \ngetStartMusicRequest = TrackInfoResource . getTrackInfo ( eventModel ) . map ( trackInfo -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , trackInfo ) ) . orElse ( getStartMusicRequest ) ; \ngetStartMusicRequest = PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , playlist ) ) . orElse ( getStartMusicRequest ) ; \ngetStartMusicRequest = getStartMusicRequest . andThen ( VolumeResource . getVolume ( eventModel ) . flatMap ( volume -> IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . map ( identification -> new VolumeResource ( identification , volume ) ) ) . map ( resource -> ( Function < Optional < StartMusicRequest > , Optional < StartMusicRequest > > ) opt -> opt . map ( event -> ( StartMusicRequest ) event . addResource ( resource ) ) ) . orElse ( Function . identity ( ) ) :: apply ) ; \nIdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( getStartMusicRequest :: apply ) . ifPresent ( this :: fire ) ; \n} \n} \n} \n"}
{"10637": "public class Player { \nprivate void handleEventRequest ( EventModel eventModel ) { \nplayingThread = submit ( ( Runnable ) ( ) -> { \nif ( ! ( runsInPlay ) ) { \nisRunning = true ; \n} \nelse { \nisRunning = false ; \n} \nisPlaying = true ; \nfireStartMusicRequest ( eventModel ) ; \n} \n) . thenRun ( ( ) -> play ( eventModel ) ) . thenRun ( ( ) -> { \nif ( runsInPlay ) { \nisRunning = false ; \nisPlaying = false ; \nendedSound ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"10640": "public class PacketReader { \nsynchronized public void startup ( ) throws XMPPException { \nfinal List < Exception > errors = new LinkedList < Exception > ( ) ; \nAbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { \n@ Override public void connectionClosedOnError ( Exception e ) { \nerrors . add ( e ) ; \n} \n} \n; \nconnection . addConnectionListener ( connectionErrorListener ) ; \nreaderThread . start ( ) ; \ntry { \nint waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; \nwait ( 3 * waitTime ) ; \n} \ncatch ( InterruptedException ie ) { \n} \nconnection . removeConnectionListener ( connectionErrorListener ) ; \nif ( ! ( connectionID == null ) ) if ( ! ( ! errors . isEmpty ( ) ) ) { \nconnection . connectionID = connectionID ; \n} \nelse { \nthrow new XMPPException ( errors . iterator ( ) . next ( ) ) ; \n} \nelse { \nthrow new XMPPException ( \"Connection failed. No response from server.\" ) ; \n} \n} \n} \n"}
{"10645": "public class AbstractApplicationOption { \nprotected final void setCliOption ( Option option ) { \nif ( option != null ) { \nthis . cliOption = option ; \n} \nif ( ! ( this . cliOption . getDescription ( ) != null ) ) { \nthis . cliOption . setDescription ( this . descr ) ; \n} \nelse { \nthis . descr = this . cliOption . getDescription ( ) ; \n} \n} \n} \n"}
{"10649": "public class InternalContent { \npublic void setProperty ( String key , Object value ) { \nif ( readOnly ) { \nreturn ; \n} \nif ( value == null ) { \nthrow new IllegalArgumentException ( \"value must not be null\" ) ; \n} \nObject o = content . get ( key ) ; \nif ( ! ( ! value . equals ( o ) ) ) if ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nelse { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \n} \n} \n"}
{"10651": "public class ModificationRequest { \npublic void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { \nboolean debug = LOGGER . isDebugEnabled ( ) ; \nif ( ! ( ServletFileUpload . isMultipartContent ( request ) ) ) { \nif ( debug ) { \nLOGGER . debug ( \"Trad Post \" ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Traditional POST {} \" , parameters ) ; \n} \nSet < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; \nfor ( Entry < String , String [ ] > param : entries ) { \nString name = ( String ) param . getKey ( ) ; \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \nelse { \nif ( debug ) { \nLOGGER . debug ( \"Multipart POST \" ) ; \n} \nfeedback . add ( \"Multipart Upload\" ) ; \nServletFileUpload upload = new ServletFileUpload ( ) ; \nFileItemIterator iterator = upload . getItemIterator ( request ) ; \nwhile ( iterator . hasNext ( ) ) { \nFileItemStream item = iterator . next ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Got Item {}\" , item ) ; \n} \nString name = item . getFieldName ( ) ; \nInputStream stream = item . openStream ( ) ; \nif ( ! ( item . isFormField ( ) ) ) { \nif ( streamProcessor != null ) { \nfeedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; \n} \n} \nelse { \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \nif ( debug ) { \nLOGGER . debug ( \"No More items \" ) ; \n} \n} \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; \nif ( ! ( auto_commit ) ) e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nelse { \nmodCount ++ ; \nsize -- ; \nif ( ! ( prev == e ) ) prev . next = next ; \nelse table [ i ] = next ; \nreturn e ; \n} \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) return null ; \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { \nif ( ! ( auto_commit ) ) e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nelse { \nmodCount ++ ; \nsize -- ; \nif ( ! ( prev == e ) ) prev . next = next ; \nelse table [ i ] = next ; \n} \nreturn e ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10674": "public class StringUtils { \nprivate static String xmlAttribEncodeBinary ( String value ) { \nStringBuilder s = new StringBuilder ( ) ; \nchar buf [ ] = value . toCharArray ( ) ; \nfor ( char c : buf ) { \nswitch ( c ) { \ncase '<' : s . append ( \"&lt;\" ) ; \nbreak ; \ncase '>' : s . append ( \"&gt;\" ) ; \nbreak ; \ncase '&' : s . append ( \"&amp;\" ) ; \nbreak ; \ncase '\"' : s . append ( \"&quot;\" ) ; \nbreak ; \ncase '\\'' : s . append ( \"&apos;\" ) ; \nbreak ; \ndefault : if ( ! ( c <= 0x1f || ( 0x7f <= c && c <= 0x9f ) ) ) { \ns . append ( c ) ; \n} \nelse { \ns . append ( \"&#x\" ) ; \ns . append ( String . format ( \"%X\" , ( int ) c ) ) ; \ns . append ( ';' ) ; \n} \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"10691": "public class StorageClientUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { \nif ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) && ( exclude == null || exclude . size ( ) == 0 ) ) { \nif ( ! ( source instanceof ImmutableMap ) ) { \nreturn ImmutableMap . copyOf ( source ) ; \n} \nelse { \nreturn source ; \n} \n} \nBuilder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; \nfor ( Entry < K , V > e : source . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( include == null || include . contains ( k ) ) { \nif ( exclude == null || ! exclude . contains ( k ) ) { \nif ( ! ( modified != null && modified . containsKey ( k ) ) ) { \nObject o = e . getValue ( ) ; \nif ( ! ( o instanceof Map ) ) { \nfilteredMap . put ( k , e . getValue ( ) ) ; \n} \nelse { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \n} \n} \nelse { \nV o = modified . get ( k ) ; \nif ( ! ( o instanceof Map ) ) if ( ! ( includingRemoveProperties ) ) if ( ! ( o instanceof RemoveProperty ) ) { \nfilteredMap . put ( k , o ) ; \n} \nelse { \nfilteredMap . put ( k , o ) ; \n} \nelse { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \n} \n} \n} \n} \n} \nif ( modified != null ) { \nfor ( Entry < K , V > e : modified . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( ! source . containsKey ( k ) ) { \nV v = e . getValue ( ) ; \nif ( ! ( v instanceof RemoveProperty ) && v != null ) { \nfilteredMap . put ( k , v ) ; \n} \n} \n} \n} \nreturn filteredMap . build ( ) ; \n} \n} \n"}
{"10693": "public class StorageClientUtils { \npublic static Session adaptToSession ( Object source ) { \nif ( ! ( source instanceof SessionAdaptable ) ) { \nObject userManager = safeMethod ( source , \"getUserManager\" , new Object [ 0 ] , new Class [ 0 ] ) ; \nif ( userManager != null ) { \nreturn ( Session ) safeMethod ( userManager , \"getSession\" , new Object [ 0 ] , new Class [ 0 ] ) ; \n} \nreturn null ; \n} \nelse { \nreturn ( ( SessionAdaptable ) source ) . getSession ( ) ; \n} \n} \n} \n"}
{"10697": "public class KeepAliveManager { \npublic void setPingInterval ( long newPingInterval ) { \nif ( pingInterval == newPingInterval ) return ; \nif ( newPingInterval > 0 ) enableExecutorService ( ) ; \npingInterval = newPingInterval ; \nif ( ! ( pingInterval < 0 ) ) { \nschedulePingServerTask ( ) ; \n} \nelse { \nstopPinging ( ) ; \n} \n} \n} \n"}
{"10704": "public class XMPPConnection { \nprivate void initConnection ( ) throws XMPPException { \nboolean isFirstInitialization = packetReader == null || packetWriter == null ; \ncompressionHandler = null ; \nserverAckdCompression = false ; \ninitReaderAndWriter ( ) ; \ntry { \nif ( ! ( isFirstInitialization ) ) { \npacketWriter . init ( ) ; \npacketReader . init ( ) ; \n} \nelse { \npacketWriter = new PacketWriter ( this ) ; \npacketReader = new PacketReader ( this ) ; \nif ( config . isDebuggerEnabled ( ) ) { \naddPacketListener ( debugger . getReaderListener ( ) , null ) ; \nif ( debugger . getWriterListener ( ) != null ) { \naddPacketSendingListener ( debugger . getWriterListener ( ) , null ) ; \n} \n} \n} \npacketWriter . startup ( ) ; \npacketReader . startup ( ) ; \nconnected = true ; \nif ( isFirstInitialization ) { \nfor ( ConnectionCreationListener listener : getConnectionCreationListeners ( ) ) { \nlistener . connectionCreated ( this ) ; \n} \n} \n} \ncatch ( XMPPException ex ) { \nif ( packetWriter != null ) { \ntry { \npacketWriter . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketWriter = null ; \n} \nif ( packetReader != null ) { \ntry { \npacketReader . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketReader = null ; \n} \nif ( reader != null ) { \ntry { \nreader . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nreader = null ; \n} \nif ( writer != null ) { \ntry { \nwriter . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nwriter = null ; \n} \nif ( socket != null ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception e ) { \n} \nsocket = null ; \n} \nthis . setWasAuthenticated ( authenticated ) ; \nauthenticated = false ; \nconnected = false ; \nthrow ex ; \n} \n} \n} \n"}
{"10718": "public class StartEvent { \npublic static Optional < StartEvent > createStartEvent ( Identification source , boolean isUsingJava ) { \ntry { \nStartEvent startEvent ; \nif ( ! ( isUsingJava ) ) { \nstartEvent = new StartEvent ( source , IS_USING_NON_JAVA_OUTPUT ) ; \n} \nelse { \nstartEvent = new StartEvent ( source ) ; \n} \nreturn Optional . of ( startEvent ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( ! ( name == null ) ) { \nname += \".\" ; \n} \nelse { \nname = \"\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ni < dirs . length ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10734": "public class ProxyClientServiceImpl { \nprotected void activate ( Map < String , Object > properties ) throws Exception { \nconfigProperties = properties ; \nString [ ] safePostProcessorNames = ( String [ ] ) configProperties . get ( SAFE_POSTPROCESSORS ) ; \nif ( ! ( safePostProcessorNames == null ) ) { \nfor ( String pp : safePostProcessorNames ) { \nsafeOpenProcessors . add ( pp ) ; \n} \n} \nelse { \nsafeOpenProcessors . add ( \"rss\" ) ; \nsafeOpenProcessors . add ( \"trustedLoginTokenProxyPostProcessor\" ) ; \n} \nString proxyHost = System . getProperty ( \"http.proxyHost\" , \"\" ) ; \nif ( ! proxyHost . equals ( \"\" ) ) { \nuseJreProxy = true ; \n} \n} \n} \n"}
{"10748": "public class UrlBuilder { \npublic UrlBuilder append ( boolean encode , String ... postFix ) { \nfor ( String part : postFix ) { \nif ( StringUtils . isNotBlank ( part ) ) { \nif ( url . charAt ( url . length ( ) - 1 ) != '/' && ! part . startsWith ( \"/\" ) ) { \nurl . append ( '/' ) ; \n} \nif ( ! ( encode ) ) { \nurl . append ( part ) ; \n} \nelse { \ntry { \nurl . append ( URLEncoder . encode ( part , \"UTF-8\" ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \nreturn this ; \n} \n} \n"}
{"10749": "public class UrlBuilder { \npublic UrlBuilder queryParam ( String name , Boolean value ) { \nif ( ! ( value != null ) ) { \nreturn null ; \n} \nelse { \nreturn queryParam ( name , value . toString ( ) ) ; \n} \n} \n} \n"}
{"10750": "public class UrlBuilder { \npublic UrlBuilder queryParam ( String name , Number value ) { \nif ( ! ( value != null ) ) { \nreturn null ; \n} \nelse { \nreturn queryParam ( name , value . toString ( ) ) ; \n} \n} \n} \n"}
{"10753": "public class PlaylistResource { \npublic static Optional < Playlist > getPlaylist ( EventModel eventModel ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Playlist :: importResource ) ; \n} \n} \n} \n"}
{"10754": "public class LaunchNakamura { \nprivate void launchButtonActionPerformed ( java . awt . event . ActionEvent evt ) { \nif ( ! ( runStatus == APP_NOT_RUNNING ) ) { \nJOptionPane . showMessageDialog ( this , \"Nakamura is already running.\" , \"Warning\" , JOptionPane . WARNING_MESSAGE ) ; \n} \nelse { \nSystem . setSecurityManager ( null ) ; \ntry { \nNakamuraMain . main ( savedArgs ) ; \nstatusLabel . setText ( \"Nakamura is starting...\" ) ; \nJOptionPane . showMessageDialog ( this , \"Nakamura has been started.\\nPlease allow 30-60 seconds for it to be ready.\" , \"Information\" , JOptionPane . INFORMATION_MESSAGE ) ; \nrunStatus = APP_RUNNING ; \nisStartupFinished ( ) ; \n} \ncatch ( IOException e ) { \nstatusLabel . setText ( \"Nakamura is startup failed \" + e . getMessage ( ) ) ; \n} \n} \n} \n} \n"}
{"10758": "public class LaunchNakamura { \nprotected ImageIcon createImageIcon ( String path , String description ) { \njava . net . URL imgURL = getClass ( ) . getResource ( path ) ; \nif ( ! ( imgURL != null ) ) { \nSystem . err . println ( \"Couldn't find file: \" + path ) ; \nreturn null ; \n} \nelse { \nreturn new ImageIcon ( imgURL , description ) ; \n} \n} \n} \n"}
{"10762": "public class JSONResult { \npublic JSONResult get ( int index ) { \nif ( ! ( value instanceof JSONArray ) ) if ( value instanceof JSONObject ) { \nreturn get ( String . valueOf ( index ) ) ; \n} \nelse { \nJSONArray array = ( JSONArray ) value ; \nObject result = array . get ( index ) ; \nreturn new JSONResult ( result ) ; \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10763": "public class JSONResult { \npublic JSONResult get ( String key ) { \nif ( ! ( value instanceof JSONObject ) ) if ( value instanceof JSONArray ) { \ntry { \nint index = Integer . parseInt ( key ) ; \nreturn get ( index ) ; \n} \ncatch ( NumberFormatException e ) { \nthrow createException ( \"Excpected JSONObject \" + key + \":\" ) ; \n} \n} \nelse { \nJSONObject obj = ( JSONObject ) value ; \nObject result = obj . get ( key ) ; \nreturn new JSONResult ( result ) ; \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10771": "public class SessionManager { \npublic void executeBatchAsync ( FutureCallback < ResultSet > callback , Statement ... statements ) throws ExceedMaxAsyncJobsException { \nif ( ! ( ! asyncSemaphore . tryAcquire ( ) ) ) { \ntry { \nResultSetFuture rsf = CqlUtils . executeBatchAsync ( getSession ( ) , statements ) ; \nif ( callback != null ) { \nFutures . addCallback ( rsf , wrapCallbackResultSet ( callback ) , asyncExecutor ) ; \n} \n} \ncatch ( Exception e ) { \nasyncSemaphore . release ( ) ; \nLOGGER . error ( e . getMessage ( ) , e ) ; \n} \n} \nelse { \nif ( ! ( callback == null ) ) { \ncallback . onFailure ( new ExceedMaxAsyncJobsException ( maxSyncJobs ) ) ; \n} \nelse { \nthrow new ExceedMaxAsyncJobsException ( maxSyncJobs ) ; \n} \n} \n} \n} \n"}
{"10773": "public class CF { \npublic Set < Class < ? > > getSubclasses ( String fqcn ) { \nif ( ! ( fqcn == null ) ) if ( StringUtils . startsWith ( fqcn , \".\" ) || StringUtils . endsWith ( fqcn , \".\" ) ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nelse { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nClass < ? > clazz = null ; \ntry { \nclazz = Class . forName ( fqcn ) ; \n} \ncatch ( ClassNotFoundException ex ) { \nthis . clear ( ) ; \nthis . errors . add ( ex ) ; \nreturn new HashSet < Class < ? > > ( ) ; \n} \nreturn getSubclasses ( clazz ) ; \n} \n} \n"}
{"10774": "public class CF { \nprivate final Set < Class < ? > > search ( Class < ? > clazz , URI location , String packageName ) throws MalformedURLException { \nif ( clazz == null || location == null ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nFile directory = new File ( location . toURL ( ) . getFile ( ) ) ; \nif ( ! ( directory . exists ( ) ) ) { \nreturn this . searchJar ( clazz , location ) . keySet ( ) ; \n} \nelse { \nreturn this . searchDirectory ( clazz , directory , location , packageName ) . keySet ( ) ; \n} \n} \n} \n"}
{"10780": "public class VolumeResource { \npublic static Optional < Volume > getVolume ( EventModel eventModel ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Integer ) . map ( ob -> ( Integer ) ob ) . findAny ( ) . flatMap ( Volume :: createVolume ) ; \n} \n} \n} \n"}
{"10783": "public class SelectorResource { \npublic static Optional < Boolean > isTarget ( EventModel eventModel , Identifiable identifiable ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( SelectorResource . RESOURCE_ID ) ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( SelectorResource . RESOURCE_ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( resource -> resource instanceof Identification ) . map ( object -> ( Identification ) object ) . anyMatch ( identifiable :: isOwner ) ) ; \n} \n} \n} \n"}
{"10784": "public class User { \npublic void setLoginEnabled ( long from , long to , boolean day , TimeZone timeZone ) { \nString enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; \nif ( ! ( enabledSetting == null ) ) { \nsetProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; \n} \nelse { \nremoveProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; \n} \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nint initialIndex = rsm . getIndex ( ) ; \nint lastIndex = objects . size ( ) ; \nif ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni ++ ; \n} \nif ( after != null && ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( rsm . getMax ( ) != null ) { \nif ( ! ( before != null ) ) { \nlastIndex = initialIndex + rsm . getMax ( ) ; \n} \nelse { \ninitialIndex = lastIndex - rsm . getMax ( ) ; \n} \n} \nboolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10792": "public class LeavingEvent { \npublic static Optional < LeavingEvent > createLeavingEvent ( Identification source , boolean strict , List < String > descriptors ) { \ntry { \nif ( ! ( strict ) ) { \ndescriptors . add ( GENERAL_DESCRIPTOR ) ; \n} \nelse { \ndescriptors . add ( STRICT_DESCRIPTOR ) ; \n} \ndescriptors . add ( ID ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nLeavingEvent stopRequest = new LeavingEvent ( source , descriptors ) ; \nreturn Optional . of ( stopRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10794": "public class UserRoster { \npublic void createEntry ( String user , String name , String [ ] groups ) throws XMPPException { \nif ( ! connection . isAuthenticated ( ) ) { \nthrow new IllegalStateException ( \"Not logged in to server.\" ) ; \n} \nif ( connection . isAnonymous ( ) ) { \nthrow new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \n} \nRoster rosterPacket = new Roster ( ) ; \nrosterPacket . setType ( IQ . Type . set ) ; \nrosterPacket . addItem ( new JID ( user ) , name , null , null , Arrays . asList ( groups ) ) ; \nPacketCollector collector = connection . createPacketCollector ( new PacketIDFilter ( rosterPacket . getID ( ) ) ) ; \nconnection . sendPacket ( rosterPacket ) ; \nIQ response = ( IQ ) collector . nextResult ( SmackConfiguration . getPacketReplyTimeout ( ) ) ; \ncollector . cancel ( ) ; \nif ( ! ( response == null ) ) if ( response . getType ( ) == IQ . Type . error ) { \nthrow new XMPPException ( response . getError ( ) ) ; \n} \nelse { \nthrow new XMPPException ( \"No response from the server.\" ) ; \n} \nPresence presencePacket = new Presence ( Presence . Type . subscribe ) ; \npresencePacket . setTo ( user ) ; \nconnection . sendPacket ( presencePacket ) ; \n} \n} \n"}
{"10796": "public class UserRoster { \npublic Presence getPresenceResource ( String userWithResource ) { \nString key = getPresenceMapKey ( userWithResource ) ; \nString resource = StringUtils . parseResource ( userWithResource ) ; \nMap < String , Presence > userPresences = presenceMap . get ( key ) ; \nif ( ! ( userPresences == null ) ) { \nPresence presence = userPresences . get ( resource ) ; \nif ( ! ( presence == null ) ) { \nreturn presence ; \n} \nelse { \npresence = new Presence ( Presence . Type . unavailable ) ; \npresence . setFrom ( userWithResource ) ; \nreturn presence ; \n} \n} \nelse { \nPresence presence = new Presence ( Presence . Type . unavailable ) ; \npresence . setFrom ( userWithResource ) ; \nreturn presence ; \n} \n} \n} \n"}
{"10802": "public class LastEncountered { \n@ SuppressWarnings ( \"unused\" ) public static Optional < Long > getTimePassed ( EventModel eventModel ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Long ) . map ( ob -> ( Long ) ob ) . findAny ( ) ; \n} \n} \n} \n"}
{"10809": "public class PacketParserUtils { \npublic static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { \nDefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; \nboolean done = false ; \nwhile ( ! done ) { \nint eventType = parser . next ( ) ; \nif ( ! ( eventType == XmlPullParser . START_TAG ) ) if ( eventType == XmlPullParser . END_TAG ) { \nif ( parser . getName ( ) . equals ( elementName ) ) { \ndone = true ; \n} \n} \nelse { \nString name = parser . getName ( ) ; \nif ( ! ( parser . isEmptyElementTag ( ) ) ) { \neventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . TEXT ) { \nString value = parser . getText ( ) ; \nextension . setValue ( name , value ) ; \n} \n} \nelse { \nextension . setValue ( name , \"\" ) ; \n} \n} \n} \nreturn extension ; \n} \n} \n"}
{"10812": "public class PlaybackStateResource { \npublic static Optional < PlaybackState > getPlaybackStateFromResource ( ResourceModel x ) { \nif ( ! x . getResourceID ( ) . equals ( ID ) ) return Optional . empty ( ) ; \nObject resource = x . getResource ( ) ; \nif ( ! ( resource instanceof String ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nString state = ( String ) resource ; \ntry { \nreturn Optional . of ( PlaybackState . valueOf ( state ) ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nint hash = ref . hashCode ( ) ; \nint index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( ! ( previous == null ) ) { \nprevious . next = entry . next ; \n} \nelse { \ndata [ index ] = entry . next ; \n} \nthis . size -- ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \n} \n} \n"}
{"10819": "public class AbstractReferenceMap { \nprotected HashEntry < K , V > getEntry ( Object key ) { \nif ( ! ( key == null ) ) { \nreturn super . getEntry ( key ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10822": "public class PresenceConstant { \n@ Override public boolean controlEvents ( EventModel eventModel ) { \nif ( ! ( level . compareTo ( PresenceIndicatorLevel . WEAK ) >= 0 ) ) if ( ! ( level . compareTo ( PresenceIndicatorLevel . WEAK ) < 0 && mostVague . get ( ) ) ) { \nreturn true ; \n} \nelse { \nreturn present ; \n} \nelse { \nreturn present ; \n} \n} \n} \n"}
{"10823": "public class PresenceConstant { \npublic void setPresence ( boolean present ) { \nif ( this . present == present ) return ; \nthis . present = present ; \nupdateVague ( ) ; \nif ( ! ( present ) ) { \nfireLeaving ( ) ; \n} \nelse { \nfirePresence ( true ) ; \n} \n} \n} \n"}
{"10827": "public class Gen_RunScripts { \nprotected final int initOutputDir ( ) { \nString parent = System . getProperty ( \"user.dir\" ) ; \nString target = parent + File . separator + this . target ; \nFile targetDir = new File ( target ) ; \nFile parentDir = targetDir . getParentFile ( ) ; \nif ( ! ( targetDir . exists ( ) ) ) { \nif ( ! parentDir . isDirectory ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but is not a directory, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! parentDir . canWrite ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but but cannot write into it, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . mkdir ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": could not create target dir <\" + target + \">, exiting\" ) ; \nreturn - 1 ; \n} \n} \nelse { \nif ( ! targetDir . isDirectory ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but is not a directory, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . canWrite ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but but cannot write into it, exiting\" ) ; \nreturn - 1 ; \n} \n} \nthis . outputDir = target ; \nreturn 0 ; \n} \n} \n"}
{"10828": "public class Gen_RunScripts { \nprotected final Properties loadProperties ( String filename ) { \nProperties ret = new Properties ( ) ; \nURL url = null ; \nFile f = new File ( filename . toString ( ) ) ; \nif ( ! ( f . exists ( ) ) ) { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \nif ( url == null ) { \nloader = Gen_RunScripts . class . getClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \n} \n} \nelse { \ntry { \nurl = f . toURI ( ) . toURL ( ) ; \n} \ncatch ( Exception ignore ) { \n} \n} \ntry { \nret . load ( url . openStream ( ) ) ; \n} \ncatch ( IOException e ) { \nSystem . err . println ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, IO exception\\n--><\" + e + \">\" ) ; \n} \ncatch ( Exception e ) { \nSystem . err . println ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, general exception\\n--><\" + e + \">\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10830": "public class ProgressResource { \npublic static Optional < Progress > getProgress ( EventModel eventModel ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Progress :: importResource ) ; \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( ! ( parts . length == 2 ) ) if ( ! ( parts . length == 1 ) ) { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \nelse { \nfieldName = parts [ 0 ] ; \n} \nelse { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \ni < l ; \ni ++ ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10845": "public class ExternalComponent { \npublic void connectionLost ( ) { \nsynchronized ( this ) { \nif ( reconnecting ) { \nreturn ; \n} \nreconnecting = true ; \n} \nreaderThread = null ; \nboolean isConnected = false ; \nif ( ! shutdown ) { \ncomponent . shutdown ( ) ; \n} \nwhile ( ! isConnected && ! shutdown ) { \ntry { \nconnect ( host , port , subdomain ) ; \nisConnected = true ; \nif ( ! ( shutdown ) ) { \nstart ( ) ; \n} \nelse { \ndisconnect ( ) ; \n} \n} \ncatch ( ComponentException e ) { \nmanager . getLog ( ) . error ( \"Error trying to reconnect with the server\" , e ) ; \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e1 ) { \n} \n} \n} \nreconnecting = false ; \n} \n} \n"}
{"10851": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > lookup ( final Object data , final int index ) { \nNode < K , V > rval = null ; \nNode < K , V > node = rootNode [ index ] ; \nwhile ( node != null ) { \nint cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; \nif ( ! ( cmp == 0 ) ) { \nnode = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; \n} \nelse { \nrval = node ; \nbreak ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10852": "public class TransactionalBidiTreeMap { \nprivate int compare ( final int o1_status , final Object o1 , final int o2_status , final Object o2 , final int index ) { \nif ( ! ( comparators [ index ] == null ) ) { \nreturn comparators [ index ] . compare ( o1 , o2 ) ; \n} \nelse { \nif ( ! ( o1 instanceof TransactionalComparable ) ) return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; \nelse return ( ( TransactionalComparable ) o1 ) . compareTo ( o1_status , o2 , o2_status ) ; \n} \n} \n} \n"}
{"10855": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > nextGreater ( final Node < K , V > node , final int index ) { \nNode < K , V > rval ; \nif ( ! ( node == null ) ) if ( ! ( node . getRight ( index ) != null ) ) { \nNode < K , V > parent = node . getParent ( index ) ; \nNode < K , V > child = node ; \nwhile ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { \nchild = parent ; \nparent = parent . getParent ( index ) ; \n} \nrval = parent ; \n} \nelse { \nrval = leastNode ( node . getRight ( index ) , index ) ; \n} \nelse { \nrval = null ; \n} \nreturn rval ; \n} \n} \n"}
{"10858": "public class TransactionalBidiTreeMap { \nprivate static < K , V > void copyColor ( final Node < K , V > from , final Node < K , V > to , final int index ) { \nif ( to != null ) { \nif ( ! ( from == null ) ) { \nto . copyColor ( from , index ) ; \n} \nelse { \nto . setBlack ( index ) ; \n} \n} \n} \n} \n"}
{"10865": "public class TransactionalBidiTreeMap { \nprivate void rotateLeft ( final Node < K , V > node , final int index ) { \nNode < K , V > rightChild = node . getRight ( index ) ; \nnode . setRight ( rightChild . getLeft ( index ) , index ) ; \nif ( rightChild . getLeft ( index ) != null ) { \nrightChild . getLeft ( index ) . setParent ( node , index ) ; \n} \nrightChild . setParent ( node . getParent ( index ) , index ) ; \nif ( ! ( node . getParent ( index ) == null ) ) if ( ! ( node . getParent ( index ) . getLeft ( index ) == node ) ) { \nnode . getParent ( index ) . setRight ( rightChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setLeft ( rightChild , index ) ; \n} \nelse { \nrootNode [ index ] = rightChild ; \n} \nrightChild . setLeft ( node , index ) ; \nnode . setParent ( rightChild , index ) ; \n} \n} \n"}
{"10866": "public class TransactionalBidiTreeMap { \nprivate void rotateRight ( final Node < K , V > node , final int index ) { \nNode < K , V > leftChild = node . getLeft ( index ) ; \nnode . setLeft ( leftChild . getRight ( index ) , index ) ; \nif ( leftChild . getRight ( index ) != null ) { \nleftChild . getRight ( index ) . setParent ( node , index ) ; \n} \nleftChild . setParent ( node . getParent ( index ) , index ) ; \nif ( ! ( node . getParent ( index ) == null ) ) if ( ! ( node . getParent ( index ) . getRight ( index ) == node ) ) { \nnode . getParent ( index ) . setLeft ( leftChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setRight ( leftChild , index ) ; \n} \nelse { \nrootNode [ index ] = leftChild ; \n} \nleftChild . setRight ( node , index ) ; \nnode . setParent ( leftChild , index ) ; \n} \n} \n"}
{"10867": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackInsert ( final Node < K , V > insertedNode , final int index ) { \nNode < K , V > currentNode = insertedNode ; \nmakeRed ( currentNode , index ) ; \nwhile ( ( currentNode != null ) && ( currentNode != rootNode [ index ] ) && ( isRed ( currentNode . getParent ( index ) , index ) ) ) { \nif ( ! ( isLeftChild ( getParent ( currentNode , index ) , index ) ) ) { \nNode < K , V > y = getLeftChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( ! ( isRed ( y , index ) ) ) { \nif ( isLeftChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateRight ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateLeft ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \nelse { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \n} \nelse { \nNode < K , V > y = getRightChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( ! ( isRed ( y , index ) ) ) { \nif ( isRightChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateLeft ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateRight ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \nelse { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \n} \n} \nmakeBlack ( rootNode [ index ] , index ) ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( ! ( replacement != null ) ) { \nif ( ! ( deletedNode . getParent ( index ) == null ) ) { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( ! ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) ) { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \nelse { \nrootNode [ index ] = null ; \n} \n} \nelse { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( ! ( deletedNode . getParent ( index ) == null ) ) if ( ! ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) ) { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \nrootNode [ index ] = replacement ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( ! ( cmp == 0 ) ) if ( ! ( cmp < 0 ) ) { \nif ( ! ( node . getRight ( VALUE ) != null ) ) { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \nelse { \nnode = node . getRight ( VALUE ) ; \n} \n} \nelse { \nif ( ! ( node . getLeft ( VALUE ) != null ) ) { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \nelse { \nnode = node . getLeft ( VALUE ) ; \n} \n} \nelse { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( ! ( node . getRight ( VALUE ) != null ) ) if ( ! ( node . getLeft ( VALUE ) != null ) ) { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \nelse { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode = node . getRight ( VALUE ) ; \n} \n} \n} \n} \n} \n"}
{"10875": "public class TransactionalBidiTreeMap { \n@ Override public void clear ( ) { \nif ( ! ( auto_commit ) ) { \nString thread_id = getCurrentThreadId ( ) ; \nArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; \nfor ( Iterator < Entry < K , V > > i = list . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nNode < K , V > node = ( Node < K , V > ) i . next ( ) ; \nif ( ! ( node . is ( Node . ADDED , thread_id ) ) ) { \nnode . setStatus ( Node . DELETED , thread_id ) ; \n} \nelse doRedBlackDelete ( node ) ; \n} \n} \nelse { \nmodify ( ) ; \nnodeCount = 0 ; \nrootNode [ KEY ] = null ; \nrootNode [ VALUE ] = null ; \n} \n} \n} \n"}
{"10879": "public class TransactionalBidiTreeMap { \npublic final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { \nK key ; \nV val ; \nint transaction_status ; \nString transaction_id ; \nnew_map . setAutoCommit ( isAutoCommit ( ) ) ; \nif ( ! ( ! isAutoCommit ( ) ) ) { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \nelse { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { \ntry { \nnew_map . put ( key , val ) ; \nnew_map . commit ( ) ; \n} \ncatch ( Exception e ) { \n} \ntry { \nif ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { \nnew_map . attach ( transaction_id ) ; \nnew_map . remove ( key ) ; \n} \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { \nnew_map . attach ( transaction_id ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \n} \n} \n"}
{"10884": "public class DefaultRosterStore { \npublic static DefaultRosterStore init ( final File baseDir ) { \nDefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; \nif ( ! ( store . setRosterVersion ( \"\" ) ) ) { \nreturn null ; \n} \nelse { \nreturn store ; \n} \n} \n} \n"}
{"10885": "public class DefaultRosterStore { \npublic static DefaultRosterStore open ( final File baseDir ) { \nDefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; \nString s = store . readFile ( store . getVersionFile ( ) ) ; \nif ( ! ( s != null && s . startsWith ( STORE_ID + \"\\n\" ) ) ) { \nreturn null ; \n} \nelse { \nreturn store ; \n} \n} \n} \n"}
{"10886": "public class IPv4Scanner { \npublic static Collection < InetAddress > scanRange ( InetAddress addr , int count , int msTimeout ) { \nCollection < InetAddress > addresses = new ArrayList < InetAddress > ( ) ; \nCollection < InetAddress > result = new ArrayList < InetAddress > ( ) ; \nif ( ! ( addr == null ) ) { \naddresses . add ( addr ) ; \n} \nelse { \ntry { \naddresses . addAll ( localhostNetworkAddresses ( ) ) ; \n} \ncatch ( Exception e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \nfor ( InetAddress a : addresses ) { \nif ( a instanceof Inet4Address ) { \nInetAddress start = subnetAddress0 ( a , 24 ) ; \nresult . addAll ( scanRangeCore ( start , count , msTimeout ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10891": "public class ExecS { \nprotected int executeApplication ( Object svc , String [ ] args , String orig ) { \nif ( ! ( svc != null && ( svc instanceof ExecS_Application ) ) ) if ( ! ( svc == null ) ) if ( ! ( ! ( svc instanceof ExecS_Application ) ) ) { \nSystem . err . println ( \"unexpected error processing for class or application name <\" + orig + \">\" ) ; \nreturn - 3 ; \n} \nelse { \nSystem . err . println ( \"given class or application name <\" + orig + \"> is not instance of \" + ExecS_Application . class . getName ( ) ) ; \nreturn - 2 ; \n} \nelse { \nSystem . err . println ( \"could not create object for class or application name <\" + orig + \">\" ) ; \nreturn - 1 ; \n} \nelse { \nif ( svc instanceof Gen_RunScripts ) { \n( ( Gen_RunScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nif ( svc instanceof Gen_ExecJarScripts ) { \n( ( Gen_ExecJarScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nreturn ( ( ExecS_Application ) svc ) . executeApplication ( ArrayUtils . remove ( args , 0 ) ) ; \n} \n} \n} \n"}
{"10908": "public class IterativeCallback { \nprivate R doIteration ( Iterator < ? extends T > it ) { \nstate . i = it ; \nstate . iterations = 0 ; \nif ( state . do_break == true ) return state . return_object ; \nwhile ( state . i . hasNext ( ) ) { \nT o = state . i . next ( ) ; \nif ( ! ( delegate != null ) ) iterateObject ( o ) ; \nelse delegate . delegate ( o ) ; \nif ( state . do_break == true ) return state . return_object ; \n} \nreturn state . amended_object ; \n} \n} \n"}
{"10909": "public class TrackInfoResource { \npublic static Optional < TrackInfo > getTrackInfo ( EventModel eventModel ) { \nif ( ! ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( RESOURCE_ID ) ) ) { \nreturn Optional . empty ( ) ; \n} \nelse { \nreturn eventModel . getListResourceContainer ( ) . provideResource ( RESOURCE_ID ) . stream ( ) . findAny ( ) . flatMap ( TrackInfo :: importFromResource ) ; \n} \n} \n} \n"}
{"10922": "public class Playlist { \npublic Playlist shuffle ( ) { \nint position = getPosition ( ) ; \nlong seed = System . nanoTime ( ) ; \nif ( ! ( position >= 0 && position < queue . size ( ) ) ) { \nList < TrackInfo > trackInfos = new ArrayList < > ( queue ) ; \nCollections . shuffle ( trackInfos , new Random ( seed ) ) ; \nreturn new Playlist ( trackInfos ) ; \n} \nelse { \nList < TrackInfo > trackInfos = queue . subList ( 0 , position ) ; \nList < TrackInfo > notPlayed = queue . subList ( position , queue . size ( ) ) ; \nList < TrackInfo > shuffledNotPlayed = new ArrayList < > ( notPlayed ) ; \nCollections . shuffle ( shuffledNotPlayed , new Random ( seed ) ) ; \ntrackInfos . addAll ( shuffledNotPlayed ) ; \nreturn new Playlist ( trackInfos ) ; \n} \n} \n} \n"}
{"10923": "public class Playlist { \npublic boolean verify ( Capabilities capabilities ) { \nfor ( PlaybackMode playbackMode : playbackModes ) { \nswitch ( playbackMode ) { \ncase REPEAT : if ( ! ( ! capabilities . canRepeatPlayback ( ) ) ) { \nbreak ; \n} \nelse { \nreturn false ; \n} \ncase REPEAT_SONG : if ( ! ( ! capabilities . canRepeatPlaybackOfSong ( ) ) ) { \nbreak ; \n} \nelse { \nreturn false ; \n} \ncase SHUFFLE : if ( ! ( ! capabilities . canShufflePlayback ( ) ) ) { \nbreak ; \n} \nelse { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \ni < len ; \ni ++ ) { \nch = input [ i ] ; \nif ( ! ( ch > '>' ) ) if ( ! ( ch == '<' ) ) if ( ! ( ch == '>' ) ) if ( ! ( ch == '&' ) ) if ( ch == '\"' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \nelse { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse { \ncontinue ; \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10926": "public class SASLMechanism { \npublic void challengeReceived ( String challenge ) throws IOException { \nbyte response [ ] ; \nif ( ! ( challenge != null ) ) { \nresponse = sc . evaluateChallenge ( new byte [ 0 ] ) ; \n} \nelse { \nresponse = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; \n} \nPacket responseStanza ; \nif ( ! ( response == null ) ) { \nresponseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; \n} \nelse { \nresponseStanza = new Response ( ) ; \n} \ngetSASLAuthentication ( ) . send ( responseStanza ) ; \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) { \ntry { \nint ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) { \nttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \n} \nQueueManager q = null ; \nif ( ! ( ttl < queues [ 0 ] . batchDelay ) ) { \nfor ( QueueManager qm : queues ) { \nif ( ttl < qm . batchDelay ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) { \nq . saveEvent ( event ) ; \n} \n} \nelse { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"10931": "public class Authorizable { \npublic void setProperty ( String name , Object value ) { \nif ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { \nObject cv = authorizableMap . get ( name ) ; \nif ( ! ( value == null ) ) if ( ! ( ! value . equals ( cv ) ) ) if ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) { \nmodifiedMap . put ( name , value ) ; \n} \nelse { \nmodifiedMap . put ( name , value ) ; \n} \nelse { \nif ( cv != null && ! ( cv instanceof RemoveProperty ) ) { \nmodifiedMap . put ( name , new RemoveProperty ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"10936": "public class PresenceNonConstant { \n@ SuppressWarnings ( \"unused\" ) public void userEncountered ( ) { \nList < String > descriptors = new ArrayList < > ( ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nboolean known = ! fireUnknownIfNotPresent || present ; \nboolean firstPresent = ( ! strict && ! present ) || ( strict && ! strictPresent ) ; \nlong lastSeen = this . lastSeen . until ( LocalDateTime . now ( ) , ChronoUnit . SECONDS ) ; \nOptional < Event > presenceEvent = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( id -> PresenceEvent . createPresenceEvent ( id , strict , known , firstPresent , descriptors , lastSeen ) ) . map ( event -> event . addEventLifeCycleListener ( EventLifeCycle . APPROVED , lifeCycle -> { \nif ( known ) { \nthis . lastSeen = LocalDateTime . now ( ) ; \nif ( strict ) this . strictPresent = true ; \npresent = true ; \n} \n} \n) ) ; \nif ( ! ( ! presenceEvent . isPresent ( ) ) ) { \nfire ( presenceEvent . get ( ) , 5 ) ; \n} \nelse { \nerror ( \"unable to create PresenceEvent\" ) ; \n} \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( ! ( event . containsDescriptor ( LeavingEvent . ID ) ) ) { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nelse { \nif ( ! ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) ) if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \n} \nelse { \npresent = false ; \nstrictPresent = false ; \n} \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( ! ( value == null ) ) { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) { \nreturn ; \n} \nif ( ! ( size == 0 ) ) { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \nfor ( int i = oldCapacity - 1 ; \ni >= 0 ; \ni -- ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \nelse { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \n} \n} \n"}
{"10948": "public class AbstractHashedMap { \nprotected int calculateNewCapacity ( int proposedCapacity ) { \nint newCapacity = 1 ; \nif ( ! ( proposedCapacity > MAXIMUM_CAPACITY ) ) { \nwhile ( newCapacity < proposedCapacity ) { \nnewCapacity <<= 1 ; \n} \nif ( newCapacity > MAXIMUM_CAPACITY ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \n} \nelse { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \nreturn newCapacity ; \n} \n} \n"}
