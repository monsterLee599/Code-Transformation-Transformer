{"257": "public class HTTPBuilder { \npublic void setHeaders ( Map < ? , ? > headers ) { \nthis . defaultRequestHeaders . clear ( ) ; \nif ( headers == null ) { \nreturn ; \n} \nfor ( Object key : headers . keySet ( ) ) { \nObject val = headers . get ( key ) ; \nif ( val == null ) { \ncontinue ; \n} \nthis . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; \n} \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nint code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { \nwebSocketImpl . closeConnection ( code , reason , true ) ; \n} \nelse { \nif ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) { \nwebSocketImpl . close ( code , reason , true ) ; \n} \nelse { \nwebSocketImpl . flushAndClose ( code , reason , false ) ; \n} \n} \n} \n} \n"}
{"491": "public class WebSocketImpl { \n@ Override public void send ( String text ) { \nif ( text == null ) { \nthrow new IllegalArgumentException ( \"Cannot send 'null' data to a WebSocketImpl.\" ) ; \n} \nsend ( draft . createFrames ( text , role == Role . CLIENT ) ) ; \n} \n} \n"}
{"493": "public class WebSocketClient { \npublic void connect ( ) { \nif ( connectReadThread != null ) { \nthrow new IllegalStateException ( \"WebSocketClient objects are not reuseable\" ) ; \n} \nconnectReadThread = new Thread ( this ) ; \nconnectReadThread . setName ( \"WebSocketConnectReadThread-\" + connectReadThread . getId ( ) ) ; \nconnectReadThread . start ( ) ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( part1 == null || part1 . length ( ) == 0 ) { \npath = \"/\" ; \n} \nelse { \npath = part1 ; \n} \nif ( part2 != null ) { \npath += '?' + part2 ; \n} \nint port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) { \nfor ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \n} \nengine . startHandshake ( handshake ) ; \n} \n} \n"}
{"506": "public class WebSocketServer { \nprivate void doAdditionalRead ( ) throws InterruptedException , IOException { \nWebSocketImpl conn ; \nwhile ( ! iqueue . isEmpty ( ) ) { \nconn = iqueue . remove ( 0 ) ; \nWrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; \nByteBuffer buf = takeBuffer ( ) ; \ntry { \nif ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) { \niqueue . add ( conn ) ; \n} \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n} \n} \n} \n"}
{"507": "public class WebSocketServer { \nprivate void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { \nif ( ! onConnect ( key ) ) { \nkey . cancel ( ) ; \nreturn ; \n} \nSocketChannel channel = server . accept ( ) ; \nif ( channel == null ) { \nreturn ; \n} \nchannel . configureBlocking ( false ) ; \nSocket socket = channel . socket ( ) ; \nsocket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; \nsocket . setKeepAlive ( true ) ; \nWebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; \nw . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; \ntry { \nw . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; \ni . remove ( ) ; \nallocateBuffers ( w ) ; \n} \ncatch ( IOException ex ) { \nif ( w . getSelectionKey ( ) != null ) { \nw . getSelectionKey ( ) . cancel ( ) ; \n} \nhandleIOException ( w . getSelectionKey ( ) , null , ex ) ; \n} \n} \n} \n"}
{"511": "public class WebSocketServer { \nprivate boolean doEnsureSingleThread ( ) { \nsynchronized ( this ) { \nif ( selectorthread != null ) { \nthrow new IllegalStateException ( getClass ( ) . getName ( ) + \" can only be started once.\" ) ; \n} \nselectorthread = Thread . currentThread ( ) ; \nif ( isclosed . get ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"575": "public class User { \nprivate User findById ( Long id ) { \nif ( id > 3 ) { \nreturn null ; \n} \nUser user = new User ( ) ; \nuser . id = id ; \nuser . name = \"User \" + String . valueOf ( id ) ; \nreturn user ; \n} \n} \n"}
{"588": "public class Paths { \npublic static String relative ( String startPath , String targetPath ) { \nif ( startPath . equals ( targetPath ) ) { \nreturn CURRENT_DIR ; \n} \nString [ ] start = toSegments ( canonical ( startPath ) ) ; \nString [ ] target = toSegments ( canonical ( targetPath ) ) ; \nif ( ! startPath . endsWith ( SEPARATOR ) ) { \nstart = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; \n} \nString targetFile = \"\" ; \nif ( ! targetPath . endsWith ( SEPARATOR ) ) { \ntargetFile = target [ target . length - 1 ] ; \ntarget = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; \n} \nString [ ] common = commonPrefix ( start , target ) ; \nString [ ] parents = toParentDirs ( start . length - common . length ) ; \nint relativeStartIdx = common . length ; \nString [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; \nString [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; \nSystem . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; \nString trailingSep = \"\" ; \nif ( relativePath . length > 0 ) { \ntrailingSep = SEPARATOR ; \n} \nreturn Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; \n} \n} \n"}
{"589": "public class Paths { \npublic static String canonical ( String url ) { \nString [ ] urlPath = toSegments ( url ) ; \nStack < String > canonical = new Stack < > ( ) ; \nfor ( String comp : urlPath ) { \nif ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) { \ncontinue ; \n} \nif ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) { \ncanonical . push ( comp ) ; \n} \nelse { \ncanonical . pop ( ) ; \n} \n} \nString prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nString trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nreturn prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; \n} \n} \n"}
{"638": "public class Formatters { \nprivate Formatters registerOptional ( ) { \nconversion . addConverter ( new GenericConverter ( ) { \npublic Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { \nif ( sourceType . getObjectType ( ) . equals ( String . class ) ) { \nObject element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; \nreturn Optional . ofNullable ( element ) ; \n} \nelse if ( targetType . getObjectType ( ) . equals ( String . class ) ) { \nif ( source == null ) { \nreturn \"\" ; \n} \nOptional < ? > opt = ( Optional ) source ; \nreturn opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( \"\" ) ; \n} \nreturn null ; \n} \npublic Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { \nSet < ConvertiblePair > result = new HashSet < > ( ) ; \nresult . add ( new ConvertiblePair ( Optional . class , String . class ) ) ; \nresult . add ( new ConvertiblePair ( String . class , Optional . class ) ) ; \nreturn result ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"658": "public class MethodProxy { \npublic Object invoke ( Object obj , Object [ ] args ) throws Throwable { \ntry { \ninit ( ) ; \nFastClassInfo fci = fastClassInfo ; \nreturn fci . f1 . invoke ( fci . i1 , obj , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow e . getTargetException ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nif ( fastClassInfo . i1 < 0 ) { \nthrow new IllegalArgumentException ( \"Protected method: \" + sig1 ) ; \n} \nthrow e ; \n} \n} \n} \n"}
{"668": "public class Enhancer { \nprotected void filterConstructors ( Class sc , List constructors ) { \nCollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , true ) ) ; \nif ( constructors . size ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"No visible constructors in \" + sc ) ; \n} \n} \n} \n"}
{"673": "public class AbstractClassGenerator { \npublic void setNamingPolicy ( NamingPolicy namingPolicy ) { \nif ( namingPolicy == null ) { \nnamingPolicy = DefaultNamingPolicy . INSTANCE ; \n} \nthis . namingPolicy = namingPolicy ; \n} \n} \n"}
{"791": "public class EmailUtil { \npublic static boolean isEmptyFlags ( Flags flags ) { \nif ( flags == null ) { \nreturn true ; \n} \nFlags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; \nif ( systemFlags != null && systemFlags . length > 0 ) { \nreturn false ; \n} \nString [ ] userFlags = flags . getUserFlags ( ) ; \nif ( userFlags != null && userFlags . length > 0 ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"1467": "public class ClassUtil { \npublic static void forceAccess ( final AccessibleObject accObject ) { \ntry { \nif ( System . getSecurityManager ( ) == null ) { \naccObject . setAccessible ( true ) ; \n} \nelse { \nAccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { \naccObject . setAccessible ( true ) ; \nreturn null ; \n} \n) ; \n} \n} \ncatch ( SecurityException sex ) { \n} \n} \n} \n"}
{"2015": "public class ColumnWriterBase { \n@ Override public void writeNull ( int repetitionLevel , int definitionLevel ) { \nif ( DEBUG ) { \nlog ( null , repetitionLevel , definitionLevel ) ; \n} \nrepetitionLevel ( repetitionLevel ) ; \ndefinitionLevel ( definitionLevel ) ; \nstatistics . incrementNumNulls ( ) ; \n++ valueCount ; \n} \n} \n"}
{"2016": "public class ColumnWriterBase { \nvoid writePage ( ) { \nif ( valueCount == 0 ) { \nthrow new ParquetEncodingException ( \"writing empty page\" ) ; \n} \nthis . rowsWrittenSoFar += pageRowCount ; \nif ( DEBUG ) { \nLOG . debug ( \"write page\" ) ; \n} \ntry { \nwritePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; \n} \ncatch ( IOException e ) { \nthrow new ParquetEncodingException ( \"could not write page for \" + path , e ) ; \n} \nrepetitionLevelColumn . reset ( ) ; \ndefinitionLevelColumn . reset ( ) ; \ndataColumn . reset ( ) ; \nvalueCount = 0 ; \nresetStatistics ( ) ; \npageRowCount = 0 ; \n} \n} \n"}
{"2024": "public class Statistics { \npublic void mergeStatistics ( Statistics stats ) { \nif ( stats . isEmpty ( ) ) { \nreturn ; \n} \nif ( type . equals ( stats . type ) ) { \nincrementNumNulls ( stats . getNumNulls ( ) ) ; \nif ( stats . hasNonNullValue ( ) ) { \nmergeStatisticsMinMax ( stats ) ; \nmarkAsNotEmpty ( ) ; \n} \n} \nelse { \nthrow StatisticsClassException . create ( this , stats ) ; \n} \n} \n} \n"}
{"2155": "public class JSON { \npublic String serialize ( Object obj ) throws ApiException { \ntry { \nif ( obj != null ) { \nreturn mapper . writeValueAsString ( obj ) ; \n} \nelse { \nreturn null ; \n} \n} \ncatch ( Exception e ) { \nthrow new ApiException ( 400 , e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"2156": "public class JSON { \npublic < T > T deserialize ( String body , TypeRef returnType ) throws ApiException { \nJavaType javaType = mapper . constructType ( returnType . getType ( ) ) ; \ntry { \nreturn mapper . readValue ( body , javaType ) ; \n} \ncatch ( IOException e ) { \nif ( returnType . getType ( ) . equals ( String . class ) ) { \nreturn ( T ) body ; \n} \nelse { \nthrow new ApiException ( 500 , e . getMessage ( ) , null , body ) ; \n} \n} \n} \n} \n"}
{"2308": "public class LoginManager { \npublic void release ( ) { \nsynchronized ( LoginManager . class ) { \nif ( refCount == 0 ) { \nthrow new IllegalStateException ( \"release called on LoginManager with refCount == 0\" ) ; \n} \nelse if ( refCount == 1 ) { \nCACHED_INSTANCES . remove ( loginType ) ; \nlogin . shutdown ( ) ; \n} \n-- refCount ; \n} \n} \n} \n"}
{"2338": "public class Pattern { \nstatic private int countOpenParens ( String s , int pos ) { \njava . util . regex . Pattern p = java . util . regex . Pattern . compile ( \"\\\\(\" ) ; \njava . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; \nint numParens = 0 ; \nwhile ( m . find ( ) ) { \nif ( isInsideCharClass ( s , m . start ( ) ) ) { \ncontinue ; \n} \nif ( isEscapedChar ( s , m . start ( ) ) ) { \ncontinue ; \n} \nif ( ! isNoncapturingParen ( s , m . start ( ) ) ) { \nnumParens ++ ; \n} \n} \nreturn numParens ; \n} \n} \n"}
{"2339": "public class Pattern { \nstatic public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { \nMap < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; \njava . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; \nwhile ( matcher . find ( ) ) { \nint pos = matcher . start ( ) ; \nif ( isEscapedChar ( namedPattern , pos ) ) { \ncontinue ; \n} \nString name = matcher . group ( INDEX_GROUP_NAME ) ; \nint groupIndex = countOpenParens ( namedPattern , pos ) ; \nList < GroupInfo > list ; \nif ( groupInfo . containsKey ( name ) ) { \nlist = groupInfo . get ( name ) ; \n} \nelse { \nlist = new ArrayList < GroupInfo > ( ) ; \n} \nlist . add ( new GroupInfo ( groupIndex , pos ) ) ; \ngroupInfo . put ( name , list ) ; \n} \nreturn groupInfo ; \n} \n} \n"}
{"2448": "public class NanoHTTPD { \npublic Response handle ( IHTTPSession session ) { \nfor ( IHandler < IHTTPSession , Response > interceptor : interceptors ) { \nResponse response = interceptor . handle ( session ) ; \nif ( response != null ) { \nreturn response ; \n} \n} \nreturn httpHandler . handle ( session ) ; \n} \n} \n"}
{"2454": "public class Response { \npublic boolean useGzipWhenAccepted ( ) { \nif ( gzipUsage == GzipUsage . DEFAULT ) { \nreturn getMimeType ( ) != null && ( getMimeType ( ) . toLowerCase ( ) . contains ( \"text/\" ) || getMimeType ( ) . toLowerCase ( ) . contains ( \"/json\" ) ) ; \n} \nelse { \nreturn gzipUsage == GzipUsage . ALWAYS ; \n} \n} \n} \n"}
{"2469": "public class KernelDeploymentModuleProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit unit = phaseContext . getDeploymentUnit ( ) ; \nfinal List < KernelDeploymentXmlDescriptor > kdXmlDescriptors = unit . getAttachment ( KernelDeploymentXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( kdXmlDescriptors == null || kdXmlDescriptors . isEmpty ( ) ) { \nreturn ; \n} \nfor ( KernelDeploymentXmlDescriptor kdxd : kdXmlDescriptors ) { \nif ( kdxd . getBeanFactoriesCount ( ) > 0 ) { \nfinal ModuleSpecification moduleSpecification = unit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModuleDependency dependency = new ModuleDependency ( moduleLoader , POJO_MODULE , false , false , false , false ) ; \nPathFilter filter = PathFilters . isChildOf ( BaseBeanFactory . class . getPackage ( ) . getName ( ) ) ; \ndependency . addImportFilter ( filter , true ) ; \ndependency . addImportFilter ( PathFilters . rejectAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( dependency ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"2472": "public class EJBReadWriteLock { \nprivate void decReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nassert current != null : \"can't decrease, readLockCount is not set\" ; \nnext = current . intValue ( ) - 1 ; \nif ( next == 0 ) { \nreadLockCount . remove ( ) ; \n} \nelse { \nreadLockCount . set ( new Integer ( next ) ) ; \n} \n} \n} \n"}
{"2473": "public class EJBReadWriteLock { \nprivate void incReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nif ( current == null ) { \nnext = 1 ; \n} \nelse { \nnext = current . intValue ( ) + 1 ; \n} \nreadLockCount . set ( new Integer ( next ) ) ; \n} \n} \n"}
{"2504": "public class WebMetaDataModifier { \nprivate String getTransportClassName ( final Deployment dep ) { \nString transportClassName = ( String ) dep . getProperty ( WSConstants . STACK_TRANSPORT_CLASS ) ; \nif ( transportClassName == null ) { \nthrow WSLogger . ROOT_LOGGER . missingDeploymentProperty ( WSConstants . STACK_TRANSPORT_CLASS ) ; \n} \nreturn transportClassName ; \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) { \nhits = new ArrayList < Method > ( 1 ) ; \n} \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nreturn m ; \n} \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) { \nhits = new ArrayList < Field > ( 1 ) ; \n} \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) { \nreturn f ; \n} \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2516": "public class ResourceAdapterDeploymentRegistryImpl { \npublic void registerResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { \nif ( deployment == null ) { \nthrow new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; \n} \nDEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Adding deployment: %s\" , deployment ) ; \ndeployments . add ( deployment ) ; \n} \n} \n"}
{"2517": "public class ResourceAdapterDeploymentRegistryImpl { \npublic void unregisterResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { \nif ( deployment == null ) { \nthrow new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; \n} \nDEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Removing deployment: %s\" , deployment ) ; \ndeployments . remove ( deployment ) ; \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) { \nreturn false ; \n} \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < sourceParams . length ; \ni ++ ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2532": "public class AbstractSecurityMetaDataAccessorEJB { \nprivate void ensureSameDomains ( final String oldSecurityDomain , final String newSecurityDomain ) { \nfinal boolean domainsDiffer = ! oldSecurityDomain . equals ( newSecurityDomain ) ; \nif ( domainsDiffer ) { \nthrow WSLogger . ROOT_LOGGER . multipleSecurityDomainsDetected ( oldSecurityDomain , newSecurityDomain ) ; \n} \n} \n} \n"}
{"2533": "public class AttributeAnalysis { \nvoid setIDLName ( String idlName ) { \nsuper . setIDLName ( idlName ) ; \nif ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a && ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) ) { \nidlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; \n} \nif ( accessorAnalysis != null ) { \naccessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; \n} \nif ( mutatorAnalysis != null ) { \nmutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; \n} \n} \n} \n"}
{"2535": "public class JndiName { \npublic static JndiName of ( final String name ) { \nif ( name == null || name . isEmpty ( ) ) { \nthrow NamingLogger . ROOT_LOGGER . invalidJndiName ( name ) ; \n} \nfinal String [ ] parts = name . split ( ENTRY_SEPARATOR ) ; \nJndiName current = null ; \nfor ( String part : parts ) { \ncurrent = new JndiName ( current , part ) ; \n} \nreturn current ; \n} \n} \n"}
{"2541": "public class NamingUtils { \npublic static String getLastComponent ( final Name name ) { \nif ( name . size ( ) > 0 ) { \nreturn name . get ( name . size ( ) - 1 ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"2544": "public class NamingUtils { \npublic static NamingException namingException ( final String message , final Throwable cause ) { \nfinal NamingException exception = new NamingException ( message ) ; \nif ( cause != null ) { \nexception . initCause ( cause ) ; \n} \nreturn exception ; \n} \n} \n"}
{"2555": "public class PrimitiveAnalysis { \npublic static PrimitiveAnalysis getPrimitiveAnalysis ( final Class cls ) { \nif ( cls == null ) { \nthrow IIOPLogger . ROOT_LOGGER . cannotAnalyzeNullClass ( ) ; \n} \nif ( cls == Void . TYPE ) { \nreturn voidAnalysis ; \n} \nif ( cls == Boolean . TYPE ) { \nreturn booleanAnalysis ; \n} \nif ( cls == Character . TYPE ) { \nreturn charAnalysis ; \n} \nif ( cls == Byte . TYPE ) { \nreturn byteAnalysis ; \n} \nif ( cls == Short . TYPE ) { \nreturn shortAnalysis ; \n} \nif ( cls == Integer . TYPE ) { \nreturn intAnalysis ; \n} \nif ( cls == Long . TYPE ) { \nreturn longAnalysis ; \n} \nif ( cls == Float . TYPE ) { \nreturn floatAnalysis ; \n} \nif ( cls == Double . TYPE ) { \nreturn doubleAnalysis ; \n} \nthrow IIOPLogger . ROOT_LOGGER . notAPrimitive ( cls . getName ( ) ) ; \n} \n} \n"}
{"2578": "public class WarJACCService { \nstatic int getPatternType ( String urlPattern ) { \nint type = EXACT ; \nif ( urlPattern . startsWith ( \"*.\" ) ) { \ntype = EXTENSION ; \n} \nelse if ( urlPattern . startsWith ( \"/\" ) && urlPattern . endsWith ( \"/*\" ) ) { \ntype = PREFIX ; \n} \nelse if ( urlPattern . equals ( \"/\" ) ) { \ntype = DEFAULT ; \n} \nreturn type ; \n} \n} \n"}
{"2619": "public class DefaultBeanInfo { \nprotected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { \nint size ; \nsynchronized ( indexes ) { \nsize = indexes . size ( ) ; \nfor ( int i = start ; \ni < depth && i < size ; \ni ++ ) { \nU result = lookup . lookup ( indexes . get ( i ) ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \n} \nif ( currentClass == null ) { \nreturn null ; \n} \nsynchronized ( indexes ) { \nClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; \nindexes . add ( cri ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \n} \nreturn lookup ( lookup , size , depth ) ; \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) { \nreturn PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \n} \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nint sequence = 0 ; \nwhile ( componentClass . isArray ( ) ) { \ncomponentClass = componentClass . getComponentType ( ) ; \n++ sequence ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nint idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) { \nreturn \"::CORBA::WStringValue\" ; \n} \nif ( cls == java . lang . Object . class ) { \nreturn \"::java::lang::_Object\" ; \n} \nif ( cls == java . lang . Class . class ) { \nreturn \"::javax::rmi::CORBA::ClassDesc\" ; \n} \nif ( cls == java . io . Serializable . class ) { \nreturn \"::java::io::Serializable\" ; \n} \nif ( cls == java . io . Externalizable . class ) { \nreturn \"::java::io::Externalizable\" ; \n} \nif ( cls == java . rmi . Remote . class ) { \nreturn \"::java::rmi::Remote\" ; \n} \nif ( cls == org . omg . CORBA . Object . class ) { \nreturn \"::CORBA::Object\" ; \n} \nif ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) { \nif ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2630": "public class Util { \npublic static void insertAnyPrimitive ( Any any , Object primitive ) { \nClass type = primitive . getClass ( ) ; \nif ( type == Boolean . class ) { \nany . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; \n} \nelse if ( type == Character . class ) { \nany . insert_wchar ( ( ( Character ) primitive ) . charValue ( ) ) ; \n} \nelse if ( type == Byte . class ) { \nany . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; \n} \nelse if ( type == Short . class ) { \nany . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; \n} \nelse if ( type == Integer . class ) { \nany . insert_long ( ( ( Integer ) primitive ) . intValue ( ) ) ; \n} \nelse if ( type == Long . class ) { \nany . insert_longlong ( ( ( Long ) primitive ) . longValue ( ) ) ; \n} \nelse if ( type == Float . class ) { \nany . insert_float ( ( ( Float ) primitive ) . floatValue ( ) ) ; \n} \nelse if ( type == Double . class ) { \nany . insert_double ( ( ( Double ) primitive ) . doubleValue ( ) ) ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; \n} \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) { \nthrow IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \n} \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) { \nres . append ( 'J' ) ; \n} \nfor ( int i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) { \nres . append ( c ) ; \n} \nelse { \nres . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n} \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) { \nreturn \"_\" + s ; \n} \nelse { \nreturn s ; \n} \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \nfor ( int i = 0 ; \ni < reservedIDLKeywords . length ; \n++ i ) { \nif ( reservedIDLKeywords [ i ] . equals ( s ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2633": "public class Util { \nprivate static String getSignature ( Class cls ) { \nif ( cls . isArray ( ) ) { \nreturn \"[\" + cls . getComponentType ( ) ; \n} \nif ( cls . isPrimitive ( ) ) { \nif ( cls == Byte . TYPE ) { \nreturn \"B\" ; \n} \nif ( cls == Character . TYPE ) { \nreturn \"C\" ; \n} \nif ( cls == Double . TYPE ) { \nreturn \"D\" ; \n} \nif ( cls == Float . TYPE ) { \nreturn \"F\" ; \n} \nif ( cls == Integer . TYPE ) { \nreturn \"I\" ; \n} \nif ( cls == Long . TYPE ) { \nreturn \"J\" ; \n} \nif ( cls == Short . TYPE ) { \nreturn \"S\" ; \n} \nif ( cls == Boolean . TYPE ) { \nreturn \"Z\" ; \n} \nthrow IIOPLogger . ROOT_LOGGER . unknownPrimitiveType ( cls . getName ( ) ) ; \n} \nreturn \"L\" + cls . getName ( ) . replace ( '.' , '/' ) + \";\" ; \n} \n} \n"}
{"2634": "public class Util { \nprivate static String getSignature ( Method method ) { \nStringBuffer b = new StringBuffer ( \"(\" ) ; \nClass [ ] parameterTypes = method . getParameterTypes ( ) ; \nfor ( int i = 0 ; \ni < parameterTypes . length ; \n++ i ) { \nb . append ( getSignature ( parameterTypes [ i ] ) ) ; \n} \nb . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"2635": "public class Util { \nstatic String primitiveTypeIDLName ( Class type ) { \nif ( type == Void . TYPE ) { \nreturn \"void\" ; \n} \nif ( type == Boolean . TYPE ) { \nreturn \"boolean\" ; \n} \nif ( type == Character . TYPE ) { \nreturn \"wchar\" ; \n} \nif ( type == Byte . TYPE ) { \nreturn \"octet\" ; \n} \nif ( type == Short . TYPE ) { \nreturn \"short\" ; \n} \nif ( type == Integer . TYPE ) { \nreturn \"long\" ; \n} \nif ( type == Long . TYPE ) { \nreturn \"long long\" ; \n} \nif ( type == Float . TYPE ) { \nreturn \"float\" ; \n} \nif ( type == Double . TYPE ) { \nreturn \"double\" ; \n} \nthrow IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; \n} \n} \n"}
{"2638": "public class ConcurrentReferenceHashMap { \npublic V put ( K key , V value ) { \nif ( value == null ) { \nthrow new NullPointerException ( ) ; \n} \nint hash = hashOf ( key ) ; \nreturn segmentFor ( hash ) . put ( key , hash , value , false ) ; \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni ++ ) { \nif ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) { \nreturn false ; \n} \n} \n} \ncatch ( Exception e ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2686": "public class AbstractDeploymentModelBuilder { \nprotected final Endpoint newHttpEndpoint ( final String endpointClass , final String endpointName , final Deployment dep ) { \nif ( endpointName == null ) { \nthrow WSLogger . ROOT_LOGGER . nullEndpointName ( ) ; \n} \nif ( endpointClass == null ) { \nthrow WSLogger . ROOT_LOGGER . nullEndpointClass ( ) ; \n} \nfinal Endpoint endpoint = this . deploymentModelFactory . newHttpEndpoint ( endpointClass ) ; \nendpoint . setShortName ( endpointName ) ; \nendpoint . setType ( endpointType ) ; \ndep . getService ( ) . addEndpoint ( endpoint ) ; \nreturn endpoint ; \n} \n} \n"}
{"2695": "public class ApplicableMethodInformation { \npublic boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { \nassert methodIntf != null : \"methodIntf is null\" ; \nassert method != null : \"method is null\" ; \nMethod classMethod = resolveRealMethod ( method ) ; \nString [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; \nfinal String methodName = classMethod . getName ( ) ; \nfinal String className = classMethod . getDeclaringClass ( ) . getName ( ) ; \nArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; \nT attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) { \nreturn true ; \n} \nattr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; \nif ( attr != null ) { \nreturn true ; \n} \nattr = get ( perViewStyle1 , methodIntf ) ; \nif ( attr != null ) { \nreturn false ; \n} \nattr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) { \nreturn true ; \n} \nattr = get ( style2 , methodName ) ; \nif ( attr != null ) { \nreturn true ; \n} \nattr = get ( style1 , className ) ; \nif ( attr != null ) { \nreturn false ; \n} \nif ( defaultMethodIntf == null ) { \nreturn false ; \n} \nelse { \nreturn isMethodLevel ( defaultMethodIntf , method , null ) ; \n} \n} \n} \n"}
{"2698": "public class AbstractConfigVisitorNode { \nstatic Type getComponentType ( ParameterizedType type , int index ) { \nType [ ] tp = type . getActualTypeArguments ( ) ; \nif ( index + 1 > tp . length ) { \nreturn null ; \n} \nreturn tp [ index ] ; \n} \n} \n"}
{"2701": "public class ElytronIntegrationResourceDefinitions { \npublic static ResourceDefinition getElytronTrustManagersResourceDefinition ( ) { \nfinal AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { \nLEGACY_JSSE_CONFIG } \n; \nfinal AbstractAddStepHandler addHandler = new BasicAddHandler < TrustManager > ( attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) { \n@ Override protected BasicService . ValueSupplier < TrustManager > getValueSupplier ( ServiceBuilder < TrustManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { \nfinal String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; \nfinal InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; \nif ( legacyJSSEConfig != null ) { \nserviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; \n} \nreturn ( ) -> { \nfinal SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; \nfinal JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; \nif ( jsseDomain == null ) { \nthrow SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; \n} \nfinal TrustManager [ ] trustManagers = jsseDomain . getTrustManagers ( ) ; \nif ( trustManagers == null ) { \nthrow SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"TrustManager\" , legacyJSSEConfig ) ; \n} \nfor ( TrustManager trustManager : trustManagers ) { \nif ( trustManager instanceof X509ExtendedTrustManager ) { \nreturn trustManager ; \n} \n} \nthrow SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( \"TrustManager\" , X509ExtendedTrustManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; \n} \n; \n} \n} \n; \nreturn new BasicResourceDefinition ( Constants . ELYTRON_TRUST_MANAGER , addHandler , attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) ; \n} \n} \n"}
{"2711": "public class BeanUtils { \npublic static Object instantiateBean ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , DeploymentReflectionIndex index , Module module ) throws Throwable { \nJoinpoint instantiateJoinpoint = null ; \nValueConfig [ ] parameters = new ValueConfig [ 0 ] ; \nString [ ] types = Configurator . NO_PARAMS_TYPES ; \nConstructorConfig ctorConfig = beanConfig . getConstructor ( ) ; \nif ( ctorConfig != null ) { \nparameters = ctorConfig . getParameters ( ) ; \ntypes = Configurator . getTypes ( parameters ) ; \nString factoryClass = ctorConfig . getFactoryClass ( ) ; \nFactoryConfig factory = ctorConfig . getFactory ( ) ; \nif ( factoryClass != null || factory != null ) { \nString factoryMethod = ctorConfig . getFactoryMethod ( ) ; \nif ( factoryMethod == null ) { \nthrow PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; \n} \nif ( factoryClass != null ) { \nClass < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; \nMethod method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; \nMethodJoinpoint mj = new MethodJoinpoint ( method ) ; \nmj . setTarget ( new ImmediateValue < Object > ( null ) ) ; \nmj . setParameters ( parameters ) ; \ninstantiateJoinpoint = mj ; \n} \nelse if ( factory != null ) { \nReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; \nrj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; \nrj . setParameters ( parameters ) ; \ninstantiateJoinpoint = rj ; \n} \n} \n} \nif ( instantiateJoinpoint == null ) { \nif ( beanInfo == null ) { \nthrow new StartException ( PojoLogger . ROOT_LOGGER . missingBeanInfo ( beanConfig ) ) ; \n} \nConstructor ctor = ( types . length == 0 ) ? beanInfo . getConstructor ( ) : beanInfo . findConstructor ( types ) ; \nConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint ( ctor ) ; \nconstructorJoinpoint . setParameters ( parameters ) ; \ninstantiateJoinpoint = constructorJoinpoint ; \n} \nreturn instantiateJoinpoint . dispatch ( ) ; \n} \n} \n"}
{"2713": "public class BeanUtils { \npublic static void dispatchLifecycleJoinpoint ( BeanInfo beanInfo , Object bean , LifecycleConfig config , String defaultMethod ) throws Throwable { \nif ( config != null && config . isIgnored ( ) ) { \nreturn ; \n} \nJoinpoint joinpoint = createJoinpoint ( beanInfo , bean , config , defaultMethod ) ; \nif ( joinpoint != null ) { \njoinpoint . dispatch ( ) ; \n} \n} \n} \n"}
{"2715": "public class BeanMetaDataConfig { \npublic static ServiceName toBeanName ( String name , BeanState state ) { \nif ( state == null ) { \nstate = BeanState . INSTALLED ; \n} \nreturn JBOSS_POJO . append ( name ) . append ( state . name ( ) ) ; \n} \n} \n"}
{"2716": "public class BeanMetaDataConfig { \npublic static ServiceName toInstancesName ( Class < ? > clazz , BeanState state ) { \nString clName ; \nClassLoader classLoader = clazz . getClassLoader ( ) ; \nif ( classLoader != null ) { \nclName = classLoader . toString ( ) ; \n} \nelse { \nclName = \"SystemClassLoader\" ; \n} \nif ( state == null ) { \nstate = BeanState . INSTALLED ; \n} \nreturn JBOSS_POJO . append ( clName , clazz . getName ( ) , state . name ( ) ) ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) { \nreturn ; \n} \nVirtualFile serviceXmlFile = null ; \nif ( deploymentRoot . isDirectory ( ) ) { \nserviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \n} \nelse if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { \nserviceXmlFile = deploymentRoot ; \n} \nif ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) { \nreturn ; \n} \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( xmlDescriptor != null ) { \nphaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \n} \nelse { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \n} \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \n} \n} \n"}
{"2737": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { \nMap < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; \nif ( providerMap != null ) { \nsynchronized ( providerMap ) { \nif ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { \nROOT_LOGGER . tracef ( \"deployment %s is using %s\" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; \nreturn providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; \n} \n} \n} \nString configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; \nString persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; \nif ( persistenceProviderClassName == null ) { \npersistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; \n} \nif ( configuredPersistenceProviderModule != null ) { \nList < PersistenceProvider > providers ; \nif ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) { \ntry { \nfinal ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; \nPersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; \nproviders = new ArrayList < > ( ) ; \nproviders . add ( provider ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nreturn provider ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \n} \nelse { \ntry { \nproviders = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nPersistenceProvider provider = getProviderByName ( pu , providers ) ; \nif ( provider != null ) { \nreturn provider ; \n} \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; \n} \n} \n} \nString providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; \nPersistenceProvider provider = getProviderByName ( pu ) ; \nif ( provider == null && providerNameDerivedFromClassName != null ) { \ntry { \nList < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nprovider = getProviderByName ( pu , providers ) ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; \n} \n} \nif ( provider == null ) { \nthrow JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; \n} \nreturn provider ; \n} \n} \n"}
{"2743": "public class WorkCacheManager { \nprivate ContainerAnalysis lookupDone ( Class cls ) { \nSoftReference ref = ( SoftReference ) workDone . get ( cls ) ; \nif ( ref == null ) { \nreturn null ; \n} \nContainerAnalysis ret = ( ContainerAnalysis ) ref . get ( ) ; \nif ( ret == null ) { \nworkDone . remove ( cls ) ; \n} \nreturn ret ; \n} \n} \n"}
{"2746": "public class ContainerAnalysis { \nprotected String toHexString ( int i ) { \nString s = Integer . toHexString ( i ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( s . length ( ) < 8 ) { \nreturn \"00000000\" . substring ( 0 , 8 - s . length ( ) ) + s ; \n} \nelse { \nreturn s ; \n} \n} \n} \n"}
{"2747": "public class ContainerAnalysis { \nprotected String toHexString ( long l ) { \nString s = Long . toHexString ( l ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( s . length ( ) < 16 ) { \nreturn \"0000000000000000\" . substring ( 0 , 16 - s . length ( ) ) + s ; \n} \nelse { \nreturn s ; \n} \n} \n} \n"}
{"2748": "public class ContainerAnalysis { \nprotected boolean isAccessor ( Method m ) { \nClass returnType = m . getReturnType ( ) ; \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"get\" ) && name . length ( ) > \"get\" . length ( ) ) ) { \nif ( ! ( name . startsWith ( \"is\" ) && name . length ( ) > \"is\" . length ( ) ) || ! ( returnType == Boolean . TYPE ) ) { \nreturn false ; \n} \n} \nif ( returnType == Void . TYPE ) { \nreturn false ; \n} \nif ( m . getParameterTypes ( ) . length != 0 ) { \nreturn false ; \n} \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2749": "public class ContainerAnalysis { \nprotected boolean isMutator ( Method m ) { \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"set\" ) && name . length ( ) > \"set\" . length ( ) ) ) { \nreturn false ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \nreturn false ; \n} \nif ( m . getParameterTypes ( ) . length != 1 ) { \nreturn false ; \n} \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \nfor ( int i = 0 ; \ni < ex . length ; \n++ i ) { \nif ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2751": "public class ContainerAnalysis { \nprotected String attributeReadName ( String name ) { \nif ( name . startsWith ( \"get\" ) ) { \nname = name . substring ( 3 ) ; \n} \nelse if ( name . startsWith ( \"is\" ) ) { \nname = name . substring ( 2 ) ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; \n} \nreturn name ; \n} \n} \n"}
{"2752": "public class ContainerAnalysis { \nprotected String attributeWriteName ( String name ) { \nif ( name . startsWith ( \"set\" ) ) { \nname = name . substring ( 3 ) ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; \n} \nreturn name ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) { \ncontinue ; \n} \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) { \nif ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) { \noa = operations [ opIdx ] ; \n} \n} \nif ( oa == null ) { \ncontinue ; \n} \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) { \nb . append ( \"__\" ) ; \n} \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) { \ns = s . substring ( 2 ) ; \n} \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \nj < i ; \n++ j ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nif ( ! clash [ i ] ) { \ncontinue ; \n} \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nj < name . length ( ) ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) { \ncontinue ; \n} \nif ( noUpper ) { \nnoUpper = false ; \n} \nelse { \nb . append ( '_' ) ; \n} \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( c < 256 ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2761": "public class EjbDependencyDeploymentUnitProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nDeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; \nif ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) { \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; \n} \nif ( ! isEjbDeployment ( deploymentUnit ) && ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) { \nreturn ; \n} \nif ( Boolean . getBoolean ( \"org.jboss.as.ejb3.EMBEDDED\" ) ) { \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; \n} \n} \n} \n"}
{"2773": "public class CNCtx { \nprivate void callUnbind ( NameComponent [ ] path ) throws NamingException { \nif ( _nc == null ) { \nthrow IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; \n} \ntry { \n_nc . unbind ( path ) ; \n} \ncatch ( NotFound e ) { \nif ( leafNotFound ( e , path [ path . length - 1 ] ) ) { \n} \nelse { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \n} \n"}
{"2774": "public class CNCtx { \npublic NamingEnumeration listBindings ( Name name ) throws NamingException { \nif ( _nc == null ) { \nthrow IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \n} \nif ( name . size ( ) > 0 ) { \ntry { \njava . lang . Object obj = lookup ( name ) ; \nif ( obj instanceof CNCtx ) { \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; \n} \nelse { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \n} \ncatch ( NamingException ne ) { \nthrow ne ; \n} \ncatch ( BAD_PARAM e ) { \nNamingException ne = new NotContextException ( name . toString ( ) ) ; \nne . setRootCause ( e ) ; \nthrow ne ; \n} \n} \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; \n} \n} \n"}
{"2775": "public class CNCtx { \nprivate void callDestroy ( NamingContext nc ) throws NamingException { \nif ( _nc == null ) { \nthrow IIOPLogger . ROOT_LOGGER . notANamingContext ( nc . toString ( ) ) ; \n} \ntry { \nnc . destroy ( ) ; \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , null ) ; \n} \n} \n} \n"}
{"2776": "public class CNCtx { \npublic void destroySubcontext ( Name name ) throws NamingException { \nif ( _nc == null ) { \nthrow IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \n} \nNamingContext the_nc = _nc ; \nNameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; \nif ( name . size ( ) > 0 ) { \ntry { \njavax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; \nCNCtx cnc = ( CNCtx ) ctx ; \nthe_nc = cnc . _nc ; \ncnc . close ( ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( CannotProceedException e ) { \njavax . naming . Context cctx = getContinuationContext ( e ) ; \ncctx . destroySubcontext ( e . getRemainingName ( ) ) ; \nreturn ; \n} \ncatch ( NameNotFoundException e ) { \nif ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) { \nreturn ; \n} \nthrow e ; \n} \ncatch ( NamingException e ) { \nthrow e ; \n} \n} \ncallDestroy ( the_nc ) ; \ncallUnbind ( path ) ; \n} \n} \n"}
{"2777": "public class CNCtx { \nprivate javax . naming . Context callBindNewContext ( NameComponent [ ] path ) throws NamingException { \nif ( _nc == null ) { \nthrow IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; \n} \ntry { \nNamingContext nctx = _nc . bind_new_context ( path ) ; \nreturn new CNCtx ( _orb , nctx , _env , makeFullName ( path ) ) ; \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nwhile ( reader . hasNext ( ) ) { \nswitch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) { \nreturn new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \n} \nelse { \nif ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { \nthrow new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \n} \n} \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null && password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) { \npassword = resolvedPassword ; \n} \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2785": "public class JNDIBasedSecurityManagement { \nprivate Object lookUpJNDI ( String contextName ) { \nObject result = null ; \ntry { \nContext ctx = new InitialContext ( ) ; \nif ( contextName . startsWith ( SecurityConstants . JAAS_CONTEXT_ROOT ) ) { \nresult = ctx . lookup ( contextName ) ; \n} \nelse { \nresult = ctx . lookup ( SecurityConstants . JAAS_CONTEXT_ROOT + contextName ) ; \n} \n} \ncatch ( Exception e ) { \nSecurityLogger . ROOT_LOGGER . tracef ( \"Look up of JNDI for %s failed with %s\" , contextName , e . getLocalizedMessage ( ) ) ; \nreturn null ; \n} \nreturn result ; \n} \n} \n"}
{"2789": "public class IDLTypeImpl { \nstatic LocalIDLType getIDLType ( TypeCode typeCode , RepositoryImpl repository ) { \nTCKind tcKind = typeCode . kind ( ) ; \nif ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) { \nreturn new PrimitiveDefImpl ( typeCode , repository ) ; \n} \nif ( tcKind == TCKind . tk_sequence ) { \nreturn repository . getSequenceImpl ( typeCode ) ; \n} \nif ( tcKind == TCKind . tk_value || tcKind == TCKind . tk_value_box || tcKind == TCKind . tk_alias || tcKind == TCKind . tk_struct || tcKind == TCKind . tk_union || tcKind == TCKind . tk_enum || tcKind == TCKind . tk_objref ) { \ntry { \nreturn ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; \n} \ncatch ( BadKind ex ) { \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \n"}
{"2790": "public class SecurityDomainResourceDefinition { \nprivate static void waitForService ( final ServiceController < ? > controller ) throws OperationFailedException { \nif ( controller . getState ( ) == ServiceController . State . UP ) { \nreturn ; \n} \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( controller ) ; \ntry { \nmonitor . awaitStability ( 100 , MILLISECONDS ) ; \n} \ncatch ( final InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow SecurityLogger . ROOT_LOGGER . interruptedWaitingForSecurityDomain ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \nfinally { \nmonitor . removeController ( controller ) ; \n} \nif ( controller . getState ( ) != ServiceController . State . UP ) { \nthrow SecurityLogger . ROOT_LOGGER . requiredSecurityDomainServiceNotAvailable ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \n} \n} \n"}
{"2797": "public class ConnectorServices { \npublic static < T > T notNull ( T value ) { \nif ( value == null ) { \nthrow ConnectorLogger . ROOT_LOGGER . serviceNotStarted ( ) ; \n} \nreturn value ; \n} \n} \n"}
{"2798": "public class ConnectorServices { \npublic static synchronized ServiceName getDeploymentServiceName ( final String raName , final Activation raxml ) { \nif ( raName == null ) { \nthrow ConnectorLogger . ROOT_LOGGER . undefinedVar ( \"RaName\" ) ; \n} \nServiceName serviceName = null ; \nModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; \nif ( ra != null && ra . getId ( ) != null ) { \nserviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; \n} \nelse { \nserviceName = getDeploymentServiceName ( raName , ( String ) null ) ; \n} \nROOT_LOGGER . tracef ( \"ConnectorServices: getDeploymentServiceName(%s,%s) -> %s\" , raName , raxml , serviceName ) ; \nreturn serviceName ; \n} \n} \n"}
{"2799": "public class ConstantAnalysis { \npublic void insertValue ( Any any ) { \nif ( type == String . class ) { \nany . insert_wstring ( ( String ) value ) ; \n} \nelse { \nUtil . insertAnyPrimitive ( any , value ) ; \n} \n} \n} \n"}
{"2806": "public class ComponentDescription { \npublic ServiceName getContextServiceName ( ) { \nif ( contextServiceName != null ) { \nreturn contextServiceName ; \n} \nif ( getNamingMode ( ) == ComponentNamingMode . CREATE ) { \nreturn ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; \n} \nelse if ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) { \nreturn ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; \n} \nelse { \nthrow new IllegalStateException ( ) ; \n} \n} \n} \n"}
{"2826": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembers ( ) { \nif ( valueMembers != null ) { \nreturn valueMembers ; \n} \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nvalueMembers = new ValueMember [ c . length ] ; \nfor ( int i = 0 ; \ni < c . length ; \n++ i ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvalueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; \n} \nreturn valueMembers ; \n} \n} \n"}
{"2845": "public class JSFModuleIdFactory { \nString computeSlot ( String jsfVersion ) { \nif ( jsfVersion == null ) { \nreturn defaultSlot ; \n} \nif ( JsfVersionMarker . JSF_2_0 . equals ( jsfVersion ) ) { \nreturn defaultSlot ; \n} \nreturn jsfVersion ; \n} \n} \n"}
{"2846": "public class InterfaceRepository { \nprivate TypeCode getConstantTypeCode ( Class cls ) throws IRConstructionException { \nif ( cls == null ) { \nthrow IIOPLogger . ROOT_LOGGER . invalidNullClass ( ) ; \n} \nTypeCode ret = constantTypeCodeMap . get ( cls ) ; \nif ( ret == null ) { \nthrow IIOPLogger . ROOT_LOGGER . badClassForConstant ( cls . getName ( ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"2847": "public class InterfaceRepository { \nprivate void addTypeCode ( Class cls , TypeCode typeCode ) throws IRConstructionException { \nif ( cls == null ) { \nthrow IIOPLogger . ROOT_LOGGER . invalidNullClass ( ) ; \n} \nTypeCode tc = ( TypeCode ) typeCodeMap . get ( cls ) ; \nif ( tc != null ) { \nthrow IIOPLogger . ROOT_LOGGER . duplicateTypeCodeForClass ( cls . getName ( ) ) ; \n} \ntypeCodeMap . put ( cls , typeCode ) ; \n} \n} \n"}
{"2848": "public class InterfaceRepository { \nprivate ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { \nif ( \"\" . equals ( remainder ) ) { \nreturn ( ModuleDefImpl ) c ; \n} \nint idx = remainder . indexOf ( '.' ) ; \nString base ; \nif ( idx == - 1 ) { \nbase = remainder ; \n} \nelse { \nbase = remainder . substring ( 0 , idx ) ; \n} \nbase = Util . javaToIDLName ( base ) ; \nif ( previous . equals ( \"\" ) ) { \nprevious = base ; \n} \nelse { \nprevious = previous + \"/\" + base ; \n} \nif ( idx == - 1 ) { \nremainder = \"\" ; \n} \nelse { \nremainder = remainder . substring ( idx + 1 ) ; \n} \nLocalContainer next = null ; \nLocalContained contained = ( LocalContained ) c . _lookup ( base ) ; \nif ( contained instanceof LocalContainer ) { \nnext = ( LocalContainer ) contained ; \n} \nelse if ( contained != null ) { \nthrow IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \n} \nif ( next == null ) { \nString id = \"IDL:\" + previous + \":1.0\" ; \nModuleDefImpl m = new ModuleDefImpl ( id , base , \"1.0\" , c , impl ) ; \nc . add ( base , m ) ; \nif ( idx == - 1 ) { \nreturn m ; \n} \nnext = ( LocalContainer ) c . _lookup ( base ) ; \n} \nelse if ( next . def_kind ( ) != DefinitionKind . dk_Module ) { \nthrow IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \n} \nreturn ensurePackageExists ( next , previous , remainder ) ; \n} \n} \n"}
{"2851": "public class InterfaceRepository { \nprivate void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { \nif ( cls . isPrimitive ( ) ) { \nreturn ; \n} \nif ( cls . isArray ( ) ) { \naddArray ( cls ) ; \n} \nelse if ( cls . isInterface ( ) ) { \nif ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \naddInterface ( ia ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \nelse if ( Exception . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \naddException ( ea ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \n} \n"}
{"2852": "public class InterfaceRepository { \nprivate InterfaceDefImpl addInterface ( InterfaceAnalysis ia ) throws RMIIIOPViolationException , IRConstructionException { \nInterfaceDefImpl iDef ; \nClass cls = ia . getCls ( ) ; \niDef = ( InterfaceDefImpl ) interfaceMap . get ( cls ) ; \nif ( iDef != null ) { \nreturn iDef ; \n} \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] base_interfaces = addInterfaces ( ia ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \niDef = new InterfaceDefImpl ( ia . getRepositoryId ( ) , base , \"1.0\" , m , base_interfaces , impl ) ; \naddTypeCode ( cls , iDef . type ( ) ) ; \nm . add ( base , iDef ) ; \ninterfaceMap . put ( cls , iDef ) ; \naddConstants ( iDef , ia ) ; \naddAttributes ( iDef , ia ) ; \naddOperations ( iDef , ia ) ; \nreturn iDef ; \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) { \nreturn vDef ; \n} \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) { \nsuperValue = addValue ( superAnalysis ) ; \n} \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( superValue == null ) { \nbaseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \n} \nelse { \nbaseTypeCode = superValue . type ( ) ; \n} \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \nfor ( int i = 0 ; \ni < vmas . length ; \n++ i ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2854": "public class InterfaceRepository { \nprivate ExceptionDefImpl addException ( ExceptionAnalysis ea ) throws RMIIIOPViolationException , IRConstructionException { \nExceptionDefImpl eDef ; \nClass cls = ea . getCls ( ) ; \neDef = ( ExceptionDefImpl ) exceptionMap . get ( cls ) ; \nif ( eDef != null ) { \nreturn eDef ; \n} \nValueDefImpl vDef = addValue ( ea ) ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nif ( base . endsWith ( \"Exception\" ) ) { \nbase = base . substring ( 0 , base . length ( ) - 9 ) ; \n} \nbase = Util . javaToIDLName ( base + \"Ex\" ) ; \nStructMember [ ] members = new StructMember [ 1 ] ; \nmembers [ 0 ] = new StructMember ( \"value\" , vDef . type ( ) , null ) ; \nTypeCode typeCode = orb . create_exception_tc ( ea . getExceptionRepositoryId ( ) , base , members ) ; \neDef = new ExceptionDefImpl ( ea . getExceptionRepositoryId ( ) , base , \"1.0\" , typeCode , vDef , m , impl ) ; \nm . add ( base , eDef ) ; \nexceptionMap . put ( cls , eDef ) ; \nreturn eDef ; \n} \n} \n"}
{"2861": "public class WebComponentProcessor { \nprivate Set < String > getAllComponentClasses ( DeploymentUnit deploymentUnit , CompositeIndex index , WarMetaData metaData , TldsMetaData tldsMetaData ) { \nfinal Set < String > classes = new HashSet < String > ( ) ; \ngetAllComponentClasses ( metaData . getMergedJBossWebMetaData ( ) , classes ) ; \nif ( tldsMetaData == null ) { \nreturn classes ; \n} \nif ( tldsMetaData . getSharedTlds ( deploymentUnit ) != null ) { \nfor ( TldMetaData tldMetaData : tldsMetaData . getSharedTlds ( deploymentUnit ) ) { \ngetAllComponentClasses ( tldMetaData , classes ) ; \n} \n} \nif ( tldsMetaData . getTlds ( ) != null ) { \nfor ( Map . Entry < String , TldMetaData > tldMetaData : tldsMetaData . getTlds ( ) . entrySet ( ) ) { \ngetAllComponentClasses ( tldMetaData . getValue ( ) , classes ) ; \n} \n} \ngetAllAsyncListenerClasses ( index , classes ) ; \nreturn classes ; \n} \n} \n"}
{"2866": "public class Configurator { \n@ SuppressWarnings ( \"unchecked\" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { \nif ( clazz == null ) { \nreturn value ; \n} \nif ( value == null ) { \nreturn null ; \n} \nClass < ? > valueClass = value . getClass ( ) ; \nif ( valueClass == String . class ) { \nString string = ( String ) value ; \nif ( trim ) { \nstring = string . trim ( ) ; \n} \nif ( replaceProperties ) { \nvalue = PropertiesValueResolver . replaceProperties ( string ) ; \n} \n} \nif ( clazz . isAssignableFrom ( valueClass ) ) { \nreturn value ; \n} \nif ( clazz . isEnum ( ) ) { \nClass < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; \nreturn Enum . valueOf ( eclazz , value . toString ( ) ) ; \n} \nif ( valueClass == String . class ) { \nPropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; \nif ( editor != null ) { \neditor . setAsText ( ( String ) value ) ; \nreturn editor . getValue ( ) ; \n} \n} \ntry { \nMethod method = clazz . getMethod ( \"valueOf\" , valueClass ) ; \nint modifiers = method . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) { \nreturn method . invoke ( null , value ) ; \n} \n} \ncatch ( Exception ignored ) { \n} \nif ( valueClass == String . class ) { \ntry { \nConstructor constructor = clazz . getConstructor ( valueClass ) ; \nif ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) { \nreturn constructor . newInstance ( value ) ; \n} \n} \ncatch ( Exception ignored ) { \n} \n} \nreturn value ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null || values . length == 0 ) { \nreturn NO_PARAMS_TYPES ; \n} \nString [ ] types = new String [ values . length ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni ++ ) { \ntypes [ i ] = values [ i ] . getType ( ) ; \n} \nreturn types ; \n} \n} \n"}
{"2889": "public class StrictMaxPool { \npublic T get ( ) { \ntry { \nboolean acquired = semaphore . tryAcquire ( timeout , timeUnit ) ; \nif ( ! acquired ) { \nthrow EjbLogger . ROOT_LOGGER . failedToAcquirePermit ( timeout , timeUnit ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthrow EjbLogger . ROOT_LOGGER . acquireSemaphoreInterrupted ( ) ; \n} \nT bean = pool . poll ( ) ; \nif ( bean != null ) { \nreturn bean ; \n} \ntry { \nbean = create ( ) ; \n} \nfinally { \nif ( bean == null ) { \nsemaphore . release ( ) ; \n} \n} \nreturn bean ; \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \nfor ( int i = 0 ; \ni < operations . length ; \n++ i ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \nfor ( int i = 0 ; \ni < attributes . length ; \n++ i ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n} \n} \n} \n} \n"}
{"2900": "public class SecurityActions { \nstatic Method [ ] getDeclaredMethods ( final Class < ? > c ) { \nif ( System . getSecurityManager ( ) == null ) { \nreturn c . getDeclaredMethods ( ) ; \n} \nreturn AccessController . doPrivileged ( new PrivilegedAction < Method [ ] > ( ) { \npublic Method [ ] run ( ) { \nreturn c . getDeclaredMethods ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"2901": "public class SecurityActions { \nstatic Field [ ] getDeclaredFields ( final Class < ? > c ) { \nif ( System . getSecurityManager ( ) == null ) { \nreturn c . getDeclaredFields ( ) ; \n} \nreturn AccessController . doPrivileged ( new PrivilegedAction < Field [ ] > ( ) { \npublic Field [ ] run ( ) { \nreturn c . getDeclaredFields ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"2902": "public class SecurityActions { \nstatic Constructor < ? > getConstructor ( final Class < ? > c , final Class < ? > ... params ) throws NoSuchMethodException { \nif ( System . getSecurityManager ( ) == null ) { \nreturn c . getConstructor ( params ) ; \n} \nConstructor < ? > result = AccessController . doPrivileged ( new PrivilegedAction < Constructor < ? > > ( ) { \npublic Constructor < ? > run ( ) { \ntry { \nreturn c . getConstructor ( params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nreturn null ; \n} \n} \n} \n) ; \nif ( result != null ) { \nreturn result ; \n} \nthrow new NoSuchMethodException ( ) ; \n} \n} \n"}
{"2903": "public class SecurityActions { \nstatic Method getMethod ( final Class < ? > c , final String name , final Class < ? > ... params ) throws NoSuchMethodException { \nif ( System . getSecurityManager ( ) == null ) { \nreturn c . getMethod ( name , params ) ; \n} \nMethod result = AccessController . doPrivileged ( new PrivilegedAction < Method > ( ) { \npublic Method run ( ) { \ntry { \nreturn c . getMethod ( name , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nreturn null ; \n} \n} \n} \n) ; \nif ( result != null ) { \nreturn result ; \n} \nthrow new NoSuchMethodException ( ) ; \n} \n} \n"}
{"2909": "public class OPropertyEmbedded { \nprotected void setTypeInternal ( final OType iType ) { \ngetDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_UPDATE ) ; \nacquireSchemaWriteLock ( ) ; \ntry { \nif ( iType == globalRef . getType ( ) ) { \nreturn ; \n} \nif ( ! iType . getCastable ( ) . contains ( globalRef . getType ( ) ) ) { \nthrow new IllegalArgumentException ( \"Cannot change property type from \" + globalRef . getType ( ) + \" to \" + iType ) ; \n} \nthis . globalRef = owner . owner . findOrCreateGlobalProperty ( this . globalRef . getName ( ) , iType ) ; \n} \nfinally { \nreleaseSchemaWriteLock ( ) ; \n} \n} \n} \n"}
{"2912": "public class OReflectionHelper { \nprivate static List < Class < ? > > findClasses ( final File iDirectory , String iPackageName , ClassLoader iClassLoader ) throws ClassNotFoundException { \nfinal List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; \nif ( ! iDirectory . exists ( ) ) { \nreturn classes ; \n} \niPackageName += \".\" + iDirectory . getName ( ) ; \nString className ; \nfinal File [ ] files = iDirectory . listFiles ( ) ; \nif ( files != null ) { \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \nif ( file . getName ( ) . contains ( \".\" ) ) { \ncontinue ; \n} \nclasses . addAll ( findClasses ( file , iPackageName , iClassLoader ) ) ; \n} \nelse if ( file . getName ( ) . endsWith ( CLASS_EXTENSION ) ) { \nclassName = file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - CLASS_EXTENSION . length ( ) ) ; \nclasses . add ( Class . forName ( iPackageName + '.' + className , true , iClassLoader ) ) ; \n} \n} \n} \nreturn classes ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( genericType != null && genericType instanceof ParameterizedType ) { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 0 ) { \nif ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) { \nif ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) { \nreturn ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \n} \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) { \nreturn ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \n} \n} \n} \nelse if ( p . getType ( ) . isArray ( ) ) { \nreturn p . getType ( ) . getComponentType ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2915": "public class OQueryOperatorContainsText { \n@ Override public Object evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , OCommandContext iContext , final ODocumentSerializer serializer ) { \nif ( iLeft == null || iRight == null ) { \nreturn false ; \n} \nreturn iLeft . toString ( ) . indexOf ( iRight . toString ( ) ) > - 1 ; \n} \n} \n"}
{"2917": "public class OLocalRecordCache { \npublic void updateRecord ( final ORecord record ) { \nif ( record . getIdentity ( ) . getClusterId ( ) != excludedCluster && record . getIdentity ( ) . isValid ( ) && ! record . isDirty ( ) && ! ORecordVersionHelper . isTombstone ( record . getVersion ( ) ) ) { \nif ( underlying . get ( record . getIdentity ( ) ) != record ) { \nunderlying . put ( record ) ; \n} \n} \n} \n} \n"}
{"2918": "public class OLocalRecordCache { \npublic ORecord findRecord ( final ORID rid ) { \nORecord record ; \nrecord = underlying . get ( rid ) ; \nif ( record != null ) { \nOrient . instance ( ) . getProfiler ( ) . updateCounter ( CACHE_HIT , \"Record found in Level1 Cache\" , 1L , \"db.*.cache.level1.cache.found\" ) ; \n} \nelse { \nOrient . instance ( ) . getProfiler ( ) . updateCounter ( CACHE_MISS , \"Record not found in Level1 Cache\" , 1L , \"db.*.cache.level1.cache.notFound\" ) ; \n} \nreturn record ; \n} \n} \n"}
{"2932": "public class OUser { \npublic ORole allow ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { \nif ( roles == null || roles . isEmpty ( ) ) { \nif ( document . field ( \"roles\" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( \"roles\" ) ) . isEmpty ( ) ) { \nfinal ODocument doc = document ; \ndocument = null ; \nfromStream ( doc ) ; \n} \nelse { \nthrow new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' has no role defined\" ) ; \n} \n} \nfinal ORole role = checkIfAllowed ( resourceGeneric , resourceSpecific , iOperation ) ; \nif ( role == null ) { \nthrow new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' does not have permission to execute the operation '\" + ORole . permissionToString ( iOperation ) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific ) ; \n} \nreturn role ; \n} \n} \n"}
{"2933": "public class OUser { \npublic boolean isRuleDefined ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific ) { \nfor ( ORole r : roles ) if ( r == null ) { \nOLogManager . instance ( ) . warn ( this , \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\" , getName ( ) ) ; \n} \nelse if ( r . hasRule ( resourceGeneric , resourceSpecific ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"2934": "public class ODistributedOutput { \npublic static String getCompactServerStatus ( final ODistributedServerManager manager , final ODocument distribCfg ) { \nfinal StringBuilder buffer = new StringBuilder ( ) ; \nfinal Collection < ODocument > members = distribCfg . field ( \"members\" ) ; \nif ( members != null ) { \nbuffer . append ( members . size ( ) ) ; \nbuffer . append ( \":[\" ) ; \nint memberCount = 0 ; \nfor ( ODocument m : members ) { \nif ( m == null ) { \ncontinue ; \n} \nif ( memberCount ++ > 0 ) { \nbuffer . append ( \",\" ) ; \n} \nfinal String serverName = m . field ( \"name\" ) ; \nbuffer . append ( serverName ) ; \nbuffer . append ( ( Object ) m . field ( \"status\" ) ) ; \nfinal Collection < String > databases = m . field ( \"databases\" ) ; \nif ( databases != null ) { \nbuffer . append ( \"{\" ) ; \nint dbCount = 0 ; \nfor ( String dbName : databases ) { \nfinal ODistributedConfiguration dbCfg = manager . getDatabaseConfiguration ( dbName , false ) ; \nif ( dbCfg == null ) { \ncontinue ; \n} \nif ( dbCount ++ > 0 ) { \nbuffer . append ( \",\" ) ; \n} \nbuffer . append ( dbName ) ; \nbuffer . append ( \"=\" ) ; \nbuffer . append ( manager . getDatabaseStatus ( serverName , dbName ) ) ; \nbuffer . append ( \" (\" ) ; \nbuffer . append ( dbCfg . getServerRole ( serverName ) ) ; \nbuffer . append ( \")\" ) ; \n} \nbuffer . append ( \"}\" ) ; \n} \n} \nbuffer . append ( \"]\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"2937": "public class OHazelcastPlugin { \n@ Override public void memberRemoved ( final MembershipEvent iEvent ) { \ntry { \nupdateLastClusterChange ( ) ; \nif ( iEvent . getMember ( ) == null ) { \nreturn ; \n} \nfinal String nodeLeftName = getNodeName ( iEvent . getMember ( ) ) ; \nif ( nodeLeftName == null ) { \nreturn ; \n} \nremoveServer ( nodeLeftName , true ) ; \n} \ncatch ( HazelcastInstanceNotActiveException | RetryableHazelcastException e ) { \nOLogManager . instance ( ) . error ( this , \"Hazelcast is not running\" , e ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on removing the server '%s'\" , e , getNodeName ( iEvent . getMember ( ) ) ) ; \n} \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) { \nthrow new HazelcastInstanceNotActiveException ( ) ; \n} \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) { \nreturn lockManagerServer ; \n} \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nint lockManagerServerId = - 1 ; \nif ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) { \nlockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \n} \nString newServer = null ; \nint currIndex = lockManagerServerId ; \nfor ( int i = 0 ; \ni < registeredNodeById . size ( ) ; \n++ i ) { \ncurrIndex ++ ; \nif ( currIndex >= registeredNodeById . size ( ) ) { \ncurrIndex = 0 ; \n} \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) { \nthrow new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \n} \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2939": "public class OHazelcastPlugin { \nprivate void assignLockManagerFromCluster ( ) { \nString lockManagerServer = null ; \nwhile ( lockManagerServer == null ) { \nif ( activeNodes . size ( ) == 1 ) { \nlockManagerServer = nodeName ; \nif ( configurationMap . putIfAbsent ( CONFIG_LOCKMANAGER , lockManagerServer ) == null ) { \nbreak ; \n} \n} \nelse { \nlockManagerServer = ( String ) configurationMap . get ( CONFIG_LOCKMANAGER ) ; \nif ( lockManagerServer != null && lockManagerServer . equals ( nodeName ) ) { \nOLogManager . instance ( ) . info ( this , \"Found lock as current node, even if it was offline. Forcing a new election...\" ) ; \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nlockManagerServer = electNewLockManager ( ) ; \nbreak ; \n} \nif ( lockManagerServer != null ) { \nbreak ; \n} \n} \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException e ) { \nbreak ; \n} \n} \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nOLogManager . instance ( ) . info ( this , \"Distributed Lock Manager server is '%s'\" , lockManagerServer ) ; \n} \n} \n"}
{"2940": "public class OMicroTransaction { \npublic void commit ( ) { \nif ( ! active ) { \nthrow error ( \"Inactive micro-transaction on commit\" ) ; \n} \nif ( level < 1 ) { \nthrow error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n} \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoCommit ( ) ; \n} \n} \n} \n"}
{"2941": "public class OMicroTransaction { \npublic void rollback ( ) { \nif ( ! active ) { \nthrow error ( \"Inactive micro-transaction on rollback\" ) ; \n} \nif ( level < 1 ) { \nthrow error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n} \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoRollback ( ) ; \n} \n} \n} \n"}
{"2942": "public class OMicroTransaction { \npublic void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { \nif ( oldRid . equals ( newRid ) ) { \nreturn ; \n} \nfinal List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfor ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { \nfinal OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; \nif ( index == null ) { \nthrow new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; \n} \nfinal Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; \nif ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) { \ncontinue ; \n} \nfinal OTransactionIndexChanges indexChanges = entry . getValue ( ) ; \nfor ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; \nif ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { \nkeyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; \niterator . remove ( ) ; \n} \n} \n} \nfinal ORecordOperation rec = resolveRecordOperation ( oldRid ) ; \nif ( rec != null ) { \nupdatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; \nif ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { \nORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; \nfinal ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; \nif ( recordId == null ) { \nORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; \n} \nelse { \nrecordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; \nrecordId . setClusterId ( newRid . getClusterId ( ) ) ; \n} \nORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; \n} \n} \nfor ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; \nfinal List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; \nif ( transactionIndexOperations != null ) { \nfor ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { \nOTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; \nif ( indexEntryChanges == null ) { \ncontinue ; \n} \nfinal OTransactionIndexChangesPerKey keyChanges ; \nif ( indexOperation . key == null ) { \nkeyChanges = indexEntryChanges . nullKeyChanges ; \n} \nelse { \nkeyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; \n} \nif ( keyChanges != null ) { \nupdateChangesIdentity ( oldRid , newRid , keyChanges ) ; \n} \n} \n} \n} \n} \n"}
{"2944": "public class OFileUtils { \npublic static void prepareForFileCreationOrReplacement ( Path path , Object requester , String operation ) throws IOException { \nif ( Files . deleteIfExists ( path ) ) { \nOLogManager . instance ( ) . warn ( requester , \"'%s' deleted while %s\" , path , operation ) ; \n} \nfinal Path parent = path . getParent ( ) ; \nif ( parent != null ) { \nFiles . createDirectories ( parent ) ; \n} \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) { \nmaxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \n} \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) { \nexecuteLocally = true ; \n} \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) { \nreturn new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \n} \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) { \nthrow ( ONeedRetryException ) dResult ; \n} \nelse if ( dResult instanceof Exception ) { \nthrow OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \n} \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) { \nreturn new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \n} \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) { \nthrow ( ONeedRetryException ) result ; \n} \nelse if ( result instanceof Exception ) { \nthrow OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \n} \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2952": "public class OCommandExecutorSQLCreateProperty { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( type == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OClassEmbedded sourceClass = ( OClassEmbedded ) database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( sourceClass == null ) { \nthrow new OCommandExecutionException ( \"Source class '\" + className + \"' not found\" ) ; \n} \nOPropertyImpl prop = ( OPropertyImpl ) sourceClass . getProperty ( fieldName ) ; \nif ( prop != null ) { \nif ( ifNotExists ) { \nreturn sourceClass . properties ( ) . size ( ) ; \n} \nthrow new OCommandExecutionException ( \"Property '\" + className + \".\" + fieldName + \"' already exists. Remove it before to retry.\" ) ; \n} \nOClass linkedClass = null ; \nOType linkedType = null ; \nif ( linked != null ) { \nlinkedClass = database . getMetadata ( ) . getSchema ( ) . getClass ( linked ) ; \nif ( linkedClass == null ) { \nlinkedType = OType . valueOf ( linked . toUpperCase ( Locale . ENGLISH ) ) ; \n} \n} \nOPropertyImpl internalProp = sourceClass . addPropertyInternal ( fieldName , type , linkedType , linkedClass , unsafe ) ; \nif ( readonly ) { \ninternalProp . setReadonly ( true ) ; \n} \nif ( mandatory ) { \ninternalProp . setMandatory ( true ) ; \n} \nif ( notnull ) { \ninternalProp . setNotNull ( true ) ; \n} \nif ( max != null ) { \ninternalProp . setMax ( max ) ; \n} \nif ( min != null ) { \ninternalProp . setMin ( min ) ; \n} \nif ( defaultValue != null ) { \ninternalProp . setDefaultValue ( defaultValue ) ; \n} \nreturn sourceClass . properties ( ) . size ( ) ; \n} \n} \n"}
{"2955": "public class OSQLQuery { \n@ SuppressWarnings ( \"unchecked\" ) public List < T > run ( final Object ... iArgs ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( database == null ) { \nthrow new OQueryParsingException ( \"No database configured\" ) ; \n} \n( ( OMetadataInternal ) database . getMetadata ( ) ) . makeThreadLocalSchemaSnapshot ( ) ; \ntry { \nsetParameters ( iArgs ) ; \nObject o = database . getStorage ( ) . command ( this ) ; \nif ( o instanceof List ) { \nreturn ( List < T > ) o ; \n} \nelse { \nreturn ( List < T > ) Collections . singletonList ( o ) ; \n} \n} \nfinally { \n( ( OMetadataInternal ) database . getMetadata ( ) ) . clearThreadLocalSchemaSnapshot ( ) ; \n} \n} \n} \n"}
{"2961": "public class OStorageRemote { \npublic void endRequest ( final OChannelBinaryAsynchClient iNetwork ) throws IOException { \nif ( iNetwork == null ) { \nreturn ; \n} \niNetwork . flush ( ) ; \niNetwork . releaseWriteLock ( ) ; \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) { \nhost = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \n} \nif ( host . contains ( \"/\" ) ) { \nhost = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \n} \nif ( ! host . contains ( \":\" ) ) { \nhost += \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \n} \nelse if ( host . split ( \":\" ) . length < 2 || host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) { \nhost += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \n} \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2965": "public class OClientConnectionManager { \npublic OClientConnection getConnection ( final int iChannelId , ONetworkProtocol protocol ) { \nOClientConnection connection = connections . get ( iChannelId ) ; \nif ( connection != null ) { \nconnection . setProtocol ( protocol ) ; \n} \nreturn connection ; \n} \n} \n"}
{"2967": "public class OClientConnectionManager { \npublic void interrupt ( final int iChannelId ) { \nfinal OClientConnection connection = connections . get ( iChannelId ) ; \nif ( connection != null ) { \nfinal ONetworkProtocol protocol = connection . getProtocol ( ) ; \nif ( protocol != null ) { \nprotocol . softShutdown ( ) ; \n} \n} \n} \n} \n"}
{"2969": "public class OClientConnectionManager { \npublic void pushDistribCfg2Clients ( final ODocument iConfig ) { \nif ( iConfig == null ) { \nreturn ; \n} \nfinal Set < String > pushed = new HashSet < String > ( ) ; \nfor ( OClientConnection c : connections . values ( ) ) { \nif ( ! c . getData ( ) . supportsLegacyPushMessages ) { \ncontinue ; \n} \ntry { \nfinal String remoteAddress = c . getRemoteAddress ( ) ; \nif ( pushed . contains ( remoteAddress ) ) { \ncontinue ; \n} \n} \ncatch ( Exception e ) { \ncontinue ; \n} \nif ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) || c . getData ( ) . getSerializationImpl ( ) == null ) { \ncontinue ; \n} \nfinal ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; \nfinal OChannelBinary channel = p . getChannel ( ) ; \nfinal ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; \nif ( ser == null ) { \nreturn ; \n} \nfinal byte [ ] content = ser . toStream ( iConfig , false ) ; \ntry { \nif ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) { \ntry { \nchannel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; \nchannel . writeInt ( Integer . MIN_VALUE ) ; \nchannel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; \nchannel . writeBytes ( content ) ; \nchannel . flush ( ) ; \npushed . add ( c . getRemoteAddress ( ) ) ; \nOLogManager . instance ( ) . debug ( this , \"Sent updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nfinally { \nchannel . releaseWriteLock ( ) ; \n} \n} \nelse { \nOLogManager . instance ( ) . info ( this , \"Timeout on sending updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . warn ( this , \"Cannot push cluster configuration to the client %s\" , e , c . getRemoteAddress ( ) ) ; \n} \n} \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) { \nreturn ; \n} \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nfor ( Class < ? > currentClass = iClass ; \ncurrentClass != Object . class ; \n) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) { \n( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \n} \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) { \ncurrentClass = Object . class ; \n} \nif ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) && reloadSchema ) { \ndatabase . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \n} \n} \n"}
{"2973": "public class OAbstractProfiler { \nprotected void updateMetadata ( final String iName , final String iDescription , final METRIC_TYPE iType ) { \nif ( iDescription != null && dictionary . putIfAbsent ( iName , iDescription ) == null ) { \ntypes . put ( iName , iType ) ; \n} \n} \n} \n"}
{"2974": "public class ORecordIteratorClusters { \n@ Override public ORecordIteratorClusters < REC > last ( ) { \nif ( clusterIds . length == 0 ) { \nreturn this ; \n} \nbrowsedRecords = 0 ; \ncurrentClusterIdx = clusterIds . length - 1 ; \nupdateClusterRange ( ) ; \ncurrent . setClusterId ( clusterIds [ currentClusterIdx ] ) ; \nresetCurrentPosition ( ) ; \nprevPosition ( ) ; \nfinal ORecord record = getRecord ( ) ; \ncurrentRecord = readCurrentRecord ( record , 0 ) ; \nif ( currentRecord != null && ! include ( currentRecord ) ) { \ncurrentRecord = null ; \nhasPrevious ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) { \nreturn - 1 ; \n} \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) { \nreturn - 1 ; \n} \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \ni < 4 ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) { \nreturn - 1 ; \n} \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse { \n++ columnNumber ; \n} \nreturn ( char ) c ; \n} \n} \n"}
{"2976": "public class OCommandExecutorSQLFindReferences { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( recordIds . isEmpty ( ) && subQuery == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nif ( subQuery != null ) { \nfinal List < OIdentifiable > result = new OCommandSQL ( subQuery . toString ( ) ) . execute ( ) ; \nfor ( OIdentifiable id : result ) recordIds . add ( id . getIdentity ( ) ) ; \n} \nreturn OFindReferenceHelper . findReferences ( recordIds , classList ) ; \n} \n} \n"}
{"2977": "public class OCommandRequestAbstract { \n@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { \nif ( iCallback != null ) { \nonAsyncReplicationError = new OAsyncReplicationError ( ) { \nint retry = 0 ; \n@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { \nswitch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { \ncase RETRY : execute ( ) ; \nbreak ; \ncase IGNORE : } \nreturn ACTION . IGNORE ; \n} \n} \n; \n} \nelse { \nonAsyncReplicationError = null ; \n} \nreturn this ; \n} \n} \n"}
{"2978": "public class OCompressionFactory { \npublic void register ( final Class < ? extends OCompression > compression ) { \ntry { \nfinal OCompression tempInstance = compression . newInstance ( ) ; \nfinal String name = tempInstance . name ( ) ; \nif ( compressions . containsKey ( name ) ) { \nthrow new IllegalArgumentException ( \"Compression with name '\" + name + \"' was already registered\" ) ; \n} \nif ( compressionClasses . containsKey ( tempInstance . name ( ) ) ) { \nthrow new IllegalArgumentException ( \"Compression with name '\" + name + \"' was already registered\" ) ; \n} \ncompressionClasses . put ( name , compression ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Cannot register storage compression algorithm '%s'\" , e , compression ) ; \n} \n} \n} \n"}
{"2981": "public class OMemoryStream { \npublic void move ( final int iFrom , final int iPosition ) { \nif ( iPosition == 0 ) { \nreturn ; \n} \nfinal int to = iFrom + iPosition ; \nfinal int size = iPosition > 0 ? buffer . length - to : buffer . length - iFrom ; \nSystem . arraycopy ( buffer , iFrom , buffer , to , size ) ; \n} \n} \n"}
{"2986": "public class OCommandExecutorSQLMoveVertex { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . begin ( ) ; \nif ( className == null && clusterName == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nOModifiableBoolean shutdownGraph = new OModifiableBoolean ( ) ; \nfinal boolean txAlreadyBegun = getDatabase ( ) . getTransaction ( ) . isActive ( ) ; \ntry { \nfinal Set < OIdentifiable > sourceRIDs = OSQLEngine . getInstance ( ) . parseRIDTarget ( db , source , context , iArgs ) ; \nfinal List < ODocument > result = new ArrayList < ODocument > ( sourceRIDs . size ( ) ) ; \nfor ( OIdentifiable from : sourceRIDs ) { \nfinal OVertex fromVertex = toVertex ( from ) ; \nif ( fromVertex == null ) { \ncontinue ; \n} \nfinal ORID oldVertex = fromVertex . getIdentity ( ) . copy ( ) ; \nfinal ORID newVertex = fromVertex . moveTo ( className , clusterName ) ; \nfinal ODocument newVertexDoc = newVertex . getRecord ( ) ; \nif ( fields != null ) { \nfor ( final OPair < String , Object > f : fields ) { \nif ( f . getValue ( ) instanceof OSQLFunctionRuntime ) { \nf . setValue ( ( ( OSQLFunctionRuntime ) f . getValue ( ) ) . getValue ( newVertex . getRecord ( ) , null , context ) ) ; \n} \n} \nOSQLHelper . bindParameters ( newVertexDoc , fields , new OCommandParameters ( iArgs ) , context ) ; \n} \nif ( merge != null ) { \nnewVertexDoc . merge ( merge , true , false ) ; \n} \nnewVertexDoc . save ( ) ; \nresult . add ( new ODocument ( ) . setTrackingChanges ( false ) . field ( \"old\" , oldVertex , OType . LINK ) . field ( \"new\" , newVertex , OType . LINK ) ) ; \nif ( batch > 0 && result . size ( ) % batch == 0 ) { \ndb . commit ( ) ; \ndb . begin ( ) ; \n} \n} \ndb . commit ( ) ; \nreturn result ; \n} \nfinally { \n} \n} \n} \n"}
{"2987": "public class OStorageConfigurationImpl { \npublic OStorageConfigurationImpl load ( final OContextConfiguration configuration ) throws OSerializationException { \nlock . acquireWriteLock ( ) ; \ntry { \ninitConfiguration ( configuration ) ; \nfinal byte [ ] record = storage . readRecord ( CONFIG_RID , null , false , false , null ) . getResult ( ) . buffer ; \nif ( record == null ) { \nthrow new OStorageException ( \"Cannot load database configuration. The database seems corrupted\" ) ; \n} \nfromStream ( record , 0 , record . length , streamCharset ) ; \n} \nfinally { \nlock . releaseWriteLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"2991": "public class OCompositeIndexDefinition { \npublic void addIndex ( final OIndexDefinition indexDefinition ) { \nindexDefinitions . add ( indexDefinition ) ; \nif ( indexDefinition instanceof OIndexDefinitionMultiValue ) { \nif ( multiValueDefinitionIndex == - 1 ) { \nmultiValueDefinitionIndex = indexDefinitions . size ( ) - 1 ; \n} \nelse { \nthrow new OIndexException ( \"Composite key cannot contain more than one collection item\" ) ; \n} \n} \ncollate . addCollate ( indexDefinition . getCollate ( ) ) ; \n} \n} \n"}
{"2997": "public class OCommandExecutorSQLDropCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \nfinal int clusterId = database . getStorage ( ) . getClusterIdByName ( clusterName ) ; \nfor ( OClass iClass : database . getMetadata ( ) . getSchema ( ) . getClasses ( ) ) { \nfor ( int i : iClass . getClusterIds ( ) ) { \nif ( i == clusterId ) { \nreturn false ; \n} \n} \n} \ndatabase . getMetadata ( ) . getCommandCache ( ) . invalidateResultsOfCluster ( clusterName ) ; \ndatabase . dropCluster ( clusterId , true ) ; \nreturn true ; \n} \n} \n"}
{"3000": "public class OSecurityManager { \npublic String createHash ( final String iInput , final String iAlgorithm , final boolean iIncludeAlgorithm ) { \nif ( iInput == null ) { \nthrow new IllegalArgumentException ( \"Input string is null\" ) ; \n} \nif ( iAlgorithm == null ) { \nthrow new IllegalArgumentException ( \"Algorithm is null\" ) ; \n} \nfinal StringBuilder buffer = new StringBuilder ( 128 ) ; \nfinal String algorithm = validateAlgorithm ( iAlgorithm ) ; \nif ( iIncludeAlgorithm ) { \nbuffer . append ( '{' ) ; \nbuffer . append ( algorithm ) ; \nbuffer . append ( '}' ) ; \n} \nfinal String transformed ; \nif ( HASH_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createSHA256 ( iInput ) ; \n} \nelse if ( PBKDF2_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse if ( PBKDF2_SHA256_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Algorithm '\" + algorithm + \"' is not supported\" ) ; \n} \nbuffer . append ( transformed ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"3002": "public class OIndexAbstract { \npublic OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { \nacquireExclusiveLock ( ) ; \ntry { \nconfiguration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; \nthis . indexDefinition = indexDefinition ; \nif ( clustersToIndex != null ) { \nthis . clustersToIndex = new HashSet < > ( clustersToIndex ) ; \n} \nelse { \nthis . clustersToIndex = new HashSet < > ( ) ; \n} \ntry { \nif ( apiVersion == 0 ) { \nremoveValuesContainer ( ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during deletion of index '%s'\" , e , name ) ; \n} \nindexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; \napiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; \nassert indexId >= 0 ; \nassert apiVersion >= 0 ; \nonIndexEngineChange ( indexId ) ; \nif ( rebuild ) { \nfillIndex ( progressListener , false ) ; \n} \nupdateConfiguration ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' creation\" , e , name ) ; \nwhile ( true ) { \ntry { \nif ( indexId >= 0 ) { \nstorage . deleteIndexEngine ( indexId ) ; \n} \nbreak ; \n} \ncatch ( OInvalidIndexEngineIdException ignore ) { \ndoReloadIndexEngine ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' deletion\" , ex , name ) ; \n} \n} \nif ( e instanceof OIndexException ) { \nthrow ( OIndexException ) e ; \n} \nthrow OException . wrapException ( new OIndexException ( \"Cannot create the index '\" + name + \"'\" ) , e ) ; \n} \nfinally { \nreleaseExclusiveLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"3003": "public class OrientGraphQuery { \n@ Override public Iterable < Vertex > vertices ( ) { \nif ( limit == 0 ) { \nreturn Collections . emptyList ( ) ; \n} \nOTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; \nif ( transaction . isActive ( ) && transaction . getEntryCount ( ) > 0 || hasCustomPredicate ( ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && labels . length > 0 ) { \nif ( labels . length == 1 ) { \ntext . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \n} \nelse { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \n} \nelse { \ntext . append ( OrientVertexType . CLASS_NAME ) ; \n} \nfinal List < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) { \nmanageLabels ( queryParams . size ( ) > 0 , text ) ; \n} \nif ( orderBy . length ( ) > 1 ) { \ntext . append ( ORDERBY ) ; \ntext . append ( orderBy ) ; \ntext . append ( \" \" ) . append ( orderByDir ) . append ( \" \" ) ; \n} \nif ( skip > 0 && skip < Integer . MAX_VALUE ) { \ntext . append ( SKIP ) ; \ntext . append ( skip ) ; \n} \nif ( limit > 0 && limit < Integer . MAX_VALUE ) { \ntext . append ( LIMIT ) ; \ntext . append ( limit ) ; \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) { \nquery . setFetchPlan ( fetchPlan ) ; \n} \nreturn new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3004": "public class OrientGraphQuery { \n@ Override public Iterable < Edge > edges ( ) { \nif ( limit == 0 ) { \nreturn Collections . emptyList ( ) ; \n} \nif ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) || hasCustomPredicate ( ) ) { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \nif ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && labels . length > 0 ) { \nif ( labels . length == 1 ) { \ntext . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \n} \nelse { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \n} \nelse { \ntext . append ( OrientEdgeType . CLASS_NAME ) ; \n} \nList < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) { \nmanageLabels ( queryParams . size ( ) > 0 , text ) ; \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) { \nquery . setFetchPlan ( fetchPlan ) ; \n} \nif ( limit > 0 && limit < Integer . MAX_VALUE ) { \nquery . setLimit ( limit ) ; \n} \nreturn new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3005": "public class OAbstract2pcTask { \n@ Override public int [ ] getPartitionKey ( ) { \nif ( tasks . size ( ) == 1 ) { \nreturn tasks . get ( 0 ) . getPartitionKey ( ) ; \n} \nfinal int [ ] partitions = new int [ tasks . size ( ) ] ; \nfor ( int i = 0 ; \ni < tasks . size ( ) ; \n++ i ) { \nfinal OAbstractRecordReplicatedTask task = tasks . get ( i ) ; \npartitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; \n} \nreturn partitions ; \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( changesContainer == null ) { \nreturn true ; \n} \nelse if ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) { \nreturn pageIndex < changesContainer . maxNewPageIndex + 1 ; \n} \nelse { \nreturn ! changesContainer . truncate ; \n} \n} \n} \n"}
{"3009": "public class OCommandExecutorSQLAbstract { \nprotected boolean parseTimeout ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_TIMEOUT ) ) { \nreturn false ; \n} \nString word = parserNextWord ( true ) ; \ntry { \ntimeoutMs = Long . parseLong ( word ) ; \n} \ncatch ( NumberFormatException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \" + KEYWORD_TIMEOUT + \" 3000\" ) ; \n} \nif ( timeoutMs < 0 ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\" ) ; \n} \nword = parserNextWord ( true ) ; \nif ( word != null ) { \nif ( word . equals ( TIMEOUT_STRATEGY . EXCEPTION . toString ( ) ) ) { \ntimeoutStrategy = TIMEOUT_STRATEGY . EXCEPTION ; \n} \nelse if ( word . equals ( TIMEOUT_STRATEGY . RETURN . toString ( ) ) ) { \ntimeoutStrategy = TIMEOUT_STRATEGY . RETURN ; \n} \nelse { \nparserGoBack ( ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3010": "public class OCommandExecutorSQLAbstract { \nprotected String parseLock ( ) throws OCommandSQLParsingException { \nfinal String lockStrategy = parserNextWord ( true ) ; \nif ( ! lockStrategy . equalsIgnoreCase ( \"DEFAULT\" ) && ! lockStrategy . equalsIgnoreCase ( \"NONE\" ) && ! lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\" ) ; \n} \nreturn lockStrategy ; \n} \n} \n"}
{"3011": "public class OSystemDatabase { \npublic void createCluster ( final String className , final String clusterName ) { \nfinal ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal ODatabaseDocumentInternal sysdb = openSystemDatabase ( ) ; \ntry { \nif ( ! sysdb . existsCluster ( clusterName ) ) { \nOSchema schema = sysdb . getMetadata ( ) . getSchema ( ) ; \nOClass cls = schema . getClass ( className ) ; \nif ( cls != null ) { \ncls . addCluster ( clusterName ) ; \n} \nelse { \nOLogManager . instance ( ) . error ( this , \"createCluster() Class name %s does not exist\" , null , className ) ; \n} \n} \n} \nfinally { \nsysdb . close ( ) ; \n} \n} \nfinally { \nif ( currentDB != null ) { \nODatabaseRecordThreadLocal . instance ( ) . set ( currentDB ) ; \n} \nelse { \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \n} \n} \n} \n"}
{"3012": "public class OAbstractRecordCache { \npublic void freeCluster ( final int cid ) { \nfinal Set < ORID > toRemove = new HashSet < ORID > ( underlying . size ( ) / 2 ) ; \nfinal Set < ORID > keys = new HashSet < ORID > ( underlying . keys ( ) ) ; \nfor ( final ORID id : keys ) if ( id . getClusterId ( ) == cid ) { \ntoRemove . add ( id ) ; \n} \nfor ( final ORID ridToRemove : toRemove ) underlying . remove ( ridToRemove ) ; \n} \n} \n"}
{"3017": "public class ORole { \npublic ORole revoke ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { \nif ( iOperation == PERMISSION_NONE ) { \nreturn this ; \n} \nORule rule = rules . get ( resourceGeneric ) ; \nif ( rule == null ) { \nrule = new ORule ( resourceGeneric , null , null ) ; \nrules . put ( resourceGeneric , rule ) ; \n} \nrule . revokeAccess ( resourceSpecific , iOperation ) ; \nrules . put ( resourceGeneric , rule ) ; \nupdateRolesDocumentContent ( ) ; \nreturn this ; \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \nreturn true ; \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) { \nallDeletedRecords . add ( record ) ; \n} \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3025": "public class OPropertyImpl { \n@ Deprecated public OIndex < ? > getIndex ( ) { \nacquireSchemaReadLock ( ) ; \ntry { \nSet < OIndex < ? > > indexes = owner . getInvolvedIndexes ( globalRef . getName ( ) ) ; \nif ( indexes != null && ! indexes . isEmpty ( ) ) { \nreturn indexes . iterator ( ) . next ( ) ; \n} \nreturn null ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3026": "public class OPropertyImpl { \npublic OClass getLinkedClass ( ) { \nacquireSchemaReadLock ( ) ; \ntry { \nif ( linkedClass == null && linkedClassName != null ) { \nlinkedClass = owner . owner . getClass ( linkedClassName ) ; \n} \nreturn linkedClass ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3028": "public class ORecordAbstract { \nprotected void removeListener ( final ORecordListener listener ) { \nif ( _listeners != null ) { \n_listeners . remove ( listener ) ; \nif ( _listeners . isEmpty ( ) ) { \n_listeners = null ; \n} \n} \n} \n} \n"}
{"3029": "public class ODistributedMessageServiceImpl { \npublic ODistributedDatabaseImpl registerDatabase ( final String iDatabaseName , ODistributedConfiguration cfg ) { \nfinal ODistributedDatabaseImpl ddb = databases . get ( iDatabaseName ) ; \nif ( ddb != null ) { \nreturn ddb ; \n} \nreturn new ODistributedDatabaseImpl ( manager , this , iDatabaseName , cfg , manager . getServerInstance ( ) ) ; \n} \n} \n"}
{"3030": "public class ODistributedMessageServiceImpl { \npublic void timeoutRequest ( final long msgId ) { \nfinal ODistributedResponseManager asynchMgr = responsesByRequestIds . remove ( msgId ) ; \nif ( asynchMgr != null ) { \nasynchMgr . timeout ( ) ; \n} \n} \n} \n"}
{"3032": "public class ORidBag { \npublic boolean tryMerge ( final ORidBag otherValue , boolean iMergeSingleItemsOfMultiValueFields ) { \nif ( ! isEmbedded ( ) && ! otherValue . isEmbedded ( ) ) { \nfinal OSBTreeRidBag thisTree = ( OSBTreeRidBag ) delegate ; \nfinal OSBTreeRidBag otherTree = ( OSBTreeRidBag ) otherValue . delegate ; \nif ( thisTree . getCollectionPointer ( ) . equals ( otherTree . getCollectionPointer ( ) ) ) { \nthisTree . mergeChanges ( otherTree ) ; \nuuid = otherValue . uuid ; \nreturn true ; \n} \n} \nelse if ( iMergeSingleItemsOfMultiValueFields ) { \nfinal Iterator < OIdentifiable > iter = otherValue . rawIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal OIdentifiable value = iter . next ( ) ; \nif ( value != null ) { \nfinal Iterator < OIdentifiable > localIter = rawIterator ( ) ; \nboolean found = false ; \nwhile ( localIter . hasNext ( ) ) { \nfinal OIdentifiable v = localIter . next ( ) ; \nif ( value . equals ( v ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nadd ( value ) ; \n} \n} \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal int clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( clusterId > - 1 ) { \nthrow new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \n} \nif ( blob ) { \nif ( requestedId == - 1 ) { \nreturn database . addBlobCluster ( clusterName ) ; \n} \nelse { \nthrow new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \n} \n} \nelse { \nif ( requestedId == - 1 ) { \nreturn database . addCluster ( clusterName ) ; \n} \nelse { \nreturn database . addCluster ( clusterName , requestedId , null ) ; \n} \n} \n} \n} \n"}
{"3037": "public class ODatabasePoolAbstract { \npublic void onStorageUnregistered ( final OStorage iStorage ) { \nfinal String storageURL = iStorage . getURL ( ) ; \nlock ( ) ; \ntry { \nSet < String > poolToClose = null ; \nfor ( Entry < String , OReentrantResourcePool < String , DB > > e : pools . entrySet ( ) ) { \nfinal int pos = e . getKey ( ) . indexOf ( \"@\" ) ; \nfinal String dbName = e . getKey ( ) . substring ( pos + 1 ) ; \nif ( storageURL . equals ( dbName ) ) { \nif ( poolToClose == null ) { \npoolToClose = new HashSet < String > ( ) ; \n} \npoolToClose . add ( e . getKey ( ) ) ; \n} \n} \nif ( poolToClose != null ) { \nfor ( String pool : poolToClose ) remove ( pool ) ; \n} \n} \nfinally { \nunlock ( ) ; \n} \n} \n} \n"}
{"3049": "public class ODatabaseDocumentTxPooled { \n@ Override public void close ( ) { \nif ( isClosed ( ) ) { \nreturn ; \n} \ncheckOpenness ( ) ; \nif ( ownerPool != null && ownerPool . getConnectionsInCurrentThread ( getURL ( ) , userName ) > 1 ) { \nownerPool . release ( this ) ; \nreturn ; \n} \ntry { \ncommit ( true ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ntry { \ncallOnCloseListeners ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ngetLocalCache ( ) . clear ( ) ; \nif ( ownerPool != null ) { \nfinal ODatabaseDocumentPool localCopy = ownerPool ; \nownerPool = null ; \nlocalCopy . release ( this ) ; \n} \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \n} \n"}
{"3051": "public class OSessionStoragePerformanceStatistic { \npublic void completeComponentOperation ( ) { \nfinal Component currentComponent = componentsStack . peek ( ) ; \nif ( currentComponent == null ) { \nreturn ; \n} \ncurrentComponent . operationCount -- ; \nif ( currentComponent . operationCount == 0 ) { \nfinal String componentName = currentComponent . name ; \nPerformanceCountersHolder cHolder = countersByComponent . computeIfAbsent ( componentName , k -> currentComponent . type . newCountersHolder ( ) ) ; \ncHolder . operationsCount ++ ; \ncomponentsStack . pop ( ) ; \nmakeSnapshotIfNeeded ( - 1 ) ; \n} \n} \n} \n"}
{"3052": "public class OSessionStoragePerformanceStatistic { \npublic void pushComponentCounters ( Map < String , PerformanceCountersHolder > counters ) { \nif ( snapshot == null ) { \nreturn ; \n} \nfor ( Map . Entry < String , PerformanceCountersHolder > entry : snapshot . countersByComponent . entrySet ( ) ) { \nfinal String componentName = entry . getKey ( ) ; \nPerformanceCountersHolder holder = counters . computeIfAbsent ( componentName , k -> entry . getValue ( ) . newInstance ( ) ) ; \nentry . getValue ( ) . pushData ( holder ) ; \n} \n} \n} \n"}
{"3053": "public class OSessionStoragePerformanceStatistic { \npublic WritCacheCountersHolder pushWriteCacheCounters ( WritCacheCountersHolder holder ) { \nif ( snapshot == null ) { \nreturn holder ; \n} \nif ( snapshot . writCacheCountersHolder == null ) { \nreturn holder ; \n} \nif ( holder == null ) { \nholder = new WritCacheCountersHolder ( ) ; \n} \nsnapshot . writCacheCountersHolder . pushData ( holder ) ; \nreturn holder ; \n} \n} \n"}
{"3054": "public class OSessionStoragePerformanceStatistic { \npublic StorageCountersHolder pushStorageCounters ( StorageCountersHolder holder ) { \nif ( snapshot == null ) { \nreturn holder ; \n} \nif ( snapshot . storageCountersHolder == null ) { \nreturn holder ; \n} \nif ( holder == null ) { \nholder = new StorageCountersHolder ( ) ; \n} \nsnapshot . storageCountersHolder . pushData ( holder ) ; \nreturn holder ; \n} \n} \n"}
{"3055": "public class OSessionStoragePerformanceStatistic { \npublic WALCountersHolder pushWALCounters ( WALCountersHolder holder ) { \nif ( snapshot == null ) { \nreturn holder ; \n} \nif ( snapshot . walCountersHolder == null ) { \nreturn holder ; \n} \nif ( holder == null ) { \nholder = new WALCountersHolder ( ) ; \n} \nsnapshot . walCountersHolder . pushData ( holder ) ; \nreturn holder ; \n} \n} \n"}
{"3056": "public class OSessionStoragePerformanceStatistic { \npublic void pushComponentCounters ( String name , PerformanceCountersHolder holder ) { \nif ( snapshot == null ) { \nreturn ; \n} \nfinal PerformanceCountersHolder countersHolder = snapshot . countersByComponent . get ( name ) ; \nif ( countersHolder != null ) { \ncountersHolder . pushData ( holder ) ; \n} \n} \n} \n"}
{"3057": "public class OSessionStoragePerformanceStatistic { \npublic void stopWriteCacheFlushTimer ( int pagesFlushed ) { \nif ( writCacheCountersHolder == null ) { \nwritCacheCountersHolder = new WritCacheCountersHolder ( ) ; \n} \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . flushOperationsCount ++ ; \nwritCacheCountersHolder . amountOfPagesFlushed += pagesFlushed ; \nwritCacheCountersHolder . flushOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3058": "public class OSessionStoragePerformanceStatistic { \npublic void stopFuzzyCheckpointTimer ( ) { \nif ( writCacheCountersHolder == null ) { \nwritCacheCountersHolder = new WritCacheCountersHolder ( ) ; \n} \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . fuzzyCheckpointCount ++ ; \nwritCacheCountersHolder . fuzzyCheckpointTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3059": "public class OSessionStoragePerformanceStatistic { \npublic void stopFullCheckpointTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( storageCountersHolder == null ) { \nstorageCountersHolder = new StorageCountersHolder ( ) ; \n} \nstorageCountersHolder . fullCheckpointOperationsCount ++ ; \nstorageCountersHolder . fullCheckpointOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) { \nwalCountersHolder = new WALCountersHolder ( ) ; \n} \nwalCountersHolder . logRecordCount ++ ; \nwalCountersHolder . logRecordTime += timeDiff ; \nif ( isStartRecord ) { \nwalCountersHolder . startRecordCount ++ ; \nwalCountersHolder . startRecordTime += timeDiff ; \n} \nelse if ( isStopRecord ) { \nwalCountersHolder . stopRecordCount ++ ; \nwalCountersHolder . stopRecordTime += timeDiff ; \n} \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3062": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALFlushTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) { \nwalCountersHolder = new WALCountersHolder ( ) ; \n} \nwalCountersHolder . flushCount ++ ; \nwalCountersHolder . flushTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3066": "public class OrientElement { \nvoid removeRecord ( ) { \ncheckIfAttached ( ) ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nif ( checkDeletedInTx ( ) ) { \ngraph . throwRecordNotFoundException ( getIdentity ( ) , \"The graph element with id \" + getIdentity ( ) + \" not found\" ) ; \n} \ntry { \ngetRecord ( ) . load ( ) ; \n} \ncatch ( ORecordNotFoundException e ) { \ngraph . throwRecordNotFoundException ( getIdentity ( ) , e . getMessage ( ) ) ; \n} \ngetRecord ( ) . delete ( ) ; \n} \n} \n"}
{"3067": "public class OrientElement { \n@ Override public void setProperty ( final String key , final Object value ) { \nif ( checkDeletedInTx ( ) ) { \ngraph . throwRecordNotFoundException ( getIdentity ( ) , \"The graph element \" + getIdentity ( ) + \" has been deleted\" ) ; \n} \nvalidateProperty ( this , key , value ) ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( graph != null ) { \ngraph . autoStartTransaction ( ) ; \n} \ngetRecord ( ) . field ( key , value ) ; \nif ( graph != null ) { \nsave ( ) ; \n} \n} \n} \n"}
{"3068": "public class OrientElement { \n@ Override public < T > T removeProperty ( final String key ) { \nif ( checkDeletedInTx ( ) ) { \nthrow new IllegalStateException ( \"The vertex \" + getIdentity ( ) + \" has been deleted\" ) ; \n} \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( graph != null ) { \ngraph . autoStartTransaction ( ) ; \n} \nfinal Object oldValue = getRecord ( ) . removeField ( key ) ; \nif ( graph != null ) { \nsave ( ) ; \n} \nreturn ( T ) oldValue ; \n} \n} \n"}
{"3069": "public class OrientElement { \nprotected String checkForClassInSchema ( final String className ) { \nif ( className == null ) { \nreturn null ; \n} \nOrientBaseGraph graph = getGraph ( ) ; \nif ( graph == null ) { \nreturn className ; \n} \nfinal OSchema schema = graph . getRawGraph ( ) . getMetadata ( ) . getSchema ( ) ; \nif ( ! schema . existsClass ( className ) ) { \ntry { \ngraph . executeOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nreturn schema . createClass ( className , schema . getClass ( getBaseClassName ( ) ) ) ; \n} \n} \n, \"Committing the active transaction to create the new type '\" , className , \"' as subclass of '\" , getBaseClassName ( ) , \"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\" ) ; \n} \ncatch ( OSchemaException e ) { \nif ( ! schema . existsClass ( className ) ) { \nthrow e ; \n} \n} \n} \nelse { \nfinal OClass cls = schema . getClass ( className ) ; \nif ( ! cls . isSubClassOf ( getBaseClassName ( ) ) ) { \nthrow new IllegalArgumentException ( \"Class '\" + className + \"' is not an instance of \" + getBaseClassName ( ) ) ; \n} \n} \nreturn className ; \n} \n} \n"}
{"3070": "public class OIndexChangesWrapper { \npublic static OIndexCursor wrap ( OIndex < ? > source , OIndexCursor cursor , long indexRebuildVersion ) { \nif ( cursor instanceof OIndexChangesWrapper ) { \nreturn cursor ; \n} \nif ( cursor instanceof OSizeable ) { \nreturn new OIndexChangesSizeable ( source , cursor , indexRebuildVersion ) ; \n} \nreturn new OIndexChangesWrapper ( source , cursor , indexRebuildVersion ) ; \n} \n} \n"}
{"3073": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iClass == null ) { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) { \nresult . add ( entry ) ; \n} \n} \n} \nelse { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) { \nif ( entry . getRecord ( ) != null && entry . getRecord ( ) instanceof ODocument ) { \nif ( iPolymorphic ) { \nif ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) { \nresult . add ( entry ) ; \n} \n} \nelse if ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) { \nresult . add ( entry ) ; \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3074": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClusterIds ( final int [ ] iIds ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iIds == null ) { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) { \nresult . add ( entry ) ; \n} \n} \n} \nelse { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nfor ( int id : iIds ) { \nif ( entry . getRecord ( ) != null && entry . getRecord ( ) . getIdentity ( ) . getClusterId ( ) == id && entry . type == ORecordOperation . CREATED ) { \nresult . add ( entry ) ; \nbreak ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3075": "public class OTransactionRealAbstract { \npublic void addIndexEntry ( final OIndex < ? > delegate , final String iIndexName , final OTransactionIndexChanges . OPERATION iOperation , final Object key , final OIdentifiable iValue , boolean clientTrackOnly ) { \nOTransactionIndexChanges indexEntry = indexEntries . get ( iIndexName ) ; \nif ( indexEntry == null ) { \nindexEntry = new OTransactionIndexChanges ( ) ; \nindexEntries . put ( iIndexName , indexEntry ) ; \n} \nif ( iOperation == OPERATION . CLEAR ) { \nindexEntry . setCleared ( ) ; \n} \nelse { \nOTransactionIndexChangesPerKey changes = indexEntry . getChangesPerKey ( key ) ; \nchanges . clientTrackOnly = clientTrackOnly ; \nchanges . add ( iValue , iOperation ) ; \nif ( iValue == null ) { \nreturn ; \n} \nList < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( iValue . getIdentity ( ) ) ; \nif ( transactionIndexOperations == null ) { \ntransactionIndexOperations = new ArrayList < OTransactionRecordIndexOperation > ( ) ; \nrecordIndexOperations . put ( iValue . getIdentity ( ) . copy ( ) , transactionIndexOperations ) ; \n} \ntransactionIndexOperations . add ( new OTransactionRecordIndexOperation ( iIndexName , key , iOperation ) ) ; \n} \n} \n} \n"}
{"3077": "public class OCommandExecutorSQLUpdate { \n@ SuppressWarnings ( \"unchecked\" ) public boolean result ( final Object iRecord ) { \nfinal ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , \"E\" ) ) { \nthrow new OCommandExecutionException ( \"Using UPDATE EDGE on a record that is not an instance of E\" ) ; \n} \nif ( compiledFilter != null ) { \nif ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) { \nreturn false ; \n} \n} \nparameters . reset ( ) ; \nreturnHandler . beforeUpdate ( record ) ; \nboolean updated = handleContent ( record ) ; \nupdated |= handleMerge ( record ) ; \nupdated |= handleSetEntries ( record ) ; \nupdated |= handleIncrementEntries ( record ) ; \nupdated |= handleAddEntries ( record ) ; \nupdated |= handlePutEntries ( record ) ; \nupdated |= handleRemoveEntries ( record ) ; \nif ( updated ) { \nhandleUpdateEdge ( record ) ; \nrecord . setDirty ( ) ; \nrecord . save ( ) ; \nreturnHandler . afterUpdate ( record ) ; \nthis . updated = true ; \n} \nreturn true ; \n} \n} \n"}
{"3085": "public class ODistributedConfiguration { \npublic NEW_NODE_STRATEGIES getNewNodeStrategy ( ) { \nfinal String value = configuration . field ( NEW_NODE_STRATEGY ) ; \nif ( value != null ) { \nreturn NEW_NODE_STRATEGIES . valueOf ( value . toUpperCase ( Locale . ENGLISH ) ) ; \n} \nreturn NEW_NODE_STRATEGIES . STATIC ; \n} \n} \n"}
{"3086": "public class ODistributedConfiguration { \npublic Boolean isExecutionModeSynchronous ( final String iClusterName ) { \nObject value = getClusterConfiguration ( iClusterName ) . field ( EXECUTION_MODE ) ; \nif ( value == null ) { \nvalue = configuration . field ( EXECUTION_MODE ) ; \nif ( value == null ) { \nreturn null ; \n} \n} \nif ( value . toString ( ) . equalsIgnoreCase ( \"undefined\" ) ) { \nreturn null ; \n} \nreturn value . toString ( ) . equalsIgnoreCase ( EXECUTION_MODE_SYNCHRONOUS ) ; \n} \n} \n"}
{"3088": "public class ODistributedConfiguration { \npublic Map < String , Collection < String > > getServerClusterMap ( Collection < String > iClusterNames , final String iLocalNode , final boolean optimizeForLocalOnly ) { \nif ( iClusterNames == null || iClusterNames . isEmpty ( ) ) { \niClusterNames = DEFAULT_CLUSTER_NAME ; \n} \nfinal Map < String , Collection < String > > servers = new HashMap < String , Collection < String > > ( iClusterNames . size ( ) ) ; \nboolean canUseLocalNode = true ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null && ! serverList . contains ( iLocalNode ) ) { \ncanUseLocalNode = false ; \nbreak ; \n} \n} \nif ( optimizeForLocalOnly && canUseLocalNode ) { \nservers . put ( iLocalNode , iClusterNames ) ; \nreturn servers ; \n} \nfinal Map < String , Collection < String > > serverMap = new HashMap < String , Collection < String > > ( ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nfor ( String s : serverList ) { \nif ( NEW_NODE_TAG . equalsIgnoreCase ( s ) ) { \ncontinue ; \n} \nCollection < String > clustersInServer = serverMap . get ( s ) ; \nif ( clustersInServer == null ) { \nclustersInServer = new HashSet < String > ( ) ; \nserverMap . put ( s , clustersInServer ) ; \n} \nclustersInServer . add ( p ) ; \n} \n} \nif ( serverMap . size ( ) == 1 ) { \nreturn serverMap ; \n} \nif ( ! optimizeForLocalOnly ) { \nreturn serverMap ; \n} \nfinal List < String > orderedServers = new ArrayList < String > ( serverMap . keySet ( ) ) ; \nCollections . sort ( orderedServers , new Comparator < String > ( ) { \n@ Override public int compare ( final String o1 , final String o2 ) { \nreturn ( ( Integer ) serverMap . get ( o2 ) . size ( ) ) . compareTo ( ( Integer ) serverMap . get ( o1 ) . size ( ) ) ; \n} \n} \n) ; \nfinal Set < String > remainingClusters = new HashSet < String > ( iClusterNames ) ; \nfinal Set < String > includedClusters = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String s : orderedServers ) { \nfinal Collection < String > clusters = serverMap . get ( s ) ; \nif ( ! servers . isEmpty ( ) ) { \nclusters . removeAll ( includedClusters ) ; \n} \nservers . put ( s , clusters ) ; \nremainingClusters . removeAll ( clusters ) ; \nincludedClusters . addAll ( clusters ) ; \nif ( remainingClusters . isEmpty ( ) ) { \nbreak ; \n} \n} \nreturn servers ; \n} \n} \n"}
{"3089": "public class ODistributedConfiguration { \npublic Set < String > getServers ( Collection < String > iClusterNames ) { \nif ( iClusterNames == null || iClusterNames . isEmpty ( ) ) { \nreturn getAllConfiguredServers ( ) ; \n} \nfinal Set < String > partitions = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nfor ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) { \npartitions . add ( s ) ; \n} \n} \n} \nreturn partitions ; \n} \n} \n"}
{"3090": "public class ODistributedConfiguration { \npublic boolean isServerContainingAllClusters ( final String server , Collection < String > clusters ) { \nif ( clusters == null || clusters . isEmpty ( ) ) { \nclusters = DEFAULT_CLUSTER_NAME ; \n} \nfor ( String cluster : clusters ) { \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nif ( ! serverList . contains ( server ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"3091": "public class ODistributedConfiguration { \npublic boolean isServerContainingCluster ( final String server , String cluster ) { \nif ( cluster == null ) { \ncluster = ALL_WILDCARD ; \n} \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nreturn serverList . contains ( server ) ; \n} \nreturn true ; \n} \n} \n"}
{"3092": "public class ODistributedConfiguration { \npublic List < String > getMasterServers ( ) { \nfinal List < String > serverList = getClusterConfiguration ( null ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nList < String > masters = new ArrayList < String > ( serverList . size ( ) ) ; \nfor ( String s : serverList ) { \nif ( ! s . equals ( NEW_NODE_TAG ) ) { \nmasters . add ( s ) ; \n} \n} \nfinal ROLES defRole = getDefaultServerRole ( ) ; \nfinal ODocument servers = configuration . field ( SERVERS ) ; \nif ( servers != null ) { \nfor ( Iterator < String > it = masters . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nfinal String server = it . next ( ) ; \nfinal String roleAsString = servers . field ( server ) ; \nfinal ROLES role = roleAsString != null ? ROLES . valueOf ( roleAsString . toUpperCase ( Locale . ENGLISH ) ) : defRole ; \nif ( role != ROLES . MASTER ) { \nit . remove ( ) ; \n} \n} \n} \nreturn masters ; \n} \nreturn Collections . EMPTY_LIST ; \n} \n} \n"}
{"3093": "public class ODistributedConfiguration { \npublic Set < String > getAllConfiguredServers ( ) { \nfinal Set < String > servers = new HashSet < String > ( ) ; \nfor ( String p : getClusterNames ( ) ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nfor ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) { \nservers . add ( s ) ; \n} \n} \n} \nreturn servers ; \n} \n} \n"}
{"3094": "public class ODistributedConfiguration { \npublic Set < String > getClustersOnServer ( final String iNodeName ) { \nfinal Set < String > clusters = new HashSet < String > ( ) ; \nfor ( String cl : getClusterNames ( ) ) { \nfinal List < String > servers = getServers ( cl , null ) ; \nif ( servers . contains ( iNodeName ) ) { \nclusters . add ( cl ) ; \n} \n} \nreturn clusters ; \n} \n} \n"}
{"3095": "public class ODistributedConfiguration { \npublic Set < String > getClustersOwnedByServer ( final String iNodeName ) { \nfinal Set < String > clusters = new HashSet < String > ( ) ; \nfor ( String cl : getClusterNames ( ) ) { \nif ( iNodeName . equals ( getClusterOwner ( cl ) ) ) { \nclusters . add ( cl ) ; \n} \n} \nreturn clusters ; \n} \n} \n"}
{"3096": "public class ODistributedConfiguration { \npublic String getClusterOwner ( final String iClusterName ) { \nString owner ; \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nfinal ODocument cfg = iClusterName != null ? ( ODocument ) clusters . field ( iClusterName ) : null ; \nif ( cfg != null ) { \nowner = cfg . field ( OWNER ) ; \nif ( owner != null ) { \nreturn owner ; \n} \nfinal List < String > serverList = cfg . field ( SERVERS ) ; \nif ( serverList != null && ! serverList . isEmpty ( ) ) { \nowner = serverList . get ( 0 ) ; \nif ( NEW_NODE_TAG . equals ( owner ) && serverList . size ( ) > 1 ) { \nowner = serverList . get ( 1 ) ; \n} \n} \n} \nelse { \nreturn getClusterOwner ( ALL_WILDCARD ) ; \n} \nreturn owner ; \n} \n} \n"}
{"3097": "public class ODistributedConfiguration { \npublic String getConfiguredClusterOwner ( final String iClusterName ) { \nString owner = null ; \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nfinal ODocument cfg = clusters . field ( iClusterName ) ; \nif ( cfg != null ) { \nowner = cfg . field ( OWNER ) ; \n} \nreturn owner ; \n} \n} \n"}
{"3099": "public class ODistributedConfiguration { \npublic Set < String > getRegisteredServers ( ) { \nfinal ODocument servers = configuration . field ( SERVERS ) ; \nfinal Set < String > result = new HashSet < String > ( ) ; \nif ( servers != null ) { \nfor ( String s : servers . fieldNames ( ) ) result . add ( s ) ; \n} \nreturn result ; \n} \n} \n"}
{"3100": "public class ODistributedConfiguration { \npublic Set < String > getDataCenters ( ) { \nfinal ODocument dcs = configuration . field ( DCS ) ; \nif ( dcs == null ) { \nreturn Collections . EMPTY_SET ; \n} \nfinal Set < String > result = new HashSet < String > ( ) ; \nfor ( String dc : dcs . fieldNames ( ) ) { \nresult . add ( dc ) ; \n} \nreturn result ; \n} \n} \n"}
{"3102": "public class ODistributedConfiguration { \npublic boolean isSharded ( ) { \nfinal ODocument allCluster = getClusterConfiguration ( ALL_WILDCARD ) ; \nif ( allCluster != null ) { \nfinal List < String > allServers = allCluster . field ( SERVERS ) ; \nif ( allServers != null && ! allServers . isEmpty ( ) ) { \nfor ( String cl : getClusterNames ( ) ) { \nfinal List < String > servers = getServers ( cl , null ) ; \nif ( servers != null && ! servers . isEmpty ( ) && ! allServers . containsAll ( servers ) ) { \nreturn false ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3103": "public class ODistributedConfiguration { \npublic List < String > getDataCenterServers ( final String dataCenter ) { \nfinal ODocument dc = getDataCenterConfiguration ( dataCenter ) ; \nfinal List < String > servers = dc . field ( SERVERS ) ; \nif ( servers == null || servers . isEmpty ( ) ) { \nthrow new OConfigurationException ( \"Data center '\" + dataCenter + \"' does not contain any server in distributed database configuration\" ) ; \n} \nreturn new ArrayList < String > ( servers ) ; \n} \n} \n"}
{"3104": "public class ODistributedConfiguration { \npublic String getDataCenterOfServer ( final String server ) { \nfinal ODocument dcs = configuration . field ( DCS ) ; \nif ( dcs != null ) { \nfor ( String dc : dcs . fieldNames ( ) ) { \nfinal ODocument dcConfig = dcs . field ( dc ) ; \nif ( dcConfig != null ) { \nfinal List < String > dcServers = dcConfig . field ( \"servers\" ) ; \nif ( dcServers != null && ! dcServers . isEmpty ( ) ) { \nif ( dcServers . contains ( server ) ) { \nreturn dc ; \n} \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3105": "public class ODistributedConfiguration { \npublic Object getGlobalReadQuorum ( final String iClusterName ) { \nObject value = getClusterConfiguration ( iClusterName ) . field ( READ_QUORUM ) ; \nif ( value == null ) { \nvalue = configuration . field ( READ_QUORUM ) ; \n} \nreturn value ; \n} \n} \n"}
{"3106": "public class ODistributedConfiguration { \npublic int getWriteQuorum ( final String clusterName , final int totalConfiguredMasterServers , final String server ) { \nInteger overWrite = overwriteWriteQuorum . get ( ) ; \nif ( overWrite != null ) { \nreturn overWrite . intValue ( ) ; \n} \nelse { \nreturn getQuorum ( \"writeQuorum\" , clusterName , totalConfiguredMasterServers , DEFAULT_WRITE_QUORUM , server ) ; \n} \n} \n} \n"}
{"3107": "public class ODistributedConfiguration { \nprotected ODocument getClusterConfiguration ( String iClusterName ) { \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nif ( iClusterName == null ) { \niClusterName = ALL_WILDCARD ; \n} \nfinal ODocument cfg ; \nif ( ! clusters . containsField ( iClusterName ) ) { \ncfg = clusters . field ( ALL_WILDCARD ) ; \n} \nelse { \ncfg = clusters . field ( iClusterName ) ; \n} \nif ( cfg == null ) { \nreturn new ODocument ( ) ; \n} \nreturn cfg ; \n} \n} \n"}
{"3108": "public class ODistributedConfiguration { \nprivate ODocument getDataCenterConfiguration ( final String dataCenter ) { \nfinal ODocument dcs = configuration . field ( DCS ) ; \nif ( dcs != null ) { \nreturn dcs . field ( dataCenter ) ; \n} \nthrow new OConfigurationException ( \"Cannot find the data center '\" + dataCenter + \"' in distributed database configuration\" ) ; \n} \n} \n"}
{"3109": "public class OrientBaseGraph { \npublic static void clearInitStack ( ) { \nfinal ThreadLocal < Deque < OrientBaseGraph > > is = initializationStack ; \nif ( is != null ) { \nis . get ( ) . clear ( ) ; \n} \nfinal ThreadLocal < OrientBaseGraph > ag = activeGraph ; \nif ( ag != null ) { \nag . remove ( ) ; \n} \n} \n} \n"}
{"3110": "public class OrientBaseGraph { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < T extends Element > Index < T > getIndex ( final String indexName , final Class < T > indexClass ) { \nmakeActive ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex idx = indexManager . getIndex ( indexName ) ; \nif ( idx == null || ! hasIndexClass ( idx ) ) { \nreturn null ; \n} \nfinal Index < ? extends Element > index = new OrientIndex ( this , idx ) ; \nif ( indexClass . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nreturn ( Index < T > ) index ; \n} \nelse { \nthrow ExceptionFactory . indexDoesNotSupportClass ( indexName , indexClass ) ; \n} \n} \n} \n"}
{"3111": "public class OrientBaseGraph { \npublic void dropIndex ( final String indexName ) { \nmakeActive ( ) ; \nexecuteOutsideTx ( new OCallable < Object , OrientBaseGraph > ( ) { \n@ Override public Object call ( OrientBaseGraph g ) { \ntry { \nfinal OIndexManager indexManager = getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex index = indexManager . getIndex ( indexName ) ; \nODocument metadata = index . getConfiguration ( ) . field ( \"metadata\" ) ; \nString recordMapIndexName = null ; \nif ( metadata != null ) { \nrecordMapIndexName = metadata . field ( OrientIndex . CONFIG_RECORD_MAP_NAME ) ; \n} \nindexManager . dropIndex ( indexName ) ; \nif ( recordMapIndexName != null ) { \ngetRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( recordMapIndexName ) ; \n} \nsaveIndexConfiguration ( ) ; \nreturn null ; \n} \ncatch ( Exception e ) { \ng . rollback ( ) ; \nthrow new RuntimeException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n, \"drop index '\" , indexName , \"'\" ) ; \n} \n} \n"}
{"3113": "public class OrientBaseGraph { \n@ Override public OrientEdge addEdge ( final Object id , Vertex outVertex , Vertex inVertex , final String label ) { \nmakeActive ( ) ; \nString className = null ; \nString clusterName = null ; \nif ( id != null ) { \nif ( id instanceof String ) { \nfinal String [ ] args = ( ( String ) id ) . split ( \",\" ) ; \nfor ( String s : args ) { \nif ( s . startsWith ( CLASS_PREFIX ) ) { \nclassName = s . substring ( CLASS_PREFIX . length ( ) ) ; \n} \nelse if ( s . startsWith ( CLUSTER_PREFIX ) ) { \nclusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; \n} \n} \n} \n} \nfinal Object [ ] fields = isSaveOriginalIds ( ) && id != null ? new Object [ ] { \nOrientElement . DEF_ORIGINAL_ID_FIELDNAME , id } \n: null ; \nif ( outVertex instanceof PartitionVertex ) { \noutVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; \n} \nif ( inVertex instanceof PartitionVertex ) { \ninVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; \n} \nreturn ( ( OrientVertex ) outVertex ) . addEdge ( label , ( OrientVertex ) inVertex , className , clusterName , fields ) ; \n} \n} \n"}
{"3114": "public class OrientBaseGraph { \npublic OrientVertex getVertex ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) { \nthrow ExceptionFactory . vertexIdCanNotBeNull ( ) ; \n} \nif ( id instanceof OrientVertex ) { \nreturn ( OrientVertex ) id ; \n} \nelse if ( id instanceof ODocument ) { \nreturn getVertexInstance ( ( OIdentifiable ) id ) ; \n} \nsetCurrentGraphInThreadLocal ( ) ; \nORID rid ; \nif ( id instanceof OIdentifiable ) { \nrid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; \n} \nelse { \ntry { \nrid = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nif ( ! rid . isValid ( ) ) { \nreturn null ; \n} \nfinal ORecord rec = rid . getRecord ( ) ; \nif ( rec == null || ! ( rec instanceof ODocument ) ) { \nreturn null ; \n} \nfinal OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; \nif ( cls != null && cls . isEdgeType ( ) ) { \nthrow new IllegalArgumentException ( \"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\" ) ; \n} \nreturn getVertexInstance ( rec ) ; \n} \n} \n"}
{"3115": "public class OrientBaseGraph { \npublic Iterable < Vertex > getVerticesOfClass ( final String iClassName , final boolean iPolymorphic ) { \nmakeActive ( ) ; \nfinal OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( cls == null ) { \nthrow new IllegalArgumentException ( \"Cannot find class '\" + iClassName + \"' in database schema\" ) ; \n} \nif ( ! cls . isSubClassOf ( OrientVertexType . CLASS_NAME ) ) { \nthrow new IllegalArgumentException ( \"Class '\" + iClassName + \"' is not a vertex class\" ) ; \n} \nreturn new OrientElementScanIterable < Vertex > ( this , iClassName , iPolymorphic ) ; \n} \n} \n"}
{"3116": "public class OrientBaseGraph { \npublic Iterable < Edge > getEdgesOfClass ( final String iClassName , final boolean iPolymorphic ) { \nmakeActive ( ) ; \nfinal OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( cls == null ) { \nthrow new IllegalArgumentException ( \"Cannot find class '\" + iClassName + \"' in database schema\" ) ; \n} \nif ( ! cls . isSubClassOf ( OrientEdgeType . CLASS_NAME ) ) { \nthrow new IllegalArgumentException ( \"Class '\" + iClassName + \"' is not an edge class\" ) ; \n} \nreturn new OrientElementScanIterable < Edge > ( this , iClassName , iPolymorphic ) ; \n} \n} \n"}
{"3117": "public class OrientBaseGraph { \npublic OrientEdge getEdge ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) { \nthrow ExceptionFactory . edgeIdCanNotBeNull ( ) ; \n} \nif ( id instanceof OrientEdge ) { \nreturn ( OrientEdge ) id ; \n} \nelse if ( id instanceof ODocument ) { \nreturn new OrientEdge ( this , ( OIdentifiable ) id ) ; \n} \nfinal OIdentifiable rec ; \nif ( id instanceof OIdentifiable ) { \nrec = ( OIdentifiable ) id ; \n} \nelse { \nfinal String str = id . toString ( ) ; \nint pos = str . indexOf ( \"->\" ) ; \nif ( pos > - 1 ) { \nfinal String from = str . substring ( 0 , pos ) ; \nfinal String to = str . substring ( pos + 2 ) ; \nreturn getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; \n} \ntry { \nrec = new ORecordId ( str ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc == null ) { \nreturn null ; \n} \nfinal OClass cls = doc . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isVertexType ( ) ) { \nthrow new IllegalArgumentException ( \"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\" ) ; \n} \nif ( ! cls . isEdgeType ( ) ) { \nthrow new IllegalArgumentException ( \"Class '\" + doc . getClassName ( ) + \"' is not an edge class\" ) ; \n} \n} \nreturn new OrientEdge ( this , rec ) ; \n} \n} \n"}
{"3119": "public class OrientBaseGraph { \npublic void shutdown ( boolean closeDb , boolean commitTx ) { \nmakeActive ( ) ; \ntry { \nif ( ! isClosed ( ) ) { \nif ( commitTx ) { \nfinal OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; \nif ( storage instanceof OAbstractPaginatedStorage ) { \nif ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) { \ngetDatabase ( ) . commit ( ) ; \n} \n} \nelse { \ngetDatabase ( ) . commit ( ) ; \n} \n} \nelse if ( closeDb ) { \ngetDatabase ( ) . rollback ( ) ; \n} \n} \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow e ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during context close for db \" + url ) , e ) ; \n} \nfinally { \ntry { \nif ( closeDb ) { \ngetDatabase ( ) . close ( ) ; \nif ( getDatabase ( ) . isPooled ( ) ) { \ndatabase = null ; \n} \n} \npollGraphFromStack ( closeDb ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \n} \n} \nurl = null ; \nusername = null ; \npassword = null ; \nif ( ! closeDb ) { \ngetDatabase ( ) . activateOnCurrentThread ( ) ; \n} \n} \n} \n"}
{"3121": "public class OrientBaseGraph { \npublic OrientVertexType getVertexType ( final String iTypeName ) { \nmakeActive ( ) ; \nfinal OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iTypeName ) ; \nif ( cls == null ) { \nreturn null ; \n} \nOrientVertexType . checkType ( cls ) ; \nreturn new OrientVertexType ( this , cls ) ; \n} \n} \n"}
{"3123": "public class OrientBaseGraph { \npublic void dropVertexType ( final String iTypeName ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . countClass ( iTypeName ) > 0 ) { \nthrow new OCommandExecutionException ( \"cannot drop vertex type '\" + iTypeName + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\" ) ; \n} \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nODatabaseDocument rawGraph = getRawGraph ( ) ; \nrawGraph . getMetadata ( ) . getSchema ( ) . dropClass ( iTypeName ) ; \nreturn null ; \n} \n} \n, \"drop vertex type '\" , iTypeName , \"'\" ) ; \n} \n} \n"}
{"3124": "public class OrientBaseGraph { \npublic OrientEdgeType getEdgeType ( final String iTypeName ) { \nmakeActive ( ) ; \nfinal OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iTypeName ) ; \nif ( cls == null ) { \nreturn null ; \n} \nOrientEdgeType . checkType ( cls ) ; \nreturn new OrientEdgeType ( this , cls ) ; \n} \n} \n"}
{"3126": "public class OrientBaseGraph { \npublic OrientElement getElement ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) { \nthrow new IllegalArgumentException ( \"id cannot be null\" ) ; \n} \nif ( id instanceof OrientElement ) { \nreturn ( OrientElement ) id ; \n} \nOIdentifiable rec ; \nif ( id instanceof OIdentifiable ) { \nrec = ( OIdentifiable ) id ; \n} \nelse { \ntry { \nrec = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc != null ) { \nfinal OImmutableClass schemaClass = ODocumentInternal . getImmutableSchemaClass ( doc ) ; \nif ( schemaClass != null && schemaClass . isEdgeType ( ) ) { \nreturn getEdge ( doc ) ; \n} \nelse { \nreturn getVertexInstance ( doc ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3127": "public class OrientBaseGraph { \npublic < T extends Element > void dropKeyIndex ( final String key , final Class < T > elementClass ) { \nmakeActive ( ) ; \nif ( elementClass == null ) { \nthrow ExceptionFactory . classForElementCannotBeNull ( ) ; \n} \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nfinal String className = getClassName ( elementClass ) ; \ngetRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( className + \".\" + key ) ; \nreturn null ; \n} \n} \n, \"drop key index '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \n} \n} \n"}
{"3128": "public class OrientBaseGraph { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) @ Override public < T extends Element > void createKeyIndex ( final String key , final Class < T > elementClass , final Parameter ... indexParameters ) { \nmakeActive ( ) ; \nif ( elementClass == null ) { \nthrow ExceptionFactory . classForElementCannotBeNull ( ) ; \n} \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nString indexType = OClass . INDEX_TYPE . NOTUNIQUE . name ( ) ; \nOType keyType = OType . STRING ; \nString className = null ; \nString collate = null ; \nODocument metadata = null ; \nfinal String ancestorClassName = getClassName ( elementClass ) ; \nfor ( Parameter < ? , ? > p : indexParameters ) { \nif ( p . getKey ( ) . equals ( \"type\" ) ) { \nindexType = p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ; \n} \nelse if ( p . getKey ( ) . equals ( \"keytype\" ) ) { \nkeyType = OType . valueOf ( p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \n} \nelse if ( p . getKey ( ) . equals ( \"class\" ) ) { \nclassName = p . getValue ( ) . toString ( ) ; \n} \nelse if ( p . getKey ( ) . equals ( \"collate\" ) ) { \ncollate = p . getValue ( ) . toString ( ) ; \n} \nelse if ( p . getKey ( ) . toString ( ) . startsWith ( \"metadata.\" ) ) { \nif ( metadata == null ) { \nmetadata = new ODocument ( ) ; \n} \nmetadata . field ( p . getKey ( ) . toString ( ) . substring ( \"metadata.\" . length ( ) ) , p . getValue ( ) ) ; \n} \n} \nif ( className == null ) { \nclassName = ancestorClassName ; \n} \nfinal ODatabaseDocument db = getRawGraph ( ) ; \nfinal OSchema schema = db . getMetadata ( ) . getSchema ( ) ; \nfinal OClass cls = schema . getOrCreateClass ( className , schema . getClass ( ancestorClassName ) ) ; \nfinal OProperty property = cls . getProperty ( key ) ; \nif ( property != null ) { \nkeyType = property . getType ( ) ; \n} \nOPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition ( className , key , keyType ) ; \nif ( collate != null ) { \nindexDefinition . setCollate ( collate ) ; \n} \ndb . getMetadata ( ) . getIndexManager ( ) . createIndex ( className + \".\" + key , indexType , indexDefinition , cls . getPolymorphicClusterIds ( ) , null , metadata ) ; \nreturn null ; \n} \n} \n, \"create key index on '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \n} \n} \n"}
{"3134": "public class OPerformanceStatisticManager { \nprivate WritCacheCountersHolder fetchWriteCacheCounters ( ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nWritCacheCountersHolder holder = null ; \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nif ( snapshot . writCacheCountersHolder != null ) { \nif ( holder == null ) { \nholder = new WritCacheCountersHolder ( ) ; \n} \nsnapshot . writCacheCountersHolder . pushData ( holder ) ; \n} \n} \nelse { \nthreadsToRemove . add ( thread ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal WritCacheCountersHolder wch = ds . writCacheCountersHolder ; \nif ( wch != null ) { \nif ( holder == null ) { \nholder = new WritCacheCountersHolder ( ) ; \n} \nwch . pushData ( holder ) ; \n} \n} \nreturn holder ; \n} \n} \n"}
{"3136": "public class OPerformanceStatisticManager { \nprivate void fetchComponentCounters ( String componentName , PerformanceCountersHolder componentCountersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal List < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nfinal PerformanceCountersHolder holder = snapshot . countersByComponent . get ( componentName ) ; \nif ( holder != null ) { \nholder . pushData ( componentCountersHolder ) ; \n} \n} \nelse { \nthreadsToRemove . add ( thread ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersByComponents . get ( componentName ) ; \nif ( dch != null ) { \ndch . pushData ( componentCountersHolder ) ; \n} \n} \n} \n} \n"}
{"3138": "public class OServerConfiguration { \npublic String getProperty ( final String iName , final String iDefaultValue ) { \nif ( properties == null ) { \nreturn null ; \n} \nfor ( OServerEntryConfiguration p : properties ) { \nif ( p . name . equals ( iName ) ) { \nreturn p . value ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3140": "public class OObjectDatabaseTx { \npublic int getVersion ( final Object iPojo ) { \ncheckOpenness ( ) ; \nfinal ODocument record = getRecordByUserObject ( iPojo , false ) ; \nif ( record != null ) { \nreturn record . getVersion ( ) ; \n} \nreturn OObjectSerializerHelper . getObjectVersion ( iPojo ) ; \n} \n} \n"}
{"3142": "public class OObjectDatabaseTx { \npublic void setDirty ( final Object iPojo ) { \nif ( iPojo == null ) { \nreturn ; \n} \nfinal ODocument record = getRecordByUserObject ( iPojo , false ) ; \nif ( record == null ) { \nthrow new OObjectNotManagedException ( \"The object \" + iPojo + \" is not managed by current database\" ) ; \n} \nrecord . setDirty ( ) ; \n} \n} \n"}
{"3143": "public class OObjectDatabaseTx { \npublic void unsetDirty ( final Object iPojo ) { \nif ( iPojo == null ) { \nreturn ; \n} \nfinal ODocument record = getRecordByUserObject ( iPojo , false ) ; \nif ( record == null ) { \nreturn ; \n} \nORecordInternal . unsetDirty ( record ) ; \n} \n} \n"}
{"3146": "public class ODistributedResponseManagerImpl { \npublic List < String > getMissingNodes ( ) { \nsynchronousResponsesLock . lock ( ) ; \ntry { \nfinal List < String > missingNodes = new ArrayList < String > ( ) ; \nfor ( Map . Entry < String , Object > entry : responses . entrySet ( ) ) if ( entry . getValue ( ) == NO_RESPONSE ) { \nmissingNodes . add ( entry . getKey ( ) ) ; \n} \nreturn missingNodes ; \n} \nfinally { \nsynchronousResponsesLock . unlock ( ) ; \n} \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) { \nreturn true ; \n} \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) { \nbreak ; \n} \nif ( payload instanceof OConcurrentCreateException ) { \nbreak ; \n} \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) { \nsetQuorumResponse ( resp ) ; \n} \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3150": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getReceivedResponses ( ) { \nfinal List < ODistributedResponse > parsed = new ArrayList < ODistributedResponse > ( ) ; \nfor ( Object r : responses . values ( ) ) if ( r != NO_RESPONSE ) { \nparsed . add ( ( ODistributedResponse ) r ) ; \n} \nreturn parsed ; \n} \n} \n"}
{"3153": "public class OScriptManager { \npublic String getLibrary ( final ODatabase < ? > db , final String iLanguage ) { \nif ( db == null ) { \nreturn null ; \n} \nfinal StringBuilder code = new StringBuilder ( ) ; \nfinal Set < String > functions = db . getMetadata ( ) . getFunctionLibrary ( ) . getFunctionNames ( ) ; \nfor ( String fName : functions ) { \nfinal OFunction f = db . getMetadata ( ) . getFunctionLibrary ( ) . getFunction ( fName ) ; \nif ( f . getLanguage ( ) == null ) { \nthrow new OConfigurationException ( \"Database function '\" + fName + \"' has no language\" ) ; \n} \nif ( f . getLanguage ( ) . equalsIgnoreCase ( iLanguage ) ) { \nfinal String def = getFunctionDefinition ( f ) ; \nif ( def != null ) { \ncode . append ( def ) ; \ncode . append ( \"\\n\" ) ; \n} \n} \n} \nreturn code . length ( ) == 0 ? null : code . toString ( ) ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) { \nreturn false ; \n} \nif ( ! index . supportsOrderedIterations ( ) ) { \nreturn false ; \n} \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( int i = 0 ; \ni < endIndex ; \ni ++ ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) { \nreturn false ; \n} \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \nreturn false ; \n} \nfor ( int i = equalsFilterFields . size ( ) ; \ni < endIndex ; \ni ++ ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) { \nreturn false ; \n} \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) { \niTo = iText . length ( ) - 1 ; \n} \nif ( iFrom == - 1 ) { \niFrom = iText . length ( ) - 1 ; \n} \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse { \nescape = true ; \n} \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) { \nstringChar = ' ' ; \n} \n} \n} \nif ( c == iToFind && stringChar == ' ' ) { \nreturn i ; \n} \nif ( escape ) { \nescape = false ; \n} \n} \nif ( iFrom < iTo ) { \nif ( ++ i > iTo ) { \nbreak ; \n} \n} \nelse { \nif ( -- i < iFrom ) { \nbreak ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( iCurrentPosition < 0 ) { \nreturn - 1 ; \n} \nfinal int size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal int jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \nfor ( ; \niCurrentPosition < size ; \n++ iCurrentPosition ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \nfor ( int jumpIndex = 0 ; \njumpIndex < jumpCharSize ; \n++ jumpIndex ) { \nif ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nbreak ; \n} \n} \nreturn iCurrentPosition >= size ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3162": "public class OQueryAbstract { \npublic OQueryAbstract setFetchPlan ( final String fetchPlan ) { \nOFetchHelper . checkFetchPlanValid ( fetchPlan ) ; \nif ( fetchPlan != null && fetchPlan . length ( ) == 0 ) { \nthis . fetchPlan = null ; \n} \nelse { \nthis . fetchPlan = fetchPlan ; \n} \nreturn this ; \n} \n} \n"}
{"3163": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairRecord ( final ORecordId rid ) { \nif ( ! active ) { \nreturn ; \n} \nif ( rid == null || ! rid . isPersistent ( ) ) { \nreturn ; \n} \nif ( rid . getClusterPosition ( ) < - 1 ) { \nreturn ; \n} \nrecordProcessed . incrementAndGet ( ) ; \nrecords . put ( rid , Boolean . TRUE ) ; \n} \n} \n"}
{"3164": "public class OConflictResolverDatabaseRepairer { \n@ Override public void cancelRepairRecord ( final ORecordId rid ) { \nif ( ! active ) { \nreturn ; \n} \nif ( rid . getClusterPosition ( ) < - 1 ) { \nreturn ; \n} \nif ( records . remove ( rid ) != null ) { \nrecordCanceled . incrementAndGet ( ) ; \n} \n} \n} \n"}
{"3165": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairCluster ( final int clusterId ) { \nif ( ! active ) { \nreturn ; \n} \nif ( clusterId < - 1 ) { \nreturn ; \n} \nrecordProcessed . incrementAndGet ( ) ; \nclusters . put ( clusterId , Boolean . TRUE ) ; \n} \n} \n"}
{"3167": "public class OEntityManager { \npublic synchronized Object createPojo ( final String iClassName ) throws OConfigurationException { \nif ( iClassName == null ) { \nthrow new IllegalArgumentException ( \"Cannot create the object: class name is empty\" ) ; \n} \nfinal Class < ? > entityClass = classHandler . getEntityClass ( iClassName ) ; \ntry { \nif ( entityClass != null ) { \nreturn createInstance ( entityClass ) ; \n} \n} \ncatch ( Exception e ) { \nthrow OException . wrapException ( new OConfigurationException ( \"Error while creating new pojo of class '\" + iClassName + \"'\" ) , e ) ; \n} \ntry { \nreturn createInstance ( Class . forName ( iClassName ) ) ; \n} \ncatch ( Exception e ) { \nthrow OException . wrapException ( new OConfigurationException ( \"The class '\" + iClassName + \"' was not found between the entity classes. Ensure registerEntityClasses(package) has been called first\" ) , e ) ; \n} \n} \n} \n"}
{"3174": "public class OCommandExecutorSQLHASyncCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \ndatabase . checkSecurity ( ORule . ResourceGeneric . CLUSTER , \"sync\" , ORole . PERMISSION_UPDATE ) ; \nif ( ! ( database instanceof ODatabaseDocumentDistributed ) ) { \nthrow new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \n} \nfinal OHazelcastPlugin dManager = ( OHazelcastPlugin ) ( ( ODatabaseDocumentDistributed ) database ) . getDistributedManager ( ) ; \nif ( dManager == null || ! dManager . isEnabled ( ) ) { \nthrow new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \n} \nfinal String databaseName = database . getName ( ) ; \ntry { \nif ( this . parsedStatement . modeFull ) { \nreturn replaceCluster ( dManager , database , dManager . getServerInstance ( ) , databaseName , this . parsedStatement . clusterName . getStringValue ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nthrow OException . wrapException ( new OCommandExecutionException ( \"Cannot execute synchronization of cluster\" ) , e ) ; \n} \nreturn \"Mode not supported\" ; \n} \n} \n"}
{"3176": "public class OMemory { \npublic static void checkCacheMemoryConfiguration ( ) { \nfinal long maxHeapSize = Runtime . getRuntime ( ) . maxMemory ( ) ; \nfinal long maxCacheSize = getMaxCacheMemorySize ( ) ; \nfinal ONative . MemoryLimitResult physicalMemory = ONative . instance ( ) . getMemoryLimit ( false ) ; \nif ( maxHeapSize != Long . MAX_VALUE && physicalMemory != null && maxHeapSize + maxCacheSize > physicalMemory . memoryLimit ) { \nOLogManager . instance ( ) . warnNoDb ( OMemory . class , \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\" + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \" + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \" + \"lower memory requirements of the cache.\" ) ; \n} \n} \n} \n"}
{"3184": "public class OSymmetricKey { \nprotected static String separateAlgorithm ( final String cipherTransform ) { \nString [ ] array = cipherTransform . split ( \"/\" ) ; \nif ( array . length > 1 ) { \nreturn array [ 0 ] ; \n} \nreturn null ; \n} \n} \n"}
{"3186": "public class OSymmetricKey { \npublic static OSymmetricKey fromFile ( final String algorithm , final String path ) { \nString base64Key = null ; \ntry { \njava . io . FileInputStream fis = null ; \ntry { \nfis = new java . io . FileInputStream ( OSystemVariableResolver . resolveSystemVariables ( path ) ) ; \nreturn fromStream ( algorithm , fis ) ; \n} \nfinally { \nif ( fis != null ) { \nfis . close ( ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.fromFile() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \n} \n} \n"}
{"3188": "public class OSymmetricKey { \npublic String encrypt ( final String transform , final byte [ ] bytes ) { \nString encodedJSON = null ; \nif ( secretKey == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.encrypt() SecretKey is null\" ) ; \n} \nif ( transform == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.encrypt() Cannot determine cipher transformation\" ) ; \n} \ntry { \nCipher cipher = Cipher . getInstance ( transform ) ; \ncipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; \nbyte [ ] initVector = cipher . getIV ( ) ; \nbyte [ ] encrypted = cipher . doFinal ( bytes ) ; \nencodedJSON = encodeJSON ( encrypted , initVector ) ; \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.encrypt() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \nreturn encodedJSON ; \n} \n} \n"}
{"3189": "public class OSymmetricKey { \npublic void saveToStream ( final OutputStream os ) { \nif ( os == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.saveToStream() OutputStream is null\" ) ; \n} \ntry { \nfinal OutputStreamWriter osw = new OutputStreamWriter ( os ) ; \ntry { \nfinal BufferedWriter writer = new BufferedWriter ( osw ) ; \ntry { \nwriter . write ( getBase64Key ( ) ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \n} \nfinally { \nos . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.saveToStream() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \n} \n} \n"}
{"3190": "public class OSymmetricKey { \npublic void saveToKeystore ( final OutputStream os , final String ksPasswd , final String keyAlias , final String keyPasswd ) { \nif ( os == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.saveToKeystore() OutputStream is null\" ) ; \n} \nif ( ksPasswd == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.saveToKeystore() Keystore Password is required\" ) ; \n} \nif ( keyAlias == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.saveToKeystore() Key Alias is required\" ) ; \n} \nif ( keyPasswd == null ) { \nthrow new OSecurityException ( \"OSymmetricKey.saveToKeystore() Key Password is required\" ) ; \n} \ntry { \nKeyStore ks = KeyStore . getInstance ( \"JCEKS\" ) ; \nchar [ ] ksPasswdCA = ksPasswd . toCharArray ( ) ; \nchar [ ] keyPasswdCA = keyPasswd . toCharArray ( ) ; \nks . load ( null , ksPasswdCA ) ; \nKeyStore . ProtectionParameter protParam = new KeyStore . PasswordProtection ( keyPasswdCA ) ; \nKeyStore . SecretKeyEntry skEntry = new KeyStore . SecretKeyEntry ( secretKey ) ; \nks . setEntry ( keyAlias , skEntry , protParam ) ; \nks . store ( os , ksPasswdCA ) ; \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.saveToKeystore() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \n} \n} \n"}
{"3193": "public class ORecordSerializerJSON { \nprivate Object getValueAsObjectOrMap ( ODocument iRecord , String iFieldValue , OType iType , OType iLinkedType , Map < String , Character > iFieldTypes , boolean iNoMap , String iOptions ) { \nfinal String [ ] fields = OStringParser . getWords ( iFieldValue . substring ( 1 , iFieldValue . length ( ) - 1 ) , \":,\" , true ) ; \nif ( fields == null || fields . length == 0 ) { \nif ( iNoMap ) { \nODocument res = new ODocument ( ) ; \nODocumentInternal . addOwner ( res , iRecord ) ; \nreturn res ; \n} \nelse { \nreturn new HashMap < String , Object > ( ) ; \n} \n} \nif ( iNoMap || hasTypeField ( fields ) ) { \nreturn getValueAsRecord ( iRecord , iFieldValue , iType , iOptions , fields ) ; \n} \nelse { \nreturn getValueAsMap ( iRecord , iFieldValue , iLinkedType , iFieldTypes , false , iOptions , fields ) ; \n} \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null || iKey == null ) { \nreturn null ; \n} \nif ( iKey instanceof String ) { \nString iName = ( String ) iKey ; \nint pos = iName . indexOf ( '.' ) ; \nif ( pos > - 1 ) { \niName = iName . substring ( 0 , pos ) ; \n} \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) { \nreturn null ; \n} \nif ( pos > - 1 ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( value instanceof ODocument ) { \nreturn getFieldValue ( value , restFieldName ) ; \n} \nelse if ( value instanceof Map < ? , ? > ) { \nreturn getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \n} \n} \nreturn value ; \n} \nelse { \nreturn iMap . get ( iKey ) ; \n} \n} \n} \n"}
{"3196": "public class OIdentifiableIterator { \nprotected ORecord getRecord ( ) { \nfinal ORecord record ; \nif ( reusedRecord != null ) { \nrecord = reusedRecord ; \nrecord . reset ( ) ; \n} \nelse { \nrecord = null ; \n} \nreturn record ; \n} \n} \n"}
{"3197": "public class OIdentifiableIterator { \nprotected ORecord readCurrentRecord ( ORecord iRecord , final int iMovement ) { \nif ( limit > - 1 && browsedRecords >= limit ) { \nreturn null ; \n} \ndo { \nfinal boolean moveResult ; \nswitch ( iMovement ) { \ncase 1 : moveResult = nextPosition ( ) ; \nbreak ; \ncase - 1 : moveResult = prevPosition ( ) ; \nbreak ; \ncase 0 : moveResult = checkCurrentPosition ( ) ; \nbreak ; \ndefault : throw new IllegalStateException ( \"Invalid movement value : \" + iMovement ) ; \n} \nif ( ! moveResult ) { \nreturn null ; \n} \ntry { \nif ( iRecord != null ) { \nORecordInternal . setIdentity ( iRecord , new ORecordId ( current . getClusterId ( ) , current . getClusterPosition ( ) ) ) ; \niRecord = database . load ( iRecord , fetchPlan , false ) ; \n} \nelse { \niRecord = database . load ( current , fetchPlan , false ) ; \n} \n} \ncatch ( ODatabaseException e ) { \nif ( Thread . interrupted ( ) || database . isClosed ( ) ) { \nthrow e ; \n} \nif ( e . getCause ( ) instanceof OSecurityException ) { \nthrow e ; \n} \nbrokenRIDs . add ( current . copy ( ) ) ; \nOLogManager . instance ( ) . error ( this , \"Error on fetching record during browsing. The record has been skipped\" , e ) ; \n} \nif ( iRecord != null ) { \nbrowsedRecords ++ ; \nreturn iRecord ; \n} \n} \nwhile ( iMovement != 0 ) ; \nreturn null ; \n} \n} \n"}
{"3202": "public class OrientTransactionalGraph { \n@ SuppressWarnings ( \"deprecation\" ) @ Override public void stopTransaction ( final Conclusion conclusion ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . isClosed ( ) || getDatabase ( ) . getTransaction ( ) instanceof OTransactionNoTx || getDatabase ( ) . getTransaction ( ) . getStatus ( ) != TXSTATUS . BEGUN ) { \nreturn ; \n} \nif ( Conclusion . SUCCESS == conclusion ) { \ncommit ( ) ; \n} \nelse { \nrollback ( ) ; \n} \n} \n} \n"}
{"3203": "public class OrientSql { \nfinal public OStatement parse ( ) throws ParseException { \nOparse jjtn000 = new Oparse ( JJTPARSE ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \njjtn000 . jjtSetFirstToken ( getToken ( 1 ) ) ; \nOStatement result ; \ntry { \nresult = Statement ( ) ; \njj_consume_token ( 0 ) ; \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtc000 = false ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n{ \nif ( true ) { \nreturn result ; \n} \n} \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse { \njjtree . popNode ( ) ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) { \nthrow ( RuntimeException ) jjte000 ; \n} \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) { \nthrow ( ParseException ) jjte000 ; \n} \n} \n} \n{ \nif ( true ) { \nthrow ( Error ) jjte000 ; \n} \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n} \n} \nthrow new Error ( \"Missing return statement in function\" ) ; \n} \n} \n"}
{"3204": "public class OrientSql { \nfinal public Token getNextToken ( ) { \nif ( token . next != null ) { \ntoken = token . next ; \n} \nelse { \ntoken = token . next = token_source . getNextToken ( ) ; \n} \njj_ntk = - 1 ; \njj_gen ++ ; \nreturn token ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) { \nif ( t . next != null ) { \nt = t . next ; \n} \nelse { \nt = t . next = token_source . getNextToken ( ) ; \n} \n} \nreturn t ; \n} \n} \n"}
{"3207": "public class OrientVertex { \n@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { \nsetCurrentGraphInThreadLocal ( ) ; \nOrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; \nOrientBaseGraph . encodeClassNames ( iLabels ) ; \nfinal ODocument doc = getRecord ( ) ; \nfinal OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; \nfor ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { \nString fieldName = connectionField . getKey ( ) ; \nOPair < Direction , String > connection = connectionField . getValue ( ) ; \nfinal Object fieldValue = doc . rawField ( fieldName ) ; \nif ( fieldValue != null ) { \nif ( fieldValue instanceof OIdentifiable ) { \naddSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; \n} \nelse if ( fieldValue instanceof Collection < ? > ) { \nCollection < ? > coll = ( Collection < ? > ) fieldValue ; \nif ( coll . size ( ) == 1 ) { \nif ( coll instanceof ORecordLazyMultiValue ) { \naddSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; \n} \nelse if ( coll instanceof List < ? > ) { \naddSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; \n} \nelse { \naddSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; \n} \n} \nelse { \nif ( coll instanceof ORecordLazyMultiValue ) { \niterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; \n} \nelse { \niterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; \n} \n} \n} \nelse if ( fieldValue instanceof ORidBag ) { \niterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; \n} \n} \n} \nreturn iterable ; \n} \n} \n"}
{"3208": "public class OrientVertex { \n@ Override public void remove ( ) { \ncheckClass ( ) ; \nfinal OrientBaseGraph graph = checkIfAttached ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nfinal ODocument doc = getRecord ( ) ; \nif ( doc == null ) { \nthrow ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; \n} \nMap < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; \nif ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) { \nfor ( String fieldName : doc . fieldNames ( ) ) { \nfinal OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; \nif ( connection == null ) { \ncontinue ; \n} \nObject fv = doc . field ( fieldName ) ; \nif ( fv instanceof ORidBag && ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { \nList < ODocument > docs = new ArrayList < ODocument > ( ) ; \nfor ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; \ntreeRidbagEdgesToRemove . put ( fieldName , docs ) ; \n} \n} \n} \nsuper . removeRecord ( ) ; \nfinal Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; \nif ( it . hasNext ( ) ) { \nfinal Set < Edge > allEdges = new HashSet < Edge > ( ) ; \nfor ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Index < ? extends Element > index = it . next ( ) ; \nif ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; \nidx . removeElement ( this ) ; \n} \nif ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; \nfor ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { \ndoc . removeField ( entry . getKey ( ) ) ; \nIterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nODocument docEdge = iter . next ( ) ; \nOrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; \n} \n} \ngraph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; \n} \n} \n"}
{"3209": "public class OrientVertex { \n@ Override public Edge addEdge ( final String label , Vertex inVertex ) { \nif ( inVertex instanceof PartitionVertex ) { \ninVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; \n} \nreturn addEdge ( label , ( OrientVertex ) inVertex , null , null , ( Object [ ] ) null ) ; \n} \n} \n"}
{"3211": "public class OrientVertex { \npublic String getConnectionClass ( final Direction iDirection , final String iFieldName ) { \nif ( iDirection == Direction . OUT ) { \nif ( iFieldName . length ( ) > CONNECTION_OUT_PREFIX . length ( ) ) { \nreturn iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; \n} \n} \nelse if ( iDirection == Direction . IN ) { \nif ( iFieldName . length ( ) > CONNECTION_IN_PREFIX . length ( ) ) { \nreturn iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; \n} \n} \nreturn OrientEdgeType . CLASS_NAME ; \n} \n} \n"}
{"3212": "public class OrientVertex { \nprotected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { \nif ( iClassNames != null && iClassNames . length == 1 && iClassNames [ 0 ] . equalsIgnoreCase ( \"E\" ) ) { \niClassNames = null ; \n} \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( iDirection == Direction . OUT || iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) { \nreturn new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) { \nreturn new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) { \nreturn new OPair < Direction , String > ( Direction . OUT , null ) ; \n} \n} \nif ( iDirection == Direction . IN || iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) { \nreturn new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) { \nreturn new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) { \nreturn new OPair < Direction , String > ( Direction . IN , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3213": "public class ODatabaseImport { \nprivate void processBrokenRids ( Set < ORID > brokenRids ) throws IOException , ParseException { \nif ( exporterVersion >= 12 ) { \nlistener . onMessage ( \"Reading of set of RIDs of records which were detected as broken during database export\\n\" ) ; \njsonReader . readNext ( OJSONReader . BEGIN_COLLECTION ) ; \nwhile ( true ) { \njsonReader . readNext ( OJSONReader . NEXT_IN_ARRAY ) ; \nfinal ORecordId recordId = new ORecordId ( jsonReader . getValue ( ) ) ; \nbrokenRids . add ( recordId ) ; \nif ( jsonReader . lastChar ( ) == ']' ) { \nbreak ; \n} \n} \n} \nif ( migrateLinks ) { \nif ( exporterVersion >= 12 ) { \nlistener . onMessage ( brokenRids . size ( ) + \" were detected as broken during database export, links on those records will be removed from\" + \" result database\" ) ; \n} \nmigrateLinksInImportedDocuments ( brokenRids ) ; \n} \n} \n} \n"}
{"3214": "public class OConsoleApplication { \nprotected Map < Method , Object > getConsoleMethods ( ) { \nif ( methods != null ) { \nreturn methods ; \n} \nfinal Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; \nfinal Collection < Object > candidates = new ArrayList < Object > ( ) ; \ncandidates . add ( this ) ; \nwhile ( ite . hasNext ( ) ) { \ntry { \nfinal OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; \ncc . setContext ( this ) ; \ncandidates . add ( cc ) ; \n} \ncatch ( InstantiationException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \n} \nmethods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { \npublic int compare ( Method o1 , Method o2 ) { \nfinal ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; \nfinal ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; \nif ( ann1 != null && ann2 != null ) { \nif ( ann1 . priority ( ) != ann2 . priority ( ) ) { \nreturn ann1 . priority ( ) - ann2 . priority ( ) ; \n} \n} \nint res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; \nif ( res == 0 ) { \nres = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; \n} \nreturn res ; \n} \n} \n) ; \nfor ( final Object candidate : candidates ) { \nfinal Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; \nfor ( Method m : classMethods ) { \nif ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) { \ncontinue ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \ncontinue ; \n} \nmethods . put ( m , candidate ) ; \n} \n} \nreturn methods ; \n} \n} \n"}
{"3215": "public class ODistributedAbstractPlugin { \n@ Override public Object executeOnLocalNode ( final ODistributedRequestId reqId , final ORemoteTask task , final ODatabaseDocumentInternal database ) { \nif ( database != null && ! ( database . getStorage ( ) instanceof ODistributedStorage ) ) { \nthrow new ODistributedException ( \"Distributed storage was not installed for database '\" + database . getName ( ) + \"'. Implementation found: \" + database . getStorage ( ) . getClass ( ) . getName ( ) ) ; \n} \nfinal ODistributedAbstractPlugin manager = this ; \nreturn OScenarioThreadLocal . executeAsDistributed ( new Callable < Object > ( ) { \n@ Override public Object call ( ) throws Exception { \ntry { \nfinal Object result = task . execute ( reqId , serverInstance , manager , database ) ; \nif ( result instanceof Throwable && ! ( result instanceof OException ) ) { \nODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing request %d (%s) on local node: \" , ( Throwable ) result , reqId , task ) ; \n} \nelse { \nfinal String sourceNodeName = task . getNodeSource ( ) ; \nif ( database != null ) { \nfinal ODistributedDatabaseImpl ddb = getMessageService ( ) . getDatabase ( database . getName ( ) ) ; \nif ( ddb != null && ! ( result instanceof Throwable ) && task instanceof OAbstractReplicatedTask && ! task . isIdempotent ( ) ) { \nddb . setLSN ( sourceNodeName , ( ( OAbstractReplicatedTask ) task ) . getLastLSN ( ) , true ) ; \nddb . setLSN ( getLocalNodeName ( ) , ( ( OAbstractPaginatedStorage ) database . getStorage ( ) . getUnderlying ( ) ) . getLSN ( ) , true ) ; \n} \n} \n} \nreturn result ; \n} \ncatch ( InterruptedException e ) { \nODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Interrupted execution on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \nreturn e ; \n} \ncatch ( Exception e ) { \nif ( ! ( e instanceof OException ) ) { \nODistributedServerLog . error ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \n} \nreturn e ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3216": "public class ODistributedAbstractPlugin { \n@ Override public int getNodesWithStatus ( final Collection < String > iNodes , final String databaseName , final DB_STATUS ... statuses ) { \nfor ( Iterator < String > it = iNodes . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nfinal String node = it . next ( ) ; \nif ( ! isNodeStatusEqualsTo ( node , databaseName , statuses ) ) { \nit . remove ( ) ; \n} \n} \nreturn iNodes . size ( ) ; \n} \n} \n"}
{"3220": "public class OHttpRequestWrapper { \npublic int hasParameters ( final String ... iNames ) { \nint found = 0 ; \nif ( iNames != null && request . parameters != null ) { \nfor ( String name : iNames ) found += request . parameters . containsKey ( name ) ? 1 : 0 ; \n} \nreturn found ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse { \ncollatesList . add ( null ) ; \n} \n} \n} \nif ( fields == null || fields . length == 0 ) { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( keyTypes != null ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \n} \nelse if ( serializerKeyId != 0 ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \n} \nelse { \nif ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) { \nthrow new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse { \nfieldTypeList = Arrays . asList ( keyTypes ) ; \n} \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \n} \nif ( idx != null ) { \nreturn idx . getSize ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"3230": "public class OGraphCommandExecutorSQLFactory { \npublic static OrientGraph getGraph ( final boolean autoStartTx , OModifiableBoolean shouldBeShutDown ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nfinal OrientBaseGraph result = OrientBaseGraph . getActiveGraph ( ) ; \nif ( result != null && ( result instanceof OrientGraph ) ) { \nfinal ODatabaseDocumentInternal graphDb = result . getRawGraph ( ) ; \nif ( canReuseActiveGraph ( graphDb , database ) ) { \nif ( ! graphDb . isClosed ( ) ) { \nODatabaseRecordThreadLocal . instance ( ) . set ( graphDb ) ; \nif ( autoStartTx && autoTxStartRequired ( graphDb ) ) { \n( ( OrientGraph ) result ) . begin ( ) ; \n} \nshouldBeShutDown . setValue ( false ) ; \nreturn ( OrientGraph ) result ; \n} \n} \n} \nODatabaseRecordThreadLocal . instance ( ) . set ( database ) ; \nshouldBeShutDown . setValue ( true ) ; \nfinal OrientGraph g = ( OrientGraph ) OrientGraphFactory . getTxGraphImplFactory ( ) . getGraph ( database , false ) ; \nif ( autoStartTx && autoTxStartRequired ( database ) ) { \ng . begin ( ) ; \n} \nreturn g ; \n} \n} \n"}
{"3231": "public class OCommandExecutorSQLRetryAbstract { \nprotected void parseRetry ( ) throws OCommandSQLParsingException { \nretry = Integer . parseInt ( parserNextWord ( true ) ) ; \nString temp = parseOptionalWord ( true ) ; \nif ( temp . equals ( \"WAIT\" ) ) { \nwait = Integer . parseInt ( parserNextWord ( true ) ) ; \n} \nelse { \nparserGoBack ( ) ; \n} \n} \n} \n"}
{"3232": "public class OTransactionNoTx { \npublic ORecord saveRecord ( final ORecord iRecord , final String iClusterName , final OPERATION_MODE iMode , boolean iForceCreate , final ORecordCallback < ? extends Number > iRecordCreatedCallback , ORecordCallback < Integer > iRecordUpdatedCallback ) { \ntry { \nreturn database . saveAll ( iRecord , iClusterName , iMode , iForceCreate , iRecordCreatedCallback , iRecordUpdatedCallback ) ; \n} \ncatch ( Exception e ) { \nfinal ORecordId rid = ( ORecordId ) iRecord . getIdentity ( ) ; \nif ( rid . isValid ( ) ) { \ndatabase . getLocalCache ( ) . freeRecord ( rid ) ; \n} \nif ( e instanceof ONeedRetryException ) { \nthrow ( ONeedRetryException ) e ; \n} \nthrow OException . wrapException ( new ODatabaseException ( \"Error during saving of record\" + ( iRecord != null ? \" with rid \" + iRecord . getIdentity ( ) : \"\" ) ) , e ) ; \n} \n} \n} \n"}
{"3233": "public class OTransactionNoTx { \npublic void deleteRecord ( final ORecord iRecord , final OPERATION_MODE iMode ) { \nif ( ! iRecord . getIdentity ( ) . isPersistent ( ) ) { \nreturn ; \n} \ntry { \ndatabase . executeDeleteRecord ( iRecord , iRecord . getVersion ( ) , true , iMode , false ) ; \n} \ncatch ( Exception e ) { \nfinal ORecordId rid = ( ORecordId ) iRecord . getIdentity ( ) ; \nif ( rid . isValid ( ) ) { \ndatabase . getLocalCache ( ) . freeRecord ( rid ) ; \n} \nif ( e instanceof RuntimeException ) { \nthrow ( RuntimeException ) e ; \n} \nthrow OException . wrapException ( new ODatabaseException ( \"Error during deletion of record\" + ( iRecord != null ? \" with rid \" + iRecord . getIdentity ( ) : \"\" ) ) , e ) ; \n} \n} \n} \n"}
{"3234": "public class OSecurityAuthenticatorAbstract { \npublic String getAuthenticationHeader ( String databaseName ) { \nString header ; \nif ( databaseName != null ) { \nheader = \"WWW-Authenticate: Basic realm=\\\"OrientDB db-\" + databaseName + \"\\\"\" ; \n} \nelse { \nheader = \"WWW-Authenticate: Basic realm=\\\"OrientDB Server\\\"\" ; \n} \nreturn header ; \n} \n} \n"}
{"3235": "public class OSystemUserAuthenticator { \npublic String authenticate ( final String username , final String password ) { \nString principal = null ; \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nif ( user . checkPassword ( password ) ) { \nprincipal = username ; \n} \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"authenticate()\" , ex ) ; \n} \nreturn principal ; \n} \n} \n"}
{"3236": "public class OSystemUserAuthenticator { \npublic boolean isAuthorized ( final String username , final String resource ) { \nif ( username == null || resource == null ) { \nreturn false ; \n} \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nORole role = null ; \nORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; \nif ( rg != null ) { \nString specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; \nif ( specificResource == null || specificResource . equals ( \"*\" ) ) { \nspecificResource = null ; \n} \nrole = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; \n} \nreturn role != null ; \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"isAuthorized()\" , ex ) ; \n} \nreturn false ; \n} \n} \n"}
{"3237": "public class OServerShutdownHook { \n@ Override public void run ( ) { \nif ( server != null ) { \nif ( ! server . shutdown ( ) ) { \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( bufpos >= tokenBegin ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i ++ < len ) { \nif ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) { \nbufline [ j ] = newLine ++ ; \n} \nelse { \nbufline [ j ] = newLine ; \n} \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3246": "public class OLogManager { \npublic void shutdown ( ) { \nif ( shutdownFlag . compareAndSet ( false , true ) ) { \ntry { \nif ( LogManager . getLogManager ( ) instanceof ShutdownLogManager ) { \n( ( ShutdownLogManager ) LogManager . getLogManager ( ) ) . shutdown ( ) ; \n} \n} \ncatch ( NoClassDefFoundError ignore ) { \n} \n} \n} \n} \n"}
{"3247": "public class OClosableLinkedContainer { \npublic void add ( K key , V item ) throws InterruptedException { \nif ( ! item . isOpen ( ) ) { \nthrow new IllegalArgumentException ( \"All passed in items should be in open state\" ) ; \n} \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > closableEntry = new OClosableEntry < K , V > ( item ) ; \nfinal OClosableEntry < K , V > oldEntry = data . putIfAbsent ( key , closableEntry ) ; \nif ( oldEntry != null ) { \nthrow new IllegalStateException ( \"Item with key \" + key + \" already exists\" ) ; \n} \nlogAdd ( closableEntry ) ; \n} \n} \n"}
{"3249": "public class OClosableLinkedContainer { \npublic OClosableEntry < K , V > acquire ( K key ) throws InterruptedException { \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) { \nreturn null ; \n} \nboolean logOpen = false ; \nentry . acquireStateLock ( ) ; \ntry { \nif ( entry . isRetired ( ) || entry . isDead ( ) ) { \nreturn null ; \n} \nelse if ( entry . isClosed ( ) ) { \nentry . makeAcquiredFromClosed ( entry . get ( ) ) ; \nlogOpen = true ; \n} \nelse if ( entry . isOpen ( ) ) { \nentry . makeAcquiredFromOpen ( ) ; \n} \nelse { \nentry . incrementAcquired ( ) ; \n} \n} \nfinally { \nentry . releaseStateLock ( ) ; \n} \nif ( logOpen ) { \nlogOpen ( entry ) ; \n} \nelse { \nlogAcquire ( entry ) ; \n} \nassert entry . get ( ) . isOpen ( ) ; \nreturn entry ; \n} \n} \n"}
{"3250": "public class OClosableLinkedContainer { \npublic V get ( K key ) { \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry != null ) { \nreturn entry . get ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \ni < READ_BUFFER_SIZE ; \ni ++ ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) { \n; \n} \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3252": "public class OClosableLinkedContainer { \npublic boolean close ( K key ) { \nemptyBuffers ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) { \nreturn true ; \n} \nif ( entry . makeClosed ( ) ) { \ncountClosedFiles ( ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) { \nbreak ; \n} \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \n} \n} \n"}
{"3259": "public class OObjectEnumLazyMap { \nprivate void convert ( final Object iKey ) { \nif ( converted ) { \nreturn ; \n} \nif ( super . containsKey ( iKey ) ) { \nreturn ; \n} \nObject o = underlying . get ( String . valueOf ( iKey ) ) ; \nif ( o instanceof Number ) { \nsuper . put ( iKey , enumClass . getEnumConstants ( ) [ ( ( Number ) o ) . intValue ( ) ] ) ; \n} \nelse { \nsuper . put ( iKey , Enum . valueOf ( enumClass , o . toString ( ) ) ) ; \n} \n} \n} \n"}
{"3260": "public class OObjectEnumLazyMap { \nprotected void convertAll ( ) { \nif ( converted ) { \nreturn ; \n} \nfor ( java . util . Map . Entry < Object , Object > e : underlying . entrySet ( ) ) { \nif ( e . getValue ( ) instanceof Number ) { \nsuper . put ( e . getKey ( ) , enumClass . getEnumConstants ( ) [ ( ( Number ) e . getValue ( ) ) . intValue ( ) ] ) ; \n} \nelse { \nsuper . put ( e . getKey ( ) , Enum . valueOf ( enumClass , e . getValue ( ) . toString ( ) ) ) ; \n} \n} \nconverted = true ; \n} \n} \n"}
{"3265": "public class OProfileStorageStatement { \n@ Override public Object execute ( OSQLAsynchQuery < ODocument > request , OCommandContext context , OProgressListener progressListener ) { \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nfinal OStorage storage = db . getStorage ( ) ; \nif ( on ) { \n( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"OK\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \nelse { \nfinal OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; \nif ( performanceStatistic != null ) { \nrequest . getResultListener ( ) . result ( performanceStatistic . toDocument ( ) ) ; \n} \nelse { \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"Error: profiling of storage was not started.\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \n} \nreturn getResult ( request ) ; \n} \nfinally { \nif ( request . getResultListener ( ) != null ) { \nrequest . getResultListener ( ) . end ( ) ; \n} \n} \n} \n} \n"}
{"3267": "public class OSecurityShared { \npublic OUser authenticate ( final OToken authToken ) { \nfinal String dbName = getDatabase ( ) . getName ( ) ; \nif ( authToken . getIsValid ( ) != true ) { \nthrow new OSecurityAccessException ( dbName , \"Token not valid\" ) ; \n} \nOUser user = authToken . getUser ( getDatabase ( ) ) ; \nif ( user == null && authToken . getUserName ( ) != null ) { \nuser = getUser ( authToken . getUserName ( ) ) ; \n} \nif ( user == null ) { \nthrow new OSecurityAccessException ( dbName , \"Authentication failed, could not load user from token\" ) ; \n} \nif ( user . getAccountStatus ( ) != STATUSES . ACTIVE ) { \nthrow new OSecurityAccessException ( dbName , \"User '\" + user . getName ( ) + \"' is not active\" ) ; \n} \nreturn user ; \n} \n} \n"}
{"3268": "public class OSecurityShared { \npublic OUser createMetadata ( ) { \nfinal ODatabaseDocument database = getDatabase ( ) ; \nOClass identityClass = database . getMetadata ( ) . getSchema ( ) . getClass ( OIdentity . CLASS_NAME ) ; \nif ( identityClass == null ) { \nidentityClass = database . getMetadata ( ) . getSchema ( ) . createAbstractClass ( OIdentity . CLASS_NAME ) ; \n} \nOClass roleClass = createOrUpdateORoleClass ( database , identityClass ) ; \ncreateOrUpdateOUserClass ( database , identityClass , roleClass ) ; \nORole adminRole = getRole ( ORole . ADMIN ) ; \nif ( adminRole == null ) { \nadminRole = createRole ( ORole . ADMIN , ORole . ALLOW_MODES . ALLOW_ALL_BUT ) ; \nadminRole . addRule ( ORule . ResourceGeneric . BYPASS_RESTRICTED , null , ORole . PERMISSION_ALL ) . save ( ) ; \n} \nOUser adminUser = getUser ( OUser . ADMIN ) ; \nif ( adminUser == null ) { \nboolean createDefUsers = getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getContextConfiguration ( ) . getValueAsBoolean ( OGlobalConfiguration . CREATE_DEFAULT_USERS ) ; \nif ( createDefUsers ) { \nadminUser = createUser ( OUser . ADMIN , OUser . ADMIN , adminRole ) ; \n} \n} \ncreateOrUpdateORestrictedClass ( database ) ; \nreturn adminUser ; \n} \n} \n"}
{"3270": "public class OrientEdge { \n@ Override public OrientVertex getVertex ( final Direction direction ) { \nfinal OrientBaseGraph graph = setCurrentGraphInThreadLocal ( ) ; \nif ( direction . equals ( Direction . OUT ) ) { \nreturn graph . getVertex ( getOutVertex ( ) ) ; \n} \nelse if ( direction . equals ( Direction . IN ) ) { \nreturn graph . getVertex ( getInVertex ( ) ) ; \n} \nelse { \nthrow ExceptionFactory . bothIsNotSupported ( ) ; \n} \n} \n} \n"}
{"3271": "public class OrientEdge { \n@ Override public Object getId ( ) { \nif ( rawElement == null ) { \nreturn vOut . getIdentity ( ) + \"->\" + vIn . getIdentity ( ) ; \n} \nsetCurrentGraphInThreadLocal ( ) ; \nreturn super . getId ( ) ; \n} \n} \n"}
{"3272": "public class OrientEdge { \n@ Override public void setProperty ( final String key , final Object value ) { \nsetCurrentGraphInThreadLocal ( ) ; \nif ( rawElement == null ) { \nconvertToDocument ( ) ; \n} \nsuper . setProperty ( key , value ) ; \n} \n} \n"}
{"3273": "public class OrientEdge { \n@ Override public < T > T removeProperty ( String key ) { \nsetCurrentGraphInThreadLocal ( ) ; \nif ( rawElement != null ) { \nreturn super . removeProperty ( key ) ; \n} \nreturn null ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \ni < parallel - 1 ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) { \nOGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n} \n"}
{"3278": "public class OCommandExecutorSQLTraverse { \nprotected boolean parseStrategy ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_STRATEGY ) ) { \nreturn false ; \n} \nfinal String strategyWord = parserNextWord ( true ) ; \ntry { \ntraverse . setStrategy ( OTraverse . STRATEGY . valueOf ( strategyWord . toUpperCase ( Locale . ENGLISH ) ) ) ; \n} \ncatch ( IllegalArgumentException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + Arrays . toString ( OTraverse . STRATEGY . values ( ) ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"3280": "public class OCommandExecutorSQLInsert { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( newRecords == null && content == null && subQuery == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; \nif ( indexName != null ) { \nif ( newRecords == null ) { \nthrow new OCommandExecutionException ( \"No key/value found\" ) ; \n} \nfinal OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; \nif ( index == null ) { \nthrow new OCommandExecutionException ( \"Target index '\" + indexName + \"' not found\" ) ; \n} \nMap < String , Object > result = new HashMap < String , Object > ( ) ; \nfor ( Map < String , Object > candidate : newRecords ) { \nObject indexKey = getIndexKeyValue ( commandParameters , candidate ) ; \nOIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; \nif ( index instanceof OIndexMultiValues ) { \nfinal Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; \nif ( ! rids . contains ( indexValue . getIdentity ( ) ) ) { \nindex . put ( indexKey , indexValue ) ; \n} \n} \nelse { \nindex . put ( indexKey , indexValue ) ; \n} \nresult . put ( KEYWORD_KEY , indexKey ) ; \nresult . put ( KEYWORD_RID , indexValue ) ; \n} \nreturn prepareReturnItem ( new ODocument ( result ) ) ; \n} \nelse { \nfinal List < ODocument > docs = new ArrayList < ODocument > ( ) ; \nif ( newRecords != null ) { \nfor ( Map < String , Object > candidate : newRecords ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \nOSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; \nsaveRecord ( doc ) ; \ndocs . add ( doc ) ; \n} \nif ( docs . size ( ) == 1 ) { \nreturn prepareReturnItem ( docs . get ( 0 ) ) ; \n} \nelse { \nreturn prepareReturnResult ( docs ) ; \n} \n} \nelse if ( content != null ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \ndoc . merge ( content , true , false ) ; \nsaveRecord ( doc ) ; \nreturn prepareReturnItem ( doc ) ; \n} \nelse if ( subQuery != null ) { \nsubQuery . execute ( ) ; \nif ( queryResult != null ) { \nreturn prepareReturnResult ( queryResult ) ; \n} \nreturn saved . longValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3281": "public class ODatabaseRepair { \nprotected boolean fixLink ( final Object fieldValue ) { \nif ( fieldValue instanceof OIdentifiable ) { \nfinal ORID id = ( ( OIdentifiable ) fieldValue ) . getIdentity ( ) ; \nif ( id . getClusterId ( ) == 0 && id . getClusterPosition ( ) == 0 ) { \nreturn true ; \n} \nif ( id . isValid ( ) ) { \nif ( id . isPersistent ( ) ) { \nfinal ORecord connected = ( ( OIdentifiable ) fieldValue ) . getRecord ( ) ; \nif ( connected == null ) { \nreturn true ; \n} \n} \nelse { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \nretry < 100 ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) { \nreturn ; \n} \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) { \nreturn ; \n} \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3288": "public class ORecordLazyMap { \nprivate void convertLink2Record ( final Object iKey ) { \nif ( status == MULTIVALUE_CONTENT_TYPE . ALL_RECORDS ) { \nreturn ; \n} \nfinal Object value ; \nif ( iKey instanceof ORID ) { \nvalue = iKey ; \n} \nelse { \nvalue = super . get ( iKey ) ; \n} \nif ( value != null && value instanceof ORID ) { \nfinal ORID rid = ( ORID ) value ; \nmarshalling = true ; \ntry { \ntry { \nORecord record = rid . getRecord ( ) ; \nif ( record != null ) { \nORecordInternal . unTrack ( sourceRecord , rid ) ; \nORecordInternal . track ( sourceRecord , record ) ; \n} \nsuper . put ( iKey , record ) ; \n} \ncatch ( ORecordNotFoundException ignore ) { \n} \n} \nfinally { \nmarshalling = false ; \n} \n} \n} \n} \n"}
{"3289": "public class OHttpNetworkCommandManager { \npublic void registerCommand ( final OServerCommand iServerCommandInstance ) { \nfor ( String name : iServerCommandInstance . getNames ( ) ) if ( OStringSerializerHelper . contains ( name , '{' ) ) { \nrestCommands . put ( name , iServerCommandInstance ) ; \n} \nelse if ( OStringSerializerHelper . contains ( name , '*' ) ) { \nwildcardCommands . put ( name , iServerCommandInstance ) ; \n} \nelse { \nexactCommands . put ( name , iServerCommandInstance ) ; \n} \niServerCommandInstance . configure ( server ) ; \n} \n} \n"}
{"3290": "public class ODefaultPasswordAuthenticator { \nprotected OServerUserConfiguration createServerUser ( final ODocument userDoc ) { \nOServerUserConfiguration userCfg = null ; \nif ( userDoc . containsField ( \"username\" ) && userDoc . containsField ( \"resources\" ) ) { \nfinal String user = userDoc . field ( \"username\" ) ; \nfinal String resources = userDoc . field ( \"resources\" ) ; \nString password = userDoc . field ( \"password\" ) ; \nif ( password == null ) { \npassword = \"\" ; \n} \nuserCfg = new OServerUserConfiguration ( user , password , resources ) ; \n} \nreturn userCfg ; \n} \n} \n"}
{"3293": "public class OObjectProxyMethodHandler { \npublic void attach ( final Object self ) throws IllegalArgumentException , IllegalAccessException , NoSuchMethodException , InvocationTargetException { \nfor ( Class < ? > currentClass = self . getClass ( ) ; \ncurrentClass != Object . class ; \n) { \nif ( Proxy . class . isAssignableFrom ( currentClass ) ) { \ncurrentClass = currentClass . getSuperclass ( ) ; \ncontinue ; \n} \nfor ( Field f : currentClass . getDeclaredFields ( ) ) { \nfinal String fieldName = f . getName ( ) ; \nfinal Class < ? > declaringClass = f . getDeclaringClass ( ) ; \nif ( OObjectEntitySerializer . isTransientField ( declaringClass , fieldName ) || OObjectEntitySerializer . isVersionField ( declaringClass , fieldName ) || OObjectEntitySerializer . isIdField ( declaringClass , fieldName ) ) { \ncontinue ; \n} \nObject value = OObjectEntitySerializer . getFieldValue ( f , self ) ; \nvalue = setValue ( self , fieldName , value ) ; \nOObjectEntitySerializer . setFieldValue ( f , self , value ) ; \n} \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) { \ncurrentClass = Object . class ; \n} \n} \n} \n} \n"}
{"3297": "public class OClassImpl { \nprotected OClass addBaseClass ( final OClassImpl iBaseClass ) { \ncheckRecursion ( iBaseClass ) ; \nif ( subclasses == null ) { \nsubclasses = new ArrayList < OClass > ( ) ; \n} \nif ( subclasses . contains ( iBaseClass ) ) { \nreturn this ; \n} \nsubclasses . add ( iBaseClass ) ; \naddPolymorphicClusterIdsWithInheritance ( iBaseClass ) ; \nreturn this ; \n} \n} \n"}
{"3299": "public class ORecordSerializerCSVAbstract { \nprivate static OIdentifiable linkToStream ( final StringBuilder buffer , final ODocument iParentRecord , Object iLinked ) { \nif ( iLinked == null ) { \nreturn null ; \n} \nOIdentifiable resultRid = null ; \nORID rid ; \nif ( iLinked instanceof ORID ) { \nrid = ( ORID ) iLinked ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nresultRid = rid ; \n} \nelse { \nif ( iLinked instanceof String ) { \niLinked = new ORecordId ( ( String ) iLinked ) ; \n} \nif ( ! ( iLinked instanceof OIdentifiable ) ) { \nthrow new IllegalArgumentException ( \"Invalid object received. Expected a OIdentifiable but received type=\" + iLinked . getClass ( ) . getName ( ) + \" and value=\" + iLinked ) ; \n} \nORecord iLinkedRecord = ( ( OIdentifiable ) iLinked ) . getRecord ( ) ; \nrid = iLinkedRecord . getIdentity ( ) ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nfinal ODatabaseDocument database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( iParentRecord != null ) { \nif ( ! database . isRetainRecords ( ) ) { \nresultRid = iLinkedRecord . getIdentity ( ) ; \n} \n} \n} \nif ( rid . isValid ( ) ) { \nrid . toString ( buffer ) ; \n} \nreturn resultRid ; \n} \n} \n"}
{"3304": "public class ODistributedAbstractPlugin { \n@ Override public void onOpen ( final ODatabaseInternal iDatabase ) { \nif ( ! isRelatedToLocalServer ( iDatabase ) ) { \nreturn ; \n} \nif ( isOffline ( ) && status != NODE_STATUS . STARTING ) { \nreturn ; \n} \nfinal ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal String dbName = iDatabase . getName ( ) ; \nfinal ODistributedConfiguration cfg = getDatabaseConfiguration ( dbName ) ; \nif ( cfg == null ) { \nreturn ; \n} \n} \ncatch ( HazelcastException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \ncatch ( HazelcastInstanceNotActiveException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \nfinally { \nODatabaseRecordThreadLocal . instance ( ) . set ( currDb ) ; \n} \n} \n} \n"}
{"3305": "public class ODistributedAbstractPlugin { \npublic boolean installClustersOfClass ( final ODatabaseInternal iDatabase , final OClass iClass , OModifiableDistributedConfiguration cfg ) { \nfinal String databaseName = iDatabase . getName ( ) ; \nif ( iClass . isAbstract ( ) ) { \nreturn false ; \n} \ngetMessageService ( ) . registerDatabase ( databaseName , cfg ) ; \nreturn executeInDistributedDatabaseLock ( databaseName , 20000 , cfg , new OCallable < Boolean , OModifiableDistributedConfiguration > ( ) { \n@ Override public Boolean call ( final OModifiableDistributedConfiguration lastCfg ) { \nfinal Set < String > availableNodes = getAvailableNodeNames ( iDatabase . getName ( ) ) ; \nfinal List < String > cluster2Create = clusterAssignmentStrategy . assignClusterOwnershipOfClass ( iDatabase , lastCfg , iClass , availableNodes , true ) ; \nfinal Map < OClass , List < String > > cluster2CreateMap = new HashMap < OClass , List < String > > ( 1 ) ; \ncluster2CreateMap . put ( iClass , cluster2Create ) ; \ncreateClusters ( iDatabase , cluster2CreateMap , lastCfg ) ; \nreturn true ; \n} \n} \n) ; \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \nfor ( int i = 0 ; \ni < array . length ; \n++ i ) { \nif ( object . compareTo ( array [ i ] ) == 0 ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \nfor ( int i = 0 ; \ni < array . length ; \n++ i ) { \nif ( array [ i ] == object ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3314": "public class OCommandExecutorSQLSelect { \nprotected boolean parseNoCache ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_NOCACHE ) ) { \nreturn false ; \n} \nnoCache = true ; \nreturn true ; \n} \n} \n"}
{"3324": "public class OCommandExecutorSQLCreateClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nboolean alreadyExists = database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ; \nif ( ! alreadyExists || ! ifNotExists ) { \nif ( clusters != null ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; \n} \nelse { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; \n} \n} \nreturn database . getMetadata ( ) . getSchema ( ) . getClasses ( ) . size ( ) ; \n} \n} \n"}
{"3325": "public class OCommandExecutorSQLHASyncDatabase { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \ndatabase . checkSecurity ( ORule . ResourceGeneric . DATABASE , \"sync\" , ORole . PERMISSION_UPDATE ) ; \nfinal OStorage stg = database . getStorage ( ) ; \nif ( ! ( stg instanceof ODistributedStorage ) ) { \nthrow new ODistributedException ( \"SYNC DATABASE command cannot be executed against a non distributed server\" ) ; \n} \nfinal ODistributedStorage dStg = ( ODistributedStorage ) stg ; \nfinal OHazelcastPlugin dManager = ( OHazelcastPlugin ) dStg . getDistributedManager ( ) ; \nif ( dManager == null || ! dManager . isEnabled ( ) ) { \nthrow new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \n} \nfinal String databaseName = database . getName ( ) ; \nreturn dManager . installDatabase ( true , databaseName , parsedStatement . isForce ( ) , ! parsedStatement . isFull ( ) ) ; \n} \n} \n"}
{"3327": "public class ODatabaseDocumentAbstract { \npublic ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { \nif ( id == null || hooks . isEmpty ( ) || id . getIdentity ( ) . getClusterId ( ) == 0 ) { \nreturn ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinal ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; \nfinal int scopeOrdinal = scope . ordinal ( ) ; \nfinal ORID identity = id . getIdentity ( ) . copy ( ) ; \nif ( ! pushInHook ( identity ) ) { \nreturn ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \ntry { \nfinal ORecord rec = id . getRecord ( ) ; \nif ( rec == null ) { \nreturn ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinal OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; \nboolean recordChanged = false ; \nfor ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { \nswitch ( runMode ) { \ncase DEFAULT : if ( getStorage ( ) . isDistributed ( ) && hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) { \ncontinue ; \n} \nbreak ; \ncase RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) { \ncontinue ; \n} \n} \nfinal ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; \nif ( res == ORecordHook . RESULT . RECORD_CHANGED ) { \nrecordChanged = true ; \n} \nelse if ( res == ORecordHook . RESULT . SKIP_IO ) { \nreturn res ; \n} \nelse if ( res == ORecordHook . RESULT . SKIP ) { \nreturn res ; \n} \nelse if ( res == ORecordHook . RESULT . RECORD_REPLACED ) { \nreturn res ; \n} \n} \nreturn recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinally { \npopInHook ( identity ) ; \n} \n} \n} \n"}
{"3328": "public class ODatabaseDocumentAbstract { \npublic ODatabaseDocument delete ( final ORID iRecord ) { \ncheckOpenness ( ) ; \ncheckIfActive ( ) ; \nfinal ORecord rec = load ( iRecord ) ; \nif ( rec != null ) { \ndelete ( rec ) ; \n} \nreturn this ; \n} \n} \n"}
{"3329": "public class ODatabaseDocumentAbstract { \npublic long countView ( final String viewName ) { \nfinal OView cls = getMetadata ( ) . getImmutableSchemaSnapshot ( ) . getView ( viewName ) ; \nif ( cls == null ) { \nthrow new IllegalArgumentException ( \"View '\" + cls + \"' not found in database\" ) ; \n} \nreturn countClass ( cls , false ) ; \n} \n} \n"}
{"3330": "public class ODatabaseDocumentAbstract { \npublic long countClass ( final String iClassName , final boolean iPolymorphic ) { \nfinal OClass cls = getMetadata ( ) . getImmutableSchemaSnapshot ( ) . getClass ( iClassName ) ; \nif ( cls == null ) { \nthrow new IllegalArgumentException ( \"Class '\" + cls + \"' not found in database\" ) ; \n} \nreturn countClass ( cls , iPolymorphic ) ; \n} \n} \n"}
{"3331": "public class ODatabaseDocumentAbstract { \n@ Override public ODatabaseDocumentAbstract activateOnCurrentThread ( ) { \nfinal ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal . instance ( ) ; \nif ( tl != null ) { \ntl . set ( this ) ; \n} \nreturn this ; \n} \n} \n"}
{"3332": "public class OEncryptionFactory { \npublic void register ( final OEncryption iEncryption ) { \ntry { \nfinal String name = iEncryption . name ( ) ; \nif ( instances . containsKey ( name ) ) { \nthrow new IllegalArgumentException ( \"Encryption with name '\" + name + \"' was already registered\" ) ; \n} \nif ( classes . containsKey ( name ) ) { \nthrow new IllegalArgumentException ( \"Encryption with name '\" + name + \"' was already registered\" ) ; \n} \ninstances . put ( name , iEncryption ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Cannot register storage encryption algorithm '%s'\" , e , iEncryption ) ; \n} \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nint currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nwhile ( pos >= ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) ) { \ncurrentChunkIndex ++ ; \n} \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize -= currentChunk . length ; \nint relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3334": "public class OBaseParser { \nprotected String parserOptionalWord ( final boolean iUpperCase ) { \nparserPreviousPos = parserCurrentPos ; \nparserNextWord ( iUpperCase ) ; \nif ( parserLastWord . length ( ) == 0 ) { \nreturn null ; \n} \nreturn parserLastWord . toString ( ) ; \n} \n} \n"}
{"3335": "public class OBaseParser { \nprotected String parserRequiredWord ( final boolean iUpperCase , final String iCustomMessage , String iSeparators ) { \nif ( iSeparators == null ) { \niSeparators = \" ()=><,\\r\\n\" ; \n} \nparserNextWord ( iUpperCase , iSeparators ) ; \nif ( parserLastWord . length ( ) == 0 ) { \nthrowSyntaxErrorException ( iCustomMessage ) ; \n} \nif ( parserLastWord . charAt ( 0 ) == '`' && parserLastWord . charAt ( parserLastWord . length ( ) - 1 ) == '`' ) { \nreturn parserLastWord . substring ( 1 , parserLastWord . length ( ) - 1 ) ; \n} \nreturn parserLastWord . toString ( ) ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( int i = 0 ; \nparserCurrentPos <= max ; \n++ i ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) { \nparserLastWord . append ( ch ) ; \n} \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \nfor ( int c = 0 ; \nc < processedWords . length ; \n++ c ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) { \nprocessedWords [ c ] = null ; \n} \nelse { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) { \ncandidatesWordsPos = c ; \n} \n} \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) { \nreturn candidatesWordsPos ; \n} \n} \nif ( candidatesWordsCount == 0 || separator ) { \nbreak ; \n} \nparserCurrentPos ++ ; \n} \nif ( iMandatory ) { \nthrowSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3337": "public class OBaseParser { \nprotected boolean parserOptionalKeyword ( final String ... iWords ) { \nparserNextWord ( true , \" \\r\\n,\" ) ; \nif ( parserLastWord . length ( ) == 0 ) { \nreturn false ; \n} \nboolean found = iWords . length == 0 ; \nfor ( String w : iWords ) { \nif ( parserLastWord . toString ( ) . equals ( w ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nthrowSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iWords ) + \"'\" ) ; \n} \nreturn true ; \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \nreturn true ; \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( records > 0 && ! unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 && unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nif ( unsafe ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3341": "public class OMemoryInputStream { \npublic int getAsByteArrayOffset ( ) { \nif ( position >= length ) { \nreturn - 1 ; \n} \nfinal int begin = position ; \nfinal int size = OBinaryProtocol . bytes2int ( buffer , position ) ; \nposition += OBinaryProtocol . SIZE_INT + size ; \nreturn begin ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) { \nreturn 0 ; \n} \nif ( noMoreCharacters ( ) ) { \nreturn - 1 ; \n} \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) { \n; \n} \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse { \nreadBytes += read + 1 ; \n} \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nint len ; \nwhile ( toSkip > 0 ) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( len > 0 ) { \ntoSkip -= len ; \n} \nelse { \nbreak ; \n} \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) { \nbreak ; \n} \ntoSkip -- ; \n} \nelse { \ntoSkip -= result ; \n} \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3350": "public class Arrays { \npublic static void ensureOffsetLength ( final int arrayLength , final int offset , final int length ) { \nif ( offset < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( \"Offset (\" + offset + \") is negative\" ) ; \n} \nif ( length < 0 ) { \nthrow new IllegalArgumentException ( \"Length (\" + length + \") is negative\" ) ; \n} \nif ( offset + length > arrayLength ) { \nthrow new ArrayIndexOutOfBoundsException ( \"Last index (\" + ( offset + length ) + \") is greater than array length (\" + arrayLength + \")\" ) ; \n} \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \nfor ( int i = from ; \ni < to ; \ni ++ ) { \nfor ( int j = i ; \nj > from && ( c . compare ( j - 1 , j ) > 0 ) ; \nj -- ) { \nswapper . swap ( j , j - 1 ) ; \n} \n} \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) { \nreturn ; \n} \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \nfor ( int i = 0 ; \ni < n ; \ni ++ , a ++ , b ++ ) { \nswapper . swap ( a , b ) ; \n} \n} \n} \n"}
{"3358": "public class FastBufferedOutputStream { \n@ Override public void position ( final long newPosition ) throws IOException { \nflush ( ) ; \nif ( repositionableStream != null ) { \nrepositionableStream . position ( newPosition ) ; \n} \nelse if ( fileChannel != null ) { \nfileChannel . position ( newPosition ) ; \n} \nelse { \nthrow new UnsupportedOperationException ( \"position() can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel() method of the underlying byte stream exists and returns a FileChannel\" ) ; \n} \n} \n} \n"}
{"3362": "public class HollowCompactor { \nprivate Set < String > findCompactionTargets ( ) { \nList < HollowSchema > schemas = HollowSchemaSorter . dependencyOrderedSchemaList ( readEngine . getSchemas ( ) ) ; \nSet < String > typesToCompact = new HashSet < String > ( ) ; \nfor ( HollowSchema schema : schemas ) { \nif ( isCompactionCandidate ( schema . getName ( ) ) ) { \nif ( ! candidateIsDependentOnAnyTargetedType ( schema . getName ( ) , typesToCompact ) ) { \ntypesToCompact . add ( schema . getName ( ) ) ; \n} \n} \n} \nreturn typesToCompact ; \n} \n} \n"}
{"3365": "public class HollowReadFieldUtils { \npublic static boolean fieldsAreEqual ( HollowObjectTypeDataAccess typeAccess1 , int ordinal1 , int fieldPosition1 , HollowObjectTypeDataAccess typeAccess2 , int ordinal2 , int fieldPosition2 ) { \nHollowObjectSchema schema1 = typeAccess1 . getSchema ( ) ; \nswitch ( schema1 . getFieldType ( fieldPosition1 ) ) { \ncase BOOLEAN : Boolean bool1 = typeAccess1 . readBoolean ( ordinal1 , fieldPosition1 ) ; \nBoolean bool2 = typeAccess2 . readBoolean ( ordinal2 , fieldPosition2 ) ; \nreturn bool1 == bool2 ; \ncase BYTES : byte [ ] data1 = typeAccess1 . readBytes ( ordinal1 , fieldPosition1 ) ; \nbyte [ ] data2 = typeAccess2 . readBytes ( ordinal2 , fieldPosition2 ) ; \nreturn Arrays . equals ( data1 , data2 ) ; \ncase DOUBLE : double d1 = typeAccess1 . readDouble ( ordinal1 , fieldPosition1 ) ; \ndouble d2 = typeAccess2 . readDouble ( ordinal2 , fieldPosition2 ) ; \nreturn Double . compare ( d1 , d2 ) == 0 ; \ncase FLOAT : float f1 = typeAccess1 . readFloat ( ordinal1 , fieldPosition1 ) ; \nfloat f2 = typeAccess2 . readFloat ( ordinal2 , fieldPosition2 ) ; \nreturn Float . compare ( f1 , f2 ) == 0 ; \ncase INT : int i1 = typeAccess1 . readInt ( ordinal1 , fieldPosition1 ) ; \nint i2 = typeAccess2 . readInt ( ordinal2 , fieldPosition2 ) ; \nreturn i1 == i2 ; \ncase LONG : long l1 = typeAccess1 . readLong ( ordinal1 , fieldPosition1 ) ; \nlong l2 = typeAccess2 . readLong ( ordinal2 , fieldPosition2 ) ; \nreturn l1 == l2 ; \ncase STRING : String s1 = typeAccess1 . readString ( ordinal1 , fieldPosition1 ) ; \nreturn typeAccess2 . isStringFieldEqual ( ordinal2 , fieldPosition2 , s1 ) ; \ncase REFERENCE : if ( typeAccess1 == typeAccess2 && fieldPosition1 == fieldPosition2 ) { \nreturn typeAccess1 . readOrdinal ( ordinal1 , fieldPosition1 ) == typeAccess2 . readOrdinal ( ordinal2 , fieldPosition2 ) ; \n} \ndefault : } \nthrow new IllegalStateException ( \"I don't know how to test equality for a \" + schema1 . getFieldType ( fieldPosition1 ) ) ; \n} \n} \n"}
{"3366": "public class TransitiveSetTraverser { \npublic static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { \nList < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; \nCollections . reverse ( orderedSchemas ) ; \nfor ( HollowSchema referencedSchema : orderedSchemas ) { \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) { \nfor ( HollowSchema referencerSchema : orderedSchemas ) { \nif ( referencerSchema == referencedSchema ) { \nbreak ; \n} \nif ( matches . containsKey ( referencedSchema . getName ( ) ) && matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) > 0 ) { \ntraverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nif ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( int i = 0 ; \ni < elementArray . numLists ( ) ; \ni ++ ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) { \nselectArray = new int [ predictedBuckets ] ; \n} \nfor ( int j = 0 ; \nj < predictedBuckets ; \nj ++ ) { \nselectArray [ j ] = - 1 ; \n} \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) { \nbreak ; \n} \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) { \nmaxSize = setSize ; \n} \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) { \ncontinue ; \n} \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) { \ngenerateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \nelse if ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < keys . length ; \ni ++ ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3395": "public class HollowPrefixIndex { \npublic boolean contains ( String key ) { \nif ( key == null ) { \nthrow new IllegalArgumentException ( \"key cannot be null\" ) ; \n} \nTST current ; \nboolean result ; \ndo { \ncurrent = prefixIndexVolatile ; \nresult = current . contains ( key ) ; \n} \nwhile ( current != this . prefixIndexVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3398": "public class HollowSchemaSorter { \npublic static List < HollowSchema > dependencyOrderedSchemaList ( Collection < HollowSchema > schemas ) { \nDependencyIndex idx = new DependencyIndex ( ) ; \nMap < String , HollowSchema > schemaMap = new HashMap < String , HollowSchema > ( ) ; \nfor ( HollowSchema schema : schemas ) { \nschemaMap . put ( schema . getName ( ) , schema ) ; \nidx . indexSchema ( schema , schemas ) ; \n} \nList < HollowSchema > orderedSchemas = new ArrayList < HollowSchema > ( ) ; \nwhile ( idx . hasMoreTypes ( ) ) { \norderedSchemas . add ( schemaMap . get ( idx . getNextType ( ) ) ) ; \n} \nreturn orderedSchemas ; \n} \n} \n"}
{"3400": "public class GrowingSegmentedLongArray { \npublic long get ( long index ) { \nint segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; \nif ( segmentIndex >= segments . length || segments [ segmentIndex ] == null ) { \nreturn 0 ; \n} \nint longInSegment = ( int ) ( index & bitmask ) ; \nreturn segments [ segmentIndex ] [ longInSegment ] ; \n} \n} \n"}
{"3402": "public class HollowFieldMatchQuery { \npublic Map < String , BitSet > findMatchingRecords ( String typeName , String fieldName , String fieldValue ) { \nMap < String , BitSet > matches = new HashMap < String , BitSet > ( ) ; \nHollowTypeReadState typeState = readEngine . getTypeState ( typeName ) ; \nif ( typeState != null ) { \naugmentMatchingRecords ( typeState , fieldName , fieldValue , matches ) ; \n} \nreturn matches ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \nfor ( int i = 0 ; \ni < paths . length ; \ni ++ ) { \nint elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) { \nthrow new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \n} \nelementKeyPaths . set ( elementPathIdx ) ; \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \nfor ( int i = 0 ; \ni < numThreads ; \ni ++ ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \nfor ( int i = threadNumber ; \ni < matcher . getMatchedOrdinals ( ) . size ( ) ; \ni += numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) { \nhashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \n} \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInFrom ( ) . size ( ) ; \ni += numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInTo ( ) . size ( ) ; \ni += numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3411": "public class HollowMetrics { \nvoid calculateTypeMetrics ( HollowReadStateEngine hollowReadStateEngine ) { \nCollection < HollowTypeReadState > typeStates = hollowReadStateEngine . getTypeStates ( ) ; \nif ( typeStates == null ) { \nreturn ; \n} \ntotalHeapFootprint = 0L ; \ntotalPopulatedOrdinals = 0 ; \nfor ( HollowTypeReadState typeState : typeStates ) { \nlong heapCost = typeState . getApproximateHeapFootprintInBytes ( ) ; \ntotalHeapFootprint += heapCost ; \nint populatedOrdinals = typeState . getPopulatedOrdinals ( ) . cardinality ( ) ; \ntotalPopulatedOrdinals += populatedOrdinals ; \nString type = typeState . getSchema ( ) . getName ( ) ; \ntypeHeapFootprint . put ( type , heapCost ) ; \ntypePopulatedOrdinals . put ( type , populatedOrdinals ) ; \n} \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( int i = 0 ; \ni < getNumFieldPaths ( ) ; \ni ++ ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( numElements < 0 ) { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nelse if ( numElements > HASH_TABLE_MAX_SIZE ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \nif ( numElements == 0 ) { \nreturn 1 ; \n} \nif ( numElements < 3 ) { \nreturn numElements * 2 ; \n} \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3432": "public class HollowBlobWriter { \npublic void writeDelta ( OutputStream os ) throws IOException { \nstateEngine . prepareForWrite ( ) ; \nif ( stateEngine . isRestored ( ) ) { \nstateEngine . ensureAllNecessaryStatesRestored ( ) ; \n} \nList < HollowSchema > changedTypes = changedTypes ( ) ; \nDataOutputStream dos = new DataOutputStream ( os ) ; \nwriteHeader ( dos , changedTypes , false ) ; \nVarInt . writeVInt ( dos , changedTypes . size ( ) ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"write-delta\" ) ; \nfor ( final HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nif ( typeState . hasChangedSinceLastCycle ( ) ) { \ntypeState . calculateDelta ( ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nfor ( HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nif ( typeState . hasChangedSinceLastCycle ( ) ) { \nHollowSchema schema = typeState . getSchema ( ) ; \nschema . writeTo ( dos ) ; \nwriteNumShards ( dos , typeState . getNumShards ( ) ) ; \ntypeState . writeDelta ( dos ) ; \n} \n} \nos . flush ( ) ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nint hashCode = 0 ; \nfor ( int i = 0 ; \ni < query . length ; \ni ++ ) { \nif ( query [ i ] == null ) { \nthrow new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \n} \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nwhile ( ! bucketIsEmpty ) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nint selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3438": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithDelay ( int delayMillis ) { \nfinal HollowClient client = this . client ; \nfinal long targetBeginTime = System . currentTimeMillis ( ) + delayMillis ; \nrefreshExecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \ntry { \nlong delay = targetBeginTime - System . currentTimeMillis ( ) ; \nif ( delay > 0 ) { \nThread . sleep ( delay ) ; \n} \nclient . triggerRefresh ( ) ; \n} \ncatch ( Throwable th ) { \nlog . log ( Level . SEVERE , \"Async refresh failed\" , th ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3439": "public class HollowDiff { \npublic HollowTypeDiff addTypeDiff ( String type , String ... primaryKeyPaths ) { \nHollowTypeDiff typeDiff = new HollowTypeDiff ( this , type , primaryKeyPaths ) ; \nif ( typeDiff . hasAnyData ( ) ) { \ntypeDiffs . put ( type , typeDiff ) ; \n} \nreturn typeDiff ; \n} \n} \n"}
{"3441": "public class VarInt { \npublic static void writeVLong ( OutputStream out , long value ) throws IOException { \nif ( value < 0 ) { \nout . write ( ( byte ) 0x81 ) ; \n} \nif ( value > 0xFFFFFFFFFFFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x1FFFFFFFFFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x3FFFFFFFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x7FFFFFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0xFFFFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x1FFFFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x3FFFL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7FL ) ) ) ; \n} \nif ( value > 0x7FL || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7FL ) ) ) ; \n} \nout . write ( ( byte ) ( value & 0x7FL ) ) ; \n} \n} \n"}
{"3442": "public class VarInt { \npublic static void writeVInt ( OutputStream out , int value ) throws IOException { \nif ( value > 0x0FFFFFFF || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \n} \nif ( value > 0x1FFFFF || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \n} \nif ( value > 0x3FFF || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \n} \nif ( value > 0x7F || value < 0 ) { \nout . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \n} \nout . write ( ( byte ) ( value & 0x7F ) ) ; \n} \n} \n"}
{"3443": "public class VarInt { \npublic static int writeVInt ( byte data [ ] , int pos , int value ) { \nif ( value > 0x0FFFFFFF || value < 0 ) { \ndata [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \n} \nif ( value > 0x1FFFFF || value < 0 ) { \ndata [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \n} \nif ( value > 0x3FFF || value < 0 ) { \ndata [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \n} \nif ( value > 0x7F || value < 0 ) { \ndata [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \n} \ndata [ pos ++ ] = ( byte ) ( value & 0x7F ) ; \nreturn pos ; \n} \n} \n"}
{"3444": "public class VarInt { \npublic static int readVInt ( InputStream in ) throws IOException { \nbyte b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) { \nthrow new RuntimeException ( \"Attempting to read null value as int\" ) ; \n} \nint value = b & 0x7F ; \nwhile ( ( b & 0x80 ) != 0 ) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3445": "public class VarInt { \npublic static long readVLong ( InputStream in ) throws IOException { \nbyte b = ( byte ) in . read ( ) ; \nif ( b == ( byte ) 0x80 ) { \nthrow new RuntimeException ( \"Attempting to read null value as long\" ) ; \n} \nlong value = b & 0x7F ; \nwhile ( ( b & 0x80 ) != 0 ) { \nb = ( byte ) in . read ( ) ; \nvalue <<= 7 ; \nvalue |= ( b & 0x7F ) ; \n} \nreturn value ; \n} \n} \n"}
{"3597": "public class Profile { \npublic static Profile forInt ( int i ) { \nProfile p ; \nif ( i <= 0 || i > ALL . length ) { \np = UNKNOWN ; \n} \nelse { \np = ALL [ i - 1 ] ; \n} \nreturn p ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) { \nmaxI = i ; \n} \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) { \ntaps [ i ] -= 1 ; \n} \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) { \nreturn State . STOP ; \n} \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) { \nreturn State . MORE_DATA ; \n} \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) { \nreturn State . DONE ; \n} \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nreturn State . DONE ; \n} \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3600": "public class SegmentReader { \npublic ByteBuffer readToNextMarkerNewBuffer ( ) throws IOException { \nif ( done ) { \nreturn null ; \n} \nList < ByteBuffer > buffers = new ArrayList < ByteBuffer > ( ) ; \nreadToNextMarkerBuffers ( buffers ) ; \nreturn NIOUtils . combineBuffers ( buffers ) ; \n} \n} \n"}
{"3602": "public class InplaceMP4Editor { \npublic boolean modify ( File file , MP4Edit edit ) throws IOException { \nSeekableByteChannel fi = null ; \ntry { \nfi = NIOUtils . rwChannel ( file ) ; \nList < Tuple . _2 < Atom , ByteBuffer > > fragments = doTheFix ( fi , edit ) ; \nif ( fragments == null ) { \nreturn false ; \n} \nfor ( Tuple . _2 < Atom , ByteBuffer > fragment : fragments ) { \nreplaceBox ( fi , fragment . v0 , fragment . v1 ) ; \n} \nreturn true ; \n} \nfinally { \nNIOUtils . closeQuietly ( fi ) ; \n} \n} \n} \n"}
{"3603": "public class InplaceMP4Editor { \npublic boolean copy ( File src , File dst , MP4Edit edit ) throws IOException { \nSeekableByteChannel fi = null ; \nSeekableByteChannel fo = null ; \ntry { \nfi = NIOUtils . readableChannel ( src ) ; \nfo = NIOUtils . writableChannel ( dst ) ; \nList < Tuple . _2 < Atom , ByteBuffer > > fragments = doTheFix ( fi , edit ) ; \nif ( fragments == null ) { \nreturn false ; \n} \nList < _2 < Long , ByteBuffer > > fragOffsets = Tuple . _2map0 ( fragments , new Tuple . Mapper < Atom , Long > ( ) { \npublic Long map ( Atom t ) { \nreturn t . getOffset ( ) ; \n} \n} \n) ; \nMap < Long , ByteBuffer > rewrite = Tuple . asMap ( fragOffsets ) ; \nfor ( Atom atom : MP4Util . getRootAtoms ( fi ) ) { \nByteBuffer byteBuffer = rewrite . get ( atom . getOffset ( ) ) ; \nif ( byteBuffer != null ) { \nfo . write ( byteBuffer ) ; \n} \nelse { \natom . copy ( fi , fo ) ; \n} \n} \nreturn true ; \n} \nfinally { \nNIOUtils . closeQuietly ( fi ) ; \nNIOUtils . closeQuietly ( fo ) ; \n} \n} \n} \n"}
{"3604": "public class QTTimeUtil { \npublic static long getEditedDuration ( TrakBox track ) { \nList < Edit > edits = track . getEdits ( ) ; \nif ( edits == null ) { \nreturn track . getDuration ( ) ; \n} \nlong duration = 0 ; \nfor ( Edit edit : edits ) { \nduration += edit . getDuration ( ) ; \n} \nreturn duration ; \n} \n} \n"}
{"3607": "public class QTTimeUtil { \npublic static long mediaToEdited ( TrakBox trak , long mediaTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) { \nreturn mediaTv ; \n} \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nif ( mediaTv < edit . getMediaTime ( ) ) { \nreturn accum ; \n} \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( edit . getMediaTime ( ) != - 1 && ( mediaTv >= edit . getMediaTime ( ) && mediaTv < edit . getMediaTime ( ) + duration ) ) { \naccum += mediaTv - edit . getMediaTime ( ) ; \nbreak ; \n} \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3608": "public class QTTimeUtil { \npublic static long editedToMedia ( TrakBox trak , long editedTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) { \nreturn editedTv ; \n} \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( accum + duration > editedTv ) { \nreturn edit . getMediaTime ( ) + editedTv - accum ; \n} \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3615": "public class ColorSpace { \npublic boolean matches ( ColorSpace inputColor ) { \nif ( inputColor == this ) { \nreturn true ; \n} \nif ( inputColor == ANY || this == ANY ) { \nreturn true ; \n} \nif ( ( inputColor == ANY_INTERLEAVED || this == ANY_INTERLEAVED || inputColor == ANY_PLANAR || this == ANY_PLANAR ) && inputColor . planar == this . planar ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3616": "public class ColorSpace { \npublic Size compSize ( Size size , int comp ) { \nif ( compWidth [ comp ] == 0 && compHeight [ comp ] == 0 ) { \nreturn size ; \n} \nreturn new Size ( size . getWidth ( ) >> compWidth [ comp ] , size . getHeight ( ) >> compHeight [ comp ] ) ; \n} \n} \n"}
{"3618": "public class BitStream { \nprotected int readCache ( boolean peek ) throws AACException { \nint i ; \nif ( pos > buffer . length - WORD_BYTES ) { \nthrow AACException . endOfStream ( ) ; \n} \nelse { \ni = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; \n} \nif ( ! peek ) { \npos += WORD_BYTES ; \n} \nreturn i ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nint sf = _in . readBits ( 4 ) ; \nif ( sf == 0xF ) { \nconfig . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \n} \nelse { \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \n} \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( AAC_SBR == cp ) { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nelse if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) { \nthrow new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \n} \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( config . dependsOnCoreCoder ) { \nconfig . coreCoderDelay = _in . readBits ( 14 ) ; \n} \nelse { \nconfig . coreCoderDelay = 0 ; \n} \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( _in . getBitsLeft ( ) > 10 ) { \nreadSyncExtension ( _in , config ) ; \n} \n} \nelse { \nthrow new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \n} \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( range < 0x8000 ) { \nwhile ( range < 0x8000 ) { \nrenormalize ( ) ; \n} \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nwhile ( range < 0x8000 ) { \nrenormalize ( ) ; \n} \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) { \ncm . setMps ( 1 - cm . getMps ( ) ) ; \n} \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n"}
{"3623": "public class SliceHeaderReader { \nprivate static void readDecoderPicMarking ( NALUnit nalUnit , SliceHeader sh , BitReader _in ) { \nif ( nalUnit . type == NALUnitType . IDR_SLICE ) { \nboolean noOutputOfPriorPicsFlag = readBool ( _in , \"SH: no_output_of_prior_pics_flag\" ) ; \nboolean longTermReferenceFlag = readBool ( _in , \"SH: long_term_reference_flag\" ) ; \nsh . refPicMarkingIDR = new RefPicMarkingIDR ( noOutputOfPriorPicsFlag , longTermReferenceFlag ) ; \n} \nelse { \nboolean adaptiveRefPicMarkingModeFlag = readBool ( _in , \"SH: adaptive_ref_pic_marking_mode_flag\" ) ; \nif ( adaptiveRefPicMarkingModeFlag ) { \nArrayList < Instruction > mmops = new ArrayList < Instruction > ( ) ; \nint memoryManagementControlOperation ; \ndo { \nmemoryManagementControlOperation = readUEtrace ( _in , \"SH: memory_management_control_operation\" ) ; \nInstruction instr = null ; \nswitch ( memoryManagementControlOperation ) { \ncase 1 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_SHORT , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , 0 ) ; \nbreak ; \ncase 2 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_LONG , readUEtrace ( _in , \"SH: long_term_pic_num\" ) , 0 ) ; \nbreak ; \ncase 3 : instr = new RefPicMarking . Instruction ( InstrType . CONVERT_INTO_LONG , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) ) ; \nbreak ; \ncase 4 : instr = new RefPicMarking . Instruction ( InstrType . TRUNK_LONG , readUEtrace ( _in , \"SH: max_long_term_frame_idx_plus1\" ) - 1 , 0 ) ; \nbreak ; \ncase 5 : instr = new RefPicMarking . Instruction ( InstrType . CLEAR , 0 , 0 ) ; \nbreak ; \ncase 6 : instr = new RefPicMarking . Instruction ( InstrType . MARK_LONG , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) , 0 ) ; \nbreak ; \n} \nif ( instr != null ) { \nmmops . add ( instr ) ; \n} \n} \nwhile ( memoryManagementControlOperation != 0 ) ; \nsh . refPicMarkingNonIDR = new RefPicMarking ( mmops . toArray ( new Instruction [ ] { \n} \n) ) ; \n} \n} \n} \n} \n"}
{"3625": "public class Decoder { \npublic void decodeFrame ( byte [ ] frame , SampleBuffer buffer ) throws AACException { \nif ( frame != null ) { \n_in . setData ( frame ) ; \n} \nLogger . debug ( \"bits left \" + _in . getBitsLeft ( ) ) ; \ntry { \ndecode ( buffer ) ; \n} \ncatch ( AACException e ) { \nif ( ! e . isEndOfStream ( ) ) { \nthrow e ; \n} \nelse { \nLogger . warn ( \"unexpected end of frame\" ) ; \n} \n} \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) { \nthrow new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \n} \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( sinkColor != null ) { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nelse { \ntoEncode = new LoanerPicture ( pic , 0 ) ; \n} \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) { \npixelStore . putBack ( toEncode ) ; \n} \ntimestamp += fps . getDen ( ) ; \nframeNo ++ ; \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) { \nreturn 1 ; \n} \nint length = 8 ; \nwhile ( length > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ) { \nlength -- ; \n} \nreturn length ; \n} \n} \n"}
{"3631": "public class FLVWriter { \npublic void addPacket ( FLVTag pkt ) throws IOException { \nif ( ! writePacket ( writeBuf , pkt ) ) { \nwriteBuf . flip ( ) ; \nstartOfLastPacket -= out . write ( writeBuf ) ; \nwriteBuf . clear ( ) ; \nif ( ! writePacket ( writeBuf , pkt ) ) { \nthrow new RuntimeException ( \"Unexpected\" ) ; \n} \n} \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni ++ ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) { \nbreak ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nint bin ; \nint qIdx = ( range >> 6 ) & 0x3 ; \nint rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange -= rLPS ; \nint rs8 = range << 8 ; \nif ( code < rs8 ) { \nif ( cm [ 0 ] [ m ] < 62 ) { \ncm [ 0 ] [ m ] ++ ; \n} \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nelse { \nrange = rLPS ; \ncode -= rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) { \ncm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \n} \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( nBitsPending <= 0 ) { \nreadOneByte ( ) ; \n} \nint tmp = code - ( range << 8 ) ; \nif ( tmp < 0 ) { \nreturn 0 ; \n} \nelse { \ncode = tmp ; \nreturn 1 ; \n} \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) { \nreturn null ; \n} \nint from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nint val = 0xffffffff ; \nwhile ( buf . hasRemaining ( ) ) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( val >= mmin && val <= mmax ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \n-- n ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3636": "public class SampleFrequency { \npublic static SampleFrequency forInt ( int i ) { \nfinal SampleFrequency freq ; \nif ( i >= 0 && i < 12 ) { \nfreq = values ( ) [ i ] ; \n} \nelse { \nfreq = SAMPLE_FREQUENCY_NONE ; \n} \nreturn freq ; \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) { \nreturn ; \n} \nint al = a . bufa ; \nint ah = a . bufb ; \nint bl , bh ; \nif ( len > 32 ) { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nelse { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen += a . len ; \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( int i = 0 ; \ni < ID_GAIN ; \ni ++ ) { \nif ( lngain == LN_GAIN [ i ] ) { \nreturn i ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"3647": "public class DataConvert { \npublic static int [ ] fromByte ( byte [ ] b , int depth , boolean isBe ) { \nif ( depth == 24 ) { \nif ( isBe ) { \nreturn from24BE ( b ) ; \n} \nelse { \nreturn from24LE ( b ) ; \n} \n} \nelse if ( depth == 16 ) { \nif ( isBe ) { \nreturn from16BE ( b ) ; \n} \nelse { \nreturn from16LE ( b ) ; \n} \n} \nthrow new NotSupportedException ( \"Conversion from \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3648": "public class DataConvert { \npublic static byte [ ] toByte ( int [ ] ia , int depth , boolean isBe ) { \nif ( depth == 24 ) { \nif ( isBe ) { \nreturn to24BE ( ia ) ; \n} \nelse { \nreturn to24LE ( ia ) ; \n} \n} \nelse if ( depth == 16 ) { \nif ( isBe ) { \nreturn to16BE ( ia ) ; \n} \nelse { \nreturn to16LE ( ia ) ; \n} \n} \nthrow new NotSupportedException ( \"Conversion to \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) { \nthrow new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) { \nthrow new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16BE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16LE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) { \nthrow new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) { \nthrow new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16BE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16LE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \ni < ins . length ; \ni ++ ) { \nif ( ins [ i ] . remaining ( ) > max ) { \nmax = ins [ i ] . remaining ( ) ; \n} \n} \nfor ( int frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes ++ ) { \nfor ( int j = 0 ; \nj < ins . length ; \nj ++ ) { \nif ( ins [ j ] . remaining ( ) < bytesPerSample ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \noutb . put ( ( byte ) 0 ) ; \n} \n} \nelse { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3653": "public class TrakBox { \npublic Size getCodedSize ( ) { \nSampleEntry se = getSampleEntries ( ) [ 0 ] ; \nif ( ! ( se instanceof VideoSampleEntry ) ) { \nthrow new IllegalArgumentException ( \"Not a video track\" ) ; \n} \nVideoSampleEntry vse = ( VideoSampleEntry ) se ; \nreturn new Size ( vse . getWidth ( ) , vse . getHeight ( ) ) ; \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni ++ ) { \ngroups [ i ] = 1 ; \n} \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3658": "public class MBlockDecoderUtils { \npublic static int calcMVPredictionMedian ( int a , int b , int c , int d , boolean aAvb , boolean bAvb , boolean cAvb , boolean dAvb , int ref , int comp ) { \nif ( ! cAvb ) { \nc = d ; \ncAvb = dAvb ; \n} \nif ( aAvb && ! bAvb && ! cAvb ) { \nb = c = a ; \nbAvb = cAvb = aAvb ; \n} \na = aAvb ? a : NULL_VECTOR ; \nb = bAvb ? b : NULL_VECTOR ; \nc = cAvb ? c : NULL_VECTOR ; \nif ( mvRef ( a ) == ref && mvRef ( b ) != ref && mvRef ( c ) != ref ) { \nreturn mvC ( a , comp ) ; \n} \nelse if ( mvRef ( b ) == ref && mvRef ( a ) != ref && mvRef ( c ) != ref ) { \nreturn mvC ( b , comp ) ; \n} \nelse if ( mvRef ( c ) == ref && mvRef ( a ) != ref && mvRef ( b ) != ref ) { \nreturn mvC ( c , comp ) ; \n} \nreturn mvC ( a , comp ) + mvC ( b , comp ) + mvC ( c , comp ) - min ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) - max ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) ; \n} \n} \n"}
{"3659": "public class H264Encoder { \npublic EncodedFrame encodeFrame ( Picture pic , ByteBuffer _out ) { \nif ( pic . getColor ( ) != ColorSpace . YUV420J ) { \nthrow new IllegalArgumentException ( \"Input picture color is not supported: \" + pic . getColor ( ) ) ; \n} \nif ( frameNumber >= keyInterval ) { \nframeNumber = 0 ; \n} \nSliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; \nboolean idr = frameNumber == 0 ; \nByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber ++ , sliceType ) ; \nreturn new EncodedFrame ( data , idr ) ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni ++ ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) { \nretval . add ( id ) ; \n} \nuniqueSet . add ( id ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni ++ ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) { \nretval . add ( tag ) ; \n} \nuniqueSet . add ( tag ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal int slot = mNextAvailableReferenceSlot ++ ; \nif ( slot < mMaxValidReference ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \nreturn true ; \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nwhile ( ! mSpinLock . compareAndSet ( false , true ) ) { \n; \n} \n} \ntry { \nint slot = mNextAvailableReferenceSlot ++ ; \nif ( slot >= mMaxValidReference ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot ++ ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nint numSurvivors = sweepAndCollect ( ) ; \nfor ( int i = 0 ; \ni < numSurvivors ; \ni ++ ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) { \nref . delete ( ) ; \n} \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) { \nreturn false ; \n} \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) { \ntry { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3669": "public class JNILibrary { \nprivate static void deleteTemporaryFiles ( ) { \nfinal File dir = getTmpDir ( ) ; \nfinal FilenameFilter filter = new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( HUMBLE_TEMP_EXTENSION ) ; \n} \n} \n; \nfinal File markers [ ] = dir . listFiles ( filter ) ; \nfor ( File marker : markers ) { \nfinal String markerName = marker . getName ( ) ; \nfinal String libName = markerName . substring ( 0 , markerName . length ( ) - HUMBLE_TEMP_EXTENSION . length ( ) ) ; \nfinal File lib = new File ( marker . getParentFile ( ) , libName ) ; \nif ( ! lib . exists ( ) || lib . delete ( ) ) { \nmarker . delete ( ) ; \n} \n} \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) { \nthrow new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \n} \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3683": "public class Codec { \npublic java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { \njava . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; \nint count = getNumSupportedVideoFrameRates ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nRational rate = getSupportedVideoFrameRate ( i ) ; \nif ( rate != null ) { \nretval . add ( rate ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nint count = getNumSupportedVideoPixelFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) { \nretval . add ( type ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3685": "public class Codec { \npublic java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { \njava . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; \nint count = getNumSupportedAudioSampleRates ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nint rate = getSupportedAudioSampleRate ( i ) ; \nif ( rate != 0 ) { \nretval . add ( rate ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nint count = getNumSupportedAudioFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) { \nretval . add ( fmt ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3687": "public class Codec { \npublic java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { \njava . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; \nint count = getNumSupportedAudioChannelLayouts ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nAudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; \nif ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) { \nretval . add ( layout ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3692": "public class MuxerFormat { \npublic static java . util . Collection < MuxerFormat > getFormats ( ) { \njava . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; \nint count = getNumFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \n++ i ) { \nMuxerFormat fmt = getFormat ( i ) ; \nif ( fmt != null ) { \nretval . add ( fmt ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3698": "public class AMediaPictureConverter { \nprotected void validateImage ( BufferedImage image ) { \nif ( image == null ) { \nthrow new IllegalArgumentException ( \"The passed image is NULL.\" ) ; \n} \nif ( image . getType ( ) != getImageType ( ) ) { \nthrow new IllegalArgumentException ( \"The passed image is of type #\" + image . getType ( ) + \" but is required to be of BufferedImage type #\" + getImageType ( ) + \".\" ) ; \n} \n} \n} \n"}
{"3699": "public class AMediaPictureConverter { \nprotected void validatePicture ( MediaPicture picture ) { \nif ( picture == null ) { \nthrow new IllegalArgumentException ( \"The picture is NULL.\" ) ; \n} \nif ( ! picture . isComplete ( ) ) { \nthrow new IllegalArgumentException ( \"The picture is not complete.\" ) ; \n} \nPixelFormat . Type type = picture . getFormat ( ) ; \nif ( ( type != getPictureType ( ) ) && ( willResample ( ) && type != mToImageResampler . getOutputFormat ( ) ) ) { \nthrow new IllegalArgumentException ( \"Picture is of type: \" + type + \", but must be \" + getPictureType ( ) + ( willResample ( ) ? \" or \" + mToImageResampler . getOutputFormat ( ) : \"\" ) + \".\" ) ; \n} \n} \n} \n"}
{"3703": "public class JNIEnv { \npublic static CPUArch getCPUArchFromGNUString ( String gnuString ) { \nfinal String nativeCpu = gnuString . toLowerCase ( ) ; \nfinal CPUArch nativeArch ; \nif ( nativeCpu . startsWith ( \"x86_64\" ) || nativeCpu . startsWith ( \"amd64\" ) || nativeCpu . startsWith ( \"ia64\" ) ) { \nnativeArch = CPUArch . X86_64 ; \n} \nelse if ( nativeCpu . startsWith ( \"ppc64\" ) || nativeCpu . startsWith ( \"powerpc64\" ) ) { \nnativeArch = CPUArch . PPC64 ; \n} \nelse if ( nativeCpu . startsWith ( \"ppc\" ) || nativeCpu . startsWith ( \"powerpc\" ) ) { \nnativeArch = CPUArch . PPC ; \n} \nelse if ( nativeCpu . contains ( \"86\" ) ) { \nnativeArch = CPUArch . X86 ; \n} \nelse { \nnativeArch = CPUArch . UNKNOWN ; \n} \nreturn nativeArch ; \n} \n} \n"}
{"3704": "public class JNIEnv { \npublic static OSFamily getOSFamily ( String osName ) { \nfinal OSFamily retval ; \nif ( osName != null && osName . length ( ) > 0 ) { \nif ( osName . startsWith ( \"Windows\" ) ) { \nretval = OSFamily . WINDOWS ; \n} \nelse if ( osName . startsWith ( \"Mac\" ) ) { \nretval = OSFamily . MAC ; \n} \nelse if ( osName . startsWith ( \"Linux\" ) ) { \nretval = OSFamily . LINUX ; \n} \nelse { \nretval = OSFamily . UNKNOWN ; \n} \n} \nelse { \nretval = OSFamily . UNKNOWN ; \n} \nreturn retval ; \n} \n} \n"}
{"3705": "public class JNIEnv { \npublic static OSFamily getOSFamilyFromGNUString ( String gnuString ) { \nfinal String nativeOs = ( gnuString != null ? gnuString . toLowerCase ( ) : \"\" ) ; \nfinal OSFamily retval ; \nif ( nativeOs . startsWith ( \"mingw\" ) || nativeOs . startsWith ( \"cygwin\" ) ) { \nretval = OSFamily . WINDOWS ; \n} \nelse if ( nativeOs . startsWith ( \"darwin\" ) ) { \nretval = OSFamily . MAC ; \n} \nelse if ( nativeOs . startsWith ( \"linux\" ) ) { \nretval = OSFamily . LINUX ; \n} \nelse { \nretval = OSFamily . UNKNOWN ; \n} \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) { \nthrow new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \n} \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) { \nthrow new LineUnavailableException ( ) ; \n} \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3707": "public class JNILibraryLoader { \nsynchronized void loadLibrary0 ( String aLibraryName , Long aMajorVersion ) { \nif ( alreadyLoadedLibrary ( aLibraryName , aMajorVersion ) ) { \nreturn ; \n} \nList < String > libCandidates = getLibraryCandidates ( aLibraryName , aMajorVersion ) ; \nif ( libCandidates != null && libCandidates . size ( ) > 0 && ! loadCandidateLibrary ( aLibraryName , aMajorVersion , libCandidates ) ) { \ntry { \nSystem . loadLibrary ( aLibraryName ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nlog . error ( \"Could not load library: {}; version: {}.\" , aLibraryName , aMajorVersion == null ? \"\" : aMajorVersion ) ; \nthrow e ; \n} \nsetLoadedLibrary ( aLibraryName , aMajorVersion ) ; \n} \nlog . trace ( \"Successfully Loaded library: {}; Version: {}\" , aLibraryName , aMajorVersion ) ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) { \nencoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \n} \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) { \nconverter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \n} \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) { \nmuxer . write ( packet , false ) ; \n} \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) { \nmuxer . write ( packet , false ) ; \n} \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) { \ninput = input . substring ( 7 ) ; \n} \nif ( input . length ( ) == 0 ) { \nreturn new byte [ 0 ] ; \n} \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( int i = 0 ; \ni < input . length ( ) ; \n++ i ) { \nchar c = input . charAt ( i ) ; \nint digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n} \nint zeros = 0 ; \nwhile ( zeros < input58 . length && input58 [ zeros ] == 0 ) { \n++ zeros ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \nfor ( int inputStart = zeros ; \ninputStart < input58 . length ; \n) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \n++ inputStart ; \n} \n} \nwhile ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { \n++ outputStart ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3728": "public class FSTBytezEncoder { \n@ Override public void flush ( ) throws IOException { \nif ( outStream != null ) { \noutStream . write ( getBuffer ( ) , 0 , ( int ) pos ) ; \n} \npos = 0 ; \n} \n} \n"}
{"3733": "public class FSTClazzLineageInfo { \npublic static int getSpecificity ( final Class < ? > clazz ) { \nif ( clazz == null ) { \nreturn 0 ; \n} \nfinal LineageInfo lineageInfo = FSTClazzLineageInfo . getLineageInfo ( clazz ) ; \nreturn lineageInfo == null ? 0 : lineageInfo . specificity ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) { \nthrow new RuntimeException ( \"store is full. Required: \" + required ) ; \n} \nif ( required <= memory . length ( ) ) { \nreturn ; \n} \nmutationCount ++ ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni ++ ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3735": "public class FSTBinaryOffheapMap { \npublic void removeBinary ( ByteSource key ) { \ncheckThread ( ) ; \nif ( key . length ( ) != keyLen ) { \nthrow new RuntimeException ( \"key must have length \" + keyLen ) ; \n} \nmutationCount ++ ; \nlong rem = index . get ( key ) ; \nif ( rem != 0 ) { \nindex . remove ( key ) ; \ndecElems ( ) ; \nremoveEntry ( rem ) ; \n} \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nint len = name . length ( ) ; \nif ( len >= 127 ) { \nthrow new RuntimeException ( \"Ascii String too long\" ) ; \n} \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null || ascStringCache . length < len ) { \nascStringCache = new byte [ len ] ; \n} \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \n} \n} \n"}
{"3737": "public class FSTStreamEncoder { \n@ Override public void setOutstream ( OutputStream outstream ) { \nif ( buffout == null ) { \nbuffout = ( FSTOutputStream ) conf . getCachedObject ( FSTOutputStream . class ) ; \nif ( buffout == null ) { \nbuffout = new FSTOutputStream ( 1000 , outstream ) ; \n} \nelse { \nbuffout . reset ( ) ; \n} \n} \nif ( outstream == null ) { \nbuffout . setOutstream ( buffout ) ; \n} \nelse { \nbuffout . setOutstream ( outstream ) ; \n} \n} \n} \n"}
{"3748": "public class MBOut { \npublic void writeInt ( byte type , long data ) { \nif ( ! MinBin . isPrimitive ( type ) || MinBin . isArray ( type ) ) { \nthrow new RuntimeException ( \"illegal type code\" ) ; \n} \nwriteOut ( type ) ; \nwriteRawInt ( type , data ) ; \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) { \nwriteInt ( MinBin . INT_8 , data ) ; \n} \nelse if ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) { \nwriteInt ( MinBin . INT_16 , data ) ; \n} \nelse if ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) { \nwriteInt ( MinBin . INT_32 , data ) ; \n} \nelse if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) { \nwriteInt ( MinBin . INT_64 , data ) ; \n} \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) { \ntype |= MinBin . INT_8 ; \n} \nelse if ( componentType == byte . class ) { \ntype |= MinBin . INT_8 ; \n} \nelse if ( componentType == short . class ) { \ntype |= MinBin . INT_16 ; \n} \nelse if ( componentType == char . class ) { \ntype |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \n} \nelse if ( componentType == int . class ) { \ntype |= MinBin . INT_32 ; \n} \nelse if ( componentType == long . class ) { \ntype |= MinBin . INT_64 ; \n} \nelse { \nthrow new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \n} \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nif ( componentType == boolean . class ) { \nwriteRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \n} \nelse { \nwriteRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse { \nwriteObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \n} \n} \n"}
{"3767": "public class BinaryQueue { \npublic void back ( int len ) { \nif ( pollIndex >= len ) { \npollIndex -= len ; \n} \nelse { \npollIndex = pollIndex + capacity ( ) - len ; \n} \n} \n} \n"}
{"3769": "public class EmbeddedCassandraServerHelper { \npublic static void startEmbeddedCassandra ( File file , String tmpDir , long timeout ) throws IOException , ConfigurationException { \nif ( cassandraDaemon != null ) { \nreturn ; \n} \ncheckConfigNameForRestart ( file . getAbsolutePath ( ) ) ; \nlog . debug ( \"Starting cassandra...\" ) ; \nlog . debug ( \"Initialization needed\" ) ; \nSystem . setProperty ( \"cassandra.config\" , \"file:\" + file . getAbsolutePath ( ) ) ; \nSystem . setProperty ( \"cassandra-foreground\" , \"true\" ) ; \nSystem . setProperty ( \"cassandra.native.epoll.enabled\" , \"false\" ) ; \nSystem . setProperty ( \"cassandra.unsafesystem\" , \"true\" ) ; \nif ( System . getProperty ( \"log4j.configuration\" ) == null ) { \ncopy ( DEFAULT_LOG4J_CONFIG_FILE , tmpDir ) ; \nSystem . setProperty ( \"log4j.configuration\" , \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE ) ; \n} \nDatabaseDescriptor . daemonInitialization ( ) ; \ncleanupAndLeaveDirs ( ) ; \nfinal CountDownLatch startupLatch = new CountDownLatch ( 1 ) ; \nExecutorService executor = Executors . newSingleThreadExecutor ( ) ; \nexecutor . execute ( ( ) -> { \ncassandraDaemon = new CassandraDaemon ( ) ; \ncassandraDaemon . activate ( ) ; \nstartupLatch . countDown ( ) ; \n} \n) ; \ntry { \nif ( ! startupLatch . await ( timeout , MILLISECONDS ) ) { \nlog . error ( \"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\" ) ; \nthrow new AssertionError ( \"Cassandra daemon did not start within timeout\" ) ; \n} \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) -> { \nif ( session != null ) { \nsession . close ( ) ; \n} \nif ( cluster != null ) { \ncluster . close ( ) ; \n} \n} \n) ) ; \n} \ncatch ( InterruptedException e ) { \nlog . error ( \"Interrupted waiting for Cassandra daemon to start:\" , e ) ; \nthrow new AssertionError ( e ) ; \n} \nfinally { \nexecutor . shutdown ( ) ; \n} \n} \n} \n"}
{"3776": "public class BaseBroadcastOp { \npublic List < long [ ] > calculateOutputShape ( ) { \nList < long [ ] > ret = new ArrayList < > ( ) ; \nif ( larg ( ) . getShape ( ) != null && rarg ( ) . getShape ( ) != null ) { \nret . add ( Shape . broadcastOutputShape ( larg ( ) . getShape ( ) , rarg ( ) . getShape ( ) ) ) ; \n} \nelse if ( larg ( ) . getShape ( ) != null ) { \nret . add ( larg ( ) . getShape ( ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3778": "public class BooleanIndexing { \npublic static boolean and ( final INDArray n , final Condition cond ) { \nif ( cond instanceof BaseCondition ) { \nlong val = ( long ) Nd4j . getExecutioner ( ) . exec ( new MatchCondition ( n , cond ) , Integer . MAX_VALUE ) . getDouble ( 0 ) ; \nif ( val == n . lengthLong ( ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \nelse { \nboolean ret = true ; \nfinal AtomicBoolean a = new AtomicBoolean ( ret ) ; \nShape . iterate ( n , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( a . get ( ) ) { \na . compareAndSet ( true , a . get ( ) && cond . apply ( n . getDouble ( coord [ 0 ] ) ) ) ; \n} \n} \n} \n) ; \nreturn a . get ( ) ; \n} \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) { \nthrow new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \n} \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( arr . getDouble ( i ) == tadLength ) { \nresult [ i ] = true ; \n} \nelse { \nresult [ i ] = false ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) { \nthrow new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \n} \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) { \nif ( arr . getDouble ( i ) > 0 ) { \nresult [ i ] = true ; \n} \nelse { \nresult [ i ] = false ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3781": "public class BooleanIndexing { \npublic static void applyWhere ( final INDArray to , final Condition condition , final Number number ) { \nif ( condition instanceof BaseCondition ) { \nNd4j . getExecutioner ( ) . exec ( new CompareAndSet ( to , number . doubleValue ( ) , condition ) ) ; \n} \nelse { \nfinal double value = number . doubleValue ( ) ; \nfinal Function < Number , Number > dynamic = new Function < Number , Number > ( ) { \n@ Override public Number apply ( Number number ) { \nreturn value ; \n} \n} \n; \nShape . iterate ( to , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( condition . apply ( to . getDouble ( coord [ 0 ] ) ) ) { \nto . putScalar ( coord [ 0 ] , dynamic . apply ( to . getDouble ( coord [ 0 ] ) ) . doubleValue ( ) ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"3782": "public class BooleanIndexing { \npublic static INDArray firstIndex ( INDArray array , Condition condition ) { \nif ( ! ( condition instanceof BaseCondition ) ) { \nthrow new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \n} \nFirstIndex idx = new FirstIndex ( array , condition ) ; \nNd4j . getExecutioner ( ) . exec ( idx ) ; \nreturn Nd4j . scalar ( ( double ) idx . getFinalResult ( ) ) ; \n} \n} \n"}
{"3784": "public class FunctionProperties { \npublic static FunctionProperties fromFlatProperties ( FlatProperties properties ) { \nval props = new FunctionProperties ( ) ; \nfor ( int e = 0 ; \ne < properties . iLength ( ) ; \ne ++ ) { \nprops . getI ( ) . add ( properties . i ( e ) ) ; \n} \nfor ( int e = 0 ; \ne < properties . lLength ( ) ; \ne ++ ) { \nprops . getL ( ) . add ( properties . l ( e ) ) ; \n} \nfor ( int e = 0 ; \ne < properties . dLength ( ) ; \ne ++ ) { \nprops . getD ( ) . add ( properties . d ( e ) ) ; \n} \nfor ( int e = 0 ; \ne < properties . iLength ( ) ; \ne ++ ) { \nprops . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; \n} \nreturn props ; \n} \n} \n"}
{"3787": "public class AtomicThrowable { \npublic void setIfFirst ( Throwable t ) { \ntry { \nlock . writeLock ( ) . lock ( ) ; \nif ( this . t == null ) { \nthis . t = t ; \n} \n} \nfinally { \nlock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"3788": "public class MathUtils { \npublic static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { \nif ( x . size ( ) != y . size ( ) ) { \nthrow new IllegalArgumentException ( \"Sample sizes must be the same for each data applyTransformToDestination.\" ) ; \n} \nList < Double > ret = new ArrayList < Double > ( ) ; \nfor ( int i = 0 ; \ni < x . size ( ) ; \ni ++ ) { \nret . add ( x . get ( i ) ) ; \nret . add ( y . get ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3789": "public class MathUtils { \npublic static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { \nint count = 0 ; \nList < List < Double > > ret = new ArrayList < List < Double > > ( ) ; \nwhile ( count < arr . size ( ) ) { \nList < Double > sublist = arr . subList ( count , count + chunk ) ; \ncount += chunk ; \nret . add ( sublist ) ; \n} \nfor ( List < Double > lists : ret ) { \nif ( lists . size ( ) < chunk ) { \nret . remove ( lists ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3793": "public class Convolution { \npublic static INDArray col2im ( INDArray col , int sy , int sx , int ph , int pw , int h , int w ) { \nif ( col . rank ( ) != 6 ) { \nthrow new IllegalArgumentException ( \"col2im input array must be rank 6\" ) ; \n} \nINDArray output = Nd4j . create ( new long [ ] { \ncol . size ( 0 ) , col . size ( 1 ) , h , w } \n) ; \nCol2Im col2Im = Col2Im . builder ( ) . inputArrays ( new INDArray [ ] { \ncol } \n) . outputs ( new INDArray [ ] { \noutput } \n) . conv2DConfig ( Conv2DConfig . builder ( ) . sy ( sy ) . sx ( sx ) . dw ( 1 ) . dh ( 1 ) . kh ( h ) . kw ( w ) . ph ( ph ) . pw ( pw ) . build ( ) ) . build ( ) ; \nNd4j . getExecutioner ( ) . exec ( col2Im ) ; \nreturn col2Im . outputArguments ( ) [ 0 ] ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) { \nif ( ! arrs [ i ] . isScalar ( ) ) { \nthrow new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \n} \n} \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \n} \n} \n"}
{"3799": "public class BaseNDArrayFactory { \n@ Override public INDArray linspace ( int lower , int upper , int num ) { \ndouble [ ] data = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \ndouble t = ( double ) i / ( num - 1 ) ; \ndata [ i ] = lower * ( 1 - t ) + t * upper ; \n} \nINDArray ret = Nd4j . create ( data . length ) ; \nif ( ret . isScalar ( ) ) { \nreturn ret ; \n} \nfor ( int i = 0 ; \ni < ret . length ( ) ; \ni ++ ) { \nret . putScalar ( i , data [ i ] ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3811": "public class ComplexUtil { \npublic static IComplexNumber pow ( IComplexNumber num , IComplexNumber power ) { \nComplex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . pow ( new Complex ( power . realComponent ( ) . doubleValue ( ) , power . imaginaryComponent ( ) . doubleValue ( ) ) ) ; \nif ( c . isNaN ( ) ) { \nc = new Complex ( Nd4j . EPS_THRESHOLD , 0.0 ) ; \n} \nreturn Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( int i = 0 ; \ni < getFeatures ( ) . length ( ) ; \ni ++ ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( curr > cutoff ) { \ngetFeatures ( ) . putScalar ( i , 1 ) ; \n} \nelse { \ngetFeatures ( ) . putScalar ( i , 0 ) ; \n} \n} \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \nfor ( int i = 0 ; \ni < numSamples ; \ni ++ ) { \nint picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) { \nwhile ( added . contains ( picked ) ) { \npicked = rng . nextInt ( numExamples ( ) ) ; \n} \n} \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3829": "public class InvertMatrix { \npublic static INDArray invert ( INDArray arr , boolean inPlace ) { \nif ( ! arr . isSquare ( ) ) { \nthrow new IllegalArgumentException ( \"invalid array: must be square matrix\" ) ; \n} \nRealMatrix rm = CheckUtil . convertToApacheMatrix ( arr ) ; \nRealMatrix rmInverse = new LUDecomposition ( rm ) . getSolver ( ) . getInverse ( ) ; \nINDArray inverse = CheckUtil . convertFromApacheMatrix ( rmInverse ) ; \nif ( inPlace ) { \narr . assign ( inverse ) ; \n} \nreturn inverse ; \n} \n} \n"}
{"3835": "public class Shape { \npublic static boolean isVector ( DataBuffer shapeInfo ) { \nint rank = Shape . rank ( shapeInfo ) ; \nif ( rank > 2 || rank < 1 ) { \nreturn false ; \n} \nelse { \nint len = Shape . length ( shapeInfo ) ; \nDataBuffer shape = Shape . shapeOf ( shapeInfo ) ; \nreturn shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; \n} \n} \n} \n"}
{"3838": "public class Shape { \npublic static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { \nINDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; \nfor ( int i = 0 ; \ni < ret . length ; \ni ++ ) { \nret [ i ] = new NDArrayIndex ( indices [ i ] ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3839": "public class BaseDataBuffer { \nprotected short getShort ( long i ) { \nif ( dataType ( ) != Type . HALF ) { \nthrow new UnsupportedOperationException ( \"getShort() is supported for Half-precision buffers only\" ) ; \n} \nreturn fromFloat ( ( ( HalfIndexer ) indexer ) . get ( offset ( ) + i ) ) ; \n} \n} \n"}
{"3855": "public class MultipleEpochsIterator { \n@ Override public DataSet next ( ) { \nif ( ! iter . hasNext ( ) && passes < numPasses ) { \npasses ++ ; \nbatch = 0 ; \nlog . info ( \"Epoch \" + passes + \" batch \" + batch ) ; \niter . reset ( ) ; \n} \nbatch ++ ; \nDataSet next = iter . next ( ) ; \nif ( preProcessor != null ) { \npreProcessor . preProcess ( next ) ; \n} \nreturn next ; \n} \n} \n"}
{"3858": "public class Paths { \npublic static boolean nameExistsInPath ( String name ) { \nString path = System . getenv ( PATH_ENV_VARIABLE ) ; \nString [ ] dirs = path . split ( File . pathSeparator ) ; \nfor ( String dir : dirs ) { \nFile dirFile = new File ( dir ) ; \nif ( ! dirFile . exists ( ) ) { \ncontinue ; \n} \nif ( dirFile . isFile ( ) && dirFile . getName ( ) . equals ( name ) ) { \nreturn true ; \n} \nelse { \nIterator < File > files = FileUtils . iterateFiles ( dirFile , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile curr = files . next ( ) ; \nif ( curr . getName ( ) . equals ( name ) ) { \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3864": "public class RRWLock { \n@ Override public void attachObject ( Object object ) { \nif ( ! objectLocks . containsKey ( object ) ) { \nobjectLocks . put ( object , new ReentrantReadWriteLock ( ) ) ; \n} \n} \n} \n"}
{"3869": "public class CudaAffinityManager { \n@ Override public Integer getDeviceForThread ( long threadId ) { \nif ( getNumberOfDevices ( ) == 1 ) { \nreturn 0 ; \n} \nInteger aff = affinityMap . get ( threadId ) ; \nif ( aff == null ) { \nInteger deviceId = getNextDevice ( threadId ) ; \naffinityMap . put ( threadId , deviceId ) ; \naffiliated . set ( new AtomicBoolean ( false ) ) ; \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( deviceId ) ) ; \naffiliated . get ( ) . set ( true ) ; \n} \nreturn deviceId ; \n} \nelse { \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nif ( affiliated . get ( ) == null ) { \naffiliated . set ( new AtomicBoolean ( false ) ) ; \n} \nif ( ! affiliated . get ( ) . get ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( aff ) ) ; \naffiliated . get ( ) . set ( true ) ; \nreturn aff ; \n} \n} \nreturn aff ; \n} \n} \n} \n"}
{"3871": "public class CudaAffinityManager { \nprotected Integer getNextDevice ( long threadId ) { \nInteger device = null ; \nif ( ! CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isForcedSingleGPU ( ) && getNumberOfDevices ( ) > 0 ) { \nsynchronized ( this ) { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( devPtr . getAndIncrement ( ) ) ; \nif ( devPtr . get ( ) >= CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) { \ndevPtr . set ( 0 ) ; \n} \nlogger . debug ( \"Mapping thread [{}] to device [{}], out of [{}] devices...\" , threadId , device , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) ; \n} \n} \nelse { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( 0 ) ; \nlogger . debug ( \"Single device is forced, mapping to device [{}]\" , device ) ; \n} \nreturn device ; \n} \n} \n"}
{"3874": "public class Nd4jKafkaProducer { \npublic void publish ( INDArray arr ) { \nif ( producerTemplate == null ) { \nproducerTemplate = camelContext . createProducerTemplate ( ) ; \n} \nproducerTemplate . sendBody ( \"direct:start\" , arr ) ; \n} \n} \n"}
{"3875": "public class InstrumentationApplication { \npublic void start ( ) { \ntry { \nInputStream is = new ClassPathResource ( resourcePath , InstrumentationApplication . class . getClassLoader ( ) ) . getInputStream ( ) ; \nFile tmpConfig = new File ( resourcePath ) ; \nif ( ! tmpConfig . getParentFile ( ) . exists ( ) ) { \ntmpConfig . getParentFile ( ) . mkdirs ( ) ; \n} \nBufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( tmpConfig ) ) ; \nIOUtils . copy ( is , bos ) ; \nbos . flush ( ) ; \nrun ( new String [ ] { \n\"server\" , tmpConfig . getAbsolutePath ( ) } \n) ; \ntmpConfig . deleteOnExit ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"3877": "public class DefaultOpExecutioner { \nprotected void interceptIntDataType ( Op op ) { \nif ( op . x ( ) != null && op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) { \nthrow new ND4JIllegalStateException ( \"Op.X contains INT data. Operations on INT dataType are not supported yet\" ) ; \n} \nif ( op . z ( ) != null && op . z ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) { \nthrow new ND4JIllegalStateException ( \"Op.Z contains INT data. Operations on INT dataType are not supported yet\" ) ; \n} \nif ( op . y ( ) != null && op . y ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) { \nthrow new ND4JIllegalStateException ( \"Op.Y contains INT data. Operations on INT dataType are not supported yet.\" ) ; \n} \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( payload != null ) { \nif ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) { \nstorage . getArray ( key ) . assign ( payload ) ; \n} \nelse { \nstorage . setArray ( key , payload ) ; \n} \n} \nelse { \nif ( index >= 0 ) { \nif ( storage . getArray ( key ) == null ) { \nthrow new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \n} \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \nelse { \nstorage . getArray ( key ) . assign ( value ) ; \n} \n} \n} \n} \n"}
{"3883": "public class OpProfiler { \nprotected String getOpClass ( Op op ) { \nif ( op instanceof ScalarOp ) { \nreturn \"ScalarOp\" ; \n} \nelse if ( op instanceof MetaOp ) { \nreturn \"MetaOp\" ; \n} \nelse if ( op instanceof GridOp ) { \nreturn \"GridOp\" ; \n} \nelse if ( op instanceof BroadcastOp ) { \nreturn \"BroadcastOp\" ; \n} \nelse if ( op instanceof RandomOp ) { \nreturn \"RandomOp\" ; \n} \nelse if ( op instanceof Accumulation ) { \nreturn \"AccumulationOp\" ; \n} \nelse if ( op instanceof TransformOp ) { \nif ( op . y ( ) == null ) { \nreturn \"TransformOp\" ; \n} \nelse { \nreturn \"PairWiseTransformOp\" ; \n} \n} \nelse if ( op instanceof IndexAccumulation ) { \nreturn \"IndexAccumulationOp\" ; \n} \nelse if ( op instanceof CustomOp ) { \nreturn \"CustomOp\" ; \n} \nelse { \nreturn \"Unknown Op calls\" ; \n} \n} \n} \n"}
{"3884": "public class SDVariable { \npublic INDArray storeAndAllocateNewArray ( ) { \nval shape = sameDiff . getShapeForVarName ( getVarName ( ) ) ; \nif ( getArr ( ) != null && Arrays . equals ( getArr ( ) . shape ( ) , shape ) ) { \nreturn getArr ( ) ; \n} \nif ( varName == null ) { \nthrow new ND4JIllegalStateException ( \"Unable to store array for null variable name!\" ) ; \n} \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Unable to allocate new array. No shape found for variable \" + varName ) ; \n} \nval arr = getWeightInitScheme ( ) . create ( shape ) ; \nsameDiff . putArrayForVarName ( getVarName ( ) , arr ) ; \nreturn arr ; \n} \n} \n"}
{"3885": "public class SDVariable { \npublic long [ ] getShape ( ) { \nlong [ ] initialShape = sameDiff . getShapeForVarName ( getVarName ( ) ) ; \nif ( initialShape == null ) { \nval arr = getArr ( ) ; \nif ( arr != null ) { \nreturn arr . shape ( ) ; \n} \n} \nreturn initialShape ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) { \nreturn arr ; \n} \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) { \nif ( shape [ i ] < 1 ) { \nshape [ i ] = 1 ; \n} \n} \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( shapeMatrix . length ( ) > 1 ) { \nreturn arr . get ( indexes ) ; \n} \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3890": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { \nif ( nd . isVector ( ) ) { \nIComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { \n1 , n } \n) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \ntruncated . putScalar ( i , nd . getComplex ( i ) ) ; \n} \nreturn truncated ; \n} \nif ( nd . size ( dimension ) > n ) { \nlong [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; \nshape [ dimension ] = n ; \nIComplexNDArray ret = Nd4j . createComplex ( shape ) ; \nIComplexNDArray ndLinear = nd . linearView ( ) ; \nIComplexNDArray retLinear = ret . linearView ( ) ; \nfor ( int i = 0 ; \ni < ret . length ( ) ; \ni ++ ) { \nretLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \nreturn nd ; \n} \n} \n"}
{"3891": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray padWithZeros ( IComplexNDArray nd , long [ ] targetShape ) { \nif ( Arrays . equals ( nd . shape ( ) , targetShape ) ) { \nreturn nd ; \n} \nif ( ArrayUtil . prod ( nd . shape ( ) ) >= ArrayUtil . prod ( targetShape ) ) { \nreturn nd ; \n} \nIComplexNDArray ret = Nd4j . createComplex ( targetShape ) ; \nINDArrayIndex [ ] targetShapeIndex = NDArrayIndex . createCoveringShape ( nd . shape ( ) ) ; \nret . put ( targetShapeIndex , nd ) ; \nreturn ret ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) { \nreturn ; \n} \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \ni < numDevices ; \ni ++ ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \n} \n} \n"}
{"3916": "public class SameDiff { \npublic String [ ] getInputsForFunction ( DifferentialFunction function ) { \nif ( ! incomingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Illegal function instance id found \" + function . getOwnName ( ) ) ; \n} \nreturn incomingArgsReverse . get ( function . getOwnName ( ) ) ; \n} \n} \n"}
{"3919": "public class SameDiff { \npublic void associateArrayWithVariable ( INDArray arr , SDVariable variable ) { \nif ( variable == null ) { \nthrow new ND4JIllegalArgumentException ( \"Variable must not be null!\" ) ; \n} \nif ( arr == null ) { \nthrow new ND4JIllegalArgumentException ( \"Array must not be null\" ) ; \n} \nreverseArrayLookup . put ( arr , variable ) ; \nvariableNameToArr . put ( variable . getVarName ( ) , arr ) ; \nif ( ! shapeAlreadyExistsForVarName ( variable . getVarName ( ) ) ) { \nputShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \nelse { \nupdateShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) { \nthrow new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \n} \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) { \nthrow new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \n} \nfor ( int i = 0 ; \ni < varNames . length ; \ni ++ ) { \nif ( varNames [ i ] == null ) { \nthrow new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \n} \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3923": "public class SameDiff { \npublic void addArgsFor ( String [ ] variables , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) { \nthrow new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \n} \nfor ( val varName : variables ) { \nif ( isPlaceHolder ( varName ) ) { \nplaceHolderFunctions . add ( function . getOwnName ( ) ) ; \n} \n} \nincomingArgs . put ( variables , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , variables ) ; \nfor ( val variableName : variables ) { \nList < DifferentialFunction > funcs = functionsArgsFor . get ( variableName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionsArgsFor . put ( variableName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3924": "public class SameDiff { \npublic boolean hasArgs ( DifferentialFunction function ) { \nval vertexIdArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nif ( vertexIdArgs != null ) { \nval args = incomingArgs . get ( vertexIdArgs ) ; \nif ( args != null ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3925": "public class SameDiff { \npublic INDArray [ ] eval ( Map < String , INDArray > inputs ) { \nSameDiff execPipeline = dup ( ) ; \nList < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; \nif ( opExecAction . isEmpty ( ) ) { \nthrow new IllegalStateException ( \"No ops found to execute.\" ) ; \n} \nINDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; \nfor ( int i = 0 ; \ni < ret . length ; \ni ++ ) { \nval varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; \nret [ i ] = execPipeline . getArrForVarName ( varName ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3935": "public class SameDiff { \npublic Pair < Map < SDVariable , DifferentialFunction > , List < DifferentialFunction > > exec ( String functionName ) { \nif ( debugMode ) { \nreturn sameDiffFunctionInstances . get ( functionName ) . enableDebugMode ( ) . exec ( ) ; \n} \nelse { \nreturn sameDiffFunctionInstances . get ( functionName ) . exec ( ) ; \n} \n} \n} \n"}
{"3939": "public class CudaMemoryManager { \n@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { \nAtomicAllocator allocator = AtomicAllocator . getInstance ( ) ; \nif ( kind == MemoryKind . HOST ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; \nif ( ptr == null ) { \nthrow new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from HOST memory\" ) ; \n} \nif ( initialize ) { \nPointer . memset ( ptr , 0 , bytes ) ; \n} \nreturn ptr ; \n} \nelse if ( kind == MemoryKind . DEVICE ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; \nif ( ptr == null ) { \nthrow new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + \"] memory\" ) ; \n} \nif ( initialize ) { \nCudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; \nint i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; \nif ( i == 0 ) { \nthrow new ND4JIllegalStateException ( \"memset failed on device_\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; \n} \ncontext . getSpecialStream ( ) . synchronize ( ) ; \n} \nreturn ptr ; \n} \nelse { \nthrow new RuntimeException ( \"Unknown MemoryKind requested: \" + kind ) ; \n} \n} \n} \n"}
{"3942": "public class DataTypeUtil { \npublic static DataBuffer . Type getDtypeFromContext ( ) { \ntry { \nlock . readLock ( ) . lock ( ) ; \nif ( dtype == null ) { \nlock . readLock ( ) . unlock ( ) ; \nlock . writeLock ( ) . lock ( ) ; \nif ( dtype == null ) { \ndtype = getDtypeFromContext ( Nd4jContext . getInstance ( ) . getConf ( ) . getProperty ( \"dtype\" ) ) ; \n} \nlock . writeLock ( ) . unlock ( ) ; \nlock . readLock ( ) . lock ( ) ; \n} \nreturn dtype ; \n} \nfinally { \nlock . readLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"3946": "public class BaseLevel2 { \n@ Override public void trmv ( char order , char Uplo , char TransA , char Diag , INDArray A , INDArray X ) { \nif ( Nd4j . getExecutioner ( ) . getProfilingMode ( ) == OpExecutioner . ProfilingMode . ALL ) { \nOpProfiler . getInstance ( ) . processBlasCall ( false , A , X ) ; \n} \nif ( A . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . DOUBLE , A , X ) ; \ndtrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nelse { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . FLOAT , A , X ) ; \nstrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nOpExecutionerUtil . checkForAny ( X ) ; \n} \n} \n"}
{"3947": "public class Nd4jKafkaConsumer { \npublic INDArray receive ( ) { \nif ( consumerTemplate == null ) { \nconsumerTemplate = camelContext . createConsumerTemplate ( ) ; \n} \nreturn consumerTemplate . receiveBody ( \"direct:receive\" , INDArray . class ) ; \n} \n} \n"}
{"3950": "public class TFGraphMapper { \npublic String getNodeName ( String name ) { \nString ret = name ; \nif ( ret . startsWith ( \"^\" ) ) { \nret = ret . substring ( 1 ) ; \n} \nif ( ret . endsWith ( \"/read\" ) ) { \nret = ret . replace ( \"/read\" , \"\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3951": "public class NativeOpExecutioner { \nprivate void invoke ( ScalarOp op , int [ ] dimension ) { \ndimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; \nPair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; \nPointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; \nPointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; \nPointer devTadShapeInfoZ = null ; \nPointer devTadOffsetsZ = null ; \nPair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; \ndevTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; \ndevTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; \nif ( extraz . get ( ) == null ) { \nextraz . set ( new PointerPointer ( 32 ) ) ; \n} \nPointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) { \nloop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \nelse if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nloop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \n} \n} \n"}
{"3956": "public class AtomicState { \npublic void releaseToe ( ) { \nif ( getCurrentState ( ) == AccessState . TOE ) { \nif ( 1 > 0 ) { \nif ( toeRequests . decrementAndGet ( ) == 0 ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \ncurrentState . set ( AccessState . TACK . ordinal ( ) ) ; \n} \n} \nelse { \nthrow new IllegalStateException ( \"releaseToe() is called from different thread.\" ) ; \n} \n} \nelse { \nthrow new IllegalStateException ( \"Object is NOT in Toe state!\" ) ; \n} \n} \n} \n"}
{"3957": "public class AtomicState { \npublic AccessState getCurrentState ( ) { \nif ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) { \nreturn AccessState . TOE ; \n} \nelse { \nif ( tickRequests . get ( ) <= tackRequests . get ( ) ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \nreturn AccessState . TACK ; \n} \nelse { \nreturn AccessState . TICK ; \n} \n} \n} \n} \n"}
{"3959": "public class VectorAggregation { \n@ Override public void processMessage ( ) { \nif ( clipboard . isTracking ( this . originatorId , this . getTaskId ( ) ) ) { \nclipboard . pin ( this ) ; \nif ( clipboard . isReady ( this . originatorId , taskId ) ) { \nVoidAggregation aggregation = clipboard . unpin ( this . originatorId , taskId ) ; \nif ( aggregation == null ) { \nreturn ; \n} \nVectorCompleteMessage msg = new VectorCompleteMessage ( taskId , aggregation . getAccumulatedResult ( ) ) ; \nmsg . setOriginatorId ( aggregation . getOriginatorId ( ) ) ; \ntransport . sendMessage ( msg ) ; \n} \n} \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) { \nlog . warn ( \"Warning: empty dataset from the fetcher\" ) ; \n} \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \nfor ( int i = 0 ; \ni < examples . size ( ) ; \ni ++ ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \n} \ncurr = new DataSet ( inputs , labels ) ; \n} \n} \n"}
{"3963": "public class AtomicAllocator { \n@ Override public void synchronizeHostData ( DataBuffer buffer ) { \nif ( buffer . isConstant ( ) ) { \nreturn ; \n} \nif ( memoryHandler . isDeviceDependant ( ) ) { \nAllocationPoint point = getAllocationPoint ( buffer . getTrackingPoint ( ) ) ; \nif ( point == null ) { \nthrow new RuntimeException ( \"AllocationPoint is NULL\" ) ; \n} \nmemoryHandler . synchronizeThreadDevice ( Thread . currentThread ( ) . getId ( ) , memoryHandler . getDeviceId ( ) , point ) ; \n} \n} \n} \n"}
{"3964": "public class AdaGradUpdater { \n@ Override public void applyUpdater ( INDArray gradient , int iteration , int epoch ) { \nif ( historicalGradient == null ) { \nthrow new IllegalStateException ( \"Updater has not been initialized with view state\" ) ; \n} \ndouble learningRate = config . getLearningRate ( iteration , epoch ) ; \ndouble epsilon = config . getEpsilon ( ) ; \nhistoricalGradient . addi ( gradient . mul ( gradient ) ) ; \nINDArray sqrtHistory = sqrt ( historicalGradient . dup ( gradientReshapeOrder ) , false ) . addi ( epsilon ) ; \ngradient . muli ( sqrtHistory . rdivi ( learningRate ) ) ; \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) { \nthrow new ND4JArraySizeException ( ) ; \n} \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \ni < index . rows ( ) ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nj < row . columns ( ) ; \nj ++ ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3968": "public class DifferentialFunction { \npublic boolean hasPlaceHolderInputs ( ) { \nval args = args ( ) ; \nfor ( val arg : args ) if ( sameDiff . hasPlaceHolderVariables ( arg ( ) . getVarName ( ) ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nint addPrecision = this . precision ; \nwhile ( addPrecision > 0 ) { \nthis . scientificFormat += \"#\" ; \naddPrecision -= 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . scientificFormat . length ( ) + 2 > this . padding ) { \nthis . padding = this . scientificFormat . length ( ) + 2 ; \n} \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize && arr . length ( ) > 1000 ) { \nreturn format ( arr , 0 , true ) ; \n} \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"3971": "public class BaseGraphMapper { \n@ Override public SameDiff importGraph ( GRAPH_TYPE tfGraph ) { \nSameDiff diff = SameDiff . create ( ) ; \nImportState < GRAPH_TYPE , TENSOR_TYPE > importState = new ImportState < > ( ) ; \nimportState . setSameDiff ( diff ) ; \nimportState . setGraph ( tfGraph ) ; \nval variablesForGraph = variablesForGraph ( tfGraph ) ; \nimportState . setVariables ( variablesForGraph ) ; \nfor ( Map . Entry < String , TENSOR_TYPE > entry : variablesForGraph . entrySet ( ) ) { \nif ( dataTypeForTensor ( entry . getValue ( ) ) == DataBuffer . Type . UNKNOWN ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) { \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , var . getShape ( ) ) ; \n} \n} \ncontinue ; \n} \nval arr = getNDArrayFromTensor ( entry . getKey ( ) , entry . getValue ( ) , tfGraph ) ; \nif ( arr != null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , arr ) ; \ndiff . associateArrayWithVariable ( arr , var ) ; \n} \nelse if ( getShapeFromTensor ( entry . getValue ( ) ) == null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) { \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \n} \nelse { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , originalShape ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \n} \nval tfNodesList = getNodeList ( tfGraph ) ; \nfor ( NODE_TYPE tfNode : tfNodesList ) { \nif ( ! opsToIgnore ( ) . contains ( getOpType ( tfNode ) ) || isOpIgnoreException ( tfNode ) ) { \nmapNodeType ( tfNode , importState ) ; \n} \n} \nreturn diff ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) { \narr . putScalar ( 0 , getReal ( 0 ) ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \n} \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) { \narr . putScalar ( 0 , getReal ( 0 ) ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \n} \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \nfor ( int i = 0 ; \ni < linearView ( ) . length ( ) ; \ni ++ ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( diff <= Nd4j . EPS_THRESHOLD ) { \nlinear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \n} \nelse { \nlinear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) { \nLinAlgExceptions . assertSameLength ( this , arr ) ; \n} \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \nlinear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nelse { \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) { \nr . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3984": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray subi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( other . isScalar ( ) ) { \nreturn subi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \n} \nelse if ( result == other ) { \nif ( data . dataType ( ) == ( DataBuffer . Type . DOUBLE ) ) { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asFloat ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \n} \nelse { \nNd4j . getBlasWrapper ( ) . copy ( this , result ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \n} \nreturn cResult ; \n} \n} \n"}
{"3986": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( Number value ) { \nIComplexNDArray one = linearView ( ) ; \nfor ( int i = 0 ; \ni < one . length ( ) ; \ni ++ ) { \none . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( length ( ) >= Integer . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \n} \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < length ( ) ; \ni ++ ) { \nret . putScalar ( i , linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3990": "public class BaseLevel1 { \n@ Override public int iamax ( IComplexNDArray arr ) { \nif ( arr . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nreturn izamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; \n} \nreturn icamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; \n} \n} \n"}
{"3991": "public class BaseLevel1 { \n@ Override public void copy ( IComplexNDArray x , IComplexNDArray y ) { \nif ( x . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nzcopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \n} \nelse { \nccopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \n} \n} \n} \n"}
{"3992": "public class BaseLevel1 { \n@ Override public void scal ( long N , IComplexNumber alpha , IComplexNDArray X ) { \nif ( X . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nzscal ( N , alpha . asDouble ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \n} \nelse { \ncscal ( N , alpha . asFloat ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \n} \n} \n} \n"}
{"3996": "public class TypeUtils { \npublic static < T > Constructor < T > getNoArgConstructor ( Class < T > clazz ) { \ntry { \nConstructor < T > ctor = clazz . getDeclaredConstructor ( new Class [ 0 ] ) ; \nctor . setAccessible ( true ) ; \nreturn ctor ; \n} \ncatch ( NoSuchMethodException e ) { \nif ( clazz . isMemberClass ( ) || clazz . isAnonymousClass ( ) || clazz . isLocalClass ( ) ) { \nthrow new IllegalStateException ( clazz . getName ( ) + \" must be static and must have a no-arg constructor\" , e ) ; \n} \nelse { \nthrow new IllegalStateException ( clazz . getName ( ) + \" must have a no-arg constructor\" , e ) ; \n} \n} \n} \n} \n"}
{"3999": "public class TypeUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < A extends Annotation > A getAnnotation ( Annotation [ ] annotations , Class < A > annotationType ) { \nfor ( Annotation anno : annotations ) if ( annotationType . isAssignableFrom ( anno . getClass ( ) ) ) { \nreturn ( A ) anno ; \n} \nreturn null ; \n} \n} \n"}
{"4006": "public class Registrar { \npublic < T > EntityMetadata < T > getMetadataSafe ( String kind ) throws IllegalArgumentException { \nEntityMetadata < T > metadata = this . getMetadata ( kind ) ; \nif ( metadata == null ) { \nthrow new IllegalArgumentException ( \"No entity class has been registered which matches kind '\" + kind + \"'\" ) ; \n} \nelse { \nreturn metadata ; \n} \n} \n} \n"}
{"4014": "public class LogUtils { \npublic static String msg ( Path path , String msg ) { \nStringBuilder bld = new StringBuilder ( ) ; \nbld . append ( \"\\t.\" ) ; \nbld . append ( path . toPathString ( ) ) ; \nif ( bld . length ( ) < PATH_PADDING ) { \nwhile ( bld . length ( ) < PATH_PADDING ) { \nbld . append ( ' ' ) ; \n} \n} \nelse { \nbld . append ( '\\t' ) ; \n} \nbld . append ( msg ) ; \nreturn bld . toString ( ) ; \n} \n} \n"}
{"4017": "public class Key { \npublic static < V > Key < V > key ( final com . google . cloud . datastore . Key raw ) { \nif ( raw == null ) { \nreturn null ; \n} \nelse { \nreturn new Key < > ( raw ) ; \n} \n} \n} \n"}
{"4018": "public class Key { \npublic static com . google . cloud . datastore . Key key ( final Key < ? > typed ) { \nif ( typed == null ) { \nreturn null ; \n} \nelse { \nreturn typed . getRaw ( ) ; \n} \n} \n} \n"}
{"4019": "public class Key { \nprivate static String getKindHere ( final Class < ? > clazz ) { \nfinal Entity ourAnn = TypeUtils . getDeclaredAnnotation ( clazz , Entity . class ) ; \nif ( ourAnn != null ) { \nif ( ourAnn . name ( ) . length ( ) != 0 ) { \nreturn ourAnn . name ( ) ; \n} \nelse { \nreturn clazz . getSimpleName ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( type instanceof Class ) { \nfor ( Class < ? > clazz = ( Class < ? > ) type ; \nclazz != null ; \nclazz = clazz . getEnclosingClass ( ) ) { \nif ( clazz . getTypeParameters ( ) . length != 0 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( type instanceof ParameterizedType ) { \nreturn false ; \n} \nelse { \nthrow new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse if ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) { \nreturn true ; \n} \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) { \nreturn getArrayExactDirectSuperTypes ( clazz ) ; \n} \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \nType [ ] result ; \nint resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse if ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse if ( type instanceof WildcardType ) { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof CaptureType ) { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof GenericArrayType ) { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse if ( type == null ) { \nthrow new NullPointerException ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n} \n"}
{"4026": "public class ClassPopulator { \nprivate Boolean getIndexInstruction ( Class < P > clazz ) { \nIndex ind = clazz . getAnnotation ( Index . class ) ; \nUnindex unind = clazz . getAnnotation ( Unindex . class ) ; \nif ( ind != null && unind != null ) { \nthrow new IllegalStateException ( \"You cannot have @Index and @Unindex on the same class: \" + clazz ) ; \n} \nif ( ind != null ) { \nreturn true ; \n} \nelse if ( unind != null ) { \nreturn false ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"4027": "public class ClassPopulator { \nprivate boolean isOfInterest ( Method method ) { \nfor ( Annotation [ ] annos : method . getParameterAnnotations ( ) ) if ( TypeUtils . getAnnotation ( annos , AlsoLoad . class ) != null ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4028": "public class ClassPopulator { \nprivate List < Property > getDeclaredProperties ( ObjectifyFactory fact , Class < ? > clazz ) { \nList < Property > good = new ArrayList < > ( ) ; \nfor ( Field field : clazz . getDeclaredFields ( ) ) if ( isOfInterest ( field ) ) { \ngood . add ( new FieldProperty ( fact , clazz , field ) ) ; \n} \nfor ( Method method : clazz . getDeclaredMethods ( ) ) if ( isOfInterest ( method ) ) { \ngood . add ( new MethodProperty ( method ) ) ; \n} \nreturn good ; \n} \n} \n"}
{"4031": "public class Round { \npublic void execute ( ) { \nif ( needsExecution ( ) ) { \nlog . trace ( \"Executing round: {}\" , pending ) ; \nResult < Map < com . google . cloud . datastore . Key , Entity > > fetched = fetchPending ( ) ; \ntranslated = loadEngine . translate ( fetched ) ; \nif ( loadEngine . ofy . getTransaction ( ) != null && depth > 0 ) { \ntranslated . now ( ) ; \n} \n} \n} \n} \n"}
{"4032": "public class Round { \nprivate Result < Map < com . google . cloud . datastore . Key , Entity > > fetchPending ( ) { \nfinal Map < com . google . cloud . datastore . Key , Entity > combined = new HashMap < > ( ) ; \nSet < com . google . cloud . datastore . Key > fetch = new HashSet < > ( ) ; \nfor ( com . google . cloud . datastore . Key key : pending ) { \nEntity ent = stuffed . get ( key ) ; \nif ( ent == null ) { \nfetch . add ( key ) ; \n} \nelse { \ncombined . put ( key , ent ) ; \n} \n} \nif ( fetch . isEmpty ( ) ) { \nreturn new ResultNow < > ( combined ) ; \n} \nelse { \nfinal Result < Map < com . google . cloud . datastore . Key , Entity > > fetched = loadEngine . fetch ( fetch ) ; \nreturn ( ) -> { \ncombined . putAll ( fetched . now ( ) ) ; \nreturn combined ; \n} \n; \n} \n} \n} \n"}
{"4033": "public class ClassTranslator { \nprivate void addIndexedDiscriminators ( final Class < ? > clazz ) { \nif ( clazz == Object . class ) { \nreturn ; \n} \nthis . addIndexedDiscriminators ( clazz . getSuperclass ( ) ) ; \nfinal Subclass sub = clazz . getAnnotation ( Subclass . class ) ; \nif ( sub != null && sub . index ( ) ) { \nfinal String disc = ( sub . name ( ) . length ( ) > 0 ) ? sub . name ( ) : clazz . getSimpleName ( ) ; \nthis . indexedDiscriminators . add ( StringValue . of ( disc ) ) ; \n} \n} \n} \n"}
{"4035": "public class GenericUtils { \npublic static Type getCollectionComponentType ( Type collectionType ) { \nType componentType = GenericTypeReflector . getTypeParameter ( collectionType , Collection . class . getTypeParameters ( ) [ 0 ] ) ; \nif ( componentType == null ) { \nreturn Object . class ; \n} \nelse { \nreturn componentType ; \n} \n} \n} \n"}
{"4036": "public class GenericUtils { \npublic static Type getMapKeyType ( Type mapType ) { \nType componentType = GenericTypeReflector . getTypeParameter ( mapType , Map . class . getTypeParameters ( ) [ 0 ] ) ; \nif ( componentType == null ) { \nreturn Object . class ; \n} \nelse { \nreturn componentType ; \n} \n} \n} \n"}
{"4037": "public class ForwardPath { \npublic static ForwardPath of ( Path path ) { \nForwardPath next = new ForwardPath ( path ) ; \nif ( path . getPrevious ( ) == Path . root ( ) ) { \nreturn next ; \n} \nForwardPath previous = of ( path . getPrevious ( ) ) ; \nprevious . next = next ; \nreturn previous ; \n} \n} \n"}
{"4038": "public class ForwardPath { \npublic Path getFinalPath ( ) { \nForwardPath here = this ; \nwhile ( here . next != null ) { \nhere = here . next ; \n} \nreturn here . getPath ( ) ; \n} \n} \n"}
{"4041": "public class EntityMemcache { \npublic void putAll ( final Collection < Bucket > updates ) { \nfinal Set < Key > good = this . cachePutIfUntouched ( updates ) ; \nif ( good . size ( ) == updates . size ( ) ) { \nreturn ; \n} \nfinal List < Key > bad = updates . stream ( ) . map ( Bucket :: getKey ) . filter ( key -> ! good . contains ( key ) ) . collect ( Collectors . toList ( ) ) ; \nif ( ! bad . isEmpty ( ) ) { \nfinal Map < Key , Object > cached = this . cacheGetAll ( bad ) ; \ncached . values ( ) . removeIf ( Objects :: isNull ) ; \nthis . empty ( cached . keySet ( ) ) ; \n} \n} \n} \n"}
{"4042": "public class EntityMemcache { \npublic void empty ( final Iterable < Key > keys ) { \nfinal Map < Key , Object > updates = new HashMap < > ( ) ; \nfor ( final Key key : keys ) if ( cacheControl . isCacheable ( key ) ) { \nupdates . put ( key , null ) ; \n} \nthis . memcacheWithRetry . putAll ( updates ) ; \n} \n} \n"}
{"4046": "public class KeyMetadata { \nprivate void findKeyFields ( Class < ? > inspect , CreateContext ctx , Path path ) { \nif ( inspect == Object . class ) { \nreturn ; \n} \nfindKeyFields ( inspect . getSuperclass ( ) , ctx , path ) ; \nfor ( Field field : inspect . getDeclaredFields ( ) ) { \nif ( field . getAnnotation ( Id . class ) != null ) { \nif ( this . idMeta != null ) { \nthrow new IllegalStateException ( \"Multiple @Id fields in the class hierarchy of \" + clazz . getName ( ) ) ; \n} \nif ( ( field . getType ( ) != Long . class ) && ( field . getType ( ) != long . class ) && ( field . getType ( ) != String . class ) ) { \nthrow new IllegalStateException ( \"@Id field '\" + field . getName ( ) + \"' in \" + inspect . getName ( ) + \" must be of type Long, long, or String\" ) ; \n} \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . idMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \nelse if ( field . getAnnotation ( Parent . class ) != null ) { \nif ( this . parentMeta != null ) { \nthrow new IllegalStateException ( \"Multiple @Parent fields in the class hierarchy of \" + clazz . getName ( ) ) ; \n} \nif ( ! isAllowedParentFieldType ( field . getType ( ) ) ) { \nthrow new IllegalStateException ( \"@Parent fields must be Ref<?>, Key<?>, or datastore Key. Illegal parent: \" + field ) ; \n} \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . parentMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \n} \n} \n} \n"}
{"4048": "public class KeyMetadata { \npublic void setLongId ( P pojo , Long id ) { \nif ( ! clazz . isAssignableFrom ( pojo . getClass ( ) ) ) { \nthrow new IllegalArgumentException ( \"Trying to use metadata for \" + clazz . getName ( ) + \" to set key of \" + pojo . getClass ( ) . getName ( ) ) ; \n} \nthis . idMeta . getProperty ( ) . set ( pojo , id ) ; \n} \n} \n"}
{"4049": "public class KeyMetadata { \nprivate com . google . cloud . datastore . Key getParentRaw ( P pojo ) { \nif ( parentMeta == null ) { \nreturn null ; \n} \nfinal Value < Object > value = parentMeta . getValue ( pojo , new SaveContext ( ) , Path . root ( ) ) ; \nreturn ( value == null || value . getType ( ) == ValueType . NULL ) ? null : ( com . google . cloud . datastore . Key ) value . get ( ) ; \n} \n} \n"}
{"4050": "public class ClassTranslatorFactory { \nprivate void registerSubclass ( final ClassTranslator < P > translator , final TypeKey < ? super P > superclassTypeKey , final CreateContext ctx , final Path path ) { \nif ( superclassTypeKey . getTypeAsClass ( ) == Object . class ) { \nreturn ; \n} \n@ SuppressWarnings ( \"unchecked\" ) final ClassTranslator < ? super P > superTranslator = create ( ( TypeKey ) superclassTypeKey , ctx , path ) ; \nsuperTranslator . registerSubclass ( translator ) ; \nregisterSubclass ( translator , new TypeKey < > ( superclassTypeKey . getTypeAsClass ( ) . getSuperclass ( ) ) , ctx , path ) ; \n} \n} \n"}
{"4054": "public class Session { \npublic void addAll ( final Session other ) { \nif ( log . isTraceEnabled ( ) ) { \nlog . trace ( \"Adding all values to session: {}\" , other . map . keySet ( ) ) ; \n} \nmap . putAll ( other . map ) ; \n} \n} \n"}
{"4055": "public class LoadEngine { \npublic < T > Result < T > load ( final Key < T > key ) { \nif ( key == null ) { \nthrow new NullPointerException ( \"You tried to load a null key!\" ) ; \n} \nfinal Result < T > result = round . get ( key ) ; \nif ( ofy . getTransaction ( ) != null ) { \n( ( PrivateAsyncTransaction ) ofy . getTransaction ( ) ) . enlist ( result ) ; \n} \nif ( key . getParent ( ) != null ) { \nfinal KeyMetadata < ? > meta = ofy . factory ( ) . keys ( ) . getMetadata ( key ) ; \nif ( meta != null ) { \nif ( meta . shouldLoadParent ( loadArrangement ) ) { \nload ( key . getParent ( ) ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"4059": "public class LoadEngine { \n@ SuppressWarnings ( \"unchecked\" ) public < T > T load ( final BaseEntity < com . google . cloud . datastore . Key > ent , final LoadContext ctx ) { \nif ( ent == null ) { \nreturn null ; \n} \nfinal EntityMetadata < T > meta = ofy . factory ( ) . getMetadata ( ent . getKey ( ) . getKind ( ) ) ; \nif ( meta == null ) { \nreturn ( T ) ent ; \n} \nelse { \nreturn meta . load ( ent , ctx ) ; \n} \n} \n} \n"}
{"4060": "public class Keys { \npublic com . google . cloud . datastore . Key createRawAny ( final com . google . cloud . datastore . Key parent , final String kind , final Object id ) { \nif ( id instanceof String ) { \nreturn createRaw ( parent , kind , ( String ) id ) ; \n} \nelse if ( id instanceof Long ) { \nreturn createRaw ( parent , kind , ( Long ) id ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"id '\" + id + \"' must be String or Long\" ) ; \n} \n} \n} \n"}
{"4062": "public class Keys { \n@ SuppressWarnings ( \"unchecked\" ) public static < S > Value < S > getIdValue ( final IncompleteKey key ) { \nif ( key instanceof com . google . cloud . datastore . Key ) { \nfinal com . google . cloud . datastore . Key completeKey = ( com . google . cloud . datastore . Key ) key ; \nif ( completeKey . hasId ( ) ) { \nreturn ( Value < S > ) LongValue . of ( completeKey . getId ( ) ) ; \n} \nelse { \nreturn ( Value < S > ) StringValue . of ( completeKey . getName ( ) ) ; \n} \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"4067": "public class FieldProperty { \nprivate boolean matches ( Object onPojo , If < ? , ? > [ ] conditions ) { \nif ( conditions == null ) { \nreturn false ; \n} \nObject value = this . get ( onPojo ) ; \nfor ( If < ? , ? > condition : conditions ) { \n@ SuppressWarnings ( \"unchecked\" ) If < Object , Object > cond = ( If < Object , Object > ) condition ; \nif ( cond . matchesValue ( value ) ) { \nreturn true ; \n} \nif ( cond . matchesPojo ( onPojo ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4068": "public class LiveRef { \nprivate Objectify ofy ( ) { \nif ( ofy == null || ( ofy . getTransaction ( ) != null && ! ofy . getTransaction ( ) . isActive ( ) ) ) { \nofy = ObjectifyService . ofy ( ) ; \n} \nreturn ofy ; \n} \n} \n"}
{"4069": "public class ObjectifyFactory { \npublic AsyncDatastore asyncDatastore ( final boolean enableGlobalCache ) { \nif ( this . entityMemcache != null && enableGlobalCache && this . registrar . isCacheEnabled ( ) ) { \nreturn new CachingAsyncDatastore ( asyncDatastore ( ) , this . entityMemcache ) ; \n} \nelse { \nreturn asyncDatastore ( ) ; \n} \n} \n} \n"}
{"4073": "public class ObjectifyFactory { \npublic void close ( final Objectify ofy ) { \nfinal Deque < Objectify > stack = stacks . get ( ) ; \nif ( stack . isEmpty ( ) ) { \nthrow new IllegalStateException ( \"You have already destroyed the Objectify context.\" ) ; \n} \nfinal Objectify popped = stack . removeLast ( ) ; \nassert popped == ofy : \"Mismatched objectify instances; somehow the stack was corrupted\" ; \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) { \nlist . set ( i , index ( value , true ) ) ; \n} \n} \n} \n} \n"}
{"4076": "public class Ref { \nfinal public T safe ( ) throws NotFoundException { \nT t = this . get ( ) ; \nif ( t == null ) { \nthrow new NotFoundException ( key ( ) ) ; \n} \nelse { \nreturn t ; \n} \n} \n} \n"}
{"4079": "public class IfConditionGenerator { \npublic If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { \nif ( ifClasses . length == 0 ) { \nreturn ALWAYS ; \n} \nIf < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; \nfor ( int i = 0 ; \ni < ifClasses . length ; \ni ++ ) { \nClass < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; \nresult [ i ] = this . createIf ( ifClass , field ) ; \nType valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; \nClass < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; \nType pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; \nClass < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; \nif ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) { \nthrow new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because you cannot assign \" + field . getType ( ) . getName ( ) + \" to \" + valueClass . getName ( ) ) ; \n} \nif ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) { \nthrow new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because the containing class \" + field . getDeclaringClass ( ) . getName ( ) + \" is not compatible with \" + pojoClass . getName ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4081": "public class LoadContext { \npublic Object getContainer ( Type containerType , Path path ) { \nClass < ? > containerClass = GenericTypeReflector . erase ( containerType ) ; \nIterator < Object > containersIt = containers . descendingIterator ( ) ; \ncontainersIt . next ( ) ; \nwhile ( containersIt . hasNext ( ) ) { \nObject potentialContainer = containersIt . next ( ) ; \nif ( containerClass . isAssignableFrom ( potentialContainer . getClass ( ) ) ) { \nreturn potentialContainer ; \n} \n} \nthrow new IllegalStateException ( \"No container matching \" + containerType + \" in \" + containers + \" at path \" + path ) ; \n} \n} \n"}
{"4083": "public class FutureHelper { \npublic static void unwrapAndThrow ( Throwable ex ) { \nif ( ex instanceof RuntimeException ) { \nthrow ( RuntimeException ) ex ; \n} \nelse if ( ex instanceof Error ) { \nthrow ( Error ) ex ; \n} \nelse if ( ex instanceof ExecutionException ) { \nunwrapAndThrow ( ex . getCause ( ) ) ; \n} \nelse { \nthrow new UndeclaredThrowableException ( ex ) ; \n} \n} \n} \n"}
{"4086": "public class Translators { \nprivate Translator < ? , ? > create ( final TypeKey tk , final CreateContext ctx , final Path path ) { \nfor ( final TranslatorFactory < ? , ? > trans : this . translatorFactories ) { \n@ SuppressWarnings ( \"unchecked\" ) final Translator < ? , ? > soFar = trans . create ( tk , ctx , path ) ; \nif ( soFar != null ) { \nreturn soFar ; \n} \n} \nthrow new IllegalArgumentException ( \"Don't know how to translate \" + tk . getType ( ) + \" with annotations \" + Arrays . toString ( tk . getAnnotations ( ) ) ) ; \n} \n} \n"}
{"4087": "public class PropertyPopulator { \n@ Override public void load ( final FullEntity < ? > container , final LoadContext ctx , final Path containerPath , final P intoPojo ) { \ntry { \nif ( translator instanceof Recycles ) { \nctx . recycle ( property . get ( intoPojo ) ) ; \n} \nfinal Value < D > value = ( translator instanceof Synthetic ) ? null : getPropertyFromContainer ( container , containerPath ) ; \nsetValue ( intoPojo , value , ctx , containerPath ) ; \n} \ncatch ( SkipException ex ) { \n} \n} \n} \n"}
{"4088": "public class PropertyPopulator { \nprivate Value < D > getPropertyFromContainer ( final FullEntity < ? > container , final Path containerPath ) { \nString foundName = null ; \nValue < D > value = null ; \nfor ( String name : property . getLoadNames ( ) ) { \nif ( container . contains ( name ) ) { \nif ( foundName != null ) { \nthrow new IllegalStateException ( \"Collision trying to load field; multiple name matches for '\" + property . getName ( ) + \"' at '\" + containerPath . extend ( foundName ) + \"' and '\" + containerPath . extend ( name ) + \"'\" ) ; \n} \nvalue = container . getValue ( name ) ; \nfoundName = name ; \n} \n} \nif ( foundName == null ) { \nthrow new SkipException ( ) ; \n} \nelse { \nreturn value ; \n} \n} \n} \n"}
{"4090": "public class PropertyPopulator { \n@ Override public void save ( final P onPojo , boolean index , final SaveContext ctx , final Path containerPath , final FullEntity . Builder < ? > into ) { \nif ( property . isSaved ( onPojo ) ) { \nfinal Boolean propertyIndexInstruction = property . getIndexInstruction ( onPojo ) ; \nif ( propertyIndexInstruction != null ) { \nindex = propertyIndexInstruction ; \n} \n@ SuppressWarnings ( \"unchecked\" ) final P value = ( P ) property . get ( onPojo ) ; \ntry { \nfinal Path propPath = containerPath . extend ( property . getName ( ) ) ; \nfinal Value < D > propValue = translator . save ( value , index , ctx , propPath ) ; \ninto . set ( property . getName ( ) , propValue ) ; \n} \ncatch ( SkipException ex ) { \n} \n} \n} \n} \n"}
{"4119": "public class URLUtil { \nstatic URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { \nif ( ! target . startsWith ( \"?\" ) ) { \nreturn new URL ( base , target ) ; \n} \nString basePath = base . getPath ( ) ; \nString baseRightMost = \"\" ; \nint baseRightMostIdx = basePath . lastIndexOf ( \"/\" ) ; \nif ( baseRightMostIdx != - 1 ) { \nbaseRightMost = basePath . substring ( baseRightMostIdx + 1 ) ; \n} \nif ( target . startsWith ( \"?\" ) ) { \ntarget = baseRightMost + target ; \n} \nreturn new URL ( base , target ) ; \n} \n} \n"}
{"4120": "public class URLUtil { \npublic static String [ ] getHostSegments ( URL url ) { \nString host = url . getHost ( ) ; \nif ( IP_PATTERN . matcher ( host ) . matches ( ) ) { \nreturn new String [ ] { \nhost } \n; \n} \nreturn host . split ( \"\\\\.\" ) ; \n} \n} \n"}
{"4123": "public class ConfUtils { \npublic static List < String > loadListFromConf ( String paramKey , Map stormConf ) { \nObject obj = stormConf . get ( paramKey ) ; \nList < String > list = new LinkedList < > ( ) ; \nif ( obj == null ) { \nreturn list ; \n} \nif ( obj instanceof PersistentVector ) { \nlist . addAll ( ( PersistentVector ) obj ) ; \n} \nelse { \nlist . add ( obj . toString ( ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"4126": "public class WARCRecordFormat { \npublic static byte [ ] generateWARCInfo ( Map < String , String > fields ) { \nStringBuffer buffer = new StringBuffer ( ) ; \nbuffer . append ( WARC_VERSION ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( \"WARC-Type: warcinfo\" ) . append ( CRLF ) ; \nString mainID = UUID . randomUUID ( ) . toString ( ) ; \nString date = fields . get ( \"WARC-Date\" ) ; \nbuffer . append ( \"WARC-Date: \" ) . append ( date ) . append ( CRLF ) ; \nString filename = fields . get ( \"WARC-Filename\" ) ; \nbuffer . append ( \"WARC-Filename: \" ) . append ( filename ) . append ( CRLF ) ; \nbuffer . append ( \"WARC-Record-ID\" ) . append ( \": \" ) . append ( \"<urn:uuid:\" ) . append ( mainID ) . append ( \">\" ) . append ( CRLF ) ; \nbuffer . append ( \"Content-Type\" ) . append ( \": \" ) . append ( \"application/warc-fields\" ) . append ( CRLF ) ; \nStringBuilder fieldsBuffer = new StringBuilder ( ) ; \nIterator < Entry < String , String > > iter = fields . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nEntry < String , String > entry = iter . next ( ) ; \nString key = entry . getKey ( ) ; \nif ( key . startsWith ( \"WARC-\" ) ) { \ncontinue ; \n} \nfieldsBuffer . append ( key ) . append ( \": \" ) . append ( entry . getValue ( ) ) . append ( CRLF ) ; \n} \nbuffer . append ( \"Content-Length\" ) . append ( \": \" ) . append ( fieldsBuffer . toString ( ) . getBytes ( StandardCharsets . UTF_8 ) . length ) . append ( CRLF ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( fieldsBuffer . toString ( ) ) ; \nbuffer . append ( CRLF ) ; \nbuffer . append ( CRLF ) ; \nreturn buffer . toString ( ) . getBytes ( StandardCharsets . UTF_8 ) ; \n} \n} \n"}
{"4127": "public class RefreshTag { \npublic static String extractRefreshURL ( String value ) { \nif ( StringUtils . isBlank ( value ) ) { \nreturn null ; \n} \ntry { \nif ( matcher . reset ( value ) . matches ( ) ) { \nreturn matcher . group ( 1 ) ; \n} \n} \ncatch ( Exception e ) { \n} \nreturn null ; \n} \n} \n"}
{"4131": "public class CloudSearchUtils { \npublic static String cleanFieldName ( String name ) { \nString lowercase = name . toLowerCase ( ) ; \nlowercase = lowercase . replaceAll ( \"[^a-z_0-9]\" , \"_\" ) ; \nif ( lowercase . length ( ) < 3 || lowercase . length ( ) > 64 ) { \nthrow new RuntimeException ( \"Field name must be between 3 and 64 chars : \" + lowercase ) ; \n} \nif ( lowercase . equals ( \"score\" ) ) { \nthrow new RuntimeException ( \"Field name must be score\" ) ; \n} \nreturn lowercase ; \n} \n} \n"}
{"4133": "public class CharsetIdentification { \nprivate static String getCharsetFromText ( byte [ ] content , String declaredCharset , int maxLengthCharsetDetection ) { \nString charset = null ; \nCharsetDetector charsetDetector = new CharsetDetector ( ) ; \ncharsetDetector . enableInputFilter ( true ) ; \nif ( declaredCharset != null ) { \ncharsetDetector . setDeclaredEncoding ( declaredCharset ) ; \n} \nbyte [ ] subContent = content ; \nif ( maxLengthCharsetDetection != - 1 && content . length > maxLengthCharsetDetection ) { \nsubContent = Arrays . copyOfRange ( content , 0 , maxLengthCharsetDetection ) ; \n} \ncharsetDetector . setText ( subContent ) ; \ntry { \nCharsetMatch charsetMatch = charsetDetector . detect ( ) ; \ncharset = validateCharset ( charsetMatch . getName ( ) ) ; \n} \ncatch ( Exception e ) { \ncharset = null ; \n} \nreturn charset ; \n} \n} \n"}
{"4134": "public class CharsetIdentification { \nprivate static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { \nint len = buffer . length ; \nif ( maxlength > 0 && maxlength < len ) { \nlen = maxlength ; \n} \nString html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; \nDocument doc = Parser . htmlParser ( ) . parseInput ( html , \"dummy\" ) ; \nElements metaElements = doc . select ( \"meta[http-equiv=content-type], meta[charset]\" ) ; \nString foundCharset = null ; \nfor ( Element meta : metaElements ) { \nif ( meta . hasAttr ( \"http-equiv\" ) ) { \nfoundCharset = getCharsetFromContentType ( meta . attr ( \"content\" ) ) ; \n} \nif ( foundCharset == null && meta . hasAttr ( \"charset\" ) ) { \nfoundCharset = meta . attr ( \"charset\" ) ; \n} \nif ( foundCharset != null ) { \nreturn foundCharset ; \n} \n} \nreturn foundCharset ; \n} \n} \n"}
{"4137": "public class Metadata { \npublic static String getFirstValue ( Metadata md , String ... keys ) { \nfor ( String key : keys ) { \nString val = md . getFirstValue ( key ) ; \nif ( StringUtils . isBlank ( val ) ) { \ncontinue ; \n} \nreturn val ; \n} \nreturn null ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( int i = 1 ; \ni < tokens . length ; \ni ++ ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) { \nsecure = true ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) { \ncontinue ; \n} \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) { \ncontinue ; \n} \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) { \ncontinue ; \n} \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) { \ncontinue ; \n} \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) { \nreturn ; \n} \nint numNodes = nodes . getLength ( ) ; \nfor ( int i = 0 ; \ni < numNodes ; \ni ++ ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( int att = 0 ; \natt < attrs . getLength ( ) ; \natt ++ ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"4161": "public class AbstractIndexerBolt { \nprotected String trimText ( String text ) { \nif ( maxLengthText == - 1 ) { \nreturn text ; \n} \nif ( text == null ) { \nreturn text ; \n} \nif ( text . length ( ) <= maxLengthText ) { \nreturn text ; \n} \nreturn text . substring ( 0 , maxLengthText ) ; \n} \n} \n"}
{"4162": "public class DefaultScheduler { \nprotected final Optional < Integer > checkCustomInterval ( Metadata metadata , Status s ) { \nif ( customIntervals == null ) { \nreturn Optional . empty ( ) ; \n} \nfor ( CustomInterval customInterval : customIntervals ) { \nString [ ] values = metadata . getValues ( customInterval . key ) ; \nif ( values == null ) { \ncontinue ; \n} \nfor ( String v : values ) { \nif ( v . equals ( customInterval . value ) ) { \nreturn customInterval . getDurationForStatus ( s ) ; \n} \n} \n} \nreturn Optional . empty ( ) ; \n} \n} \n"}
{"4169": "public class WheelView { \npublic void invalidateWheelItemDrawable ( int position ) { \nint adapterPos = rawPositionToAdapterPosition ( position ) ; \nif ( isEmptyItemPosition ( adapterPos ) ) { \nreturn ; \n} \nCacheItem cacheItem = mItemCacheArray [ adapterPos ] ; \nif ( cacheItem != null ) { \ncacheItem . mDirty = true ; \n} \ninvalidate ( ) ; \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( vel > 0f ) { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) { \nmAngularVelocity = 0f ; \n} \n} \nelse if ( vel < 0f ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) { \nmAngularVelocity = 0f ; \n} \n} \nif ( mAngularVelocity != 0f ) { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \nelse { \nmRequiresUpdate = false ; \n} \n} \n} \n"}
{"4175": "public class ArrayChar { \n@ Override public ByteBuffer getDataAsByteBuffer ( ) { \nByteBuffer bb = ByteBuffer . allocate ( ( int ) getSize ( ) ) ; \nresetLocalIterator ( ) ; \nwhile ( hasNext ( ) ) { \nbb . put ( nextByte ( ) ) ; \n} \nreturn bb ; \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nint rank = getRank ( ) ; \nif ( rank != 1 ) { \nthrow new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \n} \nint arrayLen = indexCalc . getShape ( 0 ) ; \nint strLen = Math . min ( val . length ( ) , arrayLen ) ; \nfor ( int k = 0 ; \nk < strLen ; \nk ++ ) { \nstorage [ k ] = val . charAt ( k ) ; \n} \nchar c = 0 ; \nfor ( int k = strLen ; \nk < arrayLen ; \nk ++ ) { \nstorage [ k ] = c ; \n} \n} \n} \n"}
{"4178": "public class ArrayChar { \npublic static ArrayChar makeFromString ( String s , int max ) { \nArrayChar result = new ArrayChar . D1 ( max ) ; \nfor ( int i = 0 ; \ni < max && i < s . length ( ) ; \ni ++ ) { \nresult . setChar ( i , s . charAt ( i ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nfor ( int k = 0 ; \nk < s . length ( ) && k < strlen ; \nk ++ ) { \ncdata [ start + k ] = s . charAt ( k ) ; \n} \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4183": "public class IndependentWindow { \npublic void showIfNotIconified ( ) { \nif ( getState ( ) == Frame . ICONIFIED ) { \nreturn ; \n} \nSwingUtilities . invokeLater ( new Runnable ( ) { \npublic void run ( ) { \nIndependentWindow . super . show ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"4189": "public class DateRange { \npublic boolean included ( Date d ) { \nif ( isEmpty ) { \nreturn false ; \n} \nif ( getStart ( ) . after ( d ) ) { \nreturn false ; \n} \nif ( getEnd ( ) . before ( d ) ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"4190": "public class DateRange { \npublic DateRange intersect ( DateRange clip ) { \nif ( isEmpty ) { \nreturn this ; \n} \nif ( clip . isEmpty ) { \nreturn clip ; \n} \nDateType ss = getStart ( ) ; \nDateType s = ss . before ( clip . getStart ( ) ) ? clip . getStart ( ) : ss ; \nDateType ee = getEnd ( ) ; \nDateType e = ee . before ( clip . getEnd ( ) ) ? ee : clip . getEnd ( ) ; \nreturn new DateRange ( s , e , null , resolution ) ; \n} \n} \n"}
{"4191": "public class DateRange { \npublic void extend ( DateRange dr ) { \nboolean localEmpty = isEmpty ; \nif ( localEmpty || dr . getStart ( ) . before ( getStart ( ) ) ) { \nsetStart ( dr . getStart ( ) ) ; \n} \nif ( localEmpty || getEnd ( ) . before ( dr . getEnd ( ) ) ) { \nsetEnd ( dr . getEnd ( ) ) ; \n} \n} \n} \n"}
{"4192": "public class DateRange { \npublic void extend ( Date d ) { \nif ( d . before ( getStart ( ) . getDate ( ) ) ) { \nsetStart ( new DateType ( false , d ) ) ; \n} \nif ( getEnd ( ) . before ( d ) ) { \nsetEnd ( new DateType ( false , d ) ) ; \n} \n} \n} \n"}
{"4196": "public class DateRange { \nprivate void recalcDuration ( ) { \nlong min = getStart ( ) . getDate ( ) . getTime ( ) ; \nlong max = getEnd ( ) . getDate ( ) . getTime ( ) ; \ndouble secs = .001 * ( max - min ) ; \nif ( secs < 0 ) { \nsecs = 0 ; \n} \nif ( duration == null ) { \ntry { \nduration = new TimeDuration ( chooseResolution ( secs ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( resolution == null ) { \nduration . setValueInSeconds ( secs ) ; \n} \nelse { \ndouble resSecs = resolution . getValueInSeconds ( ) ; \ndouble closest = Math . round ( secs / resSecs ) ; \nsecs = closest * resSecs ; \nduration . setValueInSeconds ( secs ) ; \n} \nhashCode = 0 ; \n} \n} \n"}
{"4199": "public class DtCoverageDataset { \npublic String getName ( ) { \nString loc = ncd . getLocation ( ) ; \nint pos = loc . lastIndexOf ( '/' ) ; \nif ( pos < 0 ) { \npos = loc . lastIndexOf ( '\\\\' ) ; \n} \nreturn ( pos < 0 ) ? loc : loc . substring ( pos + 1 ) ; \n} \n} \n"}
{"4202": "public class HorizCoordSys2D { \nprivate Optional < List < RangeIterator > > computeBounds ( LatLonRect llbb , int horizStride ) { \nsynchronized ( this ) { \nif ( edges == null ) { \nedges = new Edges ( ) ; \n} \n} \nreturn edges . computeBoundsExhaustive ( llbb , horizStride ) ; \n} \n} \n"}
{"4203": "public class RangeDateSelector { \nprivate void synchUI ( boolean slidersOK ) { \neventOK = false ; \nif ( slidersOK ) { \nminSlider . setValue ( scale . world2slider ( dateRange . getStart ( ) ) ) ; \n} \nminField . setValue ( dateRange . getStart ( ) ) ; \nif ( maxField != null ) { \nif ( slidersOK ) { \nmaxSlider . setValue ( scale . world2slider ( dateRange . getEnd ( ) ) ) ; \n} \nmaxField . setValue ( dateRange . getEnd ( ) ) ; \n} \nif ( durationField != null ) { \ndurationField . setValue ( dateRange . getDuration ( ) ) ; \n} \neventOK = true ; \n} \n} \n"}
{"4205": "public class CatalogWatcher { \npublic void register ( Path dir ) throws IOException { \nif ( ! enable ) { \nreturn ; \n} \nWatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; \nif ( trace ) { \nPath prev = keys . get ( key ) ; \nif ( prev == null ) { \nSystem . out . format ( \"CatalogWatcher register: %s%n\" , dir ) ; \n} \nelse { \nif ( ! dir . equals ( prev ) ) { \nSystem . out . format ( \"update: %s -> %s%n\" , prev , dir ) ; \n} \n} \n} \nkeys . put ( key , dir ) ; \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) { \nreturn ; \n} \nfor ( ; \n; \n) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . println ( \"WatchKey not recognized!!\" ) ; \ncontinue ; \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) { \ncontinue ; \n} \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive && ( kind == ENTRY_CREATE ) ) { \ntry { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) { \nregisterAll ( child ) ; \n} \n} \ncatch ( IOException x ) { \n} \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) { \nbreak ; \n} \n} \n} \n} \n} \n"}
{"4208": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( location . startsWith ( DataFactory . SCHEME ) ) { \nDataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; \nerrlog . format ( \"%s\" , result . errLog ) ; \nif ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { \nerrlog . format ( \"wanted %s but dataset is of type %s%n\" , wantFeatureType , result . featureType ) ; \nresult . close ( ) ; \nreturn null ; \n} \nreturn result . featureDataset ; \n} \nelse if ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) { \nOptional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; \nif ( opt . isPresent ( ) ) { \nreturn opt . get ( ) ; \n} \nerrlog . format ( \"%s\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse if ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { \nString spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; \nMFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; \nreturn CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; \n} \nDatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; \nif ( durl . serviceType == null ) { \nOptional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; \nif ( opt . isPresent ( ) ) { \nreturn opt . get ( ) ; \n} \nelse if ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) && ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { \nerrlog . format ( \"%s%n\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \n} \nNetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; \nFeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; \nif ( fd == null ) { \nncd . close ( ) ; \n} \nreturn fd ; \n} \n} \n"}
{"4209": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( debug ) { \nSystem . out . println ( \"wrap \" + ncd . getLocation ( ) + \" want = \" + wantFeatureType ) ; \n} \nif ( ( wantFeatureType == null ) || ( wantFeatureType == FeatureType . ANY ) ) { \nreturn wrapUnknown ( ncd , task , errlog ) ; \n} \nObject analysis = null ; \nFeatureDatasetFactory useFactory = null ; \nfor ( Factory fac : factoryList ) { \nif ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) { \ncontinue ; \n} \nif ( debug ) { \nSystem . out . println ( \" wrap try factory \" + fac . factory . getClass ( ) . getName ( ) ) ; \n} \nanalysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; \nif ( analysis != null ) { \nuseFactory = fac . factory ; \nbreak ; \n} \n} \nif ( null == useFactory ) { \nerrlog . format ( \"**Failed to find FeatureDatasetFactory for= %s datatype=%s%n\" , ncd . getLocation ( ) , wantFeatureType ) ; \nreturn null ; \n} \nreturn useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; \n} \n} \n"}
{"4210": "public class FeatureDatasetFactoryManager { \nstatic public boolean featureTypeOk ( FeatureType want , FeatureType facType ) { \nif ( want == null ) { \nreturn true ; \n} \nif ( want == facType ) { \nreturn true ; \n} \nif ( want == FeatureType . ANY_POINT ) { \nreturn facType . isPointFeatureType ( ) ; \n} \nif ( facType == FeatureType . ANY_POINT ) { \nreturn want . isPointFeatureType ( ) ; \n} \nif ( want == FeatureType . COVERAGE ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . GRID ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . SIMPLE_GEOMETRY ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . UGRID ) { \nreturn facType . isUnstructuredGridFeatureType ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"4211": "public class FeatureDatasetFactoryManager { \nstatic public FeatureType findFeatureType ( NetcdfFile ncd ) { \nString cdm_datatype = ncd . findAttValueIgnoreCase ( null , CF . FEATURE_TYPE , null ) ; \nif ( cdm_datatype == null ) { \ncdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_data_type\" , null ) ; \n} \nif ( cdm_datatype == null ) { \ncdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_datatype\" , null ) ; \n} \nif ( cdm_datatype == null ) { \ncdm_datatype = ncd . findAttValueIgnoreCase ( null , \"thredds_data_type\" , null ) ; \n} \nif ( cdm_datatype != null ) { \nfor ( FeatureType ft : FeatureType . values ( ) ) if ( cdm_datatype . equalsIgnoreCase ( ft . name ( ) ) ) { \nif ( debug ) { \nSystem . out . println ( \" wrapUnknown found cdm_datatype \" + cdm_datatype ) ; \n} \nreturn ft ; \n} \n} \nCF . FeatureType cff = CF . FeatureType . getFeatureTypeFromGlobalAttribute ( ncd ) ; \nif ( cff != null ) { \nreturn CF . FeatureType . convert ( cff ) ; \n} \nreturn null ; \n} \n} \n"}
{"4213": "public class ConfigCatalogHtmlWriter { \nString convertCatalogToHtml ( Catalog cat , boolean isLocalCatalog ) { \nStringBuilder sb = new StringBuilder ( 10000 ) ; \nString uri = cat . getUriString ( ) ; \nif ( uri == null ) { \nuri = cat . getName ( ) ; \n} \nif ( uri == null ) { \nuri = \"unknown\" ; \n} \nString catname = Escape . html ( uri ) ; \nsb . append ( getHtmlDoctypeAndOpenTag ( ) ) ; \nsb . append ( \"<head>\\r\\n\" ) ; \nsb . append ( \"<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>\" ) ; \nsb . append ( \"<title>\" ) ; \nsb . append ( \"Catalog \" ) . append ( catname ) ; \nsb . append ( \"</title>\\r\\n\" ) ; \nsb . append ( getTdsCatalogCssLink ( ) ) . append ( \"\\n\" ) ; \nsb . append ( this . getGoogleTrackingContent ( ) ) ; \nsb . append ( \"</head>\\r\\n\" ) ; \nsb . append ( \"<body>\" ) ; \nsb . append ( \"<h1>\" ) ; \nString logoUrl = htmlConfig . prepareUrlStringForHtml ( htmlConfig . getInstallLogoUrl ( ) ) ; \nif ( logoUrl != null ) { \nsb . append ( \"<img src='\" ) . append ( logoUrl ) ; \nString logoAlt = htmlConfig . getInstallLogoAlt ( ) ; \nif ( logoAlt != null ) { \nsb . append ( \"' alt='\" ) . append ( logoAlt ) ; \n} \nsb . append ( \"' align='left' valign='top'\" ) . append ( \">\\n\" ) ; \n} \nsb . append ( \" Catalog \" ) . append ( catname ) ; \nsb . append ( \"</h1>\" ) ; \nsb . append ( \"<HR size='1' noshade='noshade'>\" ) ; \nsb . append ( \"<table width='100%' cellspacing='0' cellpadding='5' align='center'>\\r\\n\" ) ; \nsb . append ( \"<tr>\\r\\n\" ) ; \nsb . append ( \"<th align='left'><font size='+1'>\" ) ; \nsb . append ( \"Dataset\" ) ; \nsb . append ( \"</font></th>\\r\\n\" ) ; \nsb . append ( \"<th align='center'><font size='+1'>\" ) ; \nsb . append ( \"Size\" ) ; \nsb . append ( \"</font></th>\\r\\n\" ) ; \nsb . append ( \"<th align='right'><font size='+1'>\" ) ; \nsb . append ( \"Last Modified\" ) ; \nsb . append ( \"</font></th>\\r\\n\" ) ; \nsb . append ( \"</tr>\" ) ; \ndoDatasets ( cat , cat . getDatasetsLocal ( ) , sb , false , 0 , isLocalCatalog ) ; \nsb . append ( \"</table>\\r\\n\" ) ; \nsb . append ( \"<HR size='1' noshade='noshade'>\" ) ; \nappendSimpleFooter ( sb ) ; \nsb . append ( \"</body>\\r\\n\" ) ; \nsb . append ( \"</html>\\r\\n\" ) ; \nreturn ( sb . toString ( ) ) ; \n} \n} \n"}
{"4216": "public class CatalogManager { \nprivate Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { \nboolean isLatest = path . endsWith ( \"/latest.xml\" ) ; \nint pos = path . lastIndexOf ( \"/\" ) ; \nString workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; \nString filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; \nif ( match == null ) { \nreturn null ; \n} \nif ( match . dataRoot . getFeatureCollection ( ) != null ) { \nInvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; \nif ( isLatest ) { \nreturn fc . makeLatest ( match . remaining , path , baseURI ) ; \n} \nelse { \nreturn fc . makeCatalog ( match . remaining , path , baseURI ) ; \n} \n} \nDatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; \nif ( dscan != null ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \n} \nCatalogBuilder cat ; \nif ( isLatest ) { \ncat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; \n} \nelse { \ncat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; \n} \nif ( null == cat ) { \nlog . error ( \"makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = \" + workPath ) ; \n} \nreturn cat ; \n} \nCatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; \nif ( catScan != null ) { \nif ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) { \nreturn catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; \n} \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \n} \nCatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; \nif ( null == cat ) { \nlog . error ( \"makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = \" + workPath ) ; \n} \nreturn cat ; \n} \nlog . warn ( \"makeDynamicCatalog() failed for =\" + workPath + \" request path= \" + path ) ; \nreturn null ; \n} \n} \n"}
{"4217": "public class CatalogManager { \nprivate void addGlobalServices ( CatalogBuilder cat ) { \nSet < String > allServiceNames = new HashSet < > ( ) ; \nfindServices ( cat . getDatasets ( ) , allServiceNames ) ; \nif ( ! allServiceNames . isEmpty ( ) ) { \nList < Service > servicesMissing = new ArrayList < > ( ) ; \nfor ( String name : allServiceNames ) { \nif ( cat . hasServiceInDataset ( name ) ) { \ncontinue ; \n} \nService s = globalServices . findGlobalService ( name ) ; \nif ( s != null ) { \nservicesMissing . add ( s ) ; \n} \n} \nservicesMissing . forEach ( cat :: addService ) ; \n} \nfor ( DatasetBuilder node : cat . getDatasets ( ) ) { \nString sname = ( String ) node . getFldOrInherited ( Dataset . ServiceName ) ; \nString urlPath = ( String ) node . get ( Dataset . UrlPath ) ; \nString ftypeS = ( String ) node . getFldOrInherited ( Dataset . FeatureType ) ; \nif ( sname == null && urlPath != null && ftypeS != null ) { \nService s = globalServices . getStandardServices ( ftypeS ) ; \nif ( s != null ) { \nnode . put ( Dataset . ServiceName , s . getName ( ) ) ; \ncat . addService ( s ) ; \n} \n} \n} \n} \n} \n"}
{"4218": "public class HttpClientManager { \nstatic public void init ( CredentialsProvider provider , String userAgent ) { \nif ( provider != null ) { \ntry { \nHTTPSession . setGlobalCredentialsProvider ( provider ) ; \n} \ncatch ( HTTPException e ) { \nthrow new IllegalArgumentException ( e ) ; \n} \n} \nif ( userAgent != null ) { \nHTTPSession . setGlobalUserAgent ( userAgent + \"/NetcdfJava/HttpClient\" ) ; \n} \nelse { \nHTTPSession . setGlobalUserAgent ( \"NetcdfJava/HttpClient\" ) ; \n} \n} \n} \n"}
{"4219": "public class HttpClientManager { \n@ Urlencoded @ Deprecated public static String getContentAsString ( HTTPSession session , String urlencoded ) throws IOException { \nHTTPSession useSession = session ; \ntry { \nif ( useSession == null ) { \nuseSession = HTTPFactory . newSession ( urlencoded ) ; \n} \ntry ( HTTPMethod m = HTTPFactory . Get ( useSession , urlencoded ) ) { \nm . execute ( ) ; \nreturn m . getResponseAsString ( ) ; \n} \n} \nfinally { \nif ( ( session == null ) && ( useSession != null ) ) { \nuseSession . close ( ) ; \n} \n} \n} \n} \n"}
{"4221": "public class D4TSServlet { \nprotected FrontPage getFrontPage ( DapRequest drq , DapContext cxt ) throws DapException { \nif ( this . defaultroots == null ) { \nString pageroot ; \npageroot = getResourcePath ( drq , \"\" ) ; \nif ( pageroot == null ) { \nthrow new DapException ( \"Cannot locate resources directory\" ) ; \n} \nthis . defaultroots = new ArrayList < > ( ) ; \nthis . defaultroots . add ( new Root ( \"testfiles\" , pageroot ) ) ; \n} \nreturn new FrontPage ( this . defaultroots , drq ) ; \n} \n} \n"}
{"4222": "public class InvDatasetFcGrib { \n@ Override public CatalogBuilder makeCatalog ( String match , String reqPath , URI catURI ) throws IOException { \nStateGrib localState = ( StateGrib ) checkState ( ) ; \nif ( localState == null ) { \nreturn null ; \n} \nif ( localState . gribCollection == null ) { \nreturn null ; \n} \ntry { \nif ( ( match == null ) || ( match . length ( ) == 0 ) ) { \nreturn makeCatalogTop ( catURI , localState ) ; \n} \nif ( localState . gribCollection instanceof PartitionCollectionImmutable ) { \nString [ ] paths = match . split ( \"/\" ) ; \nPartitionCollectionImmutable pc = ( PartitionCollectionImmutable ) localState . gribCollection ; \nreturn makeCatalogFromPartition ( pc , paths , 0 , catURI ) ; \n} \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nlogger . error ( \"Error making catalog for \" + configPath , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"4224": "public class InvDatasetFcGrib { \npublic GribCollectionImmutable . Dataset getSingleDatasetOrByTypeName ( GribCollectionImmutable gc , String typeName ) { \nif ( gc . getDatasets ( ) . size ( ) == 1 ) { \nreturn gc . getDataset ( 0 ) ; \n} \nfor ( GribCollectionImmutable . Dataset ds : gc . getDatasets ( ) ) if ( ds . getType ( ) . toString ( ) . equalsIgnoreCase ( typeName ) ) { \nreturn ds ; \n} \nreturn null ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \n} \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \n} \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) { \nSystem . out . println ( \" read record \" + recnum ) ; \n} \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) { \nraf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \n} \nelse { \nraf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \n} \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4237": "public class N3iosp { \nprotected void fillNonRecordVariables ( ) throws IOException { \nfor ( Variable v : ncfile . getVariables ( ) ) { \nif ( v . isUnlimited ( ) ) { \ncontinue ; \n} \ntry { \nwriteData ( v , v . getShapeAsSection ( ) , makeConstantArray ( v ) ) ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n"}
{"4245": "public class McIDASLookup { \npublic final String getLevelName ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \nString levelUnit = getLevelUnit ( gr ) ; \nif ( levelUnit != null ) { \nint level1 = ( int ) gr . getLevel1 ( ) ; \nint level2 = ( int ) gr . getLevel2 ( ) ; \nif ( levelUnit . equalsIgnoreCase ( \"hPa\" ) ) { \nreturn \"pressure\" ; \n} \nelse if ( level1 == 1013 ) { \nreturn \"mean sea level\" ; \n} \nelse if ( level1 == 0 ) { \nreturn \"tropopause\" ; \n} \nelse if ( level1 == 1001 ) { \nreturn \"surface\" ; \n} \nelse if ( level2 != 0 ) { \nreturn \"layer\" ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"4246": "public class McIDASLookup { \npublic final String getLevelDescription ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelDescription ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \nreturn getLevelName ( gr ) ; \n} \n} \n"}
{"4247": "public class McIDASLookup { \npublic final String getLevelUnit ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelUnits ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \nreturn visad . jmet . MetUnits . makeSymbol ( ( ( McIDASGridRecord ) gr ) . getLevelUnitName ( ) ) ; \n} \n} \n"}
{"4251": "public class CoordTransBuilder { \nstatic public CoordinateTransform makeCoordinateTransform ( NetcdfDataset ds , AttributeContainer ctv , Formatter parseInfo , Formatter errInfo ) { \nString transform_name = ctv . findAttValueIgnoreCase ( \"transform_name\" , null ) ; \nif ( null == transform_name ) { \ntransform_name = ctv . findAttValueIgnoreCase ( \"Projection_Name\" , null ) ; \n} \nif ( null == transform_name ) { \ntransform_name = ctv . findAttValueIgnoreCase ( CF . GRID_MAPPING_NAME , null ) ; \n} \nif ( null == transform_name ) { \ntransform_name = ctv . findAttValueIgnoreCase ( CF . STANDARD_NAME , null ) ; \n} \nif ( null == transform_name ) { \nparseInfo . format ( \"**Failed to find Coordinate Transform name from Variable= %s%n\" , ctv ) ; \nreturn null ; \n} \ntransform_name = transform_name . trim ( ) ; \nClass builderClass = null ; \nfor ( Transform transform : transformList ) { \nif ( transform . transName . equals ( transform_name ) ) { \nbuilderClass = transform . transClass ; \nbreak ; \n} \n} \nif ( null == builderClass ) { \nparseInfo . format ( \"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\" , transform_name , ctv ) ; \nreturn null ; \n} \nObject builderObject ; \ntry { \nbuilderObject = builderClass . newInstance ( ) ; \n} \ncatch ( InstantiationException | IllegalAccessException e ) { \nlog . error ( \"Cant create new instance \" + builderClass . getName ( ) , e ) ; \nreturn null ; \n} \nif ( null == builderObject ) { \nparseInfo . format ( \"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\" , builderClass . getName ( ) , ctv ) ; \nreturn null ; \n} \nCoordinateTransform ct ; \nif ( builderObject instanceof VertTransformBuilderIF ) { \nVertTransformBuilderIF vertBuilder = ( VertTransformBuilderIF ) builderObject ; \nvertBuilder . setErrorBuffer ( errInfo ) ; \nct = vertBuilder . makeCoordinateTransform ( ds , ctv ) ; \n} \nelse if ( builderObject instanceof HorizTransformBuilderIF ) { \nHorizTransformBuilderIF horizBuilder = ( HorizTransformBuilderIF ) builderObject ; \nhorizBuilder . setErrorBuffer ( errInfo ) ; \nString units = AbstractTransformBuilder . getGeoCoordinateUnits ( ds , ctv ) ; \nct = horizBuilder . makeCoordinateTransform ( ctv , units ) ; \n} \nelse { \nlog . error ( \"Illegals class \" + builderClass . getName ( ) ) ; \nreturn null ; \n} \nif ( ct != null ) { \nparseInfo . format ( \" Made Coordinate transform %s from variable %s: %s%n\" , transform_name , ctv . getName ( ) , builderObject . getClass ( ) . getName ( ) ) ; \n} \nreturn ct ; \n} \n} \n"}
{"4252": "public class CoordTransBuilder { \nstatic public VariableDS makeDummyTransformVariable ( NetcdfDataset ds , CoordinateTransform ct ) { \nVariableDS v = new VariableDS ( ds , null , null , ct . getName ( ) , DataType . CHAR , \"\" , null , null ) ; \nList < Parameter > params = ct . getParameters ( ) ; \nfor ( Parameter p : params ) { \nif ( p . isString ( ) ) { \nv . addAttribute ( new Attribute ( p . getName ( ) , p . getStringValue ( ) ) ) ; \n} \nelse { \ndouble [ ] data = p . getNumericValues ( ) ; \nArray dataA = Array . factory ( DataType . DOUBLE , new int [ ] { \ndata . length } \n, data ) ; \nv . addAttribute ( new Attribute ( p . getName ( ) , dataA ) ) ; \n} \n} \nv . addAttribute ( new Attribute ( _Coordinate . TransformType , ct . getTransformType ( ) . toString ( ) ) ) ; \nArray data = Array . factory ( DataType . CHAR , new int [ ] { \n} \n, new char [ ] { \n' ' } \n) ; \nv . setCachedData ( data , true ) ; \nreturn v ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) { \nusePopup = true ; \n} \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4256": "public class FixedYearLengthChronology { \n@ Override public final Chronology withZone ( DateTimeZone zone ) { \nif ( zone . equals ( DateTimeZone . UTC ) ) { \nreturn this . withUTC ( ) ; \n} \nthrow new UnsupportedOperationException ( \"Not supported yet.\" ) ; \n} \n} \n"}
{"4261": "public class SimpleGeomController { \nvoid finishInit ( ) { \nnp = ui . panz ; \nvertPanel = ui . vertPanel ; \ndataValueLabel = ui . dataValueLabel ; \nposLabel = ui . positionLabel ; \nproject = ( ProjectionImpl ) store . getBean ( LastProjectionName , null ) ; \nif ( project != null ) { \nsetProjection ( project ) ; \n} \nProjectionRect ma = ( ProjectionRect ) store . getBean ( LastMapAreaName , null ) ; \nif ( ma != null ) { \nnp . setMapArea ( ma ) ; \n} \nmakeEventManagement ( ) ; \n} \n} \n"}
{"4262": "public class CalendarDateRange { \nstatic public CalendarDateRange of ( DateRange dr ) { \nif ( dr == null ) { \nreturn null ; \n} \nreturn CalendarDateRange . of ( dr . getStart ( ) . getDate ( ) , dr . getEnd ( ) . getDate ( ) ) ; \n} \n} \n"}
{"4269": "public class WFSGetCapabilitiesWriter { \nprivate void writeAConstraint ( String name , boolean isImplemented ) { \nString defValue ; \nif ( isImplemented ) { \ndefValue = \"TRUE\" ; \n} \nelse { \ndefValue = \"FALSE\" ; \n} \nfileOutput += \"<ows:Constraint name=\\\"\" + name + \"\\\"> \" + \"<ows:NoValues/> \" + \"<ows:DefaultValue>\" + defValue + \"</ows:DefaultValue> \" + \"</ows:Constraint>\" ; \n} \n} \n"}
{"4272": "public class LogReader { \npublic void readAll ( File dir , FileFilter ff , Closure closure , LogFilter logf , Stats stat ) throws IOException { \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nSystem . out . printf ( \"Dir has no files= %s%n\" , dir ) ; \nreturn ; \n} \nList < File > list = Arrays . asList ( files ) ; \nCollections . sort ( list ) ; \nfor ( File f : list ) { \nif ( ( ff != null ) && ! ff . accept ( f ) ) { \ncontinue ; \n} \nif ( f . isDirectory ( ) ) { \nreadAll ( f , ff , closure , logf , stat ) ; \n} \nelse { \nscanLogFile ( f , closure , logf , stat ) ; \n} \n} \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) { \nbreak ; \n} \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) { \ncontinue ; \n} \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4281": "public class GempakGridReader { \npublic void printGrids ( ) { \nList < GridRecord > gridList = gridIndex . getGridRecords ( ) ; \nif ( gridList == null ) { \nreturn ; \n} \nSystem . out . println ( \"  NUM       TIME1              TIME2           LEVL1 LEVL2  VCORD PARM\" ) ; \nfor ( GridRecord aGridList : gridList ) { \nSystem . out . println ( aGridList ) ; \n} \n} \n} \n"}
{"4283": "public class CalendarDate { \npublic static CalendarDate of ( Calendar cal , int year , int monthOfYear , int dayOfMonth , int hourOfDay , int minuteOfHour , int secondOfMinute ) { \nChronology base = Calendar . getChronology ( cal ) ; \nDateTime dt = new DateTime ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , base ) ; \nif ( ! Calendar . isDefaultChronology ( cal ) ) { \ndt = dt . withChronology ( Calendar . getChronology ( cal ) ) ; \n} \ndt = dt . withZone ( DateTimeZone . UTC ) ; \nreturn new CalendarDate ( cal , dt ) ; \n} \n} \n"}
{"4287": "public class CalendarDate { \npublic static CalendarDate parseUdunits ( String calendarName , String udunits ) { \nint pos = udunits . indexOf ( ' ' ) ; \nif ( pos < 0 ) { \nreturn null ; \n} \nString valString = udunits . substring ( 0 , pos ) . trim ( ) ; \nString unitString = udunits . substring ( pos + 1 ) . trim ( ) ; \nCalendarDateUnit cdu = CalendarDateUnit . of ( calendarName , unitString ) ; \ndouble val = Double . parseDouble ( valString ) ; \nreturn cdu . makeCalendarDate ( val ) ; \n} \n} \n"}
{"4290": "public class DownloadController { \npublic void setup ( HttpServletRequest req , HttpServletResponse resp ) throws SendError { \nthis . req = req ; \nthis . res = resp ; \nif ( ! once ) { \ndoonce ( req ) ; \n} \ntry { \nthis . params = new DownloadParameters ( req ) ; \n} \ncatch ( IOException ioe ) { \nthrow new SendError ( res . SC_BAD_REQUEST , ioe ) ; \n} \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nint c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( c < ' ' ) { \nbuf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \n} \nelse { \nbuf . append ( ( char ) c ) ; \n} \nbreak ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4293": "public class CDMUtil { \nstatic public NetcdfFile unwrapfile ( NetcdfFile file ) { \nfor ( ; \n; \n) { \nif ( file instanceof NetcdfDataset ) { \nNetcdfDataset ds = ( NetcdfDataset ) file ; \nfile = ds . getReferencedFile ( ) ; \nif ( file == null ) { \nbreak ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn file ; \n} \n} \n"}
{"4294": "public class CDMUtil { \nstatic public boolean containsVLEN ( List < Dimension > dimset ) { \nif ( dimset == null ) { \nreturn false ; \n} \nfor ( Dimension dim : dimset ) { \nif ( dim . isVariableLength ( ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) { \nreturn new int [ 0 ] ; \n} \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( int i = 0 ; \ni < effectiverank ; \ni ++ ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \n} \nreturn shape ; \n} \n} \n"}
{"4305": "public class GribDataReader { \npublic Array readData ( SectionIterable want ) throws IOException , InvalidRangeException { \nif ( vindex instanceof PartitionCollectionImmutable . VariableIndexPartitioned ) { \nreturn readDataFromPartition ( ( PartitionCollectionImmutable . VariableIndexPartitioned ) vindex , want ) ; \n} \nelse { \nreturn readDataFromCollection ( vindex , want ) ; \n} \n} \n} \n"}
{"4306": "public class GribDataReader { \npublic Array readData2 ( CoordsSet want , RangeIterator yRange , RangeIterator xRange ) throws IOException { \nif ( vindex instanceof PartitionCollectionImmutable . VariableIndexPartitioned ) { \nreturn readDataFromPartition2 ( ( PartitionCollectionImmutable . VariableIndexPartitioned ) vindex , want , yRange , xRange ) ; \n} \nelse { \nreturn readDataFromCollection2 ( vindex , want , yRange , xRange ) ; \n} \n} \n} \n"}
{"4307": "public class StationTimeSeriesCollectionImpl { \n@ Override public PointFeatureCollection flatten ( List < String > stationNames , CalendarDateRange dateRange , List < VariableSimpleIF > varList ) throws IOException { \nif ( ( stationNames == null ) || ( stationNames . size ( ) == 0 ) ) { \nreturn new StationTimeSeriesCollectionFlattened ( this , dateRange ) ; \n} \nList < StationFeature > subsetStations = getStationHelper ( ) . getStationFeaturesFromNames ( stationNames ) ; \nreturn new StationTimeSeriesCollectionFlattened ( new StationSubset ( this , subsetStations ) , dateRange ) ; \n} \n} \n"}
{"4308": "public class InvCatalog { \npublic InvService findService ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nfor ( InvService s : services ) { \nif ( name . equals ( s . getName ( ) ) ) { \nreturn s ; \n} \nif ( s . getServiceType ( ) == ServiceType . COMPOUND ) { \nInvService result = s . findNestedService ( name ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4314": "public class CatalogBuilderHelper { \nstatic CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { \nif ( ! ancestorCrDs . isCollection ( ) ) { \nthrow new IllegalArgumentException ( \"Ancestor dataset <\" + ancestorCrDs . getPath ( ) + \"> not a collection.\" ) ; \n} \nif ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) { \nthrow new IllegalArgumentException ( \"Dataset path <\" + path + \"> not descendant of given dataset <\" + ancestorCrDs . getPath ( ) + \">.\" ) ; \n} \nif ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) { \nreturn ancestorCrDs ; \n} \nString remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; \nif ( remainingPath . startsWith ( \"/\" ) ) { \nremainingPath = remainingPath . substring ( 1 ) ; \n} \nString [ ] pathSegments = remainingPath . split ( \"/\" ) ; \nCrawlableDataset curCrDs = ancestorCrDs ; \nfor ( int i = 0 ; \ni < pathSegments . length ; \ni ++ ) { \ncurCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; \nif ( filter != null ) { \nif ( ! filter . accept ( curCrDs ) ) { \nreturn null ; \n} \n} \n} \nif ( ! curCrDs . exists ( ) ) { \nreturn null ; \n} \nreturn curCrDs ; \n} \n} \n"}
{"4316": "public class CalendarDateUnit { \nstatic public CalendarDateUnit of ( String calendarName , String udunitString ) { \nCalendar calt = Calendar . get ( calendarName ) ; \nif ( calt == null ) { \ncalt = Calendar . getDefault ( ) ; \n} \nreturn new CalendarDateUnit ( calt , udunitString ) ; \n} \n} \n"}
{"4317": "public class CalendarDateUnit { \nstatic public CalendarDateUnit withCalendar ( Calendar calt , String udunitString ) { \nif ( calt == null ) { \ncalt = Calendar . getDefault ( ) ; \n} \nreturn new CalendarDateUnit ( calt , udunitString ) ; \n} \n} \n"}
{"4318": "public class CalendarDateUnit { \nstatic public CalendarDateUnit of ( Calendar calt , CalendarPeriod . Field periodField , CalendarDate baseDate ) { \nif ( calt == null ) { \ncalt = Calendar . getDefault ( ) ; \n} \nreturn new CalendarDateUnit ( calt , periodField , baseDate ) ; \n} \n} \n"}
{"4319": "public class CalendarDateUnit { \npublic double makeOffsetFromRefDate ( CalendarDate date ) { \nif ( isCalendarField ) { \nif ( date . equals ( baseDate ) ) { \nreturn 0.0 ; \n} \nreturn date . getDifference ( baseDate , periodField ) ; \n} \nelse { \nlong msecs = date . getDifferenceInMsecs ( baseDate ) ; \nreturn msecs / period . getValueInMillisecs ( ) ; \n} \n} \n} \n"}
{"4320": "public class CalendarDateUnit { \npublic CalendarDate makeCalendarDate ( double value ) { \nif ( isCalendarField ) { \nreturn baseDate . add ( CalendarPeriod . of ( ( int ) value , periodField ) ) ; \n} \nelse { \nreturn baseDate . add ( value , periodField ) ; \n} \n} \n} \n"}
{"4327": "public class SigmetIOServiceProvider { \nstatic float calcElev ( short angle ) { \nfinal double maxval = 65536.0 ; \ndouble ang = ( double ) angle ; \nif ( angle < 0 ) { \nang = ( ~ angle ) + 1 ; \n} \ndouble temp = ( ang / maxval ) * 360.0 ; \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4337": "public class DtCoverageCS { \npublic LatLonRect getLatLonBoundingBox ( ) { \nif ( llbb == null ) { \nif ( ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) && ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) ) { \nreturn null ; \n} \nCoordinateAxis horizXaxis = getXHorizAxis ( ) ; \nCoordinateAxis horizYaxis = getYHorizAxis ( ) ; \nif ( isLatLon ( ) ) { \ndouble startLat = horizYaxis . getMinValue ( ) ; \ndouble startLon = horizXaxis . getMinValue ( ) ; \ndouble deltaLat = horizYaxis . getMaxValue ( ) - startLat ; \ndouble deltaLon = horizXaxis . getMaxValue ( ) - startLon ; \nLatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; \nllbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; \n} \nelse { \nProjectionImpl dataProjection = getProjection ( ) ; \nProjectionRect bb = getBoundingBox ( ) ; \nif ( bb != null ) { \nllbb = dataProjection . projToLatLonBB ( bb ) ; \n} \n} \n} \nreturn llbb ; \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) { \nsdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \n} \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4346": "public class GridDatasetInfo { \nprivate String getShapeString ( int [ ] shape ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) { \nif ( i != 0 ) { \nbuf . append ( \" \" ) ; \n} \nbuf . append ( shape [ i ] ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4347": "public class Slice { \npublic Slice finish ( ) throws DapException { \nif ( this . first == UNDEFINED ) { \nthis . first = 0 ; \n} \nif ( this . stride == UNDEFINED ) { \nthis . stride = 1 ; \n} \nif ( this . stop == UNDEFINED && this . maxsize != UNDEFINED ) { \nthis . stop = this . maxsize ; \n} \nif ( this . stop == UNDEFINED && this . maxsize == UNDEFINED ) { \nthis . stop = this . first + 1 ; \n} \nif ( this . maxsize == UNDEFINED && this . stop != UNDEFINED ) { \nthis . maxsize = this . stop ; \n} \nassert ( this . first != UNDEFINED ) ; \nassert ( this . stride != UNDEFINED ) ; \nassert ( this . stop != UNDEFINED ) ; \nif ( this . first > this . maxsize ) { \nthrow new DapException ( \"Slice: first index > max size\" ) ; \n} \nif ( this . stop > ( this . maxsize + 1 ) ) { \nthrow new DapException ( \"Slice: stop > max size\" ) ; \n} \nif ( this . first < 0 ) { \nthrow new DapException ( \"Slice: first index < 0\" ) ; \n} \nif ( this . stop < 0 ) { \nthrow new DapException ( \"Slice: stop index < 0\" ) ; \n} \nif ( this . stride <= 0 ) { \nthrow new DapException ( \"Slice: stride index <= 0\" ) ; \n} \nif ( this . first > this . stop ) { \nthrow new DapException ( \"Slice: first index > last\" ) ; \n} \nreturn this ; \n} \n} \n"}
{"4348": "public class Slice { \npublic String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nif ( ( this . stop - this . first ) == 0 ) { \nreturn String . format ( \"[0]\" ) ; \n} \nelse if ( this . stride == 1 ) { \nif ( ( this . stop - this . first ) == 1 ) { \nreturn String . format ( \"[%d]\" , this . first ) ; \n} \nelse { \nreturn String . format ( \"[%d:%d]\" , this . first , this . stop - 1 ) ; \n} \n} \nelse { \nreturn String . format ( \"[%d:%d:%d]\" , this . first , this . stride , this . stop - 1 ) ; \n} \n} \n} \n"}
{"4350": "public class Slice { \nstatic long MAP ( Slice target , long i ) throws DapException { \nif ( i < 0 ) { \nthrow new DapException ( \"Slice.compose: i must be >= 0\" ) ; \n} \nif ( i > target . getStop ( ) ) { \nthrow new DapException ( \"i must be < stop\" ) ; \n} \nreturn target . getFirst ( ) + i * target . getStride ( ) ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nint savepos = buf0 . position ( ) ; \nint limit0 = buf0 . limit ( ) ; \nint skipcount = 0 ; \nif ( limit0 > MAXLIMIT ) { \nlimit0 = MAXLIMIT ; \n} \nif ( limit0 >= buf0 . limit ( ) ) { \nlimit0 = buf0 . limit ( ) ; \n} \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount += 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . println ( \"order=\" + buf0 . order ( ) ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) { \ns = \"\\\\r\" ; \n} \nelse if ( c == '\\n' ) { \ns = \"\\\\n\" ; \n} \nelse if ( c < ' ' || c >= 0x7f ) { \ns = \"?\" ; \n} \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4353": "public class EarthEllipsoid { \npublic static EarthEllipsoid getType ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nreturn hash . get ( name ) ; \n} \n} \n"}
{"4357": "public class DodsURLExtractor { \npublic ArrayList extract ( String url ) throws IOException { \nif ( debug ) { \nSystem . out . println ( \" URLextract=\" + url ) ; \n} \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \nurlList = new ArrayList ( ) ; \nwantURLS = true ; \nwantText = false ; \nparser . parse ( r , callback , false ) ; \nreturn urlList ; \n} \n} \n"}
{"4358": "public class DodsURLExtractor { \npublic String getTextContent ( String url ) throws IOException { \nif ( debug ) { \nSystem . out . println ( \" URL.getTextContent=\" + url ) ; \n} \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \ntextBuffer = new StringBuffer ( 3000 ) ; \nwantURLS = false ; \nwantText = true ; \nparser . parse ( r , callback , false ) ; \nreturn textBuffer . toString ( ) ; \n} \n} \n"}
{"4359": "public class DodsURLExtractor { \nprivate InputStream filterTag ( InputStream in ) throws IOException { \nBufferedReader buffIn = new BufferedReader ( new InputStreamReader ( in , CDM . UTF8 ) ) ; \nByteArrayOutputStream bos = new ByteArrayOutputStream ( 10000 ) ; \nString line = buffIn . readLine ( ) ; \nwhile ( line != null ) { \nString lline = line . toLowerCase ( ) ; \nif ( lline . contains ( \"<meta \" ) ) { \ncontinue ; \n} \nbos . write ( line . getBytes ( CDM . utf8Charset ) ) ; \nline = buffIn . readLine ( ) ; \n} \nbuffIn . close ( ) ; \nreturn new ByteArrayInputStream ( bos . toByteArray ( ) ) ; \n} \n} \n"}
{"4365": "public class ActionCoordinator { \npublic void addActionSourceListener ( ActionSourceListener l ) { \nif ( ! eventType . equals ( l . getEventTypeName ( ) ) ) { \nthrow new IllegalArgumentException ( \"ActionCoordinator: tried to add ActionSourceListener for wrong kind of Action \" + eventType + \" != \" + l . getEventTypeName ( ) ) ; \n} \nlm . addListener ( l ) ; \nl . addActionValueListener ( this ) ; \n} \n} \n"}
{"4368": "public class DateUnit { \npublic Date getDateOrigin ( ) { \nif ( ! ( uu instanceof TimeScaleUnit ) ) { \nreturn null ; \n} \nTimeScaleUnit tu = ( TimeScaleUnit ) uu ; \nreturn tu . getOrigin ( ) ; \n} \n} \n"}
{"4370": "public class DateUnit { \npublic Date makeDate ( double val ) { \nif ( Double . isNaN ( val ) ) { \nreturn null ; \n} \ndouble secs = timeUnit . getValueInSeconds ( val ) ; \nreturn new Date ( getDateOrigin ( ) . getTime ( ) + ( long ) ( 1000 * secs ) ) ; \n} \n} \n"}
{"4372": "public class DateUnit { \npublic String makeStandardDateString ( double value ) { \nDate date = makeDate ( value ) ; \nif ( date == null ) { \nreturn null ; \n} \nDateFormatter formatter = new DateFormatter ( ) ; \nreturn formatter . toDateTimeStringISO ( date ) ; \n} \n} \n"}
{"4373": "public class GridHorizCoordSys { \nprivate double getGridSpacingInKm ( String type ) { \ndouble value = gds . getDouble ( type ) ; \nif ( Double . isNaN ( value ) ) { \nreturn value ; \n} \nString gridUnit = gds . getParam ( GridDefRecord . GRID_UNITS ) ; \nSimpleUnit unit ; \nif ( gridUnit == null || gridUnit . length ( ) == 0 ) { \nunit = SimpleUnit . meterUnit ; \n} \nelse { \nunit = SimpleUnit . factory ( gridUnit ) ; \n} \nif ( unit != null && SimpleUnit . isCompatible ( unit . getUnitString ( ) , \"km\" ) ) { \nvalue = unit . convertTo ( value , SimpleUnit . kmUnit ) ; \n} \nreturn value ; \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) { \nradius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \n} \nif ( ! Double . isNaN ( radius_spherical_earth ) ) { \nif ( radius_spherical_earth < 10000.00 ) { \nradius_spherical_earth *= 1000.0 ; \n} \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \nelse { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) { \nmajor_axis = gds . getDouble ( \"major_axis_earth\" ) ; \n} \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) { \nminor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \n} \nif ( ! Double . isNaN ( major_axis ) && ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn true ; \n} \n} \n"}
{"4378": "public class GridHorizCoordSys { \nprivate void addCoordSystemVariable ( NetcdfFile ncfile , String name , String dims ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , new char [ ] { \n'0' } \n) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , \"\" ) ) ; \n} \nelse { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , getGridName ( ) ) ) ; \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( lad ) ) { \nscale = .933 ; \n} \nelse { \nscale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \n} \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \nSystem . out . println ( \"   should be LA1=\" + gds . getDouble ( GridDefRecord . LA1 ) + \" l)1=\" + gds . getDouble ( GridDefRecord . LO1 ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) { \nLatin = gds . getDouble ( GridDefRecord . LATIN ) ; \n} \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) { \nLo2 += 360 ; \n} \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( dy < 2100 ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) { \nmajor_axis = gds . getDouble ( \"major_axis_earth\" ) ; \n} \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) { \nminor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \n} \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4384": "public class InvCatalogFactory10 { \nprotected InvDatasetImpl readDataset ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nString alias = dsElem . getAttributeValue ( \"alias\" ) ; \nif ( alias != null ) { \nInvDatasetImpl ds = ( InvDatasetImpl ) catalog . findDatasetByID ( alias ) ; \nif ( ds == null ) { \nfactory . appendErr ( \" ** Parse error: dataset named \" + name + \" has illegal alias = \" + alias + \"\\n\" ) ; \nreturn null ; \n} \nreturn new InvDatasetImplProxy ( name , ds ) ; \n} \nInvDatasetImpl dataset = new InvDatasetImpl ( parent , name ) ; \nreadDatasetInfo ( catalog , dataset , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) { \nSystem . out . println ( \" Dataset added: \" + dataset . dump ( ) ) ; \n} \nreturn dataset ; \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) { \nif ( dsElem . getAttributeValue ( \"location\" ) == null ) { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \nelse { \nreturn readDatasetScanNew ( catalog , parent , dsElem , base ) ; \n} \n} \nelse { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) { \nif ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) { \nsortOrderIncreasing = true ; \n} \n} \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) { \nif ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) { \naddDatasetSize = false ; \n} \n} \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) { \npath = path . substring ( 1 ) ; \n} \nint last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) { \npath = path . substring ( 0 , last ) ; \n} \n} \nif ( scanDir != null ) { \nint last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) { \nscanDir = scanDir + '/' ; \n} \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) { \nSystem . out . println ( \" Dataset added: \" + datasetScan . dump ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4386": "public class InvCatalogFactory10 { \npublic Object readMetadataContentFromURL ( InvDataset dataset , java . net . URI uri ) throws java . io . IOException { \nElement elem = readContentFromURL ( uri ) ; \nObject contentObject = readMetadataContent ( dataset , elem ) ; \nif ( debugMetadataRead ) { \nSystem . out . println ( \" convert to \" + contentObject . getClass ( ) . getName ( ) ) ; \n} \nreturn contentObject ; \n} \n} \n"}
{"4390": "public class BaseType { \n@ Override public void setClearName ( String clearname ) { \nsuper . setClearName ( clearname ) ; \nif ( _attr != null ) { \n_attr . setClearName ( clearname ) ; \n} \nif ( _attrTbl != null ) { \n_attrTbl . setClearName ( clearname ) ; \n} \n} \n} \n"}
{"4391": "public class UnidataPointDatasetHelper { \nstatic public String getCoordinateName ( NetcdfDataset ds , AxisType a ) { \nList < Variable > varList = ds . getVariables ( ) ; \nfor ( Variable v : varList ) { \nif ( v instanceof Structure ) { \nList < Variable > vars = ( ( Structure ) v ) . getVariables ( ) ; \nfor ( Variable vs : vars ) { \nString axisType = ds . findAttValueIgnoreCase ( vs , _Coordinate . AxisType , null ) ; \nif ( ( axisType != null ) && axisType . equals ( a . toString ( ) ) ) { \nreturn vs . getShortName ( ) ; \n} \n} \n} \nelse { \nString axisType = ds . findAttValueIgnoreCase ( v , _Coordinate . AxisType , null ) ; \nif ( ( axisType != null ) && axisType . equals ( a . toString ( ) ) ) { \nreturn v . getShortName ( ) ; \n} \n} \n} \nif ( a == AxisType . Lat ) { \nreturn findVariableName ( ds , \"latitude\" ) ; \n} \nif ( a == AxisType . Lon ) { \nreturn findVariableName ( ds , \"longitude\" ) ; \n} \nif ( a == AxisType . Time ) { \nreturn findVariableName ( ds , \"time\" ) ; \n} \nif ( a == AxisType . Height ) { \nVariable v = findVariable ( ds , \"altitude\" ) ; \nif ( null == v ) { \nv = findVariable ( ds , \"depth\" ) ; \n} \nif ( v != null ) { \nreturn v . getShortName ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4392": "public class UnidataPointDatasetHelper { \nstatic public String getCoordinateName ( NetcdfDataset ds , AxisType a , Dimension dim ) { \nString name = getCoordinateName ( ds , a ) ; \nif ( name == null ) { \nreturn null ; \n} \nVariable v = ds . findVariable ( name ) ; \nif ( v == null ) { \nreturn null ; \n} \nif ( v . isScalar ( ) ) { \nreturn null ; \n} \nif ( ! v . getDimension ( 0 ) . equals ( dim ) ) { \nreturn null ; \n} \nreturn name ; \n} \n} \n"}
{"4393": "public class ErrorResponse { \npublic String buildXML ( ) { \nStringBuilder response = new StringBuilder ( ) ; \nresponse . append ( \"<Error\" ) ; \nif ( code > 0 ) { \nresponse . append ( String . format ( \" httpcode=\\\"%d\\\"\" , code ) ) ; \n} \nresponse . append ( \">\\n\" ) ; \nif ( message != null ) { \nresponse . append ( \"<Message>\" + getMessage ( ) + \"</Message>\\n\" ) ; \n} \nif ( context != null ) { \nresponse . append ( \"<Context>\" + getContext ( ) + \"</Context>\\n\" ) ; \n} \nif ( otherinfo != null ) { \nresponse . append ( \"<OtherInformation>\" + getOtherInfo ( ) + \"</OtherInformation>\\n\" ) ; \n} \nreturn response . toString ( ) ; \n} \n} \n"}
{"4395": "public class AWIPSConvention { \nprivate List < Dimension > breakupLevels ( NetcdfDataset ds , Variable levelVar ) throws IOException { \nif ( debugBreakup ) { \nparseInfo . format ( \"breakupLevels = %s%n\" , levelVar . getShortName ( ) ) ; \n} \nList < Dimension > dimList = new ArrayList < > ( ) ; \nArrayChar levelVarData ; \ntry { \nlevelVarData = ( ArrayChar ) levelVar . read ( ) ; \n} \ncatch ( IOException ioe ) { \nreturn dimList ; \n} \nList < String > values = null ; \nString currentUnits = null ; \nArrayChar . StringIterator iter = levelVarData . getStringIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString s = iter . next ( ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"   %s%n\" , s ) ; \n} \nStringTokenizer stoke = new StringTokenizer ( s ) ; \nif ( ! stoke . hasMoreTokens ( ) ) { \ncontinue ; \n} \nString units = stoke . nextToken ( ) . trim ( ) ; \nif ( ! units . equals ( currentUnits ) ) { \nif ( values != null ) { \ndimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \n} \nvalues = new ArrayList < > ( ) ; \ncurrentUnits = units ; \n} \nif ( stoke . hasMoreTokens ( ) ) { \nvalues . add ( stoke . nextToken ( ) ) ; \n} \nelse { \nvalues . add ( \"0\" ) ; \n} \n} \nif ( values != null ) { \ndimList . add ( makeZCoordAxis ( ds , values , currentUnits ) ) ; \n} \nif ( debugBreakup ) { \nparseInfo . format ( \"  done breakup%n\" ) ; \n} \nreturn dimList ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( len > 1 ) { \nname = name + Integer . toString ( len ) ; \n} \nelse { \nname = name + values . get ( 0 ) ; \n} \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) { \nparseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \n} \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nint count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \n} \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) { \nv . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \n} \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4398": "public class AWIPSConvention { \nprivate CoordinateAxis makeTimeCoordAxisFromReference ( NetcdfDataset ds , Variable timeVar , Array vals ) { \nVariable refVar = ds . findVariable ( \"reftime\" ) ; \nif ( refVar == null ) { \nreturn null ; \n} \ndouble refValue ; \ntry { \nArray refArray = refVar . read ( ) ; \nrefValue = refArray . getDouble ( refArray . getIndex ( ) ) ; \n} \ncatch ( IOException ioe ) { \nreturn null ; \n} \nif ( refValue == N3iosp . NC_FILL_DOUBLE ) { \nreturn null ; \n} \nArray dvals = Array . factory ( DataType . DOUBLE , vals . getShape ( ) ) ; \nIndexIterator diter = dvals . getIndexIterator ( ) ; \nIndexIterator iiter = vals . getIndexIterator ( ) ; \nwhile ( iiter . hasNext ( ) ) { \nditer . setDoubleNext ( iiter . getDoubleNext ( ) + refValue ) ; \n} \nString units = ds . findAttValueIgnoreCase ( refVar , CDM . UNITS , \"seconds since 1970-1-1 00:00:00\" ) ; \nunits = normalize ( units ) ; \nString desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\" ; \nCoordinateAxis1D timeCoord = new CoordinateAxis1D ( ds , null , \"timeCoord\" , DataType . DOUBLE , \"record\" , units , desc ) ; \ntimeCoord . setCachedData ( dvals , true ) ; \nparseInfo . format ( \"Created Time Coordinate Axis From Reference = \" ) ; \ntimeCoord . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn timeCoord ; \n} \n} \n"}
{"4399": "public class GribToNetcdfWriter { \npublic static float bitShave ( float value , int bitMask ) { \nif ( Float . isNaN ( value ) ) { \nreturn value ; \n} \nint bits = Float . floatToRawIntBits ( value ) ; \nint shave = bits & bitMask ; \nreturn Float . intBitsToFloat ( shave ) ; \n} \n} \n"}
{"4401": "public class NetcdfDataset { \nstatic public NetcdfDataset wrap ( NetcdfFile ncfile , Set < Enhance > mode ) throws IOException { \nif ( ncfile instanceof NetcdfDataset ) { \nNetcdfDataset ncd = ( NetcdfDataset ) ncfile ; \nif ( ! ncd . enhanceNeeded ( mode ) ) { \nreturn ( NetcdfDataset ) ncfile ; \n} \n} \nreturn new NetcdfDataset ( ncfile , mode ) ; \n} \n} \n"}
{"4404": "public class NetcdfDataset { \npublic CoordinateAxis findCoordinateAxis ( AxisType type ) { \nif ( type == null ) { \nreturn null ; \n} \nfor ( CoordinateAxis v : coordAxes ) { \nif ( type == v . getAxisType ( ) ) { \nreturn v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4405": "public class NetcdfDataset { \npublic CoordinateAxis findCoordinateAxis ( String fullName ) { \nif ( fullName == null ) { \nreturn null ; \n} \nfor ( CoordinateAxis v : coordAxes ) { \nif ( fullName . equals ( v . getFullName ( ) ) ) { \nreturn v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4406": "public class NetcdfDataset { \npublic CoordinateSystem findCoordinateSystem ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nfor ( CoordinateSystem v : coordSys ) { \nif ( name . equals ( v . getName ( ) ) ) { \nreturn v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4407": "public class NetcdfDataset { \npublic CoordinateTransform findCoordinateTransform ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nfor ( CoordinateTransform v : coordTransforms ) { \nif ( name . equals ( v . getName ( ) ) ) { \nreturn v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4408": "public class NetcdfDataset { \npublic boolean enhanceNeeded ( Set < Enhance > want ) throws IOException { \nif ( want == null ) { \nreturn false ; \n} \nfor ( Enhance mode : want ) { \nif ( ! this . enhanceMode . contains ( mode ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4409": "public class NetcdfDataset { \npublic void setValues ( Variable v , int npts , double start , double incr ) { \nif ( npts != v . getSize ( ) ) { \nthrow new IllegalArgumentException ( \"bad npts = \" + npts + \" should be \" + v . getSize ( ) ) ; \n} \nArray data = Array . makeArray ( v . getDataType ( ) , npts , start , incr ) ; \nif ( v . getRank ( ) != 1 ) { \ndata = data . reshape ( v . getShape ( ) ) ; \n} \nv . setCachedData ( data , true ) ; \n} \n} \n"}
{"4410": "public class NetcdfDataset { \npublic void setValues ( Variable v , List < String > values ) throws IllegalArgumentException { \nArray data = Array . makeArray ( v . getDataType ( ) , values ) ; \nif ( data . getSize ( ) != v . getSize ( ) ) { \nthrow new IllegalArgumentException ( \"Incorrect number of values specified for the Variable \" + v . getFullName ( ) + \" needed= \" + v . getSize ( ) + \" given=\" + data . getSize ( ) ) ; \n} \nif ( v . getRank ( ) != 1 ) { \ndata = data . reshape ( v . getShape ( ) ) ; \n} \nv . setCachedData ( data , true ) ; \n} \n} \n"}
{"4413": "public class MFileOS7 { \nstatic public MFileOS7 getExistingFile ( String filename ) throws IOException { \nif ( filename == null ) { \nreturn null ; \n} \nPath path = Paths . get ( filename ) ; \nif ( Files . exists ( path ) ) { \nreturn new MFileOS7 ( path ) ; \n} \nreturn null ; \n} \n} \n"}
{"4414": "public class EsriShapefile { \npublic List < EsriFeature > getFeatures ( Rectangle2D bBox ) { \nif ( bBox == null ) { \nreturn features ; \n} \nList < EsriFeature > list = new ArrayList < > ( ) ; \nfor ( EsriFeature gf : features ) { \nif ( gf . getBounds2D ( ) . intersects ( bBox ) ) { \nlist . add ( gf ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \n} \n} \n"}
{"4416": "public class ThreddsMetadata { \npublic void add ( ThreddsMetadata tmd , boolean includeInherited ) { \ncreators . addAll ( tmd . getCreators ( ) ) ; \ncontributors . addAll ( tmd . getContributors ( ) ) ; \ndates . addAll ( tmd . getDates ( ) ) ; \ndocs . addAll ( tmd . getDocumentation ( ) ) ; \nkeywords . addAll ( tmd . getKeywords ( ) ) ; \nprojects . addAll ( tmd . getProjects ( ) ) ; \nproperties . addAll ( tmd . getProperties ( ) ) ; \npublishers . addAll ( tmd . getPublishers ( ) ) ; \nvariables . addAll ( tmd . getVariables ( ) ) ; \nif ( includeInherited ) { \nmetadata . addAll ( tmd . getMetadata ( ) ) ; \n} \nelse { \nfor ( InvMetadata mdata : tmd . getMetadata ( ) ) { \nif ( ! mdata . isInherited ( ) ) { \nmetadata . add ( mdata ) ; \n} \n} \n} \nif ( gc == null ) { \ngc = tmd . getGeospatialCoverage ( ) ; \n} \nif ( timeCoverage == null ) { \ntimeCoverage = tmd . getTimeCoverage ( ) ; \n} \nif ( serviceName == null ) { \nserviceName = tmd . getServiceName ( ) ; \n} \nif ( dataType == null ) { \ndataType = tmd . getDataType ( ) ; \n} \nif ( dataSize == 0.0 ) { \ndataSize = tmd . getDataSize ( ) ; \n} \nif ( dataFormat == null ) { \ndataFormat = tmd . getDataFormatType ( ) ; \n} \nif ( authorityName == null ) { \nauthorityName = tmd . getAuthority ( ) ; \n} \nif ( variableMapLink == null ) { \nvariableMapLink = tmd . getVariableMap ( ) ; \n} \n} \n} \n"}
{"4417": "public class ThreddsMetadata { \npublic void addDocumentation ( String type , String content ) { \nif ( content == null ) { \nremoveDocumentation ( type ) ; \nreturn ; \n} \ncontent = content . trim ( ) ; \nfor ( InvDocumentation doc : getDocumentation ( ) ) { \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) { \ndoc . setInlineContent ( content ) ; \nreturn ; \n} \n} \nif ( content . length ( ) > 0 ) { \naddDocumentation ( new InvDocumentation ( null , null , null , type , content ) ) ; \n} \n} \n} \n"}
{"4418": "public class ThreddsMetadata { \npublic void removeDocumentation ( String type ) { \nIterator iter = docs . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDocumentation doc = ( InvDocumentation ) iter . next ( ) ; \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) { \niter . remove ( ) ; \n} \n} \n} \n} \n"}
{"4419": "public class LayoutSegmented { \nprivate int getMaxBytes ( long start ) { \nint segno = 0 ; \nwhile ( start >= segMax [ segno ] ) { \nsegno ++ ; \n} \nreturn ( int ) ( segMax [ segno ] - start ) ; \n} \n} \n"}
{"4420": "public class NsslRadarMosaicConvention { \npublic static boolean isMine ( NetcdfFile ncfile ) { \nString cs = ncfile . findAttValueIgnoreCase ( null , CDM . CONVENTIONS , null ) ; \nif ( cs != null ) { \nreturn false ; \n} \nString s = ncfile . findAttValueIgnoreCase ( null , \"DataType\" , null ) ; \nif ( ( s == null ) || ! ( s . equalsIgnoreCase ( \"LatLonGrid\" ) || s . equalsIgnoreCase ( \"LatLonHeightGrid\" ) ) ) { \nreturn false ; \n} \nif ( ( null == ncfile . findGlobalAttribute ( \"Latitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"Longitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LatGridSpacing\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LonGridSpacing\" ) ) || ( null == ncfile . findGlobalAttribute ( \"Time\" ) ) ) { \nreturn false ; \n} \nreturn ! ( null == ncfile . findDimension ( \"Lat\" ) || null == ncfile . findDimension ( \"Lon\" ) ) ; \n} \n} \n"}
{"4421": "public class CollectionManagerCatalog { \n@ Override public void getDataset ( Dataset ds , Object context ) { \nif ( ds . hasAccess ( ) ) { \nDataFactory tdataFactory = new DataFactory ( ) ; \nAccess access = tdataFactory . chooseDatasetAccess ( ds . getAccess ( ) ) ; \nif ( access == null ) { \nthrow new IllegalStateException ( ) ; \n} \nMFileRemote mfile = new MFileRemote ( access ) ; \nif ( mfile . getPath ( ) . endsWith ( \".xml\" ) ) { \nreturn ; \n} \nmfiles . add ( mfile ) ; \nif ( debug ) { \nSystem . out . format ( \"add %s %n\" , mfile . getPath ( ) ) ; \n} \n} \n} \n} \n"}
{"4423": "public class CoordSysBuilder { \nstatic public String buildConventionAttribute ( String mainConv , String ... convAtts ) { \nList < String > result = new ArrayList < > ( ) ; \nresult . add ( mainConv ) ; \nfor ( String convs : convAtts ) { \nif ( convs == null ) { \ncontinue ; \n} \nList < String > ss = breakupConventionNames ( convs ) ; \nfor ( String s : ss ) { \nif ( matchConvention ( s ) == null ) { \nresult . add ( s ) ; \n} \n} \n} \nboolean start = true ; \nFormatter f = new Formatter ( ) ; \nfor ( String s : result ) { \nif ( start ) { \nf . format ( \"%s\" , s ) ; \n} \nelse { \nf . format ( \", %s\" , s ) ; \n} \nstart = false ; \n} \nreturn f . toString ( ) ; \n} \n} \n"}
{"4424": "public class CoordSysBuilder { \n@ Override public void buildCoordinateSystems ( NetcdfDataset ncDataset ) { \nparseInfo . format ( \"Parsing with Convention = %s%n\" , conventionName ) ; \naddVariables ( ncDataset , ncDataset . getVariables ( ) , varList ) ; \nfindCoordinateAxes ( ncDataset ) ; \nfindCoordinateSystems ( ncDataset ) ; \nfindCoordinateTransforms ( ncDataset ) ; \nmakeCoordinateAxes ( ncDataset ) ; \nmakeCoordinateSystems ( ncDataset ) ; \nassignCoordinateSystemsExplicit ( ncDataset ) ; \nmakeCoordinateSystemsImplicit ( ncDataset ) ; \nif ( useMaximalCoordSys ) { \nmakeCoordinateSystemsMaximal ( ncDataset ) ; \n} \nmakeCoordinateTransforms ( ncDataset ) ; \nassignCoordinateTransforms ( ncDataset ) ; \nif ( debug ) { \nSystem . out . println ( \"parseInfo = \\n\" + parseInfo . toString ( ) ) ; \n} \n} \n} \n"}
{"4425": "public class CoordSysBuilder { \nprotected void findCoordinateAxes ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordAxes != null ) { \nfindCoordinateAxes ( vp , vp . coordAxes ) ; \n} \nif ( vp . coordinates != null ) { \nfindCoordinateAxes ( vp , vp . coordinates ) ; \n} \n} \n} \n} \n"}
{"4426": "public class CoordSysBuilder { \nprotected void findCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordSys != null ) { \nStringTokenizer stoker = new StringTokenizer ( vp . coordSys ) ; \nwhile ( stoker . hasMoreTokens ( ) ) { \nString vname = stoker . nextToken ( ) ; \nVarProcess ap = findVarProcess ( vname , vp ) ; \nif ( ap != null ) { \nif ( ! ap . isCoordinateSystem ) { \nparseInfo . format ( \" CoordinateSystem = %s added; referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \n} \nap . isCoordinateSystem = true ; \n} \nelse { \nparseInfo . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nuserAdvice . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) { \ncontinue ; \n} \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) { \naxisList . add ( axis ) ; \n} \n} \nif ( axisList . size ( ) < 2 ) { \ncontinue ; \n} \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( requireCompleteCoordSys ) { \nif ( cs != null ) { \nokToBuild = cs . isComplete ( ve ) ; \n} \n} \nelse { \nokToBuild = true ; \n} \nif ( cs != null && okToBuild ) { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \nelse { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) { \nokToBuild = csnew . isComplete ( ve ) ; \n} \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) { \ncheckDims -- ; \n} \nfor ( int i = 0 ; \ni < checkDims ; \ni ++ ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4430": "public class CoordSysBuilder { \nprotected void addCoordinateVariable ( Dimension dim , VarProcess vp ) { \nList < VarProcess > list = coordVarMap . get ( dim ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \ncoordVarMap . put ( dim , list ) ; \n} \nif ( ! list . contains ( vp ) ) { \nlist . add ( vp ) ; \n} \n} \n} \n"}
{"4433": "public class InvCatalogImpl { \nprivate boolean mark ( DatasetFilter filter , InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) { \nreturn false ; \n} \n} \nboolean allMarked = true ; \nfor ( InvDataset nested : ds . getDatasets ( ) ) { \nallMarked &= mark ( filter , ( InvDatasetImpl ) nested ) ; \n} \nif ( ! allMarked ) { \nreturn false ; \n} \nif ( filter . accept ( ds ) >= 0 ) { \nreturn false ; \n} \nds . setMark ( true ) ; \nif ( debugFilter ) { \nSystem . out . println ( \" mark \" + ds . getName ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) { \nreturn ; \n} \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( nested . getMark ( ) ) { \niter . remove ( ) ; \nif ( debugFilter ) { \nSystem . out . println ( \" remove \" + nested . getName ( ) ) ; \n} \n} \nelse { \ndelete ( nested ) ; \n} \n} \n} \n} \n"}
{"4435": "public class LoadCommon { \npublic void initOnce ( HttpServletRequest req ) throws SendError { \nif ( once ) { \nreturn ; \n} \nonce = true ; \nlog . info ( getClass ( ) . getName ( ) + \" GET initialization\" ) ; \nif ( this . tdsContext == null ) { \nthrow new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , \"Cannot find TDS Context\" ) ; \n} \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( req . getServerName ( ) ) ; \nint port = req . getServerPort ( ) ; \nif ( port > 0 ) { \nbuf . append ( \":\" ) ; \nbuf . append ( port ) ; \n} \nthis . server = buf . toString ( ) ; \nString tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; \nthis . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \ntmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; \nthis . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \nif ( this . threddsname == null ) { \nthis . threddsname = DEFAULTSERVLETNAME ; \n} \nFile updir = tdsContext . getUploadDir ( ) ; \nif ( updir == null ) { \nlog . warn ( \"No tds.upload.dir specified\" ) ; \nthis . uploaddir = null ; \n} \nelse { \nthis . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; \n} \nFile downdir = tdsContext . getDownloadDir ( ) ; \nif ( downdir == null ) { \nlog . warn ( \"No tds.download.dir specified\" ) ; \nthis . downloaddir = null ; \n} \nelse { \nthis . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; \n} \n} \n} \n"}
{"4438": "public class TableRowAbstract { \npublic int compare ( TableRow other , int col ) { \nString s1 = getValueAt ( col ) . toString ( ) ; \nString s2 = other . getValueAt ( col ) . toString ( ) ; \nint ret = s1 . compareToIgnoreCase ( s2 ) ; \nif ( ret == 0 ) { \nreturn compareTie ( other , col ) ; \n} \nreturn ret ; \n} \n} \n"}
{"4439": "public class TableRowAbstract { \nprotected int compareBoolean ( TableRow other , int col , boolean b1 , boolean b2 ) { \nif ( b1 == b2 ) { \nreturn compareTie ( other , col ) ; \n} \nreturn b1 ? 1 : - 1 ; \n} \n} \n"}
{"4440": "public class Dap4ParserImpl { \nDapGroup getGroupScope ( ) throws DapException { \nDapGroup gscope = ( DapGroup ) searchScope ( DapSort . GROUP , DapSort . DATASET ) ; \nif ( gscope == null ) { \nthrow new DapException ( \"Undefined Group Scope\" ) ; \n} \nreturn gscope ; \n} \n} \n"}
{"4441": "public class Dap4ParserImpl { \nvoid passReserved ( XMLAttributeMap map , DapNode node ) throws ParseException { \ntry { \nDapAttribute attr = null ; \nfor ( Map . Entry < String , SaxEvent > entry : map . entrySet ( ) ) { \nSaxEvent event = entry . getValue ( ) ; \nString key = entry . getKey ( ) ; \nString value = event . value ; \nif ( isReserved ( key ) ) { \nnode . addXMLAttribute ( key , value ) ; \n} \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"4442": "public class TimeParamsValidator { \nprivate boolean hasValidDateRange ( String time_start , String time_end , String time_duration ) { \nif ( ( null == time_start ) && ( null == time_end ) && ( null == time_duration ) ) { \nreturn false ; \n} \nif ( ( null != time_start ) && ( null != time_end ) ) { \nreturn true ; \n} \nif ( ( null != time_start ) && ( null != time_duration ) ) { \nreturn true ; \n} \nif ( ( null != time_end ) && ( null != time_duration ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4445": "public class DSPRegistry { \nsynchronized public void register ( Class < ? extends DSP > klass , boolean last ) { \nif ( registered ( klass ) ) { \nreturn ; \n} \nif ( last ) { \nregistry . add ( new Registration ( klass ) ) ; \n} \nelse { \nregistry . add ( 0 , new Registration ( klass ) ) ; \n} \n} \n} \n"}
{"4446": "public class DSPRegistry { \nsynchronized public boolean registered ( Class < ? extends DSP > klass ) { \nfor ( Registration r : registry ) { \nif ( r . dspclass == klass ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4448": "public class Grib2Tables { \npublic static Grib2Tables factory ( int center , int subCenter , int masterVersion , int localVersion , int genProcessId ) { \nGrib2TablesId id = new Grib2TablesId ( center , subCenter , masterVersion , localVersion , genProcessId ) ; \nGrib2Tables cust = tables . get ( id ) ; \nif ( cust != null ) { \nreturn cust ; \n} \nGrib2TableConfig config = Grib2TableConfig . matchTable ( id ) ; \ncust = build ( config ) ; \ntables . put ( id , cust ) ; \nreturn cust ; \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) { \ncontinue ; \n} \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) { \nrange += ti . timeIncrement ; \n} \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) { \nreturn GribNumbers . UNDEFINEDD ; \n} \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) { \nreturn range ; \n} \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { \nfac = 30.0 * 24.0 ; \n} \nelse if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \nreturn fac * range ; \n} \n} \n"}
{"4450": "public class Grib2Tables { \n@ Nullable public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { \nTimeCoordIntvDateValue tinvd = getForecastTimeInterval ( gr ) ; \nif ( tinvd == null ) { \nreturn null ; \n} \nGrib2Pds pds = gr . getPDS ( ) ; \nint unit = convertTimeUnit ( pds . getTimeUnit ( ) ) ; \nTimeCoordIntvValue tinv = tinvd . convertReferenceDate ( gr . getReferenceDate ( ) , Grib2Utils . getCalendarPeriod ( unit ) ) ; \nif ( tinv == null ) { \nreturn null ; \n} \nint [ ] result = new int [ 2 ] ; \nresult [ 0 ] = tinv . getBounds1 ( ) ; \nresult [ 1 ] = tinv . getBounds2 ( ) ; \nreturn result ; \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) { \nreturn ; \n} \nif ( this . ce == null ) { \nthis . visiblenodes = nodelist ; \n} \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( int i = 0 ; \ni < nodelist . size ( ) ; \ni ++ ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) { \nvisiblenodes . add ( node ) ; \n} \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4455": "public class Evaluator { \nstatic public VarAtt findVariableWithAttribute ( NetcdfDataset ds , String attName ) { \nfor ( Variable v : ds . getVariables ( ) ) { \nAttribute att = v . findAttributeIgnoreCase ( attName ) ; \nif ( att != null ) { \nreturn new VarAtt ( v , att ) ; \n} \n} \nfor ( Variable v : ds . getVariables ( ) ) { \nif ( v instanceof Structure ) { \nStructure s = ( Structure ) v ; \nfor ( Variable vs : s . getVariables ( ) ) { \nAttribute att = vs . findAttributeIgnoreCase ( attName ) ; \nif ( att != null ) { \nreturn new VarAtt ( vs , att ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4456": "public class Evaluator { \nstatic public Variable findVariableWithAttributeValue ( NetcdfDataset ds , String attName , String attValue ) { \nfor ( Variable v : ds . getVariables ( ) ) { \nString haveValue = ds . findAttValueIgnoreCase ( v , attName , null ) ; \nif ( ( haveValue != null ) && haveValue . equals ( attValue ) ) { \nreturn v ; \n} \n} \nfor ( Variable v : ds . getVariables ( ) ) { \nif ( v instanceof Structure ) { \nVariable vn = findVariableWithAttributeValue ( ( Structure ) v , attName , attValue ) ; \nif ( null != vn ) { \nreturn vn ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4458": "public class Evaluator { \nstatic public Variable findVariableWithAttributeValue ( Structure struct , String attName , String attValue ) { \nfor ( Variable v : struct . getVariables ( ) ) { \nAttribute att = v . findAttributeIgnoreCase ( attName ) ; \nif ( ( att != null ) && att . getStringValue ( ) . equals ( attValue ) ) { \nreturn v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4459": "public class Evaluator { \nstatic public Structure findNestedStructure ( Structure s ) { \nfor ( Variable v : s . getVariables ( ) ) { \nif ( ( v instanceof Structure ) ) { \nreturn ( Structure ) v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4461": "public class Evaluator { \nstatic public String getLiteral ( NetcdfDataset ds , String key , Formatter errlog ) { \nif ( key . startsWith ( \":\" ) ) { \nString val = ds . findAttValueIgnoreCase ( null , key . substring ( 1 ) , null ) ; \nif ( ( val == null ) && ( errlog != null ) ) { \nerrlog . format ( \" Cant find global attribute %s%n\" , key ) ; \n} \nreturn val ; \n} \nreturn key ; \n} \n} \n"}
{"4462": "public class Evaluator { \nstatic public FeatureType getFeatureType ( NetcdfDataset ds , String key , Formatter errlog ) { \nFeatureType ft = null ; \nString fts = getLiteral ( ds , key , errlog ) ; \nif ( fts != null ) { \nft = FeatureType . valueOf ( fts . toUpperCase ( ) ) ; \nif ( ( ft == null ) && ( errlog != null ) ) { \nerrlog . format ( \" Cant find Feature type %s from %s%n\" , fts , key ) ; \n} \n} \nreturn ft ; \n} \n} \n"}
{"4463": "public class Evaluator { \nstatic public String getVariableName ( NetcdfDataset ds , String key , Formatter errlog ) { \nVariable v = null ; \nString vs = getLiteral ( ds , key , errlog ) ; \nif ( vs != null ) { \nv = ds . findVariable ( vs ) ; \nif ( ( v == null ) && ( errlog != null ) ) { \nerrlog . format ( \" Cant find Variable %s from %s%n\" , vs , key ) ; \n} \n} \nreturn v == null ? null : v . getShortName ( ) ; \n} \n} \n"}
{"4464": "public class CoordinateAxis2D { \npublic double getCoordValue ( int j , int i ) { \nif ( coords == null ) { \ndoRead ( ) ; \n} \nreturn coords . get ( j , i ) ; \n} \n} \n"}
{"4465": "public class CoordinateAxis2D { \nstatic private double connectLon ( double connect , double val ) { \nif ( Double . isNaN ( connect ) ) { \nreturn val ; \n} \nif ( Double . isNaN ( val ) ) { \nreturn val ; \n} \ndouble diff = val - connect ; \nif ( Math . abs ( diff ) < MAX_JUMP ) { \nreturn val ; \n} \ndouble result = diff > 0 ? val - 360 : val + 360 ; \ndouble diff2 = connect - result ; \nif ( ( Math . abs ( diff2 ) ) < Math . abs ( diff ) ) { \nval = result ; \n} \nreturn val ; \n} \n} \n"}
{"4466": "public class CoordinateAxis2D { \npublic double [ ] getCoordValues ( ) { \nif ( coords == null ) { \ndoRead ( ) ; \n} \nif ( ! isNumeric ( ) ) { \nthrow new UnsupportedOperationException ( \"CoordinateAxis2D.getCoordValues() on non-numeric\" ) ; \n} \nreturn ( double [ ] ) coords . get1DJavaArray ( DataType . DOUBLE ) ; \n} \n} \n"}
{"4471": "public class PathMatcher { \npublic Match match ( String path ) { \nSortedMap < String , Match > tail = treeMap . tailMap ( path ) ; \nif ( tail . isEmpty ( ) ) { \nreturn null ; \n} \nString after = tail . firstKey ( ) ; \nif ( path . startsWith ( after ) ) { \nreturn treeMap . get ( after ) ; \n} \nfor ( String key : tail . keySet ( ) ) { \nif ( path . startsWith ( key ) ) { \nreturn treeMap . get ( key ) ; \n} \nif ( StringUtil2 . match ( path , key ) == 0 ) { \nbreak ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) { \nreturn - 1 ; \n} \nif ( start + max > data . length ) { \nSystem . out . println ( \"HEY KMPMatch\" ) ; \n} \nfor ( int i = start ; \ni < start + max ; \ni ++ ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) { \nj = failure [ j - 1 ] ; \n} \nif ( match [ j ] == data [ i ] ) { \nj ++ ; \n} \nif ( j == match . length ) { \nreturn i - match . length + 1 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4474": "public class PictureCache { \npublic static synchronized void add ( URL url , SourcePicture sp ) { \nTools . log ( \"PictureCache.add: \" + url . toString ( ) ) ; \nif ( sp . getSourceBufferedImage ( ) == null ) { \nTools . log ( \"PictureCache.add: invoked with a null picture! Not cached!\" ) ; \nreturn ; \n} \nif ( ( maxCache < 1 ) ) { \nTools . log ( \"PictureCache.add: cache is diabled. Not adding picture.\" ) ; \nreturn ; \n} \nif ( isInCache ( url ) ) { \nTools . log ( \"Picture \" + url . toString ( ) + \" is already in the cache. Not adding again.\" ) ; \nreturn ; \n} \nif ( pictureCache . size ( ) >= maxCache ) { \nremoveLeastPopular ( ) ; \n} \nif ( pictureCache . size ( ) < maxCache ) { \npictureCache . put ( url . toString ( ) , sp ) ; \n} \n} \n} \n"}
{"4477": "public class PictureCache { \npublic static boolean stopBackgroundLoadingExcept ( URL exemptionURL ) { \nSourcePicture sp ; \nString exemptionURLString = exemptionURL . toString ( ) ; \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nboolean inProgress = false ; \nwhile ( e . hasMoreElements ( ) ) { \nsp = ( ( SourcePicture ) e . nextElement ( ) ) ; \nif ( ! sp . getUrlString ( ) . equals ( exemptionURLString ) ) { \nsp . stopLoading ( ) ; \n} \nelse { \nTools . log ( \"PictureCache.stopBackgroundLoading: picture was already loading\" ) ; \ninProgress = true ; \n} \n} \nreturn inProgress ; \n} \n} \n"}
{"4481": "public class RandomValue { \npublic int nextCount ( int max ) throws DapException { \nint min = 1 ; \nif ( max < min || min < 1 ) { \nthrow new DapException ( \"bad range\" ) ; \n} \nint range = ( max + 1 ) - min ; \nint n = random . nextInt ( range ) ; \nn = n + min ; \nif ( DEBUG ) { \nSystem . err . println ( \"RandomValue.nextCount: \" + n ) ; \n} \nreturn n ; \n} \n} \n"}
{"4482": "public class DapNetcdfFile { \n@ Override protected Array readData ( Variable cdmvar , Section section ) throws IOException , InvalidRangeException { \nassert this . dsp != null ; \nArray result = arraymap . get ( cdmvar ) ; \nif ( result == null ) { \nthrow new IOException ( \"No data for variable: \" + cdmvar . getFullName ( ) ) ; \n} \nif ( section != null ) { \nif ( cdmvar . getRank ( ) != section . getRank ( ) ) { \nthrow new InvalidRangeException ( String . format ( \"Section rank != %s rank\" , cdmvar . getFullName ( ) ) ) ; \n} \nList < Range > ranges = section . getRanges ( ) ; \nif ( CDMUtil . hasVLEN ( ranges ) ) { \nranges = ranges . subList ( 0 , ranges . size ( ) - 1 ) ; \n} \nif ( ranges . size ( ) > 0 && ! CDMUtil . isWhole ( ranges , cdmvar ) ) { \nresult = result . sectionNoReduce ( ranges ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4484": "public class NexradStationDB { \nprivate static void readStationTable ( ) throws IOException { \nstationTableHash = new HashMap < String , Station > ( ) ; \nClassLoader cl = Level2VolumeScan . class . getClassLoader ( ) ; \nInputStream is = cl . getResourceAsStream ( \"resources/nj22/tables/nexrad.tbl\" ) ; \nList < TableParser . Record > recs = TableParser . readTable ( is , \"3,15,46, 54,60d,67d,73d\" , 50000 ) ; \nfor ( TableParser . Record record : recs ) { \nStation s = new Station ( ) ; \ns . id = \"K\" + record . get ( 0 ) ; \ns . name = record . get ( 2 ) + \" \" + record . get ( 3 ) ; \ns . lat = ( Double ) record . get ( 4 ) * .01 ; \ns . lon = ( Double ) record . get ( 5 ) * .01 ; \ns . elev = ( Double ) record . get ( 6 ) ; \nstationTableHash . put ( s . id , s ) ; \nif ( showStations ) { \nSystem . out . println ( \" station= \" + s ) ; \n} \n} \n} \n} \n"}
{"4486": "public class TypedDatasetImpl { \nprotected void removeDataVariable ( String varName ) { \nIterator iter = dataVariables . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nVariableSimpleIF v = ( VariableSimpleIF ) iter . next ( ) ; \nif ( v . getShortName ( ) . equals ( varName ) ) { \niter . remove ( ) ; \n} \n} \n} \n} \n"}
{"4488": "public class ProxyReader2D { \n@ Override public Array reallyRead ( Variable mainv , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nFmrcInvLite . Gridset . Grid gridLite = ( FmrcInvLite . Gridset . Grid ) mainv . getSPobject ( ) ; \nDataType dtype = ( mainv instanceof VariableDS ) ? ( ( VariableDS ) mainv ) . getOriginalDataType ( ) : mainv . getDataType ( ) ; \nArray allData = Array . factory ( dtype , section . getShape ( ) ) ; \nint destPos = 0 ; \nList < Range > ranges = section . getRanges ( ) ; \nRange runRange = ranges . get ( 0 ) ; \nRange timeRange = ranges . get ( 1 ) ; \nList < Range > innerSection = ranges . subList ( 2 , ranges . size ( ) ) ; \nHashMap < String , NetcdfDataset > openFilesRead = new HashMap < > ( ) ; \ntry { \nfor ( int runIdx : runRange ) { \nfor ( int timeIdx : timeRange ) { \nArray result = null ; \nTimeInventory . Instance timeInv = gridLite . getInstance ( runIdx , timeIdx ) ; \nif ( timeInv != null ) { \nif ( debugRead ) { \nSystem . out . printf ( \"HIT %d %d \" , runIdx , timeIdx ) ; \n} \nresult = read ( timeInv , gridLite . name , innerSection , openFilesRead ) ; \nresult = MAMath . convert ( result , dtype ) ; \n} \nif ( result == null ) { \nint [ ] shape = new Section ( innerSection ) . getShape ( ) ; \nresult = ( ( VariableDS ) mainv ) . getMissingDataArray ( shape ) ; \nif ( debugRead ) { \nSystem . out . printf ( \"MISS %d %d \" , runIdx , timeIdx ) ; \n} \n} \nif ( debugRead ) { \nSystem . out . printf ( \"%d %d reallyRead %s %d bytes start at %d total size is %d%n\" , runIdx , timeIdx , mainv . getFullName ( ) , result . getSize ( ) , destPos , allData . getSize ( ) ) ; \n} \nArray . arraycopy ( result , 0 , allData , destPos , ( int ) result . getSize ( ) ) ; \ndestPos += result . getSize ( ) ; \n} \n} \nreturn allData ; \n} \nfinally { \ncloseAll ( openFilesRead ) ; \n} \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nint prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \nfor ( int i = ncolors ; \ni < n ; \ni ++ ) { \ncolors [ i ] = Color . white ; \n} \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \n} \n} \n"}
{"4492": "public class GridIndex { \npublic void finish ( ) { \nif ( gcs . size ( ) == 1 ) { \nreturn ; \n} \nif ( gcs . size ( ) == 2 ) { \nList hcs = getHorizCoordSys ( ) ; \nGridDefRecord . compare ( ( GridDefRecord ) hcs . get ( 0 ) , ( GridDefRecord ) hcs . get ( 1 ) ) ; \n} \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) { \nreturn ( want == start ) ? 0 : - 1 ; \n} \nif ( isSequential ) { \nreturn want - start ; \n} \nif ( isSorted ) { \nreturn Arrays . binarySearch ( raw , want ) ; \n} \nfor ( int i = 0 ; \ni < raw . length ; \ni ++ ) { \nif ( raw [ i ] == want ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) { \nreturn false ; \n} \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) { \nSystem . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \n} \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) { \nSystem . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \n} \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4511": "public class Debug { \nstatic public void constructMenu ( JMenu topMenu ) { \nif ( debug ) { \nSystem . out . println ( \"Debug.constructMenu \" ) ; \n} \nif ( topMenu . getItemCount ( ) > 0 ) { \ntopMenu . removeAll ( ) ; \n} \ntry { \naddToMenu ( topMenu , store ) ; \n} \ncatch ( BackingStoreException e ) { \n} \ntopMenu . revalidate ( ) ; \n} \n} \n"}
{"4512": "public class Debug { \nstatic private void addToMenu ( JMenu menu , Preferences prefs ) throws BackingStoreException { \nif ( debug ) { \nSystem . out . println ( \" addMenu \" + prefs . name ( ) ) ; \n} \nString [ ] keys = prefs . keys ( ) ; \nfor ( String key : keys ) { \nboolean bval = prefs . getBoolean ( key , false ) ; \nString fullname = prefs . absolutePath ( ) + \"/\" + key ; \nmenu . add ( new DebugMenuItem ( fullname , key , bval ) ) ; \nif ( debug ) { \nSystem . out . println ( \"   leaf= <\" + key + \"><\" + fullname + \">\" ) ; \n} \n} \nString [ ] kidName = prefs . childrenNames ( ) ; \nfor ( String aKidName : kidName ) { \nPreferences pkid = prefs . node ( aKidName ) ; \nJMenu subMenu = new JMenu ( pkid . name ( ) ) ; \nmenu . add ( subMenu ) ; \naddToMenu ( subMenu , pkid ) ; \n} \n} \n} \n"}
{"4522": "public class Grib2SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( bitMapIndicator == 255 ) { \nreturn null ; \n} \nif ( bitMapIndicator == 254 ) { \nlogger . debug ( \"HEY bitMapIndicator=254 previously defined bitmap\" ) ; \n} \nif ( bitMapIndicator != 0 ) { \nthrow new UnsupportedOperationException ( \"Grib2 Bit map section pre-defined (provided by center) = \" + bitMapIndicator ) ; \n} \nraf . seek ( startingPosition ) ; \nint length = GribNumbers . int4 ( raf ) ; \nraf . skipBytes ( 2 ) ; \nbyte [ ] data = new byte [ length - 6 ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) { \npieces . name = name ; \n} \nelse if ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) { \npieces . prefix = null ; \n} \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) { \npieces . var = null ; \n} \nif ( pieces . name . length ( ) == 0 ) { \npieces . name = null ; \n} \nreturn pieces ; \n} \n} \n"}
{"4526": "public class DODSNetcdfFile { \nprivate boolean isGroup ( DStructure dstruct ) { \nBaseType parent = ( BaseType ) dstruct . getParent ( ) ; \nif ( parent == null ) { \nreturn true ; \n} \nif ( parent instanceof DStructure ) { \nreturn isGroup ( ( DStructure ) parent ) ; \n} \nreturn true ; \n} \n} \n"}
{"4527": "public class DODSNetcdfFile { \nDimension getNetcdfStrlenDim ( DODSVariable v ) { \nAttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; \nif ( table == null ) { \nreturn null ; \n} \nopendap . dap . Attribute dodsAtt = table . getAttribute ( \"DODS\" ) ; \nif ( dodsAtt == null ) { \nreturn null ; \n} \nAttributeTable dodsTable = dodsAtt . getContainerN ( ) ; \nif ( dodsTable == null ) { \nreturn null ; \n} \nopendap . dap . Attribute att = dodsTable . getAttribute ( \"strlen\" ) ; \nif ( att == null ) { \nreturn null ; \n} \nString strlen = att . getValueAtN ( 0 ) ; \nopendap . dap . Attribute att2 = dodsTable . getAttribute ( \"dimName\" ) ; \nString dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; \nif ( debugCharArray ) { \nSystem . out . println ( v . getFullName ( ) + \" has strlen= \" + strlen + \" dimName= \" + dimName ) ; \n} \nint dimLength ; \ntry { \ndimLength = Integer . parseInt ( strlen ) ; \n} \ncatch ( NumberFormatException e ) { \nlogger . warn ( \"DODSNetcdfFile \" + location + \" var = \" + v . getFullName ( ) + \" error on strlen attribute = \" + strlen ) ; \nreturn null ; \n} \nif ( dimLength <= 0 ) { \nreturn null ; \n} \nreturn new Dimension ( dimName , dimLength , dimName != null ) ; \n} \n} \n"}
{"4528": "public class DODSNetcdfFile { \nDimension getSharedDimension ( Group group , Dimension d ) { \nif ( d . getShortName ( ) == null ) { \nreturn d ; \n} \nif ( group == null ) { \ngroup = rootGroup ; \n} \nfor ( Dimension sd : group . getDimensions ( ) ) { \nif ( sd . getShortName ( ) . equals ( d . getShortName ( ) ) && sd . getLength ( ) == d . getLength ( ) ) { \nreturn sd ; \n} \n} \nd . setShared ( true ) ; \ngroup . addDimension ( d ) ; \nreturn d ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) { \ngroup = rootGroup ; \n} \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nwhile ( enumerate . hasMoreElements ( ) ) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) { \nname = StringUtil2 . unescape ( name ) ; \n} \nDimension myd ; \nif ( name == null ) { \nmyd = new Dimension ( null , dad . getSize ( ) , false ) ; \n} \nelse { \nif ( RC . getUseGroups ( ) ) { \nif ( name . indexOf ( '/' ) >= 0 ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \n} \nmyd = group . findDimension ( name ) ; \nif ( myd == null ) { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \nelse if ( myd . getLength ( ) != dad . getSize ( ) ) { \nmyd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4531": "public class DODSNetcdfFile { \nDataDDS readDataDDSfromServer ( String CE ) throws IOException , opendap . dap . DAP2Exception { \nif ( debugServerCall ) { \nSystem . out . println ( \"DODSNetcdfFile.readDataDDSfromServer = <\" + CE + \">\" ) ; \n} \nlong start = 0 ; \nif ( debugTime ) { \nstart = System . currentTimeMillis ( ) ; \n} \nif ( ! CE . startsWith ( \"?\" ) ) { \nCE = \"?\" + CE ; \n} \nDataDDS data ; \nsynchronized ( this ) { \ndata = dodsConnection . getData ( CE , null ) ; \n} \nif ( debugTime ) { \nSystem . out . println ( \"DODSNetcdfFile.readDataDDSfromServer took = \" + ( System . currentTimeMillis ( ) - start ) / 1000.0 ) ; \n} \nif ( debugDataResult ) { \nSystem . out . println ( \" dataDDS return:\" ) ; \ndata . print ( System . out ) ; \n} \nreturn data ; \n} \n} \n"}
{"4532": "public class Resource { \npublic static ImageIcon getIcon ( String fullIconName , boolean errMsg ) { \nImageIcon icon = null ; \njava . net . URL iconR = cl . getResource ( fullIconName ) ; \nif ( debugIcon ) { \nSystem . out . println ( \"classLoader \" + cl . getClassLoader ( ) ) ; \nSystem . out . println ( \"  Resource.getIcon on \" + fullIconName + \" = \" + iconR ) ; \n} \nif ( iconR != null ) { \nicon = new ImageIcon ( iconR ) ; \n} \nif ( ( icon == null ) && errMsg ) { \nSystem . out . println ( \"  ERROR: Resource.getIcon failed on \" + fullIconName ) ; \n} \nelse if ( debugIcon ) { \nSystem . out . println ( \"  Resource.getIcon ok on \" + fullIconName ) ; \n} \nreturn icon ; \n} \n} \n"}
{"4533": "public class Resource { \npublic static Image getImage ( String fullImageName ) { \nImage image = null ; \njava . net . URL url = cl . getResource ( fullImageName ) ; \nif ( url != null ) { \nimage = Toolkit . getDefaultToolkit ( ) . createImage ( url ) ; \n} \nif ( image == null ) { \nSystem . out . println ( \"  ERROR: Resource.getImageResource failed on \" + fullImageName ) ; \n} \nreturn image ; \n} \n} \n"}
{"4534": "public class Resource { \npublic static Cursor makeCursor ( String name ) { \nImage image = getImage ( name ) ; \nif ( null == image ) { \nreturn null ; \n} \nCursor cursor ; \ntry { \nToolkit tk = Toolkit . getDefaultToolkit ( ) ; \nif ( debug ) { \nImageObserver obs = new ImageObserver ( ) { \npublic boolean imageUpdate ( Image image , int flags , int x , int y , int width , int height ) { \nreturn true ; \n} \n} \n; \nSystem . out . println ( \" bestCursorSize = \" + tk . getBestCursorSize ( image . getWidth ( obs ) , image . getHeight ( obs ) ) ) ; \nSystem . out . println ( \" getMaximumCursorColors = \" + tk . getMaximumCursorColors ( ) ) ; \n} \ncursor = tk . createCustomCursor ( image , new Point ( 17 , 17 ) , name ) ; \n} \ncatch ( IndexOutOfBoundsException e ) { \nSystem . out . println ( \"NavigatedPanel createCustomCursor failed \" + e ) ; \nreturn null ; \n} \nreturn cursor ; \n} \n} \n"}
{"4537": "public class IospHelper { \nstatic public Object readDataFill ( LayoutBB layout , DataType dataType , Object fillValue ) throws java . io . IOException { \nlong size = layout . getTotalNelems ( ) ; \nif ( dataType == DataType . STRUCTURE ) { \nsize *= layout . getElemSize ( ) ; \n} \nObject arr = ( fillValue == null ) ? makePrimitiveArray ( ( int ) size , dataType ) : makePrimitiveArray ( ( int ) size , dataType , fillValue ) ; \nreturn readData ( layout , dataType , arr ) ; \n} \n} \n"}
{"4541": "public class IospHelper { \nstatic public char [ ] convertByteToChar ( byte [ ] byteArray ) { \nint size = byteArray . length ; \nchar [ ] cbuff = new char [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \ncbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; \n} \nreturn cbuff ; \n} \nstatic public byte [ ] convertCharToByte ( char [ ] from ) { \nbyte [ ] to = null ; \nif ( from != null ) { \nint size = from . length ; \nto = new byte [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nto [ i ] = ( byte ) from [ i ] ; \n} \n} \nreturn to ; \n} \n} \n"}
{"4545": "public class CDMArrayStructure { \npublic StructureData getScalarStructure ( int index , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . STRUCTURE ) { \nthrow new ForbiddenConversionException ( \"Atomic field cannot be converted to Structure\" ) ; \n} \nArray ca = memberArray ( index , memberIndex ( m ) ) ; \nif ( ca . getDataType ( ) != DataType . STRUCTURE && ca . getDataType ( ) != DataType . SEQUENCE ) { \nthrow new ForbiddenConversionException ( \"Attempt to access non-structure member\" ) ; \n} \nCDMArrayStructure as = ( CDMArrayStructure ) ca ; \nreturn as . getStructureData ( 0 ) ; \n} \n} \n"}
{"4549": "public class CrawlableDatasetFactory { \npublic static CrawlableDataset createCrawlableDataset ( String path , String className , Object configObj ) throws IOException , ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , IllegalArgumentException , NullPointerException { \nif ( path == null ) { \nthrow new NullPointerException ( \"Given path must not be null.\" ) ; \n} \nString tmpClassName = ( className == null ? defaultClassName : className ) ; \nClass crDsClass = Class . forName ( tmpClassName ) ; \nif ( ! CrawlableDataset . class . isAssignableFrom ( crDsClass ) ) { \nthrow new IllegalArgumentException ( \"Requested class <\" + className + \"> not an implementation of thredds.crawlabledataset.CrawlableDataset.\" ) ; \n} \nClass [ ] argTypes = { \nString . class , Object . class } \n; \nObject [ ] args = { \npath , configObj } \n; \nConstructor constructor = crDsClass . getDeclaredConstructor ( argTypes ) ; \ntry { \nreturn ( CrawlableDataset ) constructor . newInstance ( args ) ; \n} \ncatch ( InvocationTargetException e ) { \nif ( IOException . class . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) { \nthrow ( IOException ) e . getCause ( ) ; \n} \nelse { \nthrow e ; \n} \n} \n} \n} \n"}
{"4550": "public class CrawlableDatasetFactory { \npublic static String normalizePath ( String path ) { \nString newPath = path . replaceAll ( \"\\\\\\\\\" , \"/\" ) ; \nwhile ( newPath . endsWith ( \"/\" ) && ! newPath . equals ( \"/\" ) ) { \nnewPath = newPath . substring ( 0 , newPath . length ( ) - 1 ) ; \n} \nreturn newPath ; \n} \n} \n"}
{"4552": "public class Aggregation { \npublic void addDatasetScan ( Element crawlableDatasetElement , String dirName , String suffix , String regexpPatternString , String dateFormatMark , Set < NetcdfDataset . Enhance > enhanceMode , String subdirs , String olderThan ) { \ndatasetManager . addDirectoryScan ( dirName , suffix , regexpPatternString , subdirs , olderThan , enhanceMode ) ; \nthis . dateFormatMark = dateFormatMark ; \nif ( dateFormatMark != null ) { \nisDate = true ; \nif ( type == Type . joinExisting ) { \ntype = Type . joinExistingOne ; \n} \nDateExtractor dateExtractor = new DateExtractorFromName ( dateFormatMark , true ) ; \ndatasetManager . setDateExtractor ( dateExtractor ) ; \n} \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \nfor ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; \ndatasetsIter . hasNext ( ) ; \n) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( dataset . getMFile ( ) instanceof MFileOS ) { \ndatasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \n} \nelse if ( dataset . getMFile ( ) instanceof MFileOS7 ) { \ndatasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \n} \nelse { \ncontinue ; \n} \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) { \nlogger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \n} \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \n} \n} \n"}
{"4555": "public class Aggregation { \nprotected Dataset getTypicalDataset ( ) throws IOException { \nList < Dataset > nestedDatasets = getDatasets ( ) ; \nint n = nestedDatasets . size ( ) ; \nif ( n == 0 ) { \nthrow new FileNotFoundException ( \"No datasets in this aggregation\" ) ; \n} \nint select ; \nif ( typicalDatasetMode == TypicalDataset . LATEST ) { \nselect = n - 1 ; \n} \nelse if ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) { \nselect = ( n < 2 ) ? 0 : n - 2 ; \n} \nelse if ( typicalDatasetMode == TypicalDataset . FIRST ) { \nselect = 0 ; \n} \nelse { \nif ( r == null ) { \nr = new Random ( ) ; \n} \nselect = ( n < 2 ) ? 0 : r . nextInt ( n ) ; \n} \nreturn nestedDatasets . get ( select ) ; \n} \n} \n"}
{"4557": "public class DatasetTrackerInMem { \nvoid putResourceControl ( Dataset ds ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"putResourceControl \" + ds . getRestrictAccess ( ) + \" for \" + ds . getName ( ) ) ; \n} \nresourceControlHash . put ( ds . getUrlPath ( ) , ds . getRestrictAccess ( ) ) ; \nhasResourceControl = true ; \n} \n} \n"}
{"4559": "public class CFLine { \npublic double [ ] getBBUpper ( ) { \ndouble [ ] bbUpper = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) { \nreturn null ; \n} \nbbUpper [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbUpper [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbUpper [ 0 ] < pt . getX ( ) ) { \nbbUpper [ 0 ] = pt . getX ( ) ; \n} \nif ( bbUpper [ 1 ] < pt . getY ( ) ) { \nbbUpper [ 1 ] = pt . getY ( ) ; \n} \n} \nbbUpper [ 0 ] += 10 ; \nbbUpper [ 1 ] += 10 ; \nreturn bbUpper ; \n} \n} \n"}
{"4560": "public class CFLine { \npublic double [ ] getBBLower ( ) { \ndouble [ ] bbLower = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) { \nreturn null ; \n} \nbbLower [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbLower [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbLower [ 0 ] > pt . getX ( ) ) { \nbbLower [ 0 ] = pt . getX ( ) ; \n} \nif ( bbLower [ 1 ] > pt . getY ( ) ) { \nbbLower [ 1 ] = pt . getY ( ) ; \n} \n} \nbbLower [ 0 ] -= 10 ; \nbbLower [ 1 ] -= 10 ; \nreturn bbLower ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) { \nreturn ( false ) ; \n} \nif ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) { \nreturn ( false ) ; \n} \nif ( this . matchPatternTarget == null ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nthis . setMatchPatternTarget ( \"name\" ) ; \n} \nelse { \nthis . setMatchPatternTarget ( \"urlPath\" ) ; \n} \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nboolean isMatch ; \nif ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse if ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \nisMatch = false ; \n} \nreturn ( isMatch ) ; \n} \nelse { \nSystem . err . println ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" ) ; \nreturn ( false ) ; \n} \n} \n} \n"}
{"4566": "public class CEEvaluator { \npublic void printConstraint ( PrintWriter pw ) { \nEnumeration ec = getClauses ( ) ; \nboolean first = true ; \nwhile ( ec . hasMoreElements ( ) ) { \nClause cl = ( Clause ) ec . nextElement ( ) ; \nif ( ! first ) { \npw . print ( \" & \" ) ; \n} \ncl . printConstraint ( pw ) ; \nfirst = false ; \n} \npw . flush ( ) ; \n} \n} \n"}
{"4571": "public class Documentation { \npublic String readXlinkContent ( ) throws java . io . IOException { \nif ( uri == null ) { \nreturn \"\" ; \n} \nURL url = uri . toURL ( ) ; \nInputStream is = url . openStream ( ) ; \nByteArrayOutputStream os = new ByteArrayOutputStream ( is . available ( ) ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nwhile ( true ) { \nint bytesRead = is . read ( buffer ) ; \nif ( bytesRead == - 1 ) { \nbreak ; \n} \nos . write ( buffer , 0 , bytesRead ) ; \n} \nis . close ( ) ; \nreturn new String ( os . toByteArray ( ) , CDM . utf8Charset ) ; \n} \n} \n"}
{"4572": "public class InvAccess { \npublic URI getStandardUri ( ) { \ntry { \nInvCatalog cat = dataset . getParentCatalog ( ) ; \nif ( cat == null ) { \nreturn new URI ( getUnresolvedUrlName ( ) ) ; \n} \nreturn cat . resolveUri ( getUnresolvedUrlName ( ) ) ; \n} \ncatch ( java . net . URISyntaxException e ) { \nlogger . warn ( \"Error parsing URL= \" + getUnresolvedUrlName ( ) ) ; \nreturn null ; \n} \n} \n} \n"}
{"4574": "public class LayoutM { \npublic void addLayoutComponent ( Component comp , Object constraint ) { \nif ( debug ) { \nSystem . out . println ( name + \" addLayoutComponent= \" + comp . getClass ( ) . getName ( ) + \" \" + comp . hashCode ( ) + \" \" + constraint ) ; \n} \nif ( ! ( constraint instanceof Constraint ) ) { \nthrow new IllegalArgumentException ( \"MySpringLayout must be Constraint\" ) ; \n} \nconstraintMap . put ( comp , constraint ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4575": "public class LayoutM { \npublic void invalidateLayout ( Container target ) { \nif ( debug ) { \nSystem . out . println ( name + \" invalidateLayout \" ) ; \n} \nglobalBounds = null ; \n} \n} \n"}
{"4576": "public class LayoutM { \npublic void removeLayoutComponent ( Component comp ) { \nif ( debug ) { \nSystem . out . println ( \"removeLayoutComponent\" ) ; \n} \nconstraintMap . remove ( comp ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4577": "public class LayoutM { \npublic Dimension minimumLayoutSize ( Container parent ) { \nif ( debug ) { \nSystem . out . println ( \"minimumLayoutSize\" ) ; \n} \nif ( globalBounds == null ) { \nlayoutContainer ( parent ) ; \n} \nreturn globalBounds . getSize ( ) ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) { \nSystem . out . println ( name + \" layoutContainer \" ) ; \n} \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) { \nm . layoutContainer ( c ) ; \n} \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) { \ntarget . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nint code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \nfor ( int j = 1 ; \ntrue ; \nj ++ ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null || key == null ) { \nbreak ; \n} \nappendLine ( \" \" + key + \": \" + header ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4583": "public class GEOSTransform { \npublic double [ ] satToEarth ( double x , double y ) { \nif ( scan_geom . equals ( GOES ) ) { \ndouble [ ] lambda_theta_geos = GOES_to_GEOS ( x , y ) ; \nx = lambda_theta_geos [ 0 ] ; \ny = lambda_theta_geos [ 1 ] ; \n} \ndouble c1 = ( h * Math . cos ( x ) * Math . cos ( y ) ) * ( h * Math . cos ( x ) * Math . cos ( y ) ) ; \ndouble c2 = ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) * d ; \nif ( c1 < c2 ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble s_d = Math . sqrt ( c1 - c2 ) ; \ndouble s_n = ( h * Math . cos ( x ) * Math . cos ( y ) - s_d ) / ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) ; \ndouble s_1 = h - s_n * Math . cos ( x ) * Math . cos ( y ) ; \ndouble s_2 = s_n * Math . sin ( x ) * Math . cos ( y ) ; \ndouble s_3 = - s_n * Math . sin ( y ) ; \ndouble s_xy = Math . sqrt ( s_1 * s_1 + s_2 * s_2 ) ; \ndouble geographic_lon = Math . atan ( s_2 / s_1 ) + sub_lon ; \ndouble geographic_lat = Math . atan ( - fp * ( s_3 / s_xy ) ) ; \ndouble lonDegrees = RAD_TO_DEG * geographic_lon ; \ndouble latDegrees = RAD_TO_DEG * geographic_lat ; \nif ( lonDegrees < - 180.0 ) { \nlonDegrees += 360.0 ; \n} \nif ( lonDegrees > 180.0 ) { \nlonDegrees -= 360.0 ; \n} \nreturn new double [ ] { \nlonDegrees , latDegrees } \n; \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nnvars . add ( new PointObVar ( v ) ) ; \n} \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) { \nnvars . add ( new PointObVar ( v ) ) ; \n} \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) { \ndvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \n} \nelse if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4589": "public class CFPointObWriter { \npublic static boolean rewritePointFeatureDataset ( String fileIn , String fileOut , boolean inMemory ) throws IOException { \nSystem . out . println ( \"Rewrite2 .nc files from \" + fileIn + \" to \" + fileOut + \" inMemory= \" + inMemory ) ; \nlong start = System . currentTimeMillis ( ) ; \nNetcdfFile ncfile = inMemory ? NetcdfFile . openInMemory ( fileIn ) : NetcdfFile . open ( fileIn ) ; \nNetcdfDataset ncd = new NetcdfDataset ( ncfile ) ; \nFormatter errlog = new Formatter ( ) ; \nFeatureDataset fd = FeatureDatasetFactoryManager . wrap ( FeatureType . ANY_POINT , ncd , null , errlog ) ; \nif ( fd == null ) { \nreturn false ; \n} \nif ( fd instanceof FeatureDatasetPoint ) { \nwritePointFeatureCollection ( ( FeatureDatasetPoint ) fd , fileOut ) ; \nfd . close ( ) ; \nlong took = System . currentTimeMillis ( ) - start ; \nSystem . out . println ( \" that took \" + ( took - start ) + \" msecs\" ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4590": "public class StructureData { \npublic ArraySequence getArraySequence ( String memberName ) { \nStructureMembers . Member m = members . findMember ( memberName ) ; \nif ( m == null ) { \nthrow new IllegalArgumentException ( \"illegal member name =\" + memberName ) ; \n} \nreturn getArraySequence ( m ) ; \n} \n} \n"}
{"4592": "public class InvDataset { \npublic String getUniqueID ( ) { \nString authority = getAuthority ( ) ; \nif ( ( authority != null ) && ( getID ( ) != null ) ) { \nreturn authority + \":\" + getID ( ) ; \n} \nelse if ( getID ( ) != null ) { \nreturn getID ( ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"4593": "public class InvDataset { \npublic InvAccess getAccess ( thredds . catalog . ServiceType type ) { \nfor ( InvAccess a : getAccess ( ) ) { \nInvService s = a . getService ( ) ; \nif ( s . getServiceType ( ) == type ) { \nreturn a ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4594": "public class InvDataset { \npublic InvDatasetImpl findDatasetByName ( String name ) { \nfor ( InvDataset ds : getDatasets ( ) ) { \nif ( ds . getName ( ) . equals ( name ) ) { \nreturn ( InvDatasetImpl ) ds ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4595": "public class InvDataset { \npublic InvCatalog getParentCatalog ( ) { \nif ( catalog != null ) { \nreturn catalog ; \n} \nreturn ( parent != null ) ? parent . getParentCatalog ( ) : null ; \n} \n} \n"}
{"4596": "public class InvDataset { \npublic java . util . List < InvMetadata > getMetadata ( thredds . catalog . MetadataType want ) { \nList < InvMetadata > result = new ArrayList < InvMetadata > ( ) ; \nfor ( InvMetadata m : getMetadata ( ) ) { \nMetadataType mtype = MetadataType . getType ( m . getMetadataType ( ) ) ; \nif ( mtype == want ) { \nresult . add ( m ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4597": "public class InvDataset { \npublic InvService findService ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nfor ( InvService p : services ) { \nif ( p . getName ( ) . equals ( name ) ) { \nreturn p ; \n} \n} \nif ( parent != null ) { \nreturn parent . findService ( name ) ; \n} \nreturn ( catalog == null ) ? null : catalog . findService ( name ) ; \n} \n} \n"}
{"4598": "public class InvDataset { \npublic ThreddsMetadata . Variables getVariables ( String vocab ) { \nThreddsMetadata . Variables result = new ThreddsMetadata . Variables ( vocab , null , null , null , null ) ; \nif ( variables == null ) { \nreturn result ; \n} \nfor ( ThreddsMetadata . Variables vs : variables ) { \nif ( vs . getVocabulary ( ) . equals ( vocab ) ) { \nresult . getVariableList ( ) . addAll ( vs . getVariableList ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4599": "public class CatalogUtils { \npublic static List < InvCatalogRef > findAllCatRefsInDatasetTree ( List < InvDataset > datasets , StringBuilder log , boolean onlyRelativeUrls ) { \nList < InvCatalogRef > catRefList = new ArrayList < InvCatalogRef > ( ) ; \nfor ( InvDataset invds : datasets ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invds ; \nif ( curDs instanceof InvDatasetScan ) { \ncontinue ; \n} \nif ( curDs instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) curDs ; \nString name = catRef . getName ( ) ; \nString href = catRef . getXlinkHref ( ) ; \nURI uri ; \ntry { \nuri = new URI ( href ) ; \n} \ncatch ( URISyntaxException e ) { \nlog . append ( log . length ( ) > 0 ? \"\\n\" : \"\" ) . append ( \"***WARN - CatalogRef [\" ) . append ( name ) . append ( \"] with bad HREF [\" ) . append ( href ) . append ( \"] \" ) ; \ncontinue ; \n} \nif ( onlyRelativeUrls && uri . isAbsolute ( ) ) { \ncontinue ; \n} \ncatRefList . add ( catRef ) ; \ncontinue ; \n} \nif ( curDs . hasNestedDatasets ( ) ) { \ncatRefList . addAll ( findAllCatRefsInDatasetTree ( curDs . getDatasets ( ) , log , onlyRelativeUrls ) ) ; \n} \n} \nreturn catRefList ; \n} \n} \n"}
{"4611": "public class CeParser { \nprivate int yy_lr_goto_state_ ( int yystate , int yysym ) { \nint yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; \nif ( 0 <= yyr && yyr <= yylast_ && yycheck_ [ yyr ] == yystate ) { \nreturn yytable_ [ yyr ] ; \n} \nelse { \nreturn yydefgoto_ [ yysym - yyntokens_ ] ; \n} \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = yyn < 0 ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nint count = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) { \nif ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \n++ count ; \n} \n} \nif ( count < 5 ) { \ncount = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) { \nif ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) { \nreturn ; \n} \nint yylno = yyrline_ [ yyrule ] ; \nint yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \nfor ( int yyi = 0 ; \nyyi < yynrhs ; \nyyi ++ ) { \nyy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \n} \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) { \nthrow new DapException ( \"Attempt to read DMR twice\" ) ; \n} \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nwhile ( ( c = input . read ( ) ) >= 0 ) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse if ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) { \nthrow new DapException ( \"Malformed chunk count\" ) ; \n} \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) { \nthrow new DapException ( \"Short chunk\" ) ; \n} \n} \nelse { \nassert false : \"Internal error\" ; \n} \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse if ( dmr . endsWith ( \"\\n\" ) ) { \ndmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \n} \nelse { \ndmr = dmr + \"\\r\\n\" ; \n} \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nstate = State . ERROR ; \n} \nelse if ( ( flags & DapUtil . CHUNK_END ) != 0 ) { \nstate = State . END ; \n} \nelse { \nstate = State . DATA ; \n} \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4615": "public class ChunkInputStream { \npublic String readError ( ) throws IOException { \nstate = State . ERROR ; \nbyte [ ] bytes = new byte [ this . chunksize ] ; \ntry { \nif ( read ( bytes , 0 , this . chunksize ) < this . chunksize ) { \nthrow new ErrorException ( \"Short chunk\" ) ; \n} \n} \ncatch ( IOException ioe ) { \nthrow new ErrorException ( ioe ) ; \n} \nString document = new String ( bytes , DapUtil . UTF8 ) ; \nreturn document ; \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nif ( off >= buf . length || buf . length < ( off + len ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nif ( requestmode == RequestMode . DMR ) { \nthrow new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \n} \nint count = len ; \nint pos = off ; \nwhile ( count > 0 ) { \nif ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) { \nreturn ( len - count ) ; \n} \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) { \nthrow new IOException ( \"Unexpected EOF\" ) ; \n} \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4617": "public class ChunkInputStream { \nboolean readHeader ( InputStream input ) throws IOException { \nbyte [ ] bytehdr = new byte [ 4 ] ; \nint red = input . read ( bytehdr ) ; \nif ( red == - 1 ) { \nreturn false ; \n} \nif ( red < 4 ) { \nthrow new IOException ( \"Short binary chunk count\" ) ; \n} \nthis . flags = ( ( int ) bytehdr [ 0 ] ) & 0xFF ; \nbytehdr [ 0 ] = 0 ; \nByteBuffer buf = ByteBuffer . wrap ( bytehdr ) . order ( ByteOrder . BIG_ENDIAN ) ; \nthis . chunksize = buf . getInt ( ) ; \nthis . avail = this . chunksize ; \nreturn true ; \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( replace || ( null == targetV ) ) { \nif ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) { \nv = new StructureDS ( targetGroup , ( Structure ) v ) ; \n} \nelse if ( ! ( v instanceof VariableDS ) ) { \nv = new VariableDS ( targetGroup , v , false ) ; \n} \nif ( null != targetV ) { \ntargetGroup . remove ( targetV ) ; \n} \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \nelse if ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) { \ntargetVe . setOriginalVariable ( v ) ; \n} \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \n} \n} \n"}
{"4621": "public class IgraPor { \nprivate File getStnFile ( String location ) { \nFile file = new File ( location ) ; \nFile stnFile = new File ( file . getParentFile ( ) , STN_FILE ) ; \nif ( ! stnFile . exists ( ) ) { \nif ( file . getParentFile ( ) == null ) { \nreturn null ; \n} \nstnFile = new File ( file . getParentFile ( ) . getParentFile ( ) , STN_FILE ) ; \nif ( ! stnFile . exists ( ) ) { \nreturn null ; \n} \n} \nreturn stnFile ; \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nint pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) { \nthrow new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \n} \nif ( ext . equals ( IDX_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \n} \nelse if ( ext . equals ( DAT_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) { \nthrow new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \n} \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \n} \n} \n"}
{"4625": "public class GribCollectionBuilder { \nprivate boolean createAllRuntimeCollections ( Formatter errlog ) throws IOException { \nlong start = System . currentTimeMillis ( ) ; \nthis . type = GribCollectionImmutable . Type . SRC ; \nboolean ok = true ; \nList < MFile > files = new ArrayList < > ( ) ; \nList < ? extends Group > groups = makeGroups ( files , true , errlog ) ; \nList < MFile > allFiles = Collections . unmodifiableList ( files ) ; \nMap < Long , List < Group > > runGroups = new HashMap < > ( ) ; \nfor ( Group g : groups ) { \nList < Group > runGroup = runGroups . computeIfAbsent ( g . getRuntime ( ) . getMillis ( ) , k -> new ArrayList < > ( ) ) ; \nrunGroup . add ( g ) ; \n} \nboolean multipleRuntimes = runGroups . values ( ) . size ( ) > 1 ; \nList < MFile > partitions = new ArrayList < > ( ) ; \nfor ( List < Group > runGroupList : runGroups . values ( ) ) { \nGroup g = runGroupList . get ( 0 ) ; \nString gcname = multipleRuntimes ? GribCollectionMutable . makeName ( this . name , g . getRuntime ( ) ) : this . name ; \nMFile indexFileForRuntime = GribCollectionMutable . makeIndexMFile ( gcname , directory ) ; \npartitions . add ( indexFileForRuntime ) ; \nList < Long > runtimes = new ArrayList < > ( 1 ) ; \nruntimes . add ( g . getRuntime ( ) . getMillis ( ) ) ; \nCoordinateRuntime masterRuntimes = new CoordinateRuntime ( runtimes , null ) ; \nCalendarDateRange calendarDateRangeAll = null ; \nfor ( Coordinate coord : g . getCoordinates ( ) ) { \nif ( coord instanceof CoordinateTimeAbstract ) { \nCalendarDateRange calendarDateRange = ( ( CoordinateTimeAbstract ) coord ) . makeCalendarDateRange ( null ) ; \nif ( calendarDateRangeAll == null ) { \ncalendarDateRangeAll = calendarDateRange ; \n} \nelse { \ncalendarDateRangeAll = calendarDateRangeAll . extend ( calendarDateRange ) ; \n} \n} \n} \nassert calendarDateRangeAll != null ; \nok &= writeIndex ( gcname , indexFileForRuntime . getPath ( ) , masterRuntimes , runGroupList , allFiles , calendarDateRangeAll ) ; \nlogger . info ( \"GribCollectionBuilder write {} ok={}\" , indexFileForRuntime . getPath ( ) , ok ) ; \n} \nif ( multipleRuntimes ) { \nCollections . sort ( partitions ) ; \nPartitionManager part = new PartitionManagerFromIndexList ( dcm , partitions , logger ) ; \npart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , dcm . getAuxInfo ( FeatureCollectionConfig . AUX_CONFIG ) ) ; \nok &= GribCdmIndex . updateGribCollectionFromPCollection ( isGrib1 , part , CollectionUpdateType . always , errlog , logger ) ; \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . debug ( \"That took {} msecs\" , took ) ; \nreturn ok ; \n} \n} \n"}
{"4626": "public class DurationField { \nprotected void setEditValue ( Object value ) { \nif ( value == null ) { \ntf . setText ( \"\" ) ; \n} \nelse { \ntf . setText ( value . toString ( ) ) ; \n} \n} \n} \n"}
{"4629": "public class Util { \npublic static String cleanUnit ( String unit ) { \nif ( unit == null ) { \nreturn null ; \n} \nif ( unit . equalsIgnoreCase ( \"Proportion\" ) || unit . equalsIgnoreCase ( \"Numeric\" ) ) { \nunit = \"\" ; \n} \nelse if ( unit . equalsIgnoreCase ( \"-\" ) ) { \nunit = \"\" ; \n} \nelse if ( unit . startsWith ( \"degree\" ) && unit . endsWith ( \"true\" ) ) { \nunit = unit . replace ( ' ' , '_' ) ; \n} \nelse if ( ! unit . contains ( \" table \" ) ) { \nif ( unit . startsWith ( \"/\" ) ) { \nunit = \"1\" + unit ; \n} \nunit = unit . trim ( ) ; \nunit = StringUtil2 . remove ( unit , \"**\" ) ; \nStringBuilder sb = new StringBuilder ( unit ) ; \nStringUtil2 . remove ( sb , \"^[]\" ) ; \nStringUtil2 . replace ( sb , ' ' , \".\" ) ; \nStringUtil2 . replace ( sb , '*' , \".\" ) ; \nunit = sb . toString ( ) ; \n} \nreturn unit ; \n} \n} \n"}
{"4630": "public class Util { \npublic static String cleanName ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nint pos = name . indexOf ( \"(see\" ) ; \nif ( pos < 0 ) { \npos = name . indexOf ( \"(See\" ) ; \n} \nif ( pos > 0 ) { \nname = name . substring ( 0 , pos ) ; \n} \nname = StringUtil2 . replace ( name , '/' , \"-\" ) ; \nStringBuilder sb = new StringBuilder ( name ) ; \nStringUtil2 . replace ( sb , '+' , \"plus\" ) ; \nStringUtil2 . remove ( sb , \".;,=[]()/*\\\"\" ) ; \nreturn StringUtil2 . collapseWhitespace ( sb . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4631": "public class Util { \npublic static boolean isUnitless ( String unit ) { \nif ( unit == null ) { \nreturn true ; \n} \nString munge = unit . toLowerCase ( ) . trim ( ) ; \nmunge = StringUtil2 . remove ( munge , '(' ) ; \nreturn munge . length ( ) == 0 || munge . startsWith ( \"numeric\" ) || munge . startsWith ( \"non-dim\" ) || munge . startsWith ( \"see\" ) || munge . startsWith ( \"proportion\" ) || munge . startsWith ( \"code\" ) || munge . startsWith ( \"0=\" ) || munge . equals ( \"1\" ) ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) { \nSystem . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \n} \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4635": "public class DodsV { \nDodsV findDodsV ( String name , boolean useDone ) { \nfor ( DodsV dodsV : children ) { \nif ( useDone && dodsV . isDone ) { \ncontinue ; \n} \nif ( ( name == null ) || ( dodsV == null ) || ( dodsV . bt == null ) ) { \nlogger . warn ( \"Corrupted structure\" ) ; \ncontinue ; \n} \nif ( name . equals ( dodsV . bt . getEncodedName ( ) ) ) { \nreturn dodsV ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4636": "public class DodsV { \nDodsV findDataV ( DodsV ddsV ) { \nif ( ddsV . parent . bt != null ) { \nDodsV parentV = findDataV ( ddsV . parent ) ; \nif ( parentV == null ) { \nreturn findDodsV ( ddsV . bt . getEncodedName ( ) , true ) ; \n} \nreturn parentV . findDodsV ( ddsV . bt . getEncodedName ( ) , true ) ; \n} \nDodsV dataV = findDodsV ( ddsV . bt . getEncodedName ( ) , true ) ; \nreturn dataV ; \n} \n} \n"}
{"4637": "public class DodsV { \nDodsV findByIndex ( int index ) { \nif ( children . size ( ) <= index ) { \nreturn null ; \n} \nreturn children . get ( index ) ; \n} \n} \n"}
{"4639": "public class Variable { \npublic Dimension getDimension ( int i ) { \nif ( ( i < 0 ) || ( i >= getRank ( ) ) ) { \nreturn null ; \n} \nreturn dimensions . get ( i ) ; \n} \n} \n"}
{"4640": "public class Variable { \npublic int findDimensionIndex ( String name ) { \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( name . equals ( d . getShortName ( ) ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4641": "public class Variable { \npublic String getUnitsString ( ) { \nString units = null ; \nAttribute att = findAttribute ( CDM . UNITS ) ; \nif ( att == null ) { \natt = findAttributeIgnoreCase ( CDM . UNITS ) ; \n} \nif ( ( att != null ) && att . isString ( ) ) { \nunits = att . getStringValue ( ) ; \nif ( units != null ) { \nunits = units . trim ( ) ; \n} \n} \nreturn units ; \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) { \ntry { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nint len = d . getLength ( ) ; \nif ( len > 0 ) { \nlist . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \n} \nelse if ( len == 0 ) { \nlist . add ( Range . EMPTY ) ; \n} \nelse { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4643": "public class Variable { \npublic Variable slice ( int dim , int value ) throws InvalidRangeException { \nif ( ( dim < 0 ) || ( dim >= shape . length ) ) { \nthrow new InvalidRangeException ( \"Slice dim invalid= \" + dim ) ; \n} \nboolean recordSliceOk = false ; \nif ( ( dim == 0 ) && ( value == 0 ) ) { \nDimension d = getDimension ( 0 ) ; \nrecordSliceOk = d . isUnlimited ( ) ; \n} \nif ( ! recordSliceOk ) { \nif ( ( value < 0 ) || ( value >= shape [ dim ] ) ) { \nthrow new InvalidRangeException ( \"Slice value invalid= \" + value + \" for dimension \" + dim ) ; \n} \n} \nVariable sliceV = copy ( ) ; \nSection slice = new Section ( getShapeAsSection ( ) ) ; \nslice . replaceRange ( dim , new Range ( value , value ) ) . makeImmutable ( ) ; \nsliceV . setProxyReader ( new SliceReader ( this , dim , slice ) ) ; \nsliceV . createNewCache ( ) ; \nsliceV . setCaching ( false ) ; \nsliceV . dimensions . remove ( dim ) ; \nsliceV . resetShape ( ) ; \nreturn sliceV ; \n} \n} \n"}
{"4644": "public class Variable { \npublic void setEnumTypedef ( EnumTypedef enumTypedef ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( ! dataType . isEnum ( ) ) { \nthrow new UnsupportedOperationException ( \"Can only call Variable.setEnumTypedef() on enum types\" ) ; \n} \nthis . enumTypedef = enumTypedef ; \n} \n} \n"}
{"4645": "public class Variable { \npublic Array read ( List < Range > ranges ) throws IOException , InvalidRangeException { \nif ( null == ranges ) { \nreturn _read ( ) ; \n} \nreturn read ( new Section ( ranges ) ) ; \n} \n} \n"}
{"4646": "public class Variable { \npublic String readScalarString ( ) throws IOException { \nArray data = getScalarData ( ) ; \nif ( dataType == DataType . STRING ) { \nreturn ( String ) data . getObject ( Index . scalarIndexImmutable ) ; \n} \nelse if ( dataType == DataType . CHAR ) { \nArrayChar dataC = ( ArrayChar ) data ; \nreturn dataC . getString ( ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"readScalarString not STRING or CHAR \" + getFullName ( ) ) ; \n} \n} \n} \n"}
{"4647": "public class Variable { \nprotected Array _read ( ) throws IOException { \nif ( cache . data != null ) { \nif ( debugCaching ) { \nSystem . out . println ( \"got data from cache \" + getFullName ( ) ) ; \n} \nreturn cache . data . copy ( ) ; \n} \nArray data = proxyReader . reallyRead ( this , null ) ; \nif ( isCaching ( ) ) { \nsetCachedData ( data ) ; \nif ( debugCaching ) { \nSystem . out . println ( \"cache \" + getFullName ( ) ) ; \n} \nreturn cache . data . copy ( ) ; \n} \nelse { \nreturn data ; \n} \n} \n} \n"}
{"4648": "public class Variable { \nprotected Array _read ( Section section ) throws IOException , InvalidRangeException { \nif ( ( null == section ) || section . computeSize ( ) == getSize ( ) ) { \nreturn _read ( ) ; \n} \nif ( isCaching ( ) ) { \nif ( cache . data == null ) { \nsetCachedData ( _read ( ) ) ; \nif ( debugCaching ) { \nSystem . out . println ( \"cache \" + getFullName ( ) ) ; \n} \n} \nif ( debugCaching ) { \nSystem . out . println ( \"got data from cache \" + getFullName ( ) ) ; \n} \nreturn cache . data . sectionNoReduce ( section . getRanges ( ) ) . copy ( ) ; \n} \nreturn proxyReader . reallyRead ( this , section , null ) ; \n} \n} \n"}
{"4650": "public class Variable { \npublic String toStringDebug ( ) { \nFormatter f = new Formatter ( ) ; \nf . format ( \"Variable %s\" , getFullName ( ) ) ; \nif ( ncfile != null ) { \nf . format ( \" in file %s\" , getDatasetLocation ( ) ) ; \nString extra = ncfile . toStringDebug ( this ) ; \nif ( extra != null ) { \nf . format ( \" %s\" , extra ) ; \n} \n} \nreturn f . toString ( ) ; \n} \n} \n"}
{"4651": "public class Variable { \npublic void setDataType ( DataType dataType ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nthis . dataType = dataType ; \nthis . elementSize = getDataType ( ) . getSize ( ) ; \n} \n} \n"}
{"4652": "public class Variable { \npublic void setDimensions ( List < Dimension > dims ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nthis . dimensions = ( dims == null ) ? new ArrayList < > ( ) : new ArrayList < > ( dims ) ; \nresetShape ( ) ; \n} \n} \n"}
{"4654": "public class Variable { \npublic void setDimensions ( String dimString ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \ntry { \nsetDimensions ( Dimension . makeDimensionsList ( getParentGroup ( ) , dimString ) ) ; \nresetShape ( ) ; \n} \ncatch ( IllegalStateException e ) { \nthrow new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" setDimensions = '\" + dimString + \"' FAILED: \" + e . getMessage ( ) + \" file = \" + getDatasetLocation ( ) ) ; \n} \n} \n} \n"}
{"4655": "public class Variable { \npublic void resetDimensions ( ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nArrayList < Dimension > newDimensions = new ArrayList < > ( ) ; \nfor ( Dimension dim : dimensions ) { \nif ( dim . isShared ( ) ) { \nDimension newD = getParentGroup ( ) . findDimension ( dim . getShortName ( ) ) ; \nif ( newD == null ) { \nthrow new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" resetDimensions  FAILED, dim doesnt exist in parent group=\" + dim ) ; \n} \nnewDimensions . add ( newD ) ; \n} \nelse { \nnewDimensions . add ( dim ) ; \n} \n} \nthis . dimensions = newDimensions ; \nresetShape ( ) ; \n} \n} \n"}
{"4656": "public class Variable { \npublic void setDimension ( int idx , Dimension dim ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \ndimensions . set ( idx , dim ) ; \nresetShape ( ) ; \n} \n} \n"}
{"4657": "public class Variable { \npublic void setCachedData ( Array cacheData , boolean isMetadata ) { \nif ( ( cacheData != null ) && ( cacheData . getElementType ( ) != getDataType ( ) . getPrimitiveClassType ( ) ) ) { \nthrow new IllegalArgumentException ( \"setCachedData type=\" + cacheData . getElementType ( ) + \" incompatible with variable type=\" + getDataType ( ) ) ; \n} \nthis . cache . data = cacheData ; \nthis . isMetadata = isMetadata ; \nthis . cache . cachingSet = true ; \nthis . cache . isCaching = true ; \n} \n} \n"}
{"4659": "public class AbstractRadialAdapter { \nprotected void setBoundingBox ( ) { \nLatLonRect largestBB = null ; \nfor ( Object o : csHash . values ( ) ) { \nRadialCoordSys sys = ( RadialCoordSys ) o ; \nsys . setOrigin ( origin ) ; \nLatLonRect bb = sys . getBoundingBox ( ) ; \nif ( largestBB == null ) { \nlargestBB = bb ; \n} \nelse if ( bb != null ) { \nlargestBB . extend ( bb ) ; \n} \n} \nboundingBox = largestBB ; \n} \n} \n"}
{"4660": "public class FmrInv { \nvoid finish ( ) { \ngridList = new ArrayList < > ( uvHash . values ( ) ) ; \nCollections . sort ( gridList ) ; \nfor ( GridVariable grid : gridList ) { \ngrid . finish ( ) ; \n} \nint seqno = 0 ; \nfor ( TimeCoord tc : timeCoords ) tc . setId ( seqno ++ ) ; \nHashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; \nfor ( VertCoord vc : vertCoords ) { \nList < VertCoord > list = map . get ( vc . getName ( ) ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \nmap . put ( vc . getName ( ) , list ) ; \n} \nlist . add ( vc ) ; \n} \nfor ( List < VertCoord > list : map . values ( ) ) { \nif ( list . size ( ) > 0 ) { \nint count = 0 ; \nfor ( VertCoord vc : list ) { \nif ( count > 0 ) { \nvc . setName ( vc . getName ( ) + count ) ; \n} \ncount ++ ; \n} \n} \n} \n} \n} \n"}
{"4662": "public class SynDSP { \npublic boolean dspMatch ( String path , DapContext context ) { \nfor ( String ext : SYNEXTENSIONS ) { \nif ( path . endsWith ( ext ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) { \nreturn ; \n} \ntry { \nif ( DUMPCDL ) { \nSystem . out . println ( \"writecdl:\" ) ; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nint index = name . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nname = name . substring ( index + 1 , name . length ( ) ) ; \n} \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null || cdmdims . size ( ) == 0 ) { \nreturn ; \n} \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( cdmdim . isShared ( ) ) { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) { \nthrow new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \n} \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nelse if ( cdmdim . isVariableLength ( ) ) { \ncontinue ; \n} \nelse { \ndapdim = builddim ( cdmdim ) ; \n} \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \n} \n} \n"}
{"4667": "public class CDMDSP { \nprotected EnumTypedef findMatchingEnum ( EnumTypedef varenum ) throws DapException { \nList < EnumTypedef > candidates = new ArrayList < > ( ) ; \nfor ( Map . Entry < DapNode , CDMNode > entry : this . nodemap . getCDMMap ( ) . entrySet ( ) ) { \nCDMNode cdmnode = entry . getValue ( ) ; \nif ( cdmnode . getSort ( ) != CDMSort . ENUMERATION ) { \ncontinue ; \n} \nEnumTypedef target = ( EnumTypedef ) cdmnode ; \nMap < Integer , String > targetmap = target . getMap ( ) ; \nMap < Integer , String > varmap = varenum . getMap ( ) ; \nif ( targetmap . size ( ) != varmap . size ( ) ) { \ncontinue ; \n} \nboolean match = true ; \nfor ( Map . Entry < Integer , String > tpair : targetmap . entrySet ( ) ) { \nString tname = tpair . getValue ( ) ; \nint value = ( int ) tpair . getKey ( ) ; \nboolean found = false ; \nfor ( Map . Entry < Integer , String > vpair : varmap . entrySet ( ) ) { \nif ( tname . equals ( vpair . getValue ( ) ) && value == ( int ) vpair . getKey ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nmatch = false ; \nbreak ; \n} \n} \nif ( ! match ) { \ncontinue ; \n} \nboolean shadowed = false ; \nfor ( EnumTypedef etd : candidates ) { \nif ( shadows ( etd . getGroup ( ) , target . getGroup ( ) ) ) { \nshadowed = true ; \nbreak ; \n} \n} \nif ( ! shadowed ) { \ncandidates . add ( target ) ; \n} \n} \nswitch ( candidates . size ( ) ) { \ncase 0 : throw new DapException ( \"CDMDSP: No matching enum type decl: \" + varenum . getShortName ( ) ) ; \ncase 1 : break ; \ndefault : throw new DapException ( \"CDMDSP: Multiple matching enum type decls: \" + varenum . getShortName ( ) ) ; \n} \nreturn candidates . get ( 0 ) ; \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) { \nreturn null ; \n} \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < dimset . size ( ) ; \ni ++ ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse { \ncore . add ( dimset . get ( i ) ) ; \n} \n} \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) { \nthrow new DapException ( \"Unsupported use of (*) Dimension\" ) ; \n} \nreturn core ; \n} \n} \n"}
{"4669": "public class BufrDataProcess { \npublic int scanBufrFile ( String filename , Counter total ) throws Exception { \nint count = 0 ; \ntry ( RandomAccessFile raf = new RandomAccessFile ( filename , \"r\" ) ) { \nMessageScanner scan = new MessageScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nMessage m = scan . next ( ) ; \nif ( m == null ) { \ncontinue ; \n} \ntry { \nif ( showMess ) { \nout . format ( \"%sMessage %d header=%s%n\" , indent , count , m . getHeader ( ) ) ; \n} \ncount ++ ; \nCounter counter = new Counter ( ) ; \nprocessBufrMessageAsDataset ( scan , m , counter ) ; \nif ( showMess ) { \nout . format ( \"%scount=%d miss=%d%n\" , indent , counter . nvals , counter . nmiss ) ; \n} \ntotal . add ( counter ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"  BARF:%s on %s%n\" , e . getMessage ( ) , m . getHeader ( ) ) ; \nindent . setIndentLevel ( 0 ) ; \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"4671": "public class CdmValidatorController { \npublic void doPost ( HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException { \nlog . info ( \"doPost(): \" + UsageLog . setupRequestContext ( req ) ) ; \nboolean isMultipart = ServletFileUpload . isMultipartContent ( req ) ; \nif ( ! isMultipart ) { \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nServletFileUpload upload = new ServletFileUpload ( this . cdmValidatorContext . getFileuploadFileItemFactory ( ) ) ; \nupload . setSizeMax ( this . cdmValidatorContext . getMaxFileUploadSize ( ) ) ; \nList < FileItem > fileItems ; \ntry { \nfileItems = ( List < FileItem > ) upload . parseRequest ( req ) ; \n} \ncatch ( FileUploadException e ) { \nlog . info ( \"doPost(): Validator FileUploadException\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nif ( ! res . isCommitted ( ) ) { \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \n} \nreturn ; \n} \nString username = null ; \nboolean wantXml = false ; \nfor ( FileItem item : fileItems ) { \nif ( item . isFormField ( ) ) { \nif ( \"username\" . equals ( item . getFieldName ( ) ) ) { \nusername = item . getString ( ) ; \n} \nif ( \"xml\" . equals ( item . getFieldName ( ) ) ) { \nwantXml = item . getString ( ) . equals ( \"true\" ) ; \n} \n} \n} \nfor ( FileItem item : fileItems ) { \nif ( ! item . isFormField ( ) ) { \ntry { \nprocessUploadedFile ( req , res , ( DiskFileItem ) item , username , wantXml ) ; \nreturn ; \n} \ncatch ( Exception e ) { \nlog . info ( \"doPost(): Validator processUploadedFile\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4674": "public class Navigation { \npublic ProjectionRect getMapArea ( ProjectionRect rect ) { \nif ( rect == null ) { \nrect = new ProjectionRect ( ) ; \n} \ndouble width = pwidth / pix_per_world ; \ndouble height = pheight / pix_per_world ; \ndouble wx0 = ( pwidth / 2 - pix_x0 ) / pix_per_world ; \ndouble wy0 = ( pix_y0 - pheight / 2 ) / pix_per_world ; \nrect . setRect ( wx0 - width / 2 , wy0 - height / 2 , width , height ) ; \nreturn rect ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) { \nSystem . out . println ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" ) ; \n} \nif ( ( width < 5 ) || ( height < 5 ) ) { \nreturn ; \n} \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4679": "public class ListenerManager { \npublic synchronized void addListener ( Object l ) { \nif ( ! listeners . contains ( l ) ) { \nlisteners . add ( l ) ; \nhasListeners = true ; \n} \nelse { \nlogger . warn ( \"ListenerManager.addListener already has Listener \" + l ) ; \n} \n} \n} \n"}
{"4680": "public class ListenerManager { \npublic synchronized void removeListener ( Object l ) { \nif ( listeners . contains ( l ) ) { \nlisteners . remove ( l ) ; \nhasListeners = ( listeners . size ( ) > 0 ) ; \n} \nelse { \nlogger . warn ( \"ListenerManager.removeListener couldnt find Listener \" + l ) ; \n} \n} \n} \n"}
{"4681": "public class ListenerManager { \npublic synchronized void sendEvent ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) { \nreturn ; \n} \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException e ) { \nlogger . error ( \"ListenerManager IllegalAccessException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlogger . error ( \"ListenerManager IllegalArgumentException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new RuntimeException ( e . getCause ( ) ) ; \n} \n} \n} \n} \n"}
{"4682": "public class ListenerManager { \npublic synchronized void sendEventExcludeSource ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) { \nreturn ; \n} \nObject source = event . getSource ( ) ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \nif ( client == source ) { \ncontinue ; \n} \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException | InvocationTargetException | IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \nif ( e . getCause ( ) != null ) { \ne . getCause ( ) . printStackTrace ( ) ; \n} \nlogger . error ( \"ListenerManager calling \" + method + \" threw exception \" , e ) ; \n} \n} \n} \n} \n"}
{"4683": "public class NCdumpW { \npublic static boolean print ( String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nString filename ; \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nif ( stoke . hasMoreTokens ( ) ) { \nfilename = stoke . nextToken ( ) ; \n} \nelse { \nout . write ( usage ) ; \nreturn false ; \n} \ntry ( NetcdfFile nc = NetcdfDataset . openFile ( filename , ct ) ) { \nint pos = command . indexOf ( filename ) ; \ncommand = command . substring ( pos + filename . length ( ) ) ; \nreturn print ( nc , command , out , ct ) ; \n} \ncatch ( java . io . FileNotFoundException e ) { \nout . write ( \"file not found= \" ) ; \nout . write ( filename ) ; \nreturn false ; \n} \nfinally { \nout . close ( ) ; \n} \n} \n} \n"}
{"4684": "public class NCdumpW { \npublic static boolean print ( NetcdfFile nc , String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nWantValues showValues = WantValues . none ; \nboolean ncml = false ; \nboolean strict = false ; \nString varNames = null ; \nString trueDataset = null ; \nString fakeDataset = null ; \nif ( command != null ) { \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString toke = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-help\" ) ) { \nout . write ( usage ) ; \nout . write ( '\\n' ) ; \nreturn true ; \n} \nif ( toke . equalsIgnoreCase ( \"-vall\" ) ) { \nshowValues = WantValues . all ; \n} \nif ( toke . equalsIgnoreCase ( \"-c\" ) && ( showValues == WantValues . none ) ) { \nshowValues = WantValues . coordsOnly ; \n} \nif ( toke . equalsIgnoreCase ( \"-ncml\" ) ) { \nncml = true ; \n} \nif ( toke . equalsIgnoreCase ( \"-cdl\" ) || toke . equalsIgnoreCase ( \"-strict\" ) ) { \nstrict = true ; \n} \nif ( toke . equalsIgnoreCase ( \"-v\" ) && stoke . hasMoreTokens ( ) ) { \nvarNames = stoke . nextToken ( ) ; \n} \nif ( toke . equalsIgnoreCase ( \"-datasetname\" ) && stoke . hasMoreTokens ( ) ) { \nfakeDataset = stoke . nextToken ( ) ; \nif ( fakeDataset . length ( ) == 0 ) { \nfakeDataset = null ; \n} \nif ( fakeDataset != null ) { \ntrueDataset = nc . getLocation ( ) ; \nnc . setLocation ( fakeDataset ) ; \n} \n} \n} \n} \nboolean ok = print ( nc , out , showValues , ncml , strict , varNames , ct ) ; \nif ( trueDataset != null && fakeDataset != null ) { \nnc . setLocation ( trueDataset ) ; \n} \nreturn ok ; \n} \n} \n"}
{"4691": "public class AbstractTransformBuilder { \nprotected double readAttributeDouble ( AttributeContainer v , String attname , double defValue ) { \nAttribute att = v . findAttributeIgnoreCase ( attname ) ; \nif ( att == null ) { \nreturn defValue ; \n} \nif ( att . isString ( ) ) { \nreturn Double . parseDouble ( att . getStringValue ( ) ) ; \n} \nelse { \nreturn att . getNumericValue ( ) . doubleValue ( ) ; \n} \n} \n} \n"}
{"4692": "public class AbstractTransformBuilder { \nprotected boolean addParameter ( CoordinateTransform rs , String paramName , NetcdfFile ds , String varNameEscaped ) { \nif ( null == ( ds . findVariable ( varNameEscaped ) ) ) { \nif ( null != errBuffer ) { \nerrBuffer . format ( \"CoordTransBuilder %s: no Variable named %s%n\" , getTransformName ( ) , varNameEscaped ) ; \n} \nreturn false ; \n} \nrs . addParameter ( new Parameter ( paramName , varNameEscaped ) ) ; \nreturn true ; \n} \n} \n"}
{"4694": "public class D4Cursor { \nprotected Object readAs ( DapVariable atomvar , DapType basetype , List < Slice > slices ) throws DapException { \nif ( basetype . getTypeSort ( ) == TypeSort . Enum ) { \nbasetype = ( ( DapEnumeration ) basetype ) . getBaseType ( ) ; \nreturn readAs ( atomvar , basetype , slices ) ; \n} \nlong count = DapUtil . sliceProduct ( slices ) ; \nObject result = LibTypeFcns . newVector ( basetype , count ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( DapUtil . isContiguous ( slices ) && basetype . isFixedSize ( ) ) { \nreadContig ( slices , basetype , count , odom , result ) ; \n} \nelse { \nreadOdom ( slices , basetype , odom , result ) ; \n} \nreturn result ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) { \nmethod . setCompression ( \"deflate,gzip\" ) ; \n} \nif ( allowSessions ) { \nmethod . setUseSessions ( true ) ; \n} \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) { \nbreak ; \n} \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) { \nSystem . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) { \nSystem . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \n} \nelse { \nif ( showCompress ) { \nSystem . out . printf ( \"none %s%n\" , urlString ) ; \n} \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) { \nreturn \"\" ; \n} \nif ( CE . startsWith ( \"?\" ) ) { \nCE = CE . substring ( 1 ) ; \n} \nint selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse if ( selIndex > 0 ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) { \nce += \",\" ; \n} \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) { \nce += \"&\" ; \n} \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) { \nce += \"&\" ; \n} \nce += localSelString ; \n} \nif ( ce . length ( ) > 0 ) { \nce = \"?\" + ce ; \n} \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4712": "public class Parse { \nstatic public String cleanCharacterData ( String text ) { \nif ( text == null ) { \nreturn null ; \n} \nboolean bad = false ; \nfor ( int i = 0 , len = text . length ( ) ; \ni < len ; \ni ++ ) { \nint ch = text . charAt ( i ) ; \nif ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nbad = true ; \nbreak ; \n} \n} \nif ( ! bad ) { \nreturn text ; \n} \nStringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; \nfor ( int i = 0 , len = text . length ( ) ; \ni < len ; \ni ++ ) { \nint ch = text . charAt ( i ) ; \nif ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nsbuff . append ( ( char ) ch ) ; \n} \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) { \nreturn null ; \n} \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4717": "public class Escape { \npublic static String backslashEncode ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nint c = buf . charAt ( i ) ; \nif ( _MustBackslashEscape . indexOf ( c ) >= 0 ) { \nbuf . append ( _BACKSLASHEscape ) ; \n} \nbuf . append ( ( char ) c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4729": "public class OceanS { \nprivate Array makeC ( Array s , double a , double b ) { \nint nz = ( int ) s . getSize ( ) ; \nIndex sIndex = s . getIndex ( ) ; \nif ( a == 0 ) { \nreturn s ; \n} \nArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; \ndouble fac1 = 1.0 - b ; \ndouble denom1 = 1.0 / Math . sinh ( a ) ; \ndouble denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; \nfor ( int i = 0 ; \ni < nz ; \ni ++ ) { \ndouble sz = s . getDouble ( sIndex . set ( i ) ) ; \ndouble term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; \ndouble term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; \nc . set ( i , term1 + term2 ) ; \n} \nreturn c ; \n} \n} \n"}
{"4738": "public class DiskCache2 { \npublic File getFile ( String fileLocation ) { \nif ( ! alwaysUseCache ) { \nFile f = new File ( fileLocation ) ; \nif ( f . exists ( ) ) { \nreturn f ; \n} \nif ( canWrite ( f ) ) { \nreturn f ; \n} \n} \nif ( neverUseCache ) { \nthrow new IllegalStateException ( \"neverUseCache=true, but file does not exist and directory is not writeable =\" + fileLocation ) ; \n} \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( cachePathPolicy == CachePathPolicy . NestedDirectory ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { \ncacheLog . warn ( \"Cant create directories for file \" + dir . getPath ( ) ) ; \n} \n} \nreturn f ; \n} \n} \n"}
{"4739": "public class DiskCache2 { \npublic File getExistingFileOrCache ( String fileLocation ) { \nFile f = new File ( fileLocation ) ; \nif ( f . exists ( ) ) { \nreturn f ; \n} \nif ( neverUseCache ) { \nreturn null ; \n} \nFile fc = new File ( makeCachePath ( fileLocation ) ) ; \nif ( fc . exists ( ) ) { \nreturn fc ; \n} \nreturn null ; \n} \n} \n"}
{"4740": "public class DiskCache2 { \npublic void showCache ( PrintStream pw ) { \npw . println ( \"Cache files\" ) ; \npw . println ( \"Size   LastModified       Filename\" ) ; \nFile dir = new File ( root ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nfor ( File file : files ) { \nString org = null ; \ntry { \norg = URLDecoder . decode ( file . getName ( ) , \"UTF8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \npw . println ( \" \" + file . length ( ) + \" \" + new Date ( file . lastModified ( ) ) + \" \" + org ) ; \n} \n} \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) { \ncacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \n} \nif ( sbuff != null ) { \nsbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \ncleanCache ( file , sbuff , false ) ; \n} \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) { \ncacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \n} \nif ( sbuff != null ) { \nsbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4751": "public class SourcePicture { \npublic void stopLoading ( ) { \nif ( imageUrl == null ) { \nreturn ; \n} \nTools . log ( \"SourcePicture.stopLoading: called on \" + imageUrl ) ; \nif ( pictureStatusCode == LOADING ) { \nreader . abort ( ) ; \nabortFlag = true ; \n} \n} \n} \n"}
{"4752": "public class SourcePicture { \npublic boolean stopLoadingExcept ( URL exemptionURL ) { \nif ( imageUrl == null ) { \nreturn false ; \n} \nif ( pictureStatusCode != LOADING ) { \nTools . log ( \"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \" + imageUrl . toString ( ) ) ; \nreturn false ; \n} \nif ( ! exemptionURL . toString ( ) . equals ( imageUrl . toString ( ) ) ) { \nTools . log ( \"SourcePicture.stopLoadingExcept: called with Url \" + exemptionURL . toString ( ) + \" --> stopping loading of \" + imageUrl . toString ( ) ) ; \nstopLoading ( ) ; \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"4753": "public class SourcePicture { \npublic Dimension getSize ( ) { \nif ( sourcePictureBufferedImage != null ) { \nreturn new Dimension ( sourcePictureBufferedImage . getWidth ( ) , sourcePictureBufferedImage . getHeight ( ) ) ; \n} \nelse { \nreturn new Dimension ( 0 , 0 ) ; \n} \n} \n} \n"}
{"4755": "public class Access { \npublic URI getStandardUri ( ) { \ntry { \nCatalog cat = dataset . getParentCatalog ( ) ; \nif ( cat == null ) { \nreturn new URI ( getUnresolvedUrlName ( ) ) ; \n} \nreturn cat . resolveUri ( getUnresolvedUrlName ( ) ) ; \n} \ncatch ( java . net . URISyntaxException e ) { \nthrow new RuntimeException ( \"Error parsing URL= \" + getUnresolvedUrlName ( ) ) ; \n} \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) { \nthrow new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \n} \nfor ( int i = 0 ; \ni < fromList . size ( ) ; \ni ++ ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) { \ntransferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \n} \n} \n} \n} \n"}
{"4759": "public class DataDescriptor { \npublic boolean equals2 ( Object o ) { \nif ( this == o ) { \nreturn true ; \n} \nif ( o == null || getClass ( ) != o . getClass ( ) ) { \nreturn false ; \n} \nDataDescriptor that = ( DataDescriptor ) o ; \nif ( fxy != that . fxy ) { \nreturn false ; \n} \nif ( replication != that . replication ) { \nreturn false ; \n} \nif ( type != that . type ) { \nreturn false ; \n} \nif ( subKeys != null ? ! subKeys . equals ( that . subKeys ) : that . subKeys != null ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) { \nreturn 0 ; \n} \nInputStream s = stream ; \nif ( s == null ) { \nreturn - 1 ; \n} \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) { \nreturn - 1 ; \n} \nif ( dataLoaded ) { \nreturn 0 ; \n} \nInputStream s = stream ; \nif ( s == null ) { \nreturn - 1 ; \n} \ntry { \nfor ( int i = 0 ; \ni < nrecords ; \ni ++ ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \nfor ( int j = 0 ; \nj < nfields ; \nj ++ ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \nelse { \nnrecords -- ; \ni -- ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) { \nif ( FieldDesc [ i ] . Name . equals ( Name ) ) { \nreturn data [ i ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) { \nreturn null ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( int i = 0 ; \ni < s . length ; \ni ++ ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( int i = 0 ; \ni < b . length ; \ni ++ ) { \nif ( b [ i ] ) { \ndd [ i ] = 1 ; \n} \nelse { \ndd [ i ] = 0 ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4764": "public class DbaseFile { \npublic String [ ] getStringsByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) { \nreturn null ; \n} \nif ( d . getType ( ) != DbaseData . TYPE_CHAR ) { \nreturn null ; \n} \nreturn d . getStrings ( ) ; \n} \n} \n"}
{"4765": "public class DbaseFile { \npublic boolean [ ] getBooleansByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) { \nreturn null ; \n} \nif ( d . getType ( ) != DbaseData . TYPE_BOOLEAN ) { \nreturn null ; \n} \nreturn d . getBooleans ( ) ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) { \nSystem . out . print ( \", \" ) ; \n} \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) { \nSystem . out . print ( \", \" ) ; \n} \nelse { \nSystem . out . println ( ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4769": "public class DapNode { \npublic Map < String , DapAttribute > getAttributes ( ) { \nif ( attributes == null ) { \nattributes = new HashMap < String , DapAttribute > ( ) ; \n} \nreturn attributes ; \n} \n} \n"}
{"4770": "public class DapNode { \nsynchronized public DapAttribute setAttribute ( DapAttribute attr ) throws DapException { \nif ( attributes == null ) { \nattributes = new HashMap < String , DapAttribute > ( ) ; \n} \nDapAttribute old = attributes . get ( attr . getShortName ( ) ) ; \nattributes . put ( attr . getShortName ( ) , attr ) ; \nattr . setParent ( this ) ; \nreturn old ; \n} \n} \n"}
{"4771": "public class DapNode { \npublic synchronized void removeAttribute ( DapAttribute attr ) throws DapException { \nif ( this . attributes == null ) { \nreturn ; \n} \nString name = attr . getShortName ( ) ; \nif ( this . attributes . containsKey ( name ) ) { \nthis . attributes . remove ( name ) ; \n} \n} \n} \n"}
{"4772": "public class DapNode { \npublic DapGroup getGroup ( ) { \nif ( this . sort == DapSort . DATASET ) { \nreturn null ; \n} \nDapNode group = parent ; \nwhile ( group != null ) { \nswitch ( group . getSort ( ) ) { \ncase DATASET : case GROUP : return ( DapGroup ) group ; \ndefault : group = group . getParent ( ) ; \nbreak ; \n} \n} \nreturn ( DapGroup ) group ; \n} \n} \n"}
{"4773": "public class DapNode { \npublic DapNode getContainer ( ) { \nDapNode parent = this . parent ; \nswitch ( getSort ( ) ) { \ndefault : break ; \ncase ENUMCONST : parent = ( ( DapEnumConst ) this ) . getParent ( ) . getContainer ( ) ; \nbreak ; \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : parent = ( ( DapAttribute ) this ) . getParent ( ) ; \nif ( parent instanceof DapVariable ) { \nparent = parent . getContainer ( ) ; \n} \nbreak ; \ncase MAP : parent = ( ( DapMap ) this ) . getVariable ( ) . getContainer ( ) ; \nbreak ; \n} \nreturn parent ; \n} \n} \n"}
{"4774": "public class DapNode { \npublic String getEscapedShortName ( ) { \nif ( this . escapedname == null ) { \nthis . escapedname = Escape . backslashEscape ( getShortName ( ) , null ) ; \n} \nreturn this . escapedname ; \n} \n} \n"}
{"4775": "public class DapNode { \npublic List < DapNode > getContainerPath ( ) { \nList < DapNode > path = new ArrayList < DapNode > ( ) ; \nDapNode current = this . getContainer ( ) ; \nfor ( ; \n; \n) { \npath . add ( 0 , current ) ; \nif ( current . getContainer ( ) == null ) { \nbreak ; \n} \ncurrent = current . getContainer ( ) ; \n} \nreturn path ; \n} \n} \n"}
{"4776": "public class DapNode { \npublic List < DapGroup > getGroupPath ( ) { \nList < DapGroup > path = new ArrayList < DapGroup > ( ) ; \nDapNode current = this ; \nfor ( ; \n; \n) { \nif ( current . getSort ( ) == DapSort . GROUP || current . getSort ( ) == DapSort . DATASET ) { \npath . add ( 0 , ( DapGroup ) current ) ; \n} \nif ( current . getContainer ( ) == null ) { \nbreak ; \n} \ncurrent = current . getContainer ( ) ; \n} \nreturn path ; \n} \n} \n"}
{"4780": "public class PreferencesExt { \npublic void putBeanCollection ( String key , Collection newValue ) { \nObject oldValue = getBean ( key , null ) ; \nif ( ( oldValue == null ) || ! oldValue . equals ( newValue ) ) { \nkeyValues . put ( key , new Bean . Collection ( newValue ) ) ; \n} \n} \n} \n"}
{"4782": "public class PreferencesExt { \nprivate Object _getObject ( String keyName ) { \nObject result = null ; \ntry { \nresult = keyValues . get ( keyName ) ; \nif ( result == null ) { \nPreferencesExt sd = getStoredDefaults ( ) ; \nif ( sd != null ) { \nresult = sd . getObjectFromNode ( absolutePath ( ) , keyName ) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nreturn result ; \n} \n} \n"}
{"4783": "public class Grib2Record { \npublic float [ ] readData ( RandomAccessFile raf , long drsPos ) throws IOException { \nraf . seek ( drsPos ) ; \nGrib2SectionDataRepresentation drs = new Grib2SectionDataRepresentation ( raf ) ; \nGrib2SectionBitMap bms = new Grib2SectionBitMap ( raf ) ; \nGrib2SectionData dataSection = new Grib2SectionData ( raf ) ; \nGrib2Gds gds = getGDS ( ) ; \nGrib2DataReader reader = new Grib2DataReader ( drs . getDataTemplate ( ) , gdss . getNumberPoints ( ) , drs . getDataPoints ( ) , getScanMode ( ) , gds . getNxRaw ( ) , dataSection . getStartingPosition ( ) , dataSection . getMsgLength ( ) ) ; \nGrib2Drs gdrs = drs . getDrs ( raf ) ; \nfloat [ ] data = reader . getData ( raf , bms , gdrs ) ; \nif ( gds . isThin ( ) ) { \ndata = QuasiRegular . convertQuasiGrid ( data , gds . getNptsInLine ( ) , gds . getNxRaw ( ) , gds . getNyRaw ( ) , GribData . getInterpolationMethod ( ) ) ; \n} \nlastRecordRead = this ; \nreturn data ; \n} \n} \n"}
{"4784": "public class DSPPrinter { \npublic DSPPrinter print ( ) throws DapException { \nDapDataset dmr = this . dsp . getDMR ( ) ; \nif ( this . ce == null ) { \nthis . ce = CEConstraint . getUniversal ( dmr ) ; \n} \nthis . printer . setIndent ( 0 ) ; \nList < DapVariable > topvars = dmr . getTopVariables ( ) ; \nfor ( int i = 0 ; \ni < topvars . size ( ) ; \ni ++ ) { \nDapVariable top = topvars . get ( i ) ; \nList < Slice > slices = this . ce . getConstrainedSlices ( top ) ; \nif ( this . ce . references ( top ) ) { \nDataCursor data = dsp . getVariableData ( top ) ; \nprintVariable ( data , slices ) ; \n} \n} \nprinter . eol ( ) ; \nreturn this ; \n} \n} \n"}
{"4790": "public class NcMLWriter { \npublic Element makeDimensionElement ( Dimension dim ) throws IllegalArgumentException { \nif ( ! dim . isShared ( ) ) { \nthrow new IllegalArgumentException ( \"Cannot create private dimension: \" + \"in NcML, <dimension> elements are always shared.\" ) ; \n} \nElement dimElem = new Element ( \"dimension\" , namespace ) ; \ndimElem . setAttribute ( \"name\" , dim . getShortName ( ) ) ; \ndimElem . setAttribute ( \"length\" , Integer . toString ( dim . getLength ( ) ) ) ; \nif ( dim . isUnlimited ( ) ) { \ndimElem . setAttribute ( \"isUnlimited\" , \"true\" ) ; \n} \nreturn dimElem ; \n} \n} \n"}
{"4800": "public class CoordAxisHelper { \nprivate Optional < CoverageCoordAxisBuilder > subsetValues ( double minValue , double maxValue , int stride ) { \nif ( axis . getSpacing ( ) == CoverageCoordAxis . Spacing . discontiguousInterval ) { \nreturn subsetValuesDiscontinuous ( minValue , maxValue , stride ) ; \n} \ndouble lower = axis . isAscending ( ) ? Math . min ( minValue , maxValue ) : Math . max ( minValue , maxValue ) ; \ndouble upper = axis . isAscending ( ) ? Math . max ( minValue , maxValue ) : Math . min ( minValue , maxValue ) ; \nint minIndex = findCoordElement ( lower , false ) ; \nint maxIndex = findCoordElement ( upper , false ) ; \nif ( minIndex >= axis . getNcoords ( ) ) { \nreturn Optional . empty ( String . format ( \"no points in subset: lower %f > end %f\" , lower , axis . getEndValue ( ) ) ) ; \n} \nif ( maxIndex < 0 ) { \nreturn Optional . empty ( String . format ( \"no points in subset: upper %f < start %f\" , upper , axis . getStartValue ( ) ) ) ; \n} \nif ( minIndex < 0 ) { \nminIndex = 0 ; \n} \nif ( maxIndex >= axis . getNcoords ( ) ) { \nmaxIndex = axis . getNcoords ( ) - 1 ; \n} \nint count = maxIndex - minIndex + 1 ; \nif ( count <= 0 ) { \nthrow new IllegalArgumentException ( \"no points in subset\" ) ; \n} \ntry { \nreturn Optional . of ( subsetByIndex ( new Range ( minIndex , maxIndex , stride ) ) ) ; \n} \ncatch ( InvalidRangeException e ) { \nreturn Optional . empty ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4805": "public class XURI { \npublic String assemble ( EnumSet < Parts > parts ) { \nStringBuilder uri = new StringBuilder ( ) ; \nint useformat = ( parts . contains ( Parts . FORMAT ) ? 1 : 0 ) ; \nint usebase = ( parts . contains ( Parts . BASE ) ? 2 : 0 ) ; \nswitch ( useformat + usebase ) { \ncase 0 + 0 : break ; \ncase 1 + 0 : uri . append ( this . formatprotocol + \":\" ) ; \nbreak ; \ncase 2 + 0 : uri . append ( this . baseprotocol + \":\" ) ; \nbreak ; \ncase 2 + 1 : uri . append ( this . formatprotocol + \":\" ) ; \nif ( ! this . baseprotocol . equals ( this . formatprotocol ) ) { \nuri . append ( this . formatprotocol + \":\" ) ; \n} \nbreak ; \n} \nuri . append ( this . baseprotocol . equals ( \"file\" ) ? \"/\" : \"//\" ) ; \nif ( userinfo != null && parts . contains ( Parts . PWD ) ) { \nuri . append ( this . userinfo + \":\" ) ; \n} \nif ( this . host != null && parts . contains ( Parts . HOST ) ) { \nuri . append ( this . host ) ; \n} \nif ( this . path != null && parts . contains ( Parts . PATH ) ) { \nuri . append ( this . path ) ; \n} \nif ( this . query != null && parts . contains ( Parts . QUERY ) ) { \nuri . append ( \"?\" + this . query ) ; \n} \nif ( this . frag != null && parts . contains ( Parts . FRAG ) ) { \nuri . append ( \"#\" + this . frag ) ; \n} \nreturn uri . toString ( ) ; \n} \n} \n"}
{"4806": "public class XURI { \nstatic public String canonical ( String s ) { \nif ( s != null ) { \ns = s . trim ( ) ; \nif ( s . length ( ) == 0 ) { \ns = null ; \n} \n} \nreturn s ; \n} \n} \n"}
{"4808": "public class Nc4DMRCompiler { \npublic DapDataset compile ( ) throws DapException { \nbuildrootgroup ( this . ncid ) ; \nif ( this . dmr != null ) { \ndmr . finish ( ) ; \n} \nreturn this . dmr ; \n} \n} \n"}
{"4809": "public class InvMetadata { \npublic void finish ( ) { \nif ( init ) { \nreturn ; \n} \ninit = true ; \nif ( xlinkHref == null ) { \nreturn ; \n} \nxlinkHref = xlinkHref . trim ( ) ; \ntry { \nthis . xlinkUri = dataset . getParentCatalog ( ) . resolveUri ( xlinkHref ) ; \n} \ncatch ( java . net . URISyntaxException e ) { \nlog . append ( \" ** Error: Bad URL in metadata href = \" ) . append ( xlinkHref ) . append ( \"\\n\" ) ; \nreturn ; \n} \ntry { \nif ( converter == null ) { \nlog . append ( \"  **InvMetadata on = (\" ) . append ( this ) . append ( \"): has no converter\\n\" ) ; \nreturn ; \n} \ncontentObject = converter . readMetadataContentFromURL ( dataset , xlinkUri ) ; \nif ( isThreddsMetadata ) { \ntm = ( ThreddsMetadata ) contentObject ; \n} \n} \ncatch ( java . io . IOException e ) { \nlog . append ( \"  **InvMetadata on = (\" ) . append ( xlinkUri ) . append ( \"): Exception (\" ) . append ( e . getMessage ( ) ) . append ( \")\\n\" ) ; \n} \n} \n} \n"}
{"4810": "public class SortedTable { \npublic synchronized Object get ( Object key ) { \nint index = keys . indexOf ( key ) ; \nif ( index != - 1 ) { \nreturn elements . elementAt ( index ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"4811": "public class SortedTable { \npublic synchronized Object put ( Object key , Object value ) throws NullPointerException { \nif ( key == null || value == null ) { \nthrow new NullPointerException ( ) ; \n} \nint index = keys . indexOf ( key ) ; \nif ( index != - 1 ) { \nObject prev = elements . elementAt ( index ) ; \nelements . setElementAt ( value , index ) ; \nreturn prev ; \n} \nelse { \nkeys . addElement ( key ) ; \nelements . addElement ( value ) ; \nreturn null ; \n} \n} \n} \n"}
{"4813": "public class DMRPrinter { \nvoid printXMLAttributes ( DapNode node , CEConstraint ce , int flags ) throws IOException { \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . indent ( 2 ) ; \n} \nString name = node . getShortName ( ) ; \nif ( name != null && ( flags & NONAME ) == 0 ) { \nname = node . getShortName ( ) ; \nprintXMLAttribute ( \"name\" , name , flags ) ; \n} \nswitch ( node . getSort ( ) ) { \ncase DATASET : DapDataset dataset = ( DapDataset ) node ; \nprintXMLAttribute ( \"dapVersion\" , dataset . getDapVersion ( ) , flags ) ; \nprintXMLAttribute ( \"dmrVersion\" , dataset . getDMRVersion ( ) , flags ) ; \nprintXMLAttribute ( \"xmlns\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nprintXMLAttribute ( \"xmlns:dap\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nbreak ; \ncase DIMENSION : DapDimension orig = ( DapDimension ) node ; \nif ( orig . isShared ( ) ) { \nDapDimension actual = this . ce . getRedefDim ( orig ) ; \nif ( actual == null ) { \nactual = orig ; \n} \nlong size = actual . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , flags ) ; \n} \nbreak ; \ncase ENUMERATION : printXMLAttribute ( \"basetype\" , ( ( DapEnumeration ) node ) . getBaseType ( ) . getTypeName ( ) , flags ) ; \nbreak ; \ncase VARIABLE : DapVariable var = ( DapVariable ) node ; \nDapType basetype = var . getBaseType ( ) ; \nif ( basetype . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ncase ATTRIBUTE : DapAttribute attr = ( DapAttribute ) node ; \nbasetype = attr . getBaseType ( ) ; \nprintXMLAttribute ( \"type\" , basetype . getTypeName ( ) , flags ) ; \nif ( attr . getBaseType ( ) . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ndefault : break ; \n} \nif ( ! this . testing ) { \nprintReserved ( node ) ; \n} \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . outdent ( 2 ) ; \n} \n} \n} \n"}
{"4814": "public class DMRPrinter { \nprotected void printXMLAttribute ( String name , String value , int flags ) throws DapException { \nif ( name == null ) { \nreturn ; \n} \nif ( ( flags & NONNIL ) == 0 && ( value == null || value . length ( ) == 0 ) ) { \nreturn ; \n} \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . eol ( ) ; \nprinter . margin ( ) ; \n} \nprinter . print ( \" \" + name + \"=\" ) ; \nprinter . print ( \"\\\"\" ) ; \nif ( value != null ) { \nif ( ( flags & XMLESCAPED ) == 0 ) { \nvalue = Escape . entityEscape ( value , \"\\\"\" ) ; \n} \nprinter . print ( value ) ; \n} \nprinter . print ( \"\\\"\" ) ; \n} \n} \n"}
{"4815": "public class DMRPrinter { \nstatic boolean isSpecial ( DapAttribute attr ) { \nif ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) { \nfor ( String s : GROUPSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) { \nreturn true ; \n} \n} \n} \nelse if ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) { \nfor ( String s : VARSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) { \nreturn ; \n} \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) { \nthrow new DapException ( \"Unknown variable: \" + var ) ; \n} \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \ni < var . getRank ( ) ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \n} \n} \n"}
{"4817": "public class AreaReader { \npublic static boolean isValidFile ( RandomAccessFile raf ) { \nString fileName = raf . getLocation ( ) ; \nAreaFile af = null ; \ntry { \naf = new AreaFile ( fileName ) ; \nreturn true ; \n} \ncatch ( AreaFileException e ) { \nreturn false ; \n} \nfinally { \nif ( af != null ) { \naf . close ( ) ; \n} \n} \n} \n} \n"}
{"4822": "public class CoordSysEvaluator { \nstatic public void findCoords ( TableConfig nt , NetcdfDataset ds , Predicate p ) { \nnt . lat = findCoordShortNameByType ( ds , AxisType . Lat , p ) ; \nnt . lon = findCoordShortNameByType ( ds , AxisType . Lon , p ) ; \nnt . time = findCoordShortNameByType ( ds , AxisType . Time , p ) ; \nnt . elev = findCoordShortNameByType ( ds , AxisType . Height , p ) ; \nif ( nt . elev == null ) { \nnt . elev = findCoordShortNameByType ( ds , AxisType . Pressure , p ) ; \n} \n} \n} \n"}
{"4825": "public class CoordSysEvaluator { \nstatic public CoordinateAxis findCoordByType ( NetcdfDataset ds , AxisType atype , Predicate p ) { \nCoordinateSystem use = findBestCoordinateSystem ( ds ) ; \nif ( use == null ) { \nreturn null ; \n} \nCoordinateAxis result = findCoordByType ( use . getCoordinateAxes ( ) , atype , p ) ; \nif ( result != null ) { \nreturn result ; \n} \nreturn findCoordByType ( ds . getCoordinateAxes ( ) , atype , p ) ; \n} \n} \n"}
{"4826": "public class CoordSysEvaluator { \nstatic public Dimension findDimensionByType ( NetcdfDataset ds , AxisType atype ) { \nCoordinateAxis axis = findCoordByType ( ds , atype ) ; \nif ( axis == null ) { \nreturn null ; \n} \nif ( axis . isScalar ( ) ) { \nreturn null ; \n} \nreturn axis . getDimension ( 0 ) ; \n} \n} \n"}
{"4827": "public class CoordSysEvaluator { \nstatic private CoordinateSystem findBestCoordinateSystem ( NetcdfDataset ds ) { \nCoordinateSystem use = null ; \nfor ( CoordinateSystem cs : ds . getCoordinateSystems ( ) ) { \nif ( use == null ) { \nuse = cs ; \n} \nelse if ( cs . getCoordinateAxes ( ) . size ( ) > use . getCoordinateAxes ( ) . size ( ) ) { \nuse = cs ; \n} \n} \nreturn use ; \n} \n} \n"}
{"4828": "public class CoordsSet { \nprivate CoverageCoordAxis1D findDependent ( CoverageCoordAxis independentAxis , AxisType axisType ) { \nfor ( CoverageCoordAxis axis : axes ) { \nif ( axis . getDependenceType ( ) == CoverageCoordAxis . DependenceType . dependent ) { \nfor ( String axisName : axis . dependsOn ) { \nif ( axisName . equalsIgnoreCase ( independentAxis . getName ( ) ) && axis . getAxisType ( ) == axisType ) { \nreturn ( CoverageCoordAxis1D ) axis ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4829": "public class DSequence { \npublic BaseType getVariable ( int row , String name ) throws NoSuchVariableException { \nint dotIndex = name . indexOf ( '.' ) ; \nif ( dotIndex != - 1 ) { \nString aggregate = name . substring ( 0 , dotIndex ) ; \nString field = name . substring ( dotIndex + 1 ) ; \nBaseType aggRef = getVariable ( aggregate ) ; \nif ( aggRef instanceof DConstructor ) { \nreturn ( ( DConstructor ) aggRef ) . getVariable ( field ) ; \n} \nelse { \n; \n} \n} \nelse { \nVector selectedRow = ( Vector ) allValues . elementAt ( row ) ; \nfor ( Enumeration e = selectedRow . elements ( ) ; \ne . hasMoreElements ( ) ; \n) { \nBaseType v = ( BaseType ) e . nextElement ( ) ; \nif ( v . getEncodedName ( ) . equals ( name ) ) { \nreturn v ; \n} \n} \n} \nthrow new NoSuchVariableException ( \"DSequence: getVariable()\" ) ; \n} \n} \n"}
{"4831": "public class DSequence { \nprivate byte readMarker ( DataInputStream source ) throws IOException { \nbyte marker = source . readByte ( ) ; \nbyte unused ; \nfor ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nunused = source . readByte ( ) ; \n} \nreturn marker ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) { \nresult [ i ] = ( String ) data . getObject ( i ) ; \n} \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nresult [ count ++ ] = iter . next ( ) ; \n} \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nint paramCount = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni ++ ) { \nparamCount += myRADDs [ i ] . getNParams ( ) ; \n} \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nint next = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni ++ ) { \nint nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext += nParams ; \n} \nreturn list ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) { \nreturn ; \n} \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) { \ndrawBB ( gNP , geoSelection , Color . cyan ) ; \n} \nif ( geoBounds != null ) { \ndrawBB ( gNP , geoBounds , null ) ; \n} \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) { \nSystem . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4851": "public class Grib2RecordScanner { \n@ Nullable public static Grib2Record findRecordByDrspos ( RandomAccessFile raf , long drsPos ) throws IOException { \nlong pos = Math . max ( 0 , drsPos - ( 20 * 1000 ) ) ; \nGrib2RecordScanner scan = new Grib2RecordScanner ( raf , pos ) ; \nwhile ( scan . hasNext ( ) ) { \nucar . nc2 . grib . grib2 . Grib2Record gr = scan . next ( ) ; \nGrib2SectionDataRepresentation drs = gr . getDataRepresentationSection ( ) ; \nif ( drsPos == drs . getStartingPosition ( ) ) { \nreturn gr ; \n} \nif ( raf . getFilePointer ( ) > drsPos ) { \nbreak ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) { \nthrow new DescriptorException ( \"parameter name mismatch\" ) ; \n} \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) { \nvalues = workingArray ; \n} \nelse { \nvalues = new float [ nCells ] ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( int cell = 0 ; \ncell < nCells ; \ncell ++ ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4858": "public class ThreddsDataFactory { \npublic NetcdfDataset openDataset ( InvDataset invDataset , boolean acquire , ucar . nc2 . util . CancelTask task , Formatter log ) throws IOException { \nResult result = new Result ( ) ; \nNetcdfDataset ncd = openDataset ( invDataset , acquire , task , result ) ; \nif ( log != null ) { \nlog . format ( \"%s\" , result . errLog ) ; \n} \nreturn ( result . fatalError ) ? null : ncd ; \n} \n} \n"}
{"4860": "public class Property { \npublic static List < Property > removeDups ( List < Property > org ) { \nList < Property > result = new ArrayList < > ( org . size ( ) ) ; \nfor ( Property p : org ) if ( ! result . contains ( p ) ) { \nresult . add ( p ) ; \n} \nreturn result ; \n} \n} \n"}
{"4861": "public class VariableIndexPartitioned { \nvoid addPartition ( int partno , int groupno , int varno , int ndups , int nrecords , int nmissing , GribCollectionMutable . VariableIndex vi ) { \nif ( partList == null ) { \npartList = new ArrayList < > ( nparts ) ; \n} \npartList . add ( new PartitionForVariable2D ( partno , groupno , varno ) ) ; \nthis . ndups += ndups ; \nthis . nrecords += nrecords ; \nthis . nmissing += nmissing ; \n} \n} \n"}
{"4862": "public class Partition { \n@ Nullable public GribCollectionMutable makeGribCollection ( ) { \nGribCollectionMutable result = GribCdmIndex . openMutableGCFromIndex ( dcm . getIndexFilename ( GribCdmIndex . NCX_SUFFIX ) , config , false , true , logger ) ; \nif ( result == null ) { \nlogger . error ( \"Failed on openMutableGCFromIndex {}\" , dcm . getIndexFilename ( GribCdmIndex . NCX_SUFFIX ) ) ; \nreturn null ; \n} \nlastModified = result . lastModified ; \nfileSize = result . fileSize ; \nif ( result . masterRuntime != null ) { \npartitionDate = result . masterRuntime . getFirstDate ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"4868": "public class PicturePane { \npublic void setBufferedImage ( BufferedImage img , String statusMessage ) { \nlegend = statusMessage ; \ncenterWhenScaled = true ; \nDimension dim = getSize ( ) ; \nsclPic . setScaleSize ( dim ) ; \nSourcePicture source = new SourcePicture ( ) ; \nsource . setSourceBufferedImage ( img , statusMessage ) ; \nsclPic . setSourcePicture ( source ) ; \nif ( ! scaleToFit ) { \nsclPic . setScaleFactor ( 1.0 ) ; \n} \nsclPic . scalePicture ( ) ; \nrepaint ( ) ; \n} \n} \n"}
{"4879": "public class DataDDS { \npublic void readData ( InputStream is , StatusUI statusUI ) throws IOException , EOFException , DAP2Exception { \nBufferedInputStream bufferedIS = new BufferedInputStream ( is ) ; \nDataInputStream dataIS = new DataInputStream ( bufferedIS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nif ( statusUI != null && statusUI . userCancelled ( ) ) { \nthrow new DataReadException ( \"User cancelled\" ) ; \n} \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . deserialize ( dataIS , ver , statusUI ) ; \n} \nif ( statusUI != null ) { \nstatusUI . finished ( ) ; \n} \n} \n} \n"}
{"4881": "public class TagEnum { \npublic static TagEnum getTag ( short code ) { \nTagEnum te = hash . get ( code ) ; \nif ( te == null ) { \nte = new TagEnum ( \"UNKNOWN\" , \"UNKNOWN\" , code ) ; \n} \nreturn te ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) { \nthis . time = 0 ; \n} \n} \nelse { \nthis . time -- ; \nif ( this . time < 0 ) { \nthis . time = this . ntimes - 1 ; \n} \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) { \nreturn null ; \n} \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ni < currentDirFileList . size ( ) ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) { \ncurrentDirFileNo = i ; \n} \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) { \ncurrentDirFileNo = 0 ; \n} \n} \nelse { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) { \ncurrentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) { \nthrow new NullPointerException ( \"null array\" ) ; \n} \nif ( arr . length == 0 ) { \nthrow new IllegalArgumentException ( \"Zero-length array\" ) ; \n} \nint sum = 0 ; \nfor ( int i = 0 ; \ni < arr . length ; \ni ++ ) { \nif ( arr [ i ] <= 0 ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum += arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4885": "public class SpatialGrid { \npublic void setGrid ( Rectangle2D bbox , double width , double height ) { \noffsetX = bbox . getX ( ) ; \noffsetY = bbox . getY ( ) ; \ncountX = Math . min ( nx , ( int ) ( bbox . getWidth ( ) / ( scaleOverlap * width ) ) ) ; \ncountY = Math . min ( ny , ( int ) ( bbox . getHeight ( ) / ( scaleOverlap * height ) ) ) ; \ngridWidth = bbox . getWidth ( ) / countX ; \ngridHeight = bbox . getHeight ( ) / countY ; \nif ( debug ) { \nSystem . out . println ( \"SpatialGrid size \" + gridWidth + \" \" + gridHeight + \" = \" + countX + \" by \" + countY + \" scaleOverlap= \" + scaleOverlap ) ; \n} \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \nfor ( int y = 0 ; \ny < countY ; \ny ++ ) { \nfor ( int x = 0 ; \nx < countX ; \nx ++ ) { \ngridArray [ y ] [ x ] . used = false ; \n} \n} \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) { \nSystem . out . println ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY ) ; \n} \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nreturn false ; \n} \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) { \nreturn false ; \n} \nif ( null != findIntersection ( rect ) ) { \nreturn false ; \n} \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nreturn null ; \n} \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) { \ncontinue ; \n} \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) { \nreturn gtest . o ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nreturn null ; \n} \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) { \ncontinue ; \n} \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) { \nreturn gtest . o ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) { \nSystem . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \n} \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nreturn null ; \n} \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) { \nreturn gwant . o ; \n} \nfor ( int p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np ++ ) { \nif ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) { \nreturn o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4892": "public class SpatialGrid { \nprivate double distanceSq ( Point2D pt , int indexX , int indexY ) { \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nreturn MAX_DOUBLE ; \n} \nGridCell gtest = gridArray [ indexY ] [ indexX ] ; \nif ( ! gtest . used ) { \nreturn MAX_DOUBLE ; \n} \nRectangle2D rect = gtest . objectBB ; \ndouble dx = rect . getX ( ) + rect . getWidth ( ) / 2 - pt . getX ( ) ; \ndouble dy = rect . getY ( ) + rect . getHeight ( ) / 2 - pt . getY ( ) ; \nreturn ( dx * dx + dy * dy ) ; \n} \n} \n"}
{"4894": "public class DatasetUrl { \nstatic private ServiceType searchFragment ( String fragment ) { \nif ( fragment . length ( ) == 0 ) { \nreturn null ; \n} \nMap < String , String > map = parseFragment ( fragment ) ; \nif ( map == null ) { \nreturn null ; \n} \nString protocol = map . get ( \"protocol\" ) ; \nif ( protocol == null ) { \nfor ( String p : FRAGPROTOCOLS ) { \nif ( map . get ( p ) != null ) { \nprotocol = p ; \nbreak ; \n} \n} \n} \nif ( protocol != null ) { \nif ( protocol . equalsIgnoreCase ( \"dap\" ) || protocol . equalsIgnoreCase ( \"dods\" ) ) { \nreturn ServiceType . OPENDAP ; \n} \nif ( protocol . equalsIgnoreCase ( \"dap4\" ) ) { \nreturn ServiceType . DAP4 ; \n} \nif ( protocol . equalsIgnoreCase ( \"cdmremote\" ) ) { \nreturn ServiceType . CdmRemote ; \n} \nif ( protocol . equalsIgnoreCase ( \"thredds\" ) ) { \nreturn ServiceType . THREDDS ; \n} \nif ( protocol . equalsIgnoreCase ( \"ncml\" ) ) { \nreturn ServiceType . NCML ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) { \nreturn null ; \n} \nurl = url . toLowerCase ( ) ; \nfor ( int i = 0 ; \ni < FRAGPROTOCOLS . length ; \ni ++ ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4896": "public class DatasetUrl { \nstatic private ServiceType decodePathExtension ( String path ) { \nif ( path . endsWith ( \".dds\" ) || path . endsWith ( \".das\" ) || path . endsWith ( \".dods\" ) ) { \nreturn ServiceType . OPENDAP ; \n} \nif ( path . endsWith ( \".dmr\" ) || path . endsWith ( \".dap\" ) || path . endsWith ( \".dsr\" ) ) { \nreturn ServiceType . DAP4 ; \n} \nif ( path . endsWith ( \".xml\" ) || path . endsWith ( \".ncml\" ) ) { \nreturn ServiceType . NCML ; \n} \nreturn null ; \n} \n} \n"}
{"4897": "public class DatasetUrl { \nstatic private ServiceType checkIfDods ( String location ) throws IOException { \nint len = location . length ( ) ; \nif ( location . endsWith ( \".dds\" ) ) { \nlocation = location . substring ( 0 , len - \".dds\" . length ( ) ) ; \n} \nif ( location . endsWith ( \".das\" ) ) { \nlocation = location . substring ( 0 , len - \".das\" . length ( ) ) ; \n} \nif ( location . endsWith ( \".dods\" ) ) { \nlocation = location . substring ( 0 , len - \".dods\" . length ( ) ) ; \n} \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dds\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . equalsIgnoreCase ( \"dods-dds\" ) || v . equalsIgnoreCase ( \"dods_dds\" ) ) { \nreturn ServiceType . OPENDAP ; \n} \nelse { \nthrow new IOException ( \"OPeNDAP Server Error= \" + method . getResponseAsString ( ) ) ; \n} \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) { \nthrow new IOException ( \"Unauthorized to open dataset \" + location ) ; \n} \nreturn null ; \n} \n} \n} \n"}
{"4898": "public class DatasetUrl { \nstatic private ServiceType checkIfDap4 ( String location ) throws IOException { \nif ( location . endsWith ( \".dap\" ) ) { \nlocation = location . substring ( 0 , location . length ( ) - \".dap\" . length ( ) ) ; \n} \nelse if ( location . endsWith ( \".dmr\" ) ) { \nlocation = location . substring ( 0 , location . length ( ) - \".dmr\" . length ( ) ) ; \n} \nelse if ( location . endsWith ( \".dmr.xml\" ) ) { \nlocation = location . substring ( 0 , location . length ( ) - \".dmr.xml\" . length ( ) ) ; \n} \nelse if ( location . endsWith ( \".dsr\" ) ) { \nlocation = location . substring ( 0 , location . length ( ) - \".dsr\" . length ( ) ) ; \n} \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dmr.xml\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Type\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . startsWith ( \"application/vnd.opendap.org\" ) ) { \nreturn ServiceType . DAP4 ; \n} \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) { \nthrow new IOException ( \"Unauthorized to open dataset \" + location ) ; \n} \nreturn null ; \n} \n} \n} \n"}
{"4899": "public class NcStreamWriter { \npublic long sendData2 ( Variable v , Section section , OutputStream out , NcStreamCompression compress ) throws IOException , InvalidRangeException { \nif ( show ) { \nSystem . out . printf ( \" %s section=%s%n\" , v . getFullName ( ) , section ) ; \n} \nboolean isVlen = v . isVariableLength ( ) ; \nif ( isVlen ) { \nv . read ( section ) ; \n} \nNcStreamDataCol encoder = new NcStreamDataCol ( ) ; \nNcStreamProto . DataCol dataProto = encoder . encodeData2 ( v . getFullName ( ) , isVlen , section , v . read ( section ) ) ; \nlong size = 0 ; \nsize += writeBytes ( out , NcStream . MAGIC_DATA2 ) ; \nbyte [ ] datab = dataProto . toByteArray ( ) ; \nsize += NcStream . writeVInt ( out , datab . length ) ; \nsize += writeBytes ( out , datab ) ; \nreturn size ; \n} \n} \n"}
{"4900": "public class DapUtil { \nstatic public String fqnSuffix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( structindex >= 0 ) { \nreturn fqn . substring ( structindex + 1 , fqn . length ( ) ) ; \n} \nelse { \nreturn fqn . substring ( groupindex + 1 , fqn . length ( ) ) ; \n} \n} \n} \n"}
{"4901": "public class DapUtil { \nstatic public String fqnPrefix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( structindex >= 0 ) { \nreturn fqn . substring ( 0 , structindex ) ; \n} \nelse { \nreturn fqn . substring ( 0 , groupindex ) ; \n} \n} \n} \n"}
{"4902": "public class DapUtil { \nstatic public String locateFile ( String filename , String abspath , boolean wantdir ) { \nDeque < String > q = new ArrayDeque < String > ( ) ; \nfilename = filename . trim ( ) . replace ( '\\\\' , '/' ) ; \nabspath = abspath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( filename . charAt ( 0 ) == '/' ) { \nfilename = filename . substring ( 1 ) ; \n} \nif ( filename . endsWith ( \"/\" ) ) { \nfilename = filename . substring ( 0 , filename . length ( ) - 1 ) ; \n} \nif ( abspath . endsWith ( \"/\" ) ) { \nabspath = abspath . substring ( 0 , abspath . length ( ) - 1 ) ; \n} \nq . addFirst ( abspath ) ; \nfor ( ; \n; \n) { \nString currentpath = q . poll ( ) ; \nif ( currentpath == null ) { \nbreak ; \n} \nFile current = new File ( currentpath ) ; \nFile [ ] contents = current . listFiles ( ) ; \nif ( contents != null ) { \nfor ( File subfile : contents ) { \nif ( ! subfile . getName ( ) . equals ( filename ) ) { \ncontinue ; \n} \nif ( ( wantdir && subfile . isDirectory ( ) ) || ( ! wantdir && subfile . isFile ( ) ) ) { \nreturn DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; \n} \n} \nfor ( File subfile : contents ) { \nif ( subfile . isDirectory ( ) ) { \nq . addFirst ( currentpath + \"/\" + subfile . getName ( ) ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4903": "public class DapUtil { \nstatic public String locateRelative ( String relpath , String abspath , boolean wantdir ) { \nrelpath = relpath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( relpath . charAt ( 0 ) == '/' ) { \nrelpath = relpath . substring ( 1 ) ; \n} \nif ( relpath . endsWith ( \"/\" ) ) { \nrelpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; \n} \nString [ ] pieces = relpath . split ( \"[/]\" ) ; \nString partial = abspath ; \nfor ( int i = 0 ; \ni < pieces . length - 1 ; \ni ++ ) { \nString nextdir = locateFile ( pieces [ i ] , abspath , true ) ; \nif ( nextdir == null ) { \nreturn null ; \n} \npartial = nextdir ; \n} \nString finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; \nreturn finalpath ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) { \nsep = \"\" ; \n} \nif ( from < 0 || upto > array . length ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nif ( upto <= from ) { \nreturn \"\" ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = from ; \ni < upto ; \ni ++ , first = false ) { \nif ( ! first ) { \nresult . append ( sep ) ; \n} \nresult . append ( array [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nint protosize = 0 ; \nfor ( ; \n; \n) { \nint index = buf . indexOf ( \":\" ) ; \nif ( index < 0 ) { \nbreak ; \n} \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) { \nbreak ; \n} \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize += ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) { \nbreak ; \n} \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4912": "public class DapUtil { \nstatic public boolean isContiguous ( List < Slice > slices ) { \nfor ( Slice sl : slices ) { \nif ( sl . getStride ( ) != 1 ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4913": "public class DapUtil { \nstatic public boolean isSinglePoint ( List < Slice > slices ) { \nfor ( Slice sl : slices ) { \nif ( sl . getCount ( ) != 1 ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4914": "public class DapUtil { \nstatic public Index slicesToIndex ( List < Slice > slices ) throws DapException { \nlong [ ] positions = new long [ slices . size ( ) ] ; \nlong [ ] dimsizes = new long [ slices . size ( ) ] ; \nfor ( int i = 0 ; \ni < positions . length ; \ni ++ ) { \nSlice s = slices . get ( i ) ; \nif ( s . getCount ( ) != 1 ) { \nthrow new DapException ( \"Attempt to convert non-singleton sliceset to index\" ) ; \n} \npositions [ i ] = s . getFirst ( ) ; \ndimsizes [ i ] = s . getMax ( ) ; \n} \nreturn new Index ( positions , dimsizes ) ; \n} \n} \n"}
{"4915": "public class NcStreamReader { \npublic DataResult readData ( InputStream is , NetcdfFile ncfile , String location ) throws IOException { \nbyte [ ] b = new byte [ 4 ] ; \nint bytesRead = NcStream . readFully ( is , b ) ; \nif ( bytesRead < b . length ) { \nthrow new EOFException ( location ) ; \n} \nif ( NcStream . test ( b , NcStream . MAGIC_DATA ) ) { \nreturn readData1 ( is , ncfile ) ; \n} \nif ( NcStream . test ( b , NcStream . MAGIC_DATA2 ) ) { \nreturn readData2 ( is ) ; \n} \nthrow new IOException ( \"Data transfer corrupted on \" + location ) ; \n} \n} \n"}
{"4918": "public class FeatureCollectionConfigBuilder { \npublic FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { \nString catFilename ; \nString fcName = null ; \nint pos = catalogAndPath . indexOf ( \"#\" ) ; \nif ( pos > 0 ) { \ncatFilename = catalogAndPath . substring ( 0 , pos ) ; \nfcName = catalogAndPath . substring ( pos + 1 ) ; \n} \nelse { \ncatFilename = catalogAndPath ; \n} \nFile cat = new File ( catFilename ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \ndoc = builder . build ( cat ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \ntry { \nList < Element > fcElems = new ArrayList < > ( ) ; \nfindFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; \nif ( fcElems . size ( ) > 0 ) { \nreturn readConfig ( fcElems . get ( 0 ) ) ; \n} \n} \ncatch ( IllegalStateException e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4919": "public class DapGroup { \npublic void addDecl ( DapNode newdecl ) throws DapException { \nDapSort newsort = newdecl . getSort ( ) ; \nString newname = newdecl . getShortName ( ) ; \nboolean suppress = false ; \nif ( newsort != DapSort . DIMENSION || newname != null ) { \nfor ( DapNode decl : decls ) { \nif ( newsort == decl . getSort ( ) && newname . equals ( decl . getShortName ( ) ) ) { \nthrow new DapException ( \"DapGroup: attempt to add duplicate decl: \" + newname ) ; \n} \n} \n} \nelse { \nDapDimension anon = ( DapDimension ) newdecl ; \nassert ( newsort == DapSort . DIMENSION && newname == null ) ; \nboolean found = false ; \nfor ( DapDimension dim : dimensions ) { \nif ( ! dim . isShared ( ) && dim . getSize ( ) == anon . getSize ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found && ! isTopLevel ( ) ) { \ngetDataset ( ) . addDecl ( anon ) ; \n} \nsuppress = found || ! isTopLevel ( ) ; \n} \nif ( ! suppress ) { \ndecls . add ( newdecl ) ; \nnewdecl . setParent ( this ) ; \n} \nswitch ( newdecl . getSort ( ) ) { \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; \nbreak ; \ncase DIMENSION : if ( ! suppress ) { \ndimensions . add ( ( DapDimension ) newdecl ) ; \n} \nbreak ; \ncase ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; \nbreak ; \ncase ATOMICTYPE : break ; \ncase STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; \nbreak ; \ncase VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; \nbreak ; \ncase GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) { \ngroups . add ( ( DapGroup ) newdecl ) ; \n} \nbreak ; \ndefault : throw new ClassCastException ( newdecl . getShortName ( ) ) ; \n} \n} \n} \n"}
{"4920": "public class DapGroup { \nvoid updateGroups ( List < DapGroup > groups ) { \nassert ( groups . size ( ) == this . groups . size ( ) ) : \"Update groups: not same size\" ; \nfor ( DapGroup g : groups ) { \nif ( ! this . groups . contains ( g ) ) { \nassert ( false ) : \"Update groups: attempt to add new group\" ; \n} \n} \n} \n} \n"}
{"4922": "public class COARDSConvention { \nprotected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { \nString unit = v . getUnitsString ( ) ; \nif ( unit == null ) { \nreturn null ; \n} \nunit = unit . trim ( ) ; \nif ( unit . equalsIgnoreCase ( \"degrees_east\" ) || unit . equalsIgnoreCase ( \"degrees_E\" ) || unit . equalsIgnoreCase ( \"degreesE\" ) || unit . equalsIgnoreCase ( \"degree_east\" ) || unit . equalsIgnoreCase ( \"degree_E\" ) || unit . equalsIgnoreCase ( \"degreeE\" ) ) { \nreturn AxisType . Lon ; \n} \nif ( unit . equalsIgnoreCase ( \"degrees_north\" ) || unit . equalsIgnoreCase ( \"degrees_N\" ) || unit . equalsIgnoreCase ( \"degreesN\" ) || unit . equalsIgnoreCase ( \"degree_north\" ) || unit . equalsIgnoreCase ( \"degree_N\" ) || unit . equalsIgnoreCase ( \"degreeN\" ) ) { \nreturn AxisType . Lat ; \n} \nif ( SimpleUnit . isDateUnit ( unit ) ) { \nreturn AxisType . Time ; \n} \nif ( SimpleUnit . isCompatible ( \"mbar\" , unit ) ) { \nreturn AxisType . Pressure ; \n} \nif ( unit . equalsIgnoreCase ( \"level\" ) || unit . equalsIgnoreCase ( \"layer\" ) || unit . equalsIgnoreCase ( \"sigma_level\" ) ) { \nreturn AxisType . GeoZ ; \n} \nString positive = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . POSITIVE , null ) ; \nif ( positive != null ) { \nif ( SimpleUnit . isCompatible ( \"m\" , unit ) ) { \nreturn AxisType . Height ; \n} \nelse { \nreturn AxisType . GeoZ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4924": "public class HorizCoordSys { \nprivate Optional < CoverageCoordAxis > subsetLon ( LatLonRect llbb , int stride ) throws InvalidRangeException { \ndouble wantMin = LatLonPointImpl . lonNormalFrom ( llbb . getLonMin ( ) , lonAxis . getStartValue ( ) ) ; \ndouble wantMax = LatLonPointImpl . lonNormalFrom ( llbb . getLonMax ( ) , lonAxis . getStartValue ( ) ) ; \ndouble start = lonAxis . getStartValue ( ) ; \ndouble end = lonAxis . getEndValue ( ) ; \nList < MAMath . MinMax > lonIntvs = subsetLonIntervals ( wantMin , wantMax , start , end ) ; \nif ( lonIntvs . size ( ) == 0 ) { \nreturn Optional . empty ( String . format ( \"longitude want [%f,%f] does not intersect lon axis [%f,%f]\" , wantMin , wantMax , start , end ) ) ; \n} \nif ( lonIntvs . size ( ) == 1 ) { \nMAMath . MinMax lonIntv = lonIntvs . get ( 0 ) ; \nreturn lonAxis . subset ( lonIntv . min , lonIntv . max , stride ) ; \n} \nreturn lonAxis . subsetByIntervals ( lonIntvs , stride ) ; \n} \n} \n"}
{"4925": "public class HorizCoordSys { \npublic List < RangeIterator > getRanges ( ) { \nList < RangeIterator > result = new ArrayList < > ( ) ; \nresult . add ( getYAxis ( ) . getRange ( ) ) ; \nRangeIterator lonRange = getXAxis ( ) . getRangeIterator ( ) ; \nif ( lonRange == null ) { \nlonRange = getXAxis ( ) . getRange ( ) ; \n} \nresult . add ( lonRange ) ; \nreturn result ; \n} \n} \n"}
{"4927": "public class HTTPSession { \npublic String getSessionID ( ) { \nString sid = null ; \nString jsid = null ; \nList < Cookie > cookies = this . sessioncontext . getCookieStore ( ) . getCookies ( ) ; \nfor ( Cookie cookie : cookies ) { \nif ( cookie . getName ( ) . equalsIgnoreCase ( \"sessionid\" ) ) { \nsid = cookie . getValue ( ) ; \n} \nif ( cookie . getName ( ) . equalsIgnoreCase ( \"jsessionid\" ) ) { \njsid = cookie . getValue ( ) ; \n} \n} \nreturn ( sid == null ? jsid : sid ) ; \n} \n} \n"}
{"4928": "public class HTTPSession { \npublic HTTPSession setMaxRedirects ( int n ) { \nif ( n < 0 ) { \nthrow new IllegalArgumentException ( \"setMaxRedirects\" ) ; \n} \nlocalsettings . put ( Prop . MAX_REDIRECTS , n ) ; \nthis . cachevalid = false ; \nreturn this ; \n} \n} \n"}
{"4930": "public class HTTPSession { \nsynchronized public void close ( ) { \nif ( this . closed ) { \nreturn ; \n} \nclosed = true ; \nfor ( HTTPMethod m : this . methods ) { \nm . close ( ) ; \n} \nmethods . clear ( ) ; \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( bestMatch != null ) { \ncp = localcreds . get ( bestMatch ) ; \n} \nelse { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null && ( httpproxy != null || httpsproxy != null ) ) { \nif ( httpproxy != null ) { \nproxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \n} \nelse { \nproxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \n} \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \nif ( cp == null && proxycreds != null && proxyscope != null ) { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse if ( cp != null && proxycreds != null && proxyscope != null ) { \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nif ( cp != null ) { \nthis . sessioncontext . setCredentialsProvider ( cp ) ; \n} \n} \n} \n"}
{"4932": "public class HTTPSession { \nstatic protected synchronized void track ( HTTPSession session ) { \nif ( ! TESTING ) { \nthrow new UnsupportedOperationException ( ) ; \n} \nif ( sessionList == null ) { \nsessionList = new ConcurrentSkipListSet < HTTPSession > ( ) ; \n} \nsessionList . add ( session ) ; \n} \n} \n"}
{"4934": "public class TextGetPutPane { \nvoid validate ( String urlString ) { \nif ( urlString == null ) { \nreturn ; \n} \nURI uri ; \ntry { \nuri = new URI ( urlString ) ; \n} \ncatch ( URISyntaxException e ) { \njavax . swing . JOptionPane . showMessageDialog ( null , \"URISyntaxException on URL (\" + urlString + \") \" + e . getMessage ( ) + \"\\n\" ) ; \nreturn ; \n} \nString contents = getText ( ) ; \nByteArrayInputStream is = new ByteArrayInputStream ( contents . getBytes ( CDM . utf8Charset ) ) ; \ntry { \nCatalogBuilder catFactory = new CatalogBuilder ( ) ; \nCatalog cat = catFactory . buildFromLocation ( urlString , null ) ; \nboolean isValid = ! catFactory . hasFatalError ( ) ; \njavax . swing . JOptionPane . showMessageDialog ( this , \"Catalog Validation = \" + isValid + \"\\n\" + catFactory . getErrorMessage ( ) ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \nfor ( int ii = shape . length - 1 ; \nii >= 0 ; \nii -- ) { \nfinal int thisDim = shape [ ii ] ; \nif ( thisDim < 0 ) { \ncontinue ; \n} \nstride [ ii ] = ( int ) product ; \nproduct *= thisDim ; \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) { \nthrow new InvalidRangeException ( \"Bad ranges [] length\" ) ; \n} \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \ncontinue ; \n} \nif ( r == Range . VLEN ) { \ncontinue ; \n} \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) { \nthrow new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \n} \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) { \nthrow new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) { \nreducedRank -- ; \n} \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4938": "public class Index { \nIndex reduce ( ) { \nIndex c = this ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( shape [ ii ] == 1 ) { \nIndex newc = c . reduce ( ii ) ; \nreturn newc . reduce ( ) ; \n} \n} \nreturn c ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( dim < 0 ) || ( dim >= rank ) ) { \nthrow new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \n} \nif ( shape [ dim ] != 1 ) { \nthrow new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \n} \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4940": "public class Index { \nIndex transpose ( int index1 , int index2 ) { \nif ( ( index1 < 0 ) || ( index1 >= rank ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( ( index2 < 0 ) || ( index2 >= rank ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nIndex newIndex = ( Index ) this . clone ( ) ; \nnewIndex . stride [ index1 ] = stride [ index2 ] ; \nnewIndex . stride [ index2 ] = stride [ index1 ] ; \nnewIndex . shape [ index1 ] = shape [ index2 ] ; \nnewIndex . shape [ index2 ] = shape [ index1 ] ; \nnewIndex . fastIterator = false ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) { \nthrow new IllegalArgumentException ( ) ; \n} \nfor ( int dim : dims ) if ( ( dim < 0 ) || ( dim >= rank ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nfor ( int i = 0 ; \ni < dims . length ; \ni ++ ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) { \nisPermuted = true ; \n} \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4942": "public class Index { \nIndexIterator getIndexIterator ( Array maa ) { \nif ( fastIterator ) { \nreturn new IteratorFast ( size , maa ) ; \n} \nelse { \nreturn new IteratorImpl ( maa ) ; \n} \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nint value = offset ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( shape [ ii ] < 0 ) { \nbreak ; \n} \nvalue += current [ ii ] * stride [ ii ] ; \n} \nreturn value ; \n} \n} \n"}
{"4944": "public class Index { \npublic Index set ( int [ ] index ) { \nif ( index . length != rank ) { \nthrow new ArrayIndexOutOfBoundsException ( ) ; \n} \nif ( rank == 0 ) { \nreturn this ; \n} \nint prefixrank = ( hasvlen ? rank : rank - 1 ) ; \nSystem . arraycopy ( index , 0 , current , 0 , prefixrank ) ; \nif ( hasvlen ) { \ncurrent [ prefixrank ] = - 1 ; \n} \nreturn this ; \n} \n} \n"}
{"4945": "public class Index { \npublic void setDim ( int dim , int value ) { \nif ( value < 0 || value >= shape [ dim ] ) { \nthrow new ArrayIndexOutOfBoundsException ( ) ; \n} \nif ( shape [ dim ] >= 0 ) { \ncurrent [ dim ] = value ; \n} \n} \n} \n"}
{"4947": "public class CoordinateTimeIntv { \npublic String getTimeIntervalName ( ) { \nint firstValue = - 1 ; \nfor ( TimeCoordIntvValue tinv : timeIntervals ) { \nint value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; \nif ( firstValue < 0 ) { \nfirstValue = value ; \n} \nelse if ( value != firstValue ) { \nreturn MIXED_INTERVALS ; \n} \n} \nfirstValue = ( firstValue * timeUnit . getValue ( ) ) ; \nreturn firstValue + \"_\" + timeUnit . getField ( ) . toString ( ) ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth += n ; \nif ( depth < 0 ) { \ndepth = 0 ; \n} \nelse if ( depth > MAXDEPTH ) { \ndepth = MAXDEPTH ; \n} \n} \n} \n"}
{"4958": "public class IndentWriter { \npublic void setIndent ( int n ) { \ndepth = n ; \nif ( depth < 0 ) { \ndepth = 0 ; \n} \nelse if ( depth > MAXDEPTH ) { \ndepth = MAXDEPTH ; \n} \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( null != regexpPatternString ) { \nfilters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \n} \nelse if ( suffix != null ) { \nfilters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \n} \nif ( olderS != null ) { \ntry { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \n} \nboolean wantSubdirs = true ; \nif ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( \"false\" ) ) { \nwantSubdirs = false ; \n} \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) { \nsb . append ( \"**/\" ) ; \n} \nif ( null != regexpPatternString ) { \nsb . append ( regexpPatternString ) ; \n} \nelse if ( suffix != null ) { \nsb . append ( suffix ) ; \n} \nelse { \nsb . append ( \"noFilter\" ) ; \n} \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \n} \n} \n"}
{"4965": "public class FileWriter2 { \npublic NetcdfFile write ( CancelTask cancel ) throws IOException { \ntry { \nif ( version . isExtendedModel ( ) ) { \naddGroupExtended ( null , fileIn . getRootGroup ( ) ) ; \n} \nelse { \naddGroupClassic ( ) ; \n} \nif ( cancel != null && cancel . isCancel ( ) ) { \nreturn null ; \n} \nwriter . create ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) { \nreturn null ; \n} \ndouble total = copyVarData ( varList , null , cancel ) ; \nif ( cancel != null && cancel . isCancel ( ) ) { \nreturn null ; \n} \nwriter . flush ( ) ; \nif ( debug ) { \nSystem . out . println ( \"FileWriter done total bytes = \" + total ) ; \n} \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nwriter . abort ( ) ; \nthrow ioe ; \n} \nreturn writer . getNetcdfFile ( ) ; \n} \n} \n"}
{"4967": "public class MultiSlice { \n@ Override public String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( \"[\" ) ; \nboolean first = true ; \nfor ( Slice sub : this . subslices ) { \nif ( ! first ) { \nbuf . append ( \",\" ) ; \n} \nfirst = false ; \nif ( ( sub . stop - sub . first ) == 0 ) { \nbuf . append ( \"0\" ) ; \n} \nelse if ( sub . stride == 1 ) { \nif ( ( sub . stop - sub . first ) == 1 ) { \nbuf . append ( sub . first ) ; \n} \nelse { \nbuf . append ( String . format ( \"%d:%d\" , sub . first , sub . stop - 1 ) ) ; \n} \n} \nelse { \nbuf . append ( String . format ( \"%d:%d:%d\" , sub . first , sub . stride , sub . stop - 1 ) ) ; \n} \n} \nbuf . append ( \"]\" ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4968": "public class StructureDS { \npublic void setOriginalVariable ( ucar . nc2 . Variable orgVar ) { \nif ( ! ( orgVar instanceof Structure ) ) { \nthrow new IllegalArgumentException ( \"StructureDS must wrap a Structure; name=\" + orgVar . getFullName ( ) ) ; \n} \nthis . orgVar = ( Structure ) orgVar ; \n} \n} \n"}
{"4969": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , CancelTask cancelTask ) throws IOException { \nArray result ; \nif ( hasCachedData ( ) ) { \nresult = super . reallyRead ( client , cancelTask ) ; \n} \nelse if ( orgVar != null ) { \nresult = orgVar . read ( ) ; \n} \nelse { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \nreturn convert ( result , null ) ; \n} \n} \n"}
{"4970": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nif ( section . computeSize ( ) == getSize ( ) ) { \nreturn _read ( ) ; \n} \nArray result ; \nif ( hasCachedData ( ) ) { \nresult = super . reallyRead ( client , section , cancelTask ) ; \n} \nelse if ( orgVar != null ) { \nresult = orgVar . read ( section ) ; \n} \nelse { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \nreturn convert ( result , section ) ; \n} \n} \n"}
{"4971": "public class StructureDS { \nprivate boolean convertNeeded ( StructureMembers smData ) { \nfor ( Variable v : getVariables ( ) ) { \nif ( v instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v ; \nif ( vds . needConvert ( ) ) { \nreturn true ; \n} \n} \nelse if ( v instanceof StructureDS ) { \nStructureDS nested = ( StructureDS ) v ; \nif ( nested . convertNeeded ( null ) ) { \nreturn true ; \n} \n} \nif ( ( smData != null ) && ! varHasData ( v , smData ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) { \nv2 = findVariableFromOrgName ( m . getName ( ) ) ; \n} \nif ( v2 == null ) { \ncontinue ; \n} \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4973": "public class StructureDS { \nprivate void convertMemberInfo ( StructureMembers wrapperSm ) { \nfor ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { \nVariable v = findVariable ( m . getName ( ) ) ; \nif ( ( v == null ) && ( orgVar != null ) ) { \nv = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; \n} \nif ( v != null ) { \nm . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; \n} \nif ( v instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v ; \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \n} \n} \n"}
{"4974": "public class StructureDS { \nprivate VariableEnhanced findVariableFromOrgName ( String orgName ) { \nfor ( Variable vTop : getVariables ( ) ) { \nVariable v = vTop ; \nwhile ( v instanceof VariableEnhanced ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( ( ve . getOriginalName ( ) != null ) && ( ve . getOriginalName ( ) . equals ( orgName ) ) ) { \nreturn ( VariableEnhanced ) vTop ; \n} \nv = ve . getOriginalVariable ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4975": "public class StructureDS { \nprivate boolean varHasData ( Variable v , StructureMembers sm ) { \nif ( sm . findMember ( v . getShortName ( ) ) != null ) { \nreturn true ; \n} \nwhile ( v instanceof VariableEnhanced ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( sm . findMember ( ve . getOriginalName ( ) ) != null ) { \nreturn true ; \n} \nv = ve . getOriginalVariable ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"4977": "public class DatasetManager { \npublic boolean resourceControlOk ( HttpServletRequest req , HttpServletResponse res , String reqPath ) { \nif ( null == reqPath ) { \nreqPath = TdsPathUtils . extractPath ( req , null ) ; \n} \nString rc = null ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( reqPath ) ; \nif ( match != null ) { \nrc = match . dataRoot . getRestrict ( ) ; \n} \nif ( rc == null ) { \nrc = datasetTracker . findResourceControl ( reqPath ) ; \n} \nreturn resourceAuthorized ( req , res , rc ) ; \n} \n} \n"}
{"4986": "public class InvCatalogFactory { \npublic MetadataConverterIF getMetadataConverter ( String key ) { \nif ( key == null ) { \nreturn null ; \n} \nreturn metadataConverters . get ( key ) ; \n} \n} \n"}
{"4992": "public class GMLFeatureWriter { \npublic String writeFeature ( SimpleGeometry geom ) { \nif ( geom instanceof Point ) { \nreturn writePoint ( ( Point ) geom ) ; \n} \nelse if ( geom instanceof Line ) { \nreturn writeLine ( ( Line ) geom ) ; \n} \nelse if ( geom instanceof Polygon ) { \nreturn writePolygon ( ( Polygon ) geom ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"4996": "public class DOM4Parser { \nprotected String pull ( Node n , String name ) { \nNamedNodeMap map = n . getAttributes ( ) ; \nNode attr = map . getNamedItem ( name ) ; \nif ( attr == null ) { \nreturn null ; \n} \nreturn attr . getNodeValue ( ) ; \n} \n} \n"}
{"4997": "public class DOM4Parser { \nList < Node > getSubnodes ( Node parent ) { \nList < Node > subs = new ArrayList < > ( ) ; \nNodeList nodes = parent . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) { \nNode n = nodes . item ( i ) ; \nif ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { \nsubs . add ( n ) ; \n} \n} \nreturn subs ; \n} \n} \n"}
{"4998": "public class DOM4Parser { \nprotected void parseresponse ( Node root ) throws ParseException { \nString elemname = root . getNodeName ( ) ; \nif ( elemname . equalsIgnoreCase ( \"Error\" ) ) { \nparseerror ( root ) ; \n} \nelse if ( elemname . equalsIgnoreCase ( \"Dataset\" ) ) { \nparsedataset ( root ) ; \n} \nelse { \nthrow new ParseException ( \"Unexpected response root: \" + elemname ) ; \n} \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrs . getLength ( ) ; \ni ++ ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) { \ndap . addXMLAttribute ( key , value ) ; \n} \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) { \nreturn null ; \n} \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) { \ncontinue ; \n} \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) { \nsubStr += \":\" ; \n} \nelse { \nsubStr += ( beginInd + \":\" + endInd ) ; \n} \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5001": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { \nif ( from instanceof ArrayStructureMA ) { \nreturn ( ArrayStructureMA ) from ; \n} \nif ( from . getSize ( ) > 0 ) { \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nto . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; \n} \nreturn to ; \n} \nint numRecords = - 1 ; \nMap < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nArray array = from . extractMemberArray ( m ) ; \nassert array . getSize ( ) > 0 : \"array's size should have been computed in extractMemberArray().\" ; \nint firstDimLen = array . getShape ( ) [ 0 ] ; \nif ( numRecords == - 1 ) { \nnumRecords = firstDimLen ; \n} \nelse { \nassert numRecords == firstDimLen : String . format ( \"Expected all structure members to have the same first\" + \"dimension length, but %d != %d.\" , numRecords , firstDimLen ) ; \n} \nmemberArrayMap . put ( m . getName ( ) , array ) ; \n} \nint [ ] shape ; \nif ( numRecords == - 1 ) { \nshape = new int [ ] { \n0 } \n; \n} \nelse { \nshape = new int [ ] { \nnumRecords } \n; \n} \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; \nfor ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { \nto . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn to ; \n} \n} \n"}
{"5003": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( Structure from , int [ ] shape ) throws IOException { \nStructureMembers sm = from . makeStructureMembers ( ) ; \nfor ( Variable v : from . getVariables ( ) ) { \nArray data ; \nif ( v instanceof Sequence ) { \ndata = Array . factory ( DataType . SEQUENCE , shape ) ; \n} \nelse if ( v instanceof Structure ) { \ndata = ArrayStructureMA . factoryMA ( ( Structure ) v , combine ( shape , v . getShape ( ) ) ) ; \n} \nelse { \ndata = Array . factory ( v . getDataType ( ) , combine ( shape , v . getShape ( ) ) ) ; \n} \nStructureMembers . Member m = sm . findMember ( v . getShortName ( ) ) ; \nm . setDataArray ( data ) ; \n} \nreturn new ArrayStructureMA ( sm , shape ) ; \n} \n} \n"}
{"5004": "public class SimpleGeometryReader { \npublic GeometryType getGeometryType ( String name ) { \nVariable geometryVar = ds . findVariable ( name ) ; \nif ( geometryVar == null ) { \nreturn null ; \n} \nif ( ds . findGlobalAttribute ( CF . CONVENTIONS ) != null ) { \nif ( ucar . nc2 . dataset . conv . CF1Convention . getVersion ( ds . findGlobalAttribute ( CF . CONVENTIONS ) . getStringValue ( ) ) >= 8 ) { \nAttribute geometryTypeAttr = null ; \nString geometry_type = null ; \ngeometryTypeAttr = geometryVar . findAttribute ( CF . GEOMETRY_TYPE ) ; \nif ( geometryTypeAttr == null ) { \nreturn null ; \n} \ngeometry_type = geometryTypeAttr . getStringValue ( ) ; \nswitch ( geometry_type ) { \ncase CF . POLYGON : return GeometryType . POLYGON ; \ncase CF . LINE : return GeometryType . LINE ; \ncase CF . POINT : return GeometryType . POINT ; \ndefault : return null ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"5005": "public class StandardStationCollectionImpl { \npublic StationTimeSeriesFeature makeStation ( StructureData stationData , int recnum ) { \nStationFeature s = ft . makeStation ( stationData ) ; \nif ( s == null ) { \nreturn null ; \n} \nreturn new StandardStationFeatureImpl ( s , timeUnit , stationData , recnum ) ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) { \nreturn ; \n} \nif ( expr . sort == CEAST . Sort . SEGMENT ) { \nif ( expr . subnodes != null ) { \nthrow new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \n} \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) { \nthrow new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \n} \nexpr . field = field ; \n} \nelse if ( expr . sort == CEAST . Sort . EXPR ) { \nif ( expr . lhs != null ) { \ncompilefilter ( var , seq , expr . lhs ) ; \n} \nif ( expr . rhs != null ) { \ncompilefilter ( var , seq , expr . rhs ) ; \n} \nif ( expr . lhs != null && expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar && ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \nelse if ( expr . sort == CEAST . Sort . CONSTANT ) { \nreturn ; \n} \nelse { \nthrow new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \n} \n} \n} \n"}
{"5008": "public class CECompiler { \nprotected void dimredef ( CEAST node ) throws DapException { \nDapDimension dim = ( DapDimension ) dataset . findByFQN ( node . name , DapSort . DIMENSION ) ; \nif ( dim == null ) { \nthrow new DapException ( \"Constraint dim redef: no dimension name: \" + node . name ) ; \n} \nSlice slice = node . slice ; \nslice . finish ( ) ; \nce . addRedef ( dim , slice ) ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) { \nreturn ; \n} \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse { \nif ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5012": "public class LatLonRect { \npublic void extend ( LatLonRect r ) { \nPreconditions . checkNotNull ( r ) ; \ndouble latMin = r . getLatMin ( ) ; \ndouble latMax = r . getLatMax ( ) ; \nif ( latMax > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( latMax ) ; \n} \nif ( latMin < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( latMin ) ; \n} \nif ( allLongitude ) { \nreturn ; \n} \ndouble lonMin = getLonMin ( ) ; \ndouble lonMax = getLonMax ( ) ; \ndouble nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; \ndouble nlonMax = nlonMin + r . getWidth ( ) ; \nlonMin = Math . min ( lonMin , nlonMin ) ; \nlonMax = Math . max ( lonMax , nlonMax ) ; \nwidth = lonMax - lonMin ; \nallLongitude = width >= 360.0 ; \nif ( allLongitude ) { \nwidth = 360.0 ; \nlonMin = - 180.0 ; \n} \nelse { \nlonMin = LatLonPointImpl . lonNormal ( lonMin ) ; \n} \nlowerLeft . setLongitude ( lonMin ) ; \nupperRight . setLongitude ( lonMin + width ) ; \nlon0 = lonMin + width / 2 ; \ncrossDateline = lowerLeft . getLongitude ( ) > upperRight . getLongitude ( ) ; \n} \n} \n"}
{"5013": "public class LatLonRect { \npublic LatLonRect intersect ( LatLonRect clip ) { \ndouble latMin = Math . max ( getLatMin ( ) , clip . getLatMin ( ) ) ; \ndouble latMax = Math . min ( getLatMax ( ) , clip . getLatMax ( ) ) ; \ndouble deltaLat = latMax - latMin ; \nif ( deltaLat < 0 ) { \nreturn null ; \n} \ndouble lon1min = getLonMin ( ) ; \ndouble lon1max = getLonMax ( ) ; \ndouble lon2min = clip . getLonMin ( ) ; \ndouble lon2max = clip . getLonMax ( ) ; \nif ( ! intersect ( lon1min , lon1max , lon2min , lon2max ) ) { \nlon2min = clip . getLonMin ( ) + 360 ; \nlon2max = clip . getLonMax ( ) + 360 ; \nif ( ! intersect ( lon1min , lon1max , lon2min , lon2max ) ) { \nlon2min = clip . getLonMin ( ) - 360 ; \nlon2max = clip . getLonMax ( ) - 360 ; \n} \n} \ndouble lonMin = Math . max ( lon1min , lon2min ) ; \ndouble lonMax = Math . min ( lon1max , lon2max ) ; \ndouble deltaLon = lonMax - lonMin ; \nif ( deltaLon < 0 ) { \nreturn null ; \n} \nreturn new LatLonRect ( new LatLonPointImpl ( latMin , lonMin ) , deltaLat , deltaLon ) ; \n} \n} \n"}
{"5014": "public class MAMath { \npublic static Array add ( Array a , Array b ) throws IllegalArgumentException { \nArray result = Array . factory ( a . getDataType ( ) , a . getShape ( ) ) ; \nif ( a . getElementType ( ) == double . class ) { \naddDouble ( result , a , b ) ; \n} \nelse { \nthrow new UnsupportedOperationException ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) { \nreturn false ; \n} \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) { \ncontinue ; \n} \nwhile ( dimB < rankB ) { \nif ( shapeB [ dimB ] == 1 ) { \ndimB ++ ; \n} \nelse { \nbreak ; \n} \n} \nif ( aShapeA != shapeB [ dimB ] ) { \nreturn false ; \n} \ndimB ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5017": "public class MAMath { \npublic static Array convert ( Array org , DataType wantType ) { \nif ( org == null ) { \nreturn null ; \n} \nClass wantClass = wantType . getPrimitiveClassType ( ) ; \nif ( org . getElementType ( ) . equals ( wantClass ) ) { \nreturn org ; \n} \nArray result = Array . factory ( wantType , org . getShape ( ) ) ; \ncopy ( wantType , org . getIndexIterator ( ) , result . getIndexIterator ( ) ) ; \nreturn result ; \n} \n} \n"}
{"5018": "public class MAMath { \npublic static void copy ( Array result , Array a ) throws IllegalArgumentException { \nClass classType = a . getElementType ( ) ; \nif ( classType == double . class ) { \ncopyDouble ( result , a ) ; \n} \nelse if ( classType == float . class ) { \ncopyFloat ( result , a ) ; \n} \nelse if ( classType == long . class ) { \ncopyLong ( result , a ) ; \n} \nelse if ( classType == int . class ) { \ncopyInt ( result , a ) ; \n} \nelse if ( classType == short . class ) { \ncopyShort ( result , a ) ; \n} \nelse if ( classType == char . class ) { \ncopyChar ( result , a ) ; \n} \nelse if ( classType == byte . class ) { \ncopyByte ( result , a ) ; \n} \nelse if ( classType == boolean . class ) { \ncopyBoolean ( result , a ) ; \n} \nelse { \ncopyObject ( result , a ) ; \n} \n} \n} \n"}
{"5019": "public class MAMath { \npublic static void copyBoolean ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) { \nthrow new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \n} \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nwhile ( iterA . hasNext ( ) ) { \niterR . setBooleanNext ( iterA . getBooleanNext ( ) ) ; \n} \n} \n} \n"}
{"5020": "public class MAMath { \npublic static void copyObject ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) { \nthrow new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \n} \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nwhile ( iterA . hasNext ( ) ) { \niterR . setObjectNext ( iterA . getObjectNext ( ) ) ; \n} \n} \n} \n"}
{"5021": "public class MAMath { \npublic static MAMath . MinMax getMinMax ( Array a ) { \nIndexIterator iter = a . getIndexIterator ( ) ; \ndouble max = - Double . MAX_VALUE ; \ndouble min = Double . MAX_VALUE ; \nwhile ( iter . hasNext ( ) ) { \ndouble val = iter . getDoubleNext ( ) ; \nif ( Double . isNaN ( val ) ) { \ncontinue ; \n} \nif ( val > max ) { \nmax = val ; \n} \nif ( val < min ) { \nmin = val ; \n} \n} \nreturn new MinMax ( min , max ) ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse if ( reservedChars == null ) { \nreturn x ; \n} \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) { \nc = x . charAt ( ++ pos ) ; \n} \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5030": "public class EscapeStrings { \npublic static List < String > tokenizeEscapedName ( String escapedName ) { \nList < String > result = new ArrayList < > ( ) ; \nint pos = 0 ; \nint start = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( sep , pos + 1 ) ; \nif ( pos <= 0 ) { \nbreak ; \n} \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nresult . add ( escapedName . substring ( start , pos ) ) ; \nstart = pos + 1 ; \n} \n} \nresult . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5031": "public class EscapeStrings { \npublic static int indexOf ( String escapedName , char c ) { \nint pos = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( c , pos + 1 ) ; \nif ( pos <= 0 ) { \nreturn pos ; \n} \nif ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nreturn pos ; \n} \n} \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) { \nbuf . append ( '0' ) ; \n} \nbuf . append ( ashex ) ; \n} \nelse { \nbuf . append ( c ) ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5033": "public class Nc4Cursor { \nprotected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { \nDapVariable atomvar = ( DapVariable ) getTemplate ( ) ; \nNc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; \nint ret ; \nDapType basetype = ti . getType ( ) ; \nObject result = null ; \nif ( basetype . isFixedSize ( ) ) { \nlong memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; \nNc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nresult = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; \n} \nelse if ( basetype . isStringType ( ) ) { \nString [ ] s = new String [ 1 ] ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; \nresult = s ; \n} \nelse if ( basetype . isOpaqueType ( ) ) { \nNc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; \nbuf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; \nresult = buf ; \n} \nelse { \nthrow new DapException ( \"Unexpected atomic type: \" + basetype ) ; \n} \nreturn result ; \n} \n} \n"}
{"5034": "public class Nc4Cursor { \nstatic List < Nc4Cursor > getCursorPath ( Nc4Cursor cursor ) { \nList < Nc4Cursor > path = new ArrayList < > ( ) ; \nfor ( ; \n; \n) { \nif ( ! cursor . getScheme ( ) . isCompoundArray ( ) ) { \npath . add ( 0 , cursor ) ; \n} \nif ( cursor . getScheme ( ) == Scheme . SEQUENCE ) { \nbreak ; \n} \nNc4Cursor next = ( Nc4Cursor ) cursor . getContainer ( ) ; \nif ( next == null ) { \nassert cursor . getTemplate ( ) . isTopLevel ( ) ; \nbreak ; \n} \nassert next . getTemplate ( ) . getSort ( ) == DapSort . VARIABLE ; \ncursor = next ; \n} \nreturn path ; \n} \n} \n"}
{"5043": "public class PrefPanel { \npublic Field getField ( String name ) { \nField fld = flds . get ( name ) ; \nif ( fld == null ) { \nreturn null ; \n} \nreturn ( fld instanceof FieldResizable ) ? ( ( FieldResizable ) fld ) . getDelegate ( ) : fld ; \n} \n} \n"}
{"5044": "public class PrefPanel { \npublic Object getFieldValue ( String name ) { \nField fld = getField ( name ) ; \nif ( fld == null ) { \nthrow new IllegalArgumentException ( \"no field named \" + name ) ; \n} \nreturn fld . getValue ( ) ; \n} \n} \n"}
{"5045": "public class PrefPanel { \npublic void setFieldValue ( String name , Object value ) { \nField fld = getField ( name ) ; \nif ( fld == null ) { \nthrow new IllegalArgumentException ( \"no field named \" + name ) ; \n} \nfld . setValue ( value ) ; \n} \n} \n"}
{"5058": "public class PrefPanel { \nstatic public Frame findActiveFrame ( ) { \nFrame [ ] frames = JFrame . getFrames ( ) ; \nfor ( Frame frame : frames ) { \nif ( frame . isVisible ( ) ) { \nreturn frame ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5065": "public class Grib1ParamTables { \npublic static Grib1ParamTables factory ( String paramTablePath , String lookupTablePath ) throws IOException { \nif ( paramTablePath == null && lookupTablePath == null ) { \nreturn new Grib1ParamTables ( ) ; \n} \nLookup lookup = null ; \nGrib1ParamTableReader override = null ; \nGrib1ParamTableReader table ; \nif ( paramTablePath != null ) { \ntable = localTableHash . get ( paramTablePath ) ; \nif ( table == null ) { \ntable = new Grib1ParamTableReader ( paramTablePath ) ; \nlocalTableHash . put ( paramTablePath , table ) ; \noverride = table ; \n} \n} \nif ( lookupTablePath != null ) { \nlookup = new Lookup ( ) ; \nif ( ! lookup . readLookupTable ( lookupTablePath ) ) { \nthrow new FileNotFoundException ( \"cant read lookup table=\" + lookupTablePath ) ; \n} \n} \nreturn new Grib1ParamTables ( lookup , override ) ; \n} \n} \n"}
{"5066": "public class Grib1ParamTables { \npublic static Grib1ParamTables factory ( org . jdom2 . Element paramTableElem ) { \nif ( paramTableElem == null ) { \nreturn new Grib1ParamTables ( ) ; \n} \nreturn new Grib1ParamTables ( null , new Grib1ParamTableReader ( paramTableElem ) ) ; \n} \n} \n"}
{"5067": "public class Grib1ParamTables { \npublic static boolean addParameterTableLookup ( String lookupFilename ) throws IOException { \nLookup lookup = new Lookup ( ) ; \nif ( ! lookup . readLookupTable ( lookupFilename ) ) { \nreturn false ; \n} \nsynchronized ( lock ) { \nstandardLookup . tables . addAll ( standardTablesStart , lookup . tables ) ; \nstandardTablesStart += lookup . tables . size ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"5073": "public class DoradeDescriptor { \nprotected static String peekName ( RandomAccessFile file ) throws DescriptorException { \ntry { \nlong filepos = file . getFilePointer ( ) ; \nbyte [ ] nameBytes = new byte [ 4 ] ; \nif ( file . read ( nameBytes ) == - 1 ) { \nreturn null ; \n} \nfile . seek ( filepos ) ; \nreturn new String ( nameBytes , CDM . utf8Charset ) ; \n} \ncatch ( IOException ex ) { \nthrow new DescriptorException ( ex ) ; \n} \n} \n} \n"}
{"5083": "public class GisFeatureRenderer { \npublic void draw ( java . awt . Graphics2D g , AffineTransform pixelAT ) { \ng . setColor ( color ) ; \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ng . setStroke ( new java . awt . BasicStroke ( 0.0f ) ) ; \nRectangle2D clipRect = ( Rectangle2D ) g . getClip ( ) ; \nIterator siter = getShapes ( g , pixelAT ) ; \nwhile ( siter . hasNext ( ) ) { \nShape s = ( Shape ) siter . next ( ) ; \nRectangle2D shapeBounds = s . getBounds2D ( ) ; \nif ( shapeBounds . intersects ( clipRect ) ) { \ng . draw ( s ) ; \n} \n} \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) { \nreturn shapeList . iterator ( ) ; \n} \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) { \nSystem . out . println ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" ) ; \n} \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) { \nshape = feature . getShape ( ) ; \n} \nelse if ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse if ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5085": "public class BufrSplitter { \npublic void processStream ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = processBuffer ( b , is ) ; \nif ( b . done ) { \nbreak ; \n} \n} \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( done < want ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) { \nreturn false ; \n} \ndone += got ; \n} \nif ( showRead ) { \nSystem . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \n} \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) { \nreturn 0 ; \n} \nint c = read ( ) ; \nif ( c == - 1 ) { \nreturn - 1 ; \n} \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \nfor ( ; \ni < len ; \ni ++ ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5090": "public class GridVertCoord { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( ! isVertDimensionUsed ( ) ) { \nreturn ; \n} \nint nlevs = levels . size ( ) ; \nif ( coordValues != null ) { \nnlevs = coordValues . length ; \n} \nncfile . addDimension ( g , new Dimension ( getVariableName ( ) , nlevs , true ) ) ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) { \ncontinue ; \n} \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) { \ncontinue ; \n} \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \nfor ( int i = 0 ; \nisgridarray && i < rank ; \ni ++ ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) { \nisgridarray = false ; \n} \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) { \nisgridarray = false ; \n} \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) { \nused . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5097": "public class NcDDS { \nprivate BaseType createVariable ( NetcdfFile ncfile , Variable v ) { \nBaseType bt ; \nif ( v . getRank ( ) == 0 ) { \nbt = createScalarVariable ( ncfile , v ) ; \n} \nelse if ( v . getDataType ( ) == DataType . CHAR ) { \nif ( v . getRank ( ) > 1 ) { \nbt = new NcSDCharArray ( v ) ; \n} \nelse { \nbt = new NcSDString ( v ) ; \n} \n} \nelse if ( v . getDataType ( ) == DataType . STRING ) { \nif ( v . getRank ( ) == 0 ) { \nbt = new NcSDString ( v ) ; \n} \nelse { \nbt = new NcSDArray ( v , new NcSDString ( v ) ) ; \n} \n} \nelse { \nbt = createArray ( ncfile , v ) ; \n} \nreturn bt ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) { \nSystem . out . println ( \"NP.fireMapAreaEvent \" ) ; \n} \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) { \nSystem . out . println ( \"projection/LatLonShift: min,max = \" + box . getMinX ( ) + \" \" + box . getMaxX ( ) + \" beg,end= \" + lonBeg + \" \" + lonEnd + \" center = \" + center ) ; \n} \nif ( ( lonBeg < center - 180 ) || ( lonEnd > center + 180 ) ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) { \nSystem . out . println ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 ) ; \n} \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \n} \n} \n"}
{"5099": "public class NavigatedPanel { \npublic void setMapArea ( ProjectionRect ma ) { \nif ( debugBB ) { \nSystem . out . println ( \"NP.setMapArea \" + ma ) ; \n} \nnavigate . setMapArea ( ma ) ; \n} \n} \n"}
{"5100": "public class NavigatedPanel { \npublic void setMapArea ( LatLonRect llbb ) { \nif ( debugBB ) { \nSystem . out . println ( \"NP.setMapArea (ll) \" + llbb ) ; \n} \nnavigate . setMapArea ( project . latLonToProjBB ( llbb ) ) ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) || debugNewProjection ) { \nSystem . out . println ( \"projection/set NP=\" + project ) ; \n} \nif ( hasReference ) { \nrefWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \n} \n} \n"}
{"5104": "public class NavigatedPanel { \nprivate void redrawLater ( int delay ) { \nboolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; \nif ( debugThread ) { \nSystem . out . println ( \"redrawLater isRunning= \" + already ) ; \n} \nif ( already ) { \nreturn ; \n} \nif ( redrawTimer == null ) { \nredrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent e ) { \ndrawG ( ) ; \nredrawTimer . stop ( ) ; \n} \n} \n) ; \n} \nredrawTimer . setDelay ( delay ) ; \nredrawTimer . start ( ) ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) { \nSystem . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \n} \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) { \nreturn ; \n} \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) { \nreturn ; \n} \nif ( debugBounds ) { \nSystem . out . println ( \"  newBounds = \" + b ) ; \n} \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5112": "public class CoordinateTransform { \npublic Parameter findParameterIgnoreCase ( String name ) { \nfor ( Parameter a : params ) { \nif ( name . equalsIgnoreCase ( a . getName ( ) ) ) { \nreturn a ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5113": "public class MultiOdometer { \n@ Override public boolean hasNext ( ) { \nif ( this . current >= odomset . size ( ) ) { \nreturn false ; \n} \nOdometer ocurrent = odomset . get ( this . current ) ; \nif ( ocurrent . hasNext ( ) ) { \nreturn true ; \n} \nthis . current ++ ; \nreturn hasNext ( ) ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"5123": "public class Nidsheader { \npublic byte [ ] getUncompData ( int offset , int len ) { \nif ( len == 0 ) { \nlen = uncompdata . length - offset ; \n} \nbyte [ ] data = new byte [ len ] ; \nSystem . arraycopy ( uncompdata , offset , data , 0 , len ) ; \nreturn data ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \nfor ( int i = 0 ; \ni < nlevel ; \ni ++ ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) { \nisign = 1 ; \n} \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5133": "public class Nidsheader { \nvoid addParameter ( String pName , String longName , NetcdfFile nc , ArrayList dims , Attribute att , DataType dtype , String ut , long hoff , long doff , boolean isZ , int y0 ) { \nString vName = pName ; \nVariable vVar = new Variable ( nc , null , null , vName ) ; \nvVar . setDataType ( dtype ) ; \nif ( dims != null ) { \nvVar . setDimensions ( dims ) ; \n} \nelse { \nvVar . setDimensions ( \"\" ) ; \n} \nif ( att != null ) { \nvVar . addAttribute ( att ) ; \n} \nvVar . addAttribute ( new Attribute ( CDM . UNITS , ut ) ) ; \nvVar . addAttribute ( new Attribute ( CDM . LONG_NAME , longName ) ) ; \nnc . addVariable ( null , vVar ) ; \nvVar . setSPobject ( new Vinfo ( numX , numX0 , numY , y0 , hoff , doff , isR , isZ , null , null , 0 , 0 ) ) ; \n} \n} \n"}
{"5134": "public class Nidsheader { \nbyte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { \nbyte [ ] header = new byte [ offset ] ; \nbuf . position ( 0 ) ; \nbuf . get ( header ) ; \nbyte [ ] out = new byte [ offset + uncomplen ] ; \nSystem . arraycopy ( header , 0 , out , 0 , offset ) ; \nCBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; \nint numCompBytes = buf . remaining ( ) ; \nbyte [ ] bufc = new byte [ numCompBytes ] ; \nbuf . get ( bufc , 0 , numCompBytes ) ; \nByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; \ncbzip2 . setStream ( bis ) ; \nint total = 0 ; \nint nread ; \nbyte [ ] ubuff = new byte [ 40000 ] ; \nbyte [ ] obuff = new byte [ 40000 ] ; \ntry { \nwhile ( ( nread = cbzip2 . read ( ubuff ) ) != - 1 ) { \nif ( total + nread > obuff . length ) { \nbyte [ ] temp = obuff ; \nobuff = new byte [ temp . length * 2 ] ; \nSystem . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; \n} \nSystem . arraycopy ( ubuff , 0 , obuff , total , nread ) ; \ntotal += nread ; \n} \nif ( obuff . length >= 0 ) { \nSystem . arraycopy ( obuff , 0 , out , offset , total ) ; \n} \n} \ncatch ( BZip2ReadException ioe ) { \nlog . warn ( \"Nexrad2IOSP.uncompress \" + raf . getLocation ( ) , ioe ) ; \n} \nreturn out ; \n} \n} \n"}
{"5137": "public class Nidsheader { \nprotected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { \nif ( dataType == DataType . BYTE ) { \nreturn barray ; \n} \nif ( dataType == DataType . CHAR ) { \nreturn IospHelper . convertByteToChar ( barray ) ; \n} \nByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; \nif ( byteOrder >= 0 ) { \nbbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; \n} \nif ( dataType == DataType . SHORT ) { \nShortBuffer tbuff = bbuff . asShortBuffer ( ) ; \nshort [ ] pa = new short [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . INT ) { \nIntBuffer tbuff = bbuff . asIntBuffer ( ) ; \nint [ ] pa = new int [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . FLOAT ) { \nFloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; \nfloat [ ] pa = new float [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . DOUBLE ) { \nDoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; \ndouble [ ] pa = new double [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"5138": "public class DapController { \nprotected void doDMR ( DapRequest drq , DapContext cxt ) throws IOException { \nString realpath = getResourcePath ( drq , drq . getDatasetPath ( ) ) ; \nDSP dsp = DapCache . open ( realpath , cxt ) ; \nDapDataset dmr = dsp . getDMR ( ) ; \nByteOrder order = ( ByteOrder ) cxt . get ( Dap4Util . DAP4ENDIANTAG ) ; \nsetEndianness ( dmr , order ) ; \nCEConstraint ce = null ; \nString sce = drq . queryLookup ( DapProtocol . CONSTRAINTTAG ) ; \nce = CEConstraint . compile ( sce , dmr ) ; \nsetConstraint ( dmr , ce ) ; \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter pw = new PrintWriter ( sw ) ; \nDMRPrinter dapprinter = new DMRPrinter ( dmr , ce , pw , drq . getFormat ( ) ) ; \nif ( cxt . get ( Dap4Util . DAP4TESTTAG ) != null ) { \ndapprinter . testprint ( ) ; \n} \nelse { \ndapprinter . print ( ) ; \n} \npw . close ( ) ; \nsw . close ( ) ; \nString sdmr = sw . toString ( ) ; \nif ( DEBUG ) { \nSystem . err . println ( \"Sending: DMR:\\n\" + sdmr ) ; \n} \naddCommonHeaders ( drq ) ; \nOutputStream out = drq . getOutputStream ( ) ; \nChunkWriter cw = new ChunkWriter ( out , RequestMode . DMR , order ) ; \ncw . cacheDMR ( sdmr ) ; \ncw . close ( ) ; \n} \n} \n"}
{"5140": "public class DapController { \nprotected void senderror ( DapRequest drq , int httpcode , Throwable t ) throws IOException { \nif ( httpcode == 0 ) { \nhttpcode = HttpServletResponse . SC_BAD_REQUEST ; \n} \nErrorResponse err = new ErrorResponse ( ) ; \nerr . setCode ( httpcode ) ; \nif ( t == null ) { \nerr . setMessage ( \"Servlet error: \" + drq . getURL ( ) ) ; \n} \nelse { \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter p = new PrintWriter ( sw ) ; \nt . printStackTrace ( p ) ; \np . close ( ) ; \nsw . close ( ) ; \nerr . setMessage ( sw . toString ( ) ) ; \n} \nerr . setContext ( drq . getURL ( ) ) ; \nString errormsg = err . buildXML ( ) ; \ndrq . getResponse ( ) . sendError ( httpcode , errormsg ) ; \n} \n} \n"}
{"5142": "public class Rubberband { \npublic void stretch ( Point p ) { \nlastPt . x = stretchedPt . x ; \nlastPt . y = stretchedPt . y ; \nstretchedPt . x = p . x ; \nstretchedPt . y = p . y ; \nGraphics2D g = ( Graphics2D ) component . getGraphics ( ) ; \nif ( g != null ) { \ntry { \ng . setXORMode ( component . getBackground ( ) ) ; \nif ( firstStretch == true ) { \nfirstStretch = false ; \n} \nelse { \ndrawLast ( g ) ; \n} \ndrawNext ( g ) ; \n} \nfinally { \ng . dispose ( ) ; \n} \n} \n} \n} \n"}
{"5147": "public class ErddapMath2 { \npublic static void ensureArraySizeOkay ( long tSize , String attributeTo ) { \nif ( tSize >= Integer . MAX_VALUE ) { \nthrow new RuntimeException ( memoryTooMuchData + \"  \" + MessageFormat . format ( memoryArraySize , \"\" + tSize , \"\" + Integer . MAX_VALUE ) + ( attributeTo == null || attributeTo . length ( ) == 0 ? \"\" : \" (\" + attributeTo + \")\" ) ) ; \n} \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) { \nwrt = ENTITYESCAPES ; \n} \nStringBuilder escaped = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nint index = wrt . indexOf ( c ) ; \nif ( index < 0 ) { \nescaped . append ( c ) ; \n} \nelse { \nswitch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( c >= ' ' ) { \nescaped . append ( c ) ; \n} \nbreak ; \n} \n} \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \n) { \nchar c = s . charAt ( i ++ ) ; \nif ( c == '\\\\' ) { \nc = s . charAt ( i ++ ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \nelse { \nclear . append ( c ) ; \n} \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \ni <= len - 1 ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && i < ( len - 1 ) ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \nelse if ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse { \npiece . append ( c ) ; \n} \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5162": "public class Fmrc { \nprivate FmrcInv makeFmrcInv ( Formatter debug ) throws IOException { \ntry { \nMap < CalendarDate , FmrInv > fmrMap = new HashMap < > ( ) ; \nList < FmrInv > fmrList = new ArrayList < > ( ) ; \nfor ( MFile f : manager . getFilesSorted ( ) ) { \nMap < String , String > filesRunDateMap = ( ( MFileCollectionManager ) manager ) . getFilesRunDateMap ( ) ; \nCalendarDate runDate ; \nif ( ! filesRunDateMap . isEmpty ( ) ) { \nrunDate = CalendarDate . parseISOformat ( null , filesRunDateMap . get ( f . getPath ( ) ) ) ; \nElement element = new Element ( \"netcdf\" , ncNSHttps ) ; \nElement runDateAttr = ncmlWriter . makeAttributeElement ( new Attribute ( _Coordinate . ModelRunDate , runDate . toString ( ) ) ) ; \nconfig . innerNcml = element . addContent ( runDateAttr ) ; \n} \nGridDatasetInv inv ; \ntry { \ninv = GridDatasetInv . open ( manager , f , config . innerNcml ) ; \n} \ncatch ( IOException ioe ) { \nlogger . warn ( \"Error opening \" + f . getPath ( ) + \"(skipped)\" , ioe ) ; \ncontinue ; \n} \nrunDate = inv . getRunDate ( ) ; \nif ( debug != null ) { \ndebug . format ( \"  opened %s rundate = %s%n\" , f . getPath ( ) , inv . getRunDateString ( ) ) ; \n} \nFmrInv fmr = fmrMap . get ( runDate ) ; \nif ( fmr == null ) { \nfmr = new FmrInv ( runDate ) ; \nfmrMap . put ( runDate , fmr ) ; \nfmrList . add ( fmr ) ; \n} \nfmr . addDataset ( inv , debug ) ; \n} \nif ( debug != null ) { \ndebug . format ( \"%n\" ) ; \n} \nCollections . sort ( fmrList ) ; \nfor ( FmrInv fmr : fmrList ) { \nfmr . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Fmrc:\" + config . name + \": made fmr with rundate=\" + fmr . getRunDate ( ) + \" nfiles= \" + fmr . getFiles ( ) . size ( ) ) ; \n} \n} \nreturn new FmrcInv ( \"fmrc:\" + manager . getCollectionName ( ) , fmrList , config . fmrcConfig . regularize ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"makeFmrcInv\" , t ) ; \nthrow new RuntimeException ( t ) ; \n} \n} \n} \n"}
{"5163": "public class LogCategorizer { \nstatic public String getServiceSpecial ( String path ) { \nString ss = null ; \nif ( path . startsWith ( \"/dqcServlet\" ) ) { \nss = \"dqcServlet\" ; \n} \nelse if ( path . startsWith ( \"/cdmvalidator\" ) ) { \nss = \"cdmvalidator\" ; \n} \nreturn ss ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nint comp ; \nif ( constrained ) { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nif ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) { \ncomp ++ ; \n} \n} \n} \nelse { \ncomp = 1 + mapVars . size ( ) ; \n} \nreturn comp ; \n} \n} \n"}
{"5166": "public class ArrayStructureBBsection { \nstatic public ArrayStructureBB factory ( ArrayStructureBB org , Section section ) { \nif ( section == null || section . computeSize ( ) == org . getSize ( ) ) { \nreturn org ; \n} \nreturn new ArrayStructureBBsection ( org . getStructureMembers ( ) , org . getShape ( ) , org . getByteBuffer ( ) , section ) ; \n} \n} \n"}
{"5170": "public class M3IOConvention { \nprivate CoordinateTransform makeUTMProjection ( NetcdfDataset ds ) { \nint zone = ( int ) findAttributeDouble ( ds , \"P_ALP\" ) ; \ndouble ycent = findAttributeDouble ( ds , \"YCENT\" ) ; \nboolean isNorth = true ; \nif ( ycent < 0 ) { \nisNorth = false ; \n} \nUtmProjection utm = new UtmProjection ( zone , isNorth ) ; \nreturn new ProjectionCT ( \"UTM\" , \"EPSG\" , utm ) ; \n} \n} \n"}
{"5172": "public class DateType { \npublic boolean before ( Date d ) { \nif ( isPresent ( ) ) { \nreturn false ; \n} \nreturn date . isBefore ( CalendarDate . of ( d ) ) ; \n} \n} \n"}
{"5173": "public class DateType { \npublic boolean before ( DateType d ) { \nif ( d . isPresent ( ) ) { \nreturn true ; \n} \nif ( isPresent ( ) ) { \nreturn false ; \n} \nreturn date . isBefore ( d . getCalendarDate ( ) ) ; \n} \n} \n"}
{"5174": "public class DateType { \npublic boolean after ( Date d ) { \nif ( isPresent ( ) ) { \nreturn true ; \n} \nreturn date . isAfter ( CalendarDate . of ( d ) ) ; \n} \n} \n"}
{"5176": "public class EnhancementsImpl { \npublic void addCoordinateSystem ( CoordinateSystem cs ) { \nif ( cs == null ) { \nthrow new RuntimeException ( \"Attempted to add null CoordinateSystem to var \" + forVar . getFullName ( ) ) ; \n} \nif ( coordSys == null ) { \ncoordSys = new ArrayList < > ( 5 ) ; \n} \ncoordSys . add ( cs ) ; \n} \n} \n"}
{"5178": "public class EnhancementsImpl { \npublic String getUnitsString ( ) { \nString result = units ; \nif ( ( result == null ) && ( forVar != null ) ) { \nAttribute att = forVar . findAttribute ( CDM . UNITS ) ; \nif ( att == null ) { \natt = forVar . findAttributeIgnoreCase ( CDM . UNITS ) ; \n} \nif ( ( att != null ) && att . isString ( ) ) { \nresult = att . getStringValue ( ) ; \n} \n} \nreturn ( result == null ) ? null : result . trim ( ) ; \n} \n} \n"}
{"5179": "public class ConfigCatalogInitialization { \npublic synchronized void init ( ReadMode readMode , PreferencesExt prefs ) { \nif ( readMode == null ) { \nreadMode = defaultReadMode ; \n} \nthis . prefs = prefs ; \ntrackerNumber = prefs . getLong ( \"trackerNumber\" , 1 ) ; \nnumberCatalogs = prefs . getInt ( \"numberCatalogs\" , 10 ) ; \nnextCatId = prefs . getLong ( \"nextCatId\" , 1 ) ; \nmakeDebugActions ( ) ; \nthis . contentRootPath = this . tdsContext . getThreddsDirectory ( ) ; \nthis . contextPath = tdsContext . getContextPath ( ) ; \nreread ( readMode , true ) ; \n} \n} \n"}
{"5180": "public class ConfigCatalogInitialization { \nprivate ConfigCatalog readCatalog ( String catalogRelPath , String catalogFullPath ) { \nURI uri ; \ntry { \nuri = new URI ( this . contextPath + \"/catalog/\" + catalogRelPath ) ; \n} \ncatch ( URISyntaxException e ) { \nlogCatalogInit . error ( ERROR + \"readCatalog(): URISyntaxException=\" + e . getMessage ( ) ) ; \nreturn null ; \n} \nConfigCatalogBuilder builder = new ConfigCatalogBuilder ( ) ; \ntry { \nlogCatalogInit . info ( \"-------readCatalog(): path=\" + catalogRelPath ) ; \nConfigCatalog cat = ( ConfigCatalog ) builder . buildFromLocation ( catalogFullPath , uri ) ; \nif ( builder . hasFatalError ( ) ) { \nlogCatalogInit . error ( ERROR + \"   invalid catalog -- \" + builder . getErrorMessage ( ) ) ; \nreturn null ; \n} \nif ( builder . getErrorMessage ( ) . length ( ) > 0 ) { \nlogCatalogInit . debug ( builder . getErrorMessage ( ) ) ; \n} \nreturn cat ; \n} \ncatch ( Throwable t ) { \nlogCatalogInit . error ( ERROR + \"  Exception on catalog=\" + catalogFullPath + \" \" + t . getMessage ( ) + \"\\n log=\" + builder . getErrorMessage ( ) , t ) ; \nreturn null ; \n} \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) { \nreturn ; \n} \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) { \ncountDatasets ++ ; \n} \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) { \nexceedLimit = true ; \n} \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) { \ncontinue ; \n} \nif ( ds instanceof CatalogScan ) { \ncontinue ; \n} \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n} \n"}
{"5182": "public class ConfigCatalogInitialization { \nprivate void readCatsInDirectory ( ReadMode readMode , String dirPath , Path directory ) throws IOException { \nif ( exceedLimit ) { \nreturn ; \n} \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( directory , \"*.xml\" ) ) { \nfor ( Path p : ds ) { \nif ( ! Files . isDirectory ( p ) ) { \nString filename = p . getFileName ( ) . toString ( ) ; \nString path = dirPath . length ( ) == 0 ? filename : dirPath + \"/\" + filename ; \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \n} \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( directory ) ) { \nfor ( Path dir : ds ) { \nif ( Files . isDirectory ( dir ) ) { \nString dirPathChild = dirPath + \"/\" + dir . getFileName ( ) . toString ( ) ; \nreadCatsInDirectory ( readMode , dirPathChild , dir ) ; \n} \n} \n} \n} \n} \n"}
{"5184": "public class LatLonPointImpl { \nstatic public String latToString ( double lat , int ndec ) { \nboolean is_north = ( lat >= 0.0 ) ; \nif ( ! is_north ) { \nlat = - lat ; \n} \nString f = \"%.\" + ndec + \"f\" ; \nFormatter latBuff = new Formatter ( ) ; \nlatBuff . format ( f , lat ) ; \nlatBuff . format ( \"%s\" , is_north ? \"N\" : \"S\" ) ; \nreturn latBuff . toString ( ) ; \n} \n} \n"}
{"5185": "public class LatLonPointImpl { \nstatic public String lonToString ( double lon , int ndec ) { \ndouble wlon = lonNormal ( lon ) ; \nboolean is_east = ( wlon >= 0.0 ) ; \nif ( ! is_east ) { \nwlon = - wlon ; \n} \nString f = \"%.\" + ndec + \"f\" ; \nFormatter latBuff = new Formatter ( ) ; \nlatBuff . format ( f , wlon ) ; \nlatBuff . format ( \"%s\" , is_east ? \"E\" : \"W\" ) ; \nreturn latBuff . toString ( ) ; \n} \n} \n"}
{"5188": "public class CatalogTreeView { \npublic void setSelectedDataset ( Dataset ds ) { \nif ( ds == null ) { \nreturn ; \n} \nTreePath path = makePath ( ds ) ; \nif ( path == null ) { \nreturn ; \n} \ntree . setSelectionPath ( path ) ; \ntree . scrollPathToVisible ( path ) ; \n} \n} \n"}
{"5190": "public class CatalogTreeView { \npublic void openAll ( boolean includeCatref ) { \nif ( catalog == null ) { \nreturn ; \n} \nopen ( ( InvCatalogTreeNode ) model . getRoot ( ) , includeCatref ) ; \ntree . repaint ( ) ; \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) { \nreturn ; \n} \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \nSystem . out . println ( \"*** catalog/showJTree =\" ) ; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \nSystem . out . println ( \"*** \" ) ; \n} \nint pos = catalogName . indexOf ( '#' ) ; \nif ( pos >= 0 ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \n} \n} \n"}
{"5193": "public class GDVConvention { \nprivate String findAlias ( NetcdfDataset ds , Variable v ) { \nString alias = ds . findAttValueIgnoreCase ( v , \"coord_axis\" , null ) ; \nif ( alias == null ) { \nalias = ds . findAttValueIgnoreCase ( v , \"coord_alias\" , \"\" ) ; \n} \nreturn alias ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) { \nbuffer [ i ] = ( char ) ( b & 0x7F ) ; \n} \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse { \nbuffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n} \n"}
{"5198": "public class StructureMembers { \npublic void addMember ( Member m ) { \nmembers . add ( m ) ; \nif ( memberHash != null ) { \nmemberHash . put ( m . getName ( ) , m ) ; \n} \n} \n} \n"}
{"5199": "public class StructureMembers { \npublic int hideMember ( Member m ) { \nif ( m == null ) { \nreturn - 1 ; \n} \nint index = members . indexOf ( m ) ; \nmembers . remove ( m ) ; \nif ( memberHash != null ) { \nmemberHash . remove ( m . getName ( ) ) ; \n} \nreturn index ; \n} \n} \n"}
{"5201": "public class StructureMembers { \npublic Member findMember ( String memberName ) { \nif ( memberName == null ) { \nreturn null ; \n} \nif ( memberHash == null ) { \nint initial_capacity = ( int ) ( members . size ( ) / .75 ) + 1 ; \nmemberHash = new HashMap < > ( initial_capacity ) ; \nfor ( Member m : members ) memberHash . put ( m . getName ( ) , m ) ; \n} \nreturn memberHash . get ( memberName ) ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) { \nreturn ; \n} \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) { \nvisible [ aModelIndex ] = true ; \n} \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) { \nif ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse { \ntc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) { \nreturn ; \n} \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) { \nacts [ colno ] . addAtPos ( pos ) ; \n} \nelse { \nacts [ colno ] . hideColumn ( ) ; \n} \n} \n} \n"}
{"5204": "public class JTreeTableSorted { \npublic Iterator getSelectedRows ( ) { \nTreePath [ ] paths = table . getSelectionPaths ( ) ; \nif ( ( paths == null ) || ( paths . length < 1 ) ) { \nreturn null ; \n} \nHashSet set = new HashSet ( 2 * paths . length ) ; \nfor ( TreePath path : paths ) { \nmodel . addRowsToSetFromPath ( table . getTree ( ) , path , set ) ; \n} \nreturn set . iterator ( ) ; \n} \n} \n"}
{"5206": "public class StructureDataW { \npublic Array getArray ( StructureMembers . Member m ) { \nif ( m == null ) { \nthrow new IllegalArgumentException ( \"member is null\" ) ; \n} \nreturn memberData . get ( m ) ; \n} \n} \n"}
{"5221": "public class DIFWriter { \npublic void doOneDataset ( InvDataset ds ) { \nif ( debug ) { \nSystem . out . println ( \"doDataset \" + ds . getName ( ) ) ; \n} \nif ( isDatasetUseable ( ds , messBuffer ) ) { \nString id = StringUtil2 . replace ( ds . getID ( ) , \"/\" , \"-\" ) ; \nString fileOutName = fileDir + \"/\" + id + \".dif.xml\" ; \ntry { \nOutputStream out = new BufferedOutputStream ( new FileOutputStream ( fileOutName ) ) ; \nwriteOneEntry ( ds , out , messBuffer ) ; \nout . close ( ) ; \nmessBuffer . append ( \" OK on Write\\n\" ) ; \n} \ncatch ( IOException ioe ) { \nmessBuffer . append ( \"DIFWriter failed on write \" + ioe . getMessage ( ) + \"\\n\" ) ; \nlog . error ( \"DIFWriter failed on write \" + ioe . getMessage ( ) , ioe ) ; \n} \n} \n} \n} \n"}
{"5222": "public class DIFWriter { \npublic boolean isDatasetUseable ( InvDataset ds , StringBuilder sbuff ) { \nboolean ok = true ; \nsbuff . append ( \"Dataset \" + ds . getName ( ) + \" id = \" + ds . getID ( ) + \": \" ) ; \nif ( ! ds . isHarvest ( ) ) { \nok = false ; \nsbuff . append ( \"Dataset \" + ds . getName ( ) + \" id = \" + ds . getID ( ) + \" has harvest = false\\n\" ) ; \n} \nif ( ds . getName ( ) == null ) { \nok = false ; \nsbuff . append ( \" missing Name field\\n\" ) ; \n} \nif ( ds . getUniqueID ( ) == null ) { \nok = false ; \nsbuff . append ( \" missing ID field\\n\" ) ; \n} \nThreddsMetadata . Variables vs = ds . getVariables ( \"DIF\" ) ; \nif ( ( vs == null ) || ( vs . getVariableList ( ) . size ( ) == 0 ) ) { \nvs = ds . getVariables ( \"GRIB-1\" ) ; \n} \nif ( ( vs == null ) || ( vs . getVariableList ( ) . size ( ) == 0 ) ) { \nvs = ds . getVariables ( \"GRIB-2\" ) ; \n} \nif ( ( vs == null ) || ( vs . getVariableList ( ) . size ( ) == 0 ) ) { \nok = false ; \nsbuff . append ( \" missing Variables with DIF or GRIB compatible vocabulary\\n\" ) ; \n} \nList list = ds . getPublishers ( ) ; \nif ( ( list == null ) || ( list . size ( ) == 0 ) ) { \nok = false ; \nsbuff . append ( \" must have publisher element that defines the data center\\n\" ) ; \n} \nString summary = ds . getDocumentation ( \"summary\" ) ; \nif ( summary == null ) { \nok = false ; \nsbuff . append ( \" must have documentation element of type summary\\n\" ) ; \n} \nsbuff . append ( \" useable= \" + ok + \"\\n\" ) ; \nreturn ok ; \n} \n} \n"}
{"5224": "public class DatasetBuilder { \npublic void transferMetadata ( DatasetNode from , boolean parentsAlso ) { \nif ( parentsAlso ) { \nThreddsMetadata inherit = getInheritableMetadata ( ) ; \ninheritMetadata ( from , inherit . getFlds ( ) ) ; \n} \nfor ( Map . Entry < String , Object > entry : from . getFldIterator ( ) ) { \nif ( parentsAlso && entry . getKey ( ) . equals ( Dataset . ThreddsMetadataInheritable ) ) { \ncontinue ; \n} \nif ( Dataset . listFlds . contains ( entry . getKey ( ) ) ) { \naddToNewList ( flds , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nelse { \nflds . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nThreddsMetadata tmiOld = ( ThreddsMetadata ) get ( Dataset . ThreddsMetadataInheritable ) ; \nif ( tmiOld != null && tmiOld . isImmutable ( ) ) { \nThreddsMetadata tmiNew = new ThreddsMetadata ( tmiOld ) ; \nflds . put ( Dataset . ThreddsMetadataInheritable , tmiNew ) ; \n} \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nint count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \nfor ( int j = 0 ; \nj < nlevels ; \nj ++ ) { \nf . format ( \"   \" ) ; \nfor ( int i = 0 ; \ni < ntimes ; \ni ++ ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) { \ncount ++ ; \n} \ntotal ++ ; \n} \nf . format ( \"%n\" ) ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nint count = 0 ; \nint total = recordTracker . length ; \nfor ( int i = 0 ; \ni < total ; \ni ++ ) { \nif ( recordTracker [ i ] == null ) { \ncount ++ ; \n} \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5230": "public class GridVariable { \npublic String dump ( ) { \nDateFormatter formatter = new DateFormatter ( ) ; \nFormatter sbuff = new Formatter ( ) ; \nsbuff . format ( \"%s %d %n\" , name , records . size ( ) ) ; \nfor ( GridRecord record : records ) { \nsbuff . format ( \" level = %d %f\" , record . getLevelType1 ( ) , record . getLevel1 ( ) ) ; \nif ( null != record . getValidTime ( ) ) { \nsbuff . format ( \" time = %s\" , formatter . toDateTimeString ( record . getValidTime ( ) ) ) ; \n} \nsbuff . format ( \"%n\" ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5231": "public class GridVariable { \nprotected String makeLongName ( ) { \nFormatter f = new Formatter ( ) ; \nGridParameter param = lookup . getParameter ( firstRecord ) ; \nif ( param == null ) { \nreturn null ; \n} \nf . format ( \"%s\" , param . getDescription ( ) ) ; \nString levelName = makeLevelName ( firstRecord , lookup ) ; \nif ( levelName . length ( ) != 0 ) { \nf . format ( \" @ %s\" , levelName ) ; \n} \nreturn f . toString ( ) ; \n} \n} \n"}
{"5232": "public class CoverageCoordAxis1D { \npublic Optional < CoverageCoordAxis > subsetByIntervals ( List < MAMath . MinMax > lonIntvs , int stride ) { \nif ( axisType != AxisType . Lon ) { \nreturn Optional . empty ( \"subsetByIntervals only for longitude\" ) ; \n} \nif ( ! isRegular ( ) ) { \nreturn Optional . empty ( \"subsetByIntervals only for regular longitude\" ) ; \n} \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \ndouble start = Double . NaN ; \nboolean first = true ; \nList < RangeIterator > ranges = new ArrayList < > ( ) ; \nfor ( MAMath . MinMax lonIntv : lonIntvs ) { \nif ( first ) { \nstart = lonIntv . min ; \n} \nfirst = false ; \nOptional < RangeIterator > opt = helper . makeRange ( lonIntv . min , lonIntv . max , stride ) ; \nif ( ! opt . isPresent ( ) ) { \nreturn Optional . empty ( opt . getErrorMessage ( ) ) ; \n} \nranges . add ( opt . get ( ) ) ; \n} \ntry { \nRangeComposite compositeRange = new RangeComposite ( AxisType . Lon . toString ( ) , ranges ) ; \nint npts = compositeRange . length ( ) ; \ndouble end = start + npts * resolution ; \nCoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder ( this ) ; \nbuilder . subset ( npts , start , end , resolution , null ) ; \nbuilder . setRange ( null ) ; \nbuilder . setCompositeRange ( compositeRange ) ; \nreturn Optional . of ( new CoverageCoordAxis1D ( builder ) ) ; \n} \ncatch ( InvalidRangeException e ) { \nreturn Optional . empty ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) { \nreturn true ; \n} \nif ( b1 == null || b2 == null ) { \nreturn false ; \n} \nif ( b1 . length < len || b2 . length < len ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( b1 [ i ] != b2 [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5234": "public class AbstractDSP { \nprotected DapDataset parseDMR ( String document ) throws DapException { \nDap4Parser parser ; \nparser = new DOM4Parser ( null ) ; \nif ( PARSEDEBUG ) { \nparser . setDebugLevel ( 1 ) ; \n} \ntry { \nif ( ! parser . parse ( document ) ) { \nthrow new DapException ( \"DMR Parse failed\" ) ; \n} \n} \ncatch ( SAXException se ) { \nthrow new DapException ( se ) ; \n} \nif ( parser . getErrorResponse ( ) != null ) { \nthrow new DapException ( \"Error Response Document not supported\" ) ; \n} \nDapDataset result = parser . getDMR ( ) ; \nprocessAttributes ( result ) ; \nreturn result ; \n} \n} \n"}
{"5235": "public class AbstractDSP { \nprotected void processAttributes ( DapDataset dataset ) throws DapException { \nList < DapNode > nodes = dataset . getNodeList ( ) ; \nfor ( DapNode node : nodes ) { \nswitch ( node . getSort ( ) ) { \ncase GROUP : case DATASET : case VARIABLE : Map < String , DapAttribute > attrs = node . getAttributes ( ) ; \nif ( attrs . size ( ) > 0 ) { \nList < DapAttribute > suppressed = new ArrayList < > ( ) ; \nfor ( DapAttribute dattr : attrs . values ( ) ) { \nif ( suppress ( dattr . getShortName ( ) ) ) { \nsuppressed . add ( dattr ) ; \n} \n} \nfor ( DapAttribute dattr : suppressed ) { \nnode . removeAttribute ( dattr ) ; \n} \n} \nbreak ; \ndefault : break ; \n} \n} \ngetEndianAttribute ( dataset ) ; \n} \n} \n"}
{"5236": "public class CoordinatePartitionUnionizer { \npublic void addCoords ( List < Coordinate > coords , PartitionCollectionMutable . Partition part ) { \nCoordinate runtime = null ; \nfor ( Coordinate coord : coords ) { \nswitch ( coord . getType ( ) ) { \ncase runtime : CoordinateRuntime rtime = ( CoordinateRuntime ) coord ; \nif ( runtimeBuilder == null ) { \nruntimeBuilder = new CoordinateRuntime . Builder2 ( rtime . getTimeUnits ( ) ) ; \n} \nruntimeBuilder . addAll ( coord ) ; \nruntime = coord ; \nif ( debugPartitionErrors && ! duplicateRuntimeMessage && part != null ) { \ntestDuplicateRuntime ( rtime , part ) ; \n} \nbreak ; \ncase time : CoordinateTime time = ( CoordinateTime ) coord ; \nif ( timeBuilder == null ) { \ntimeBuilder = new CoordinateTime . Builder2 ( coord . getCode ( ) , time . getTimeUnit ( ) , time . getRefDate ( ) ) ; \n} \ntimeBuilder . addAll ( coord ) ; \nbreak ; \ncase timeIntv : CoordinateTimeIntv timeIntv = ( CoordinateTimeIntv ) coord ; \nif ( timeIntvBuilder == null ) { \ntimeIntvBuilder = new CoordinateTimeIntv . Builder2 ( null , coord . getCode ( ) , timeIntv . getTimeUnit ( ) , timeIntv . getRefDate ( ) ) ; \n} \ntimeIntvBuilder . addAll ( intervalFilter ( ( CoordinateTimeIntv ) coord ) ) ; \nbreak ; \ncase time2D : CoordinateTime2D time2D = ( CoordinateTime2D ) coord ; \nif ( time2DBuilder == null ) { \ntime2DBuilder = new CoordinateTime2DUnionizer ( time2D . isTimeInterval ( ) , time2D . getTimeUnit ( ) , coord . getCode ( ) , false , logger ) ; \n} \ntime2DBuilder . addAll ( time2D ) ; \nCoordinateRuntime runtimeFrom2D = time2D . getRuntimeCoordinate ( ) ; \nif ( ! runtimeFrom2D . equals ( runtime ) ) { \nlogger . warn ( \"HEY CoordinateUnionizer runtimes not equal\" ) ; \n} \nbreak ; \ncase ens : if ( ensBuilder == null ) { \nensBuilder = new CoordinateEns . Builder2 ( coord . getCode ( ) ) ; \n} \nensBuilder . addAll ( coord ) ; \nbreak ; \ncase vert : CoordinateVert vertCoord = ( CoordinateVert ) coord ; \nif ( vertBuilder == null ) { \nvertBuilder = new CoordinateVert . Builder2 ( coord . getCode ( ) , vertCoord . getVertUnit ( ) ) ; \n} \nvertBuilder . addAll ( coord ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) { \nthrow new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \n} \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < nlats ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \ni < nyRaw ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex ++ ; \n} \nelse { \nuseIndex -- ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) { \nSystem . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \n} \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) { \nthrow new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \n} \nif ( v . getDataType ( ) == DataType . SEQUENCE ) { \nindexSelect = null ; \n} \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nint row = rectIndex [ 0 ] ; \nint minrow = Math . max ( row - 1 , 0 ) ; \nint maxrow = Math . min ( row + 1 , nrows ) ; \nint col = rectIndex [ 1 ] ; \nint mincol = Math . max ( col - 1 , 0 ) ; \nint maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) { \nSystem . out . printf ( \"%n   box9:\" ) ; \n} \nfor ( int i = minrow ; \ni <= maxrow ; \ni ++ ) { \nfor ( int j = mincol ; \nj <= maxcol ; \nj ++ ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"5241": "public class HTTPMethod { \npublic synchronized void close ( ) { \nif ( closed ) { \nreturn ; \n} \nclosed = true ; \nif ( methodstream != null ) { \ntry { \nthis . methodstream . close ( ) ; \n} \ncatch ( IOException ioe ) { \n} \nthis . methodstream = null ; \n} \nif ( this . lastresponse != null ) { \nif ( false ) { \ntry { \ntry { \nEntityUtils . consume ( this . lastresponse . getEntity ( ) ) ; \n} \nfinally { \nHttpClientUtils . closeQuietly ( this . lastresponse ) ; \n} \n} \ncatch ( IOException ignore ) { \n} \n} \nelse { \nHttpClientUtils . closeQuietly ( this . lastresponse ) ; \n} \nthis . lastresponse = null ; \n} \nif ( session != null ) { \nsession . removeMethod ( this ) ; \nif ( localsession ) { \nsession . close ( ) ; \nsession = null ; \n} \n} \nthis . lastrequest = null ; \n} \n} \n"}
{"5242": "public class HTTPMethod { \npublic int execute ( ) throws HTTPException { \nHttpResponse res = executeRaw ( ) ; \nif ( res != null ) { \nreturn res . getStatusLine ( ) . getStatusCode ( ) ; \n} \nelse { \nthrow new HTTPException ( \"HTTPMethod.execute: null response\" ) ; \n} \n} \n} \n"}
{"5243": "public class CFpointObs { \nprotected boolean identifyEncodingStation ( NetcdfDataset ds , EncodingInfo info , CF . FeatureType ftype , Formatter errlog ) { \nDimension obsDim = null ; \nif ( info . time . getRank ( ) > 0 ) { \nobsDim = info . time . getDimension ( info . time . getRank ( ) - 1 ) ; \n} \nelse if ( info . time . getParentStructure ( ) != null ) { \nStructure parent = info . time . getParentStructure ( ) ; \nobsDim = parent . getDimension ( parent . getRank ( ) - 1 ) ; \n} \nif ( obsDim == null ) { \nerrlog . format ( \"CFpointObs: must have a non-scalar Time coordinate%n\" ) ; \nreturn false ; \n} \nif ( info . lat . getRank ( ) == 0 ) { \ninfo . set ( Encoding . single , null , obsDim ) ; \nreturn true ; \n} \nDimension stnDim = info . lat . getDimension ( 0 ) ; \nif ( obsDim == stnDim ) { \ninfo . set ( Encoding . flat , null , obsDim ) ; \nreturn true ; \n} \nif ( identifyRaggeds ( ds , info , stnDim , obsDim , errlog ) ) { \nreturn true ; \n} \nif ( info . lat . getRank ( ) == 1 ) { \ninfo . set ( Encoding . multidim , stnDim , obsDim ) ; \nreturn true ; \n} \nerrlog . format ( \"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\" , ftype ) ; \nreturn false ; \n} \n} \n"}
{"5244": "public class CFpointObs { \nprotected String matchAxisTypeAndDimension ( NetcdfDataset ds , AxisType type , final Dimension outer ) { \nVariable var = CoordSysEvaluator . findCoordByType ( ds , type , new CoordSysEvaluator . Predicate ( ) { \npublic boolean match ( CoordinateAxis axis ) { \nif ( ( outer == null ) && ( axis . getRank ( ) == 0 ) ) { \nreturn true ; \n} \nif ( ( outer != null ) && ( axis . getRank ( ) == 1 ) && ( outer . equals ( axis . getDimension ( 0 ) ) ) ) { \nreturn true ; \n} \nif ( axis . getParentStructure ( ) != null ) { \nStructure parent = axis . getParentStructure ( ) ; \nif ( ( outer != null ) && ( parent . getRank ( ) == 1 ) && ( outer . equals ( parent . getDimension ( 0 ) ) ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n) ; \nif ( var == null ) { \nreturn null ; \n} \nreturn var . getFullName ( ) ; \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \n} \nelse if ( task . isError ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \n} \nelse if ( task . isCancel ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \n} \nelse { \nfireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nint i = 0 ; \nwhile ( i < u . length ( ) ) { \nchar c = u . charAt ( i ) ; \nif ( c == '\\\\' ) { \nif ( i + 1 == u . length ( ) ) { \nthrow new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \n} \nbuf . append ( \"%5c\" ) ; \ni ++ ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \nelse { \nbuf . append ( c ) ; \n} \ni ++ ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5249": "public class HTTPUtil { \nstatic URI uriExclude ( final URI uri , URIPart ... excludes ) { \nURIBuilder urib = new URIBuilder ( ) ; \nEnumSet < URIPart > set = EnumSet . of ( excludes [ 0 ] , excludes ) ; \nfor ( URIPart part : URIPart . values ( ) ) { \nif ( set . contains ( part ) ) { \ncontinue ; \n} \nswitch ( part ) { \ncase SCHEME : urib . setScheme ( uri . getScheme ( ) ) ; \nbreak ; \ncase USERINFO : urib . setUserInfo ( uri . getUserInfo ( ) ) ; \nbreak ; \ncase HOST : urib . setHost ( uri . getHost ( ) ) ; \nbreak ; \ncase PORT : urib . setPort ( uri . getPort ( ) ) ; \nbreak ; \ncase PATH : urib . setPath ( uri . getPath ( ) ) ; \nbreak ; \ncase QUERY : urib . setCustomQuery ( uri . getQuery ( ) ) ; \nbreak ; \ncase FRAGMENT : urib . setFragment ( uri . getFragment ( ) ) ; \nbreak ; \n} \n} \ntry { \nreturn urib . build ( ) ; \n} \ncatch ( URISyntaxException e ) { \nthrow new IllegalArgumentException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"5250": "public class HTTPUtil { \nstatic public String nullify ( String s ) { \nif ( s != null && s . length ( ) == 0 ) { \ns = null ; \n} \nreturn s ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) { \nprefix = \"\" ; \n} \nif ( suffix == null ) { \nsuffix = \"\" ; \n} \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nint prelen = prefix . length ( ) ; \nif ( prelen > 0 && result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen ++ ; \n} \nif ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) { \nresult . append ( suffix . substring ( 1 ) ) ; \n} \nelse { \nresult . append ( suffix ) ; \n} \nint len = result . length ( ) ; \nif ( len > 0 && result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5252": "public class LastModifiedLimitFilter { \npublic boolean accept ( CrawlableDataset dataset ) { \nDate lastModDate = dataset . lastModified ( ) ; \nif ( lastModDate != null ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( now - lastModDate . getTime ( ) > lastModifiedLimitInMillis ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5258": "public class BitCounterCompressed { \npublic int ncounters ( ) { \nif ( nested == null ) { \nreturn 1 ; \n} \nelse { \nint ncounters = 0 ; \nfor ( BitCounterCompressed [ ] counters : nested ) { \nif ( counters == null ) { \ncontinue ; \n} \nfor ( BitCounterCompressed counter : counters ) if ( counter != null ) { \nncounters += counter . ncounters ( ) ; \n} \n} \nreturn ncounters ; \n} \n} \n} \n"}
{"5261": "public class NetcdfFileWriteable { \npublic Attribute deleteGlobalAttribute ( String attName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nAttribute att = findGlobalAttribute ( attName ) ; \nif ( null == att ) { \nreturn null ; \n} \nrootGroup . remove ( att ) ; \nreturn att ; \n} \n} \n"}
{"5262": "public class NetcdfFileWriteable { \npublic Attribute renameGlobalAttribute ( String oldName , String newName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nAttribute att = findGlobalAttribute ( oldName ) ; \nif ( null == att ) { \nreturn null ; \n} \nrootGroup . remove ( att ) ; \natt = new Attribute ( newName , att . getValues ( ) ) ; \nrootGroup . addAttribute ( att ) ; \nreturn att ; \n} \n} \n"}
{"5265": "public class NetcdfFileWriteable { \npublic Attribute deleteVariableAttribute ( String varName , String attName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nVariable v = findVariable ( varName ) ; \nif ( v == null ) { \nreturn null ; \n} \nAttribute att = v . findAttribute ( attName ) ; \nif ( null == att ) { \nreturn null ; \n} \nv . remove ( att ) ; \nreturn att ; \n} \n} \n"}
{"5266": "public class NetcdfFileWriteable { \npublic Attribute renameVariableAttribute ( String varName , String attName , String newName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nVariable v = findVariable ( varName ) ; \nif ( v == null ) { \nreturn null ; \n} \nAttribute att = v . findAttribute ( attName ) ; \nif ( null == att ) { \nreturn null ; \n} \nv . remove ( att ) ; \natt = new Attribute ( newName , att . getValues ( ) ) ; \nv . addAttribute ( att ) ; \nreturn att ; \n} \n} \n"}
{"5267": "public class GempakSurfaceFileReader { \nprotected void makeFileSubType ( ) { \nKey key = findKey ( GempakStation . SLAT ) ; \nif ( key == null ) { \nthrow new IllegalStateException ( \"File does not have key=\" + GempakStation . SLAT ) ; \n} \nString latType = key . type ; \nKey dateKey = findKey ( DATE ) ; \nif ( dateKey != null && ! dateKey . type . equals ( latType ) ) { \nif ( latType . equals ( ROW ) ) { \nsubType = CLIMATE ; \n} \nelse { \nsubType = STANDARD ; \n} \n} \nelse { \nsubType = SHIP ; \n} \n} \n} \n"}
{"5268": "public class WFSGetFeatureWriter { \nprivate void writeHeadersAndBB ( ) { \nfileOutput += \"<wfs:FeatureCollection xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" + namespace + \" \" + server + \"?request=DescribeFeatureType\" + WFSXMLHelper . AMPERSAND + \"service=wfs\" + WFSXMLHelper . AMPERSAND + \"version=2.0.0\" + WFSXMLHelper . AMPERSAND + \"typename=\" + WFSController . TDSNAMESPACE + \"%3A\" + ftName ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml/3.2\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:wfs=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/wfs/2.0\" ) + \" xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\" numberMatched=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \" numberReturned=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \">\" ; \ndouble [ ] boundLower ; \ndouble [ ] boundUpper ; \nif ( geometries . isEmpty ( ) ) { \nboundLower = new double [ 2 ] ; \nboundUpper = new double [ 2 ] ; \nboundLower [ 0 ] = - 180 ; \nboundLower [ 1 ] = - 90 ; \nboundUpper [ 0 ] = 180 ; \nboundUpper [ 1 ] = 90 ; \n} \nelse { \nboundLower = geometries . get ( 0 ) . getBBLower ( ) ; \nboundUpper = geometries . get ( 0 ) . getBBUpper ( ) ; \n} \nfor ( SimpleGeometry item : geometries ) { \ndouble [ ] low = item . getBBLower ( ) ; \nif ( boundLower [ 0 ] > low [ 0 ] ) { \nboundLower [ 0 ] = low [ 0 ] ; \n} \nif ( boundLower [ 1 ] > low [ 1 ] ) { \nboundLower [ 1 ] = low [ 1 ] ; \n} \ndouble [ ] upper = item . getBBUpper ( ) ; \nif ( boundUpper [ 0 ] < upper [ 0 ] ) { \nboundUpper [ 0 ] = upper [ 0 ] ; \n} \nif ( boundUpper [ 1 ] < upper [ 1 ] ) { \nboundUpper [ 1 ] = upper [ 1 ] ; \n} \nboundLower [ 0 ] -= 10 ; \nboundLower [ 1 ] -= 10 ; \nboundUpper [ 0 ] += 10 ; \nboundUpper [ 1 ] += 10 ; \n} \nfileOutput += \"<wfs:boundedBy>\" + \"<wfs:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<wfs:lowerCorner>\" + boundLower [ 0 ] + \" \" + boundLower [ 1 ] + \"</wfs:lowerCorner>\" + \"<wfs:upperCorner>\" + boundUpper [ 0 ] + \" \" + boundUpper [ 1 ] + \"</wfs:upperCorner>\" + \"</wfs:Envelope>\" + \"</wfs:boundedBy>\" ; \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) { \nthrow new DapException ( \"Attempt to write DSR twice\" ) ; \n} \nif ( dsr == null ) { \nthrow new DapException ( \"Attempt to write empty DSR\" ) ; \n} \nint len = dsr . length ( ) ; \nwhile ( len > 0 ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) { \nbreak ; \n} \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) { \nthrow new DapException ( \"Attempt to write empty DSR\" ) ; \n} \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null || dxr8 . length == 0 ) { \nreturn ; \n} \nif ( mode == RequestMode . DMR || mode == RequestMode . DSR ) { \nstate = State . END ; \n} \nelse { \nint flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) { \nflags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \n} \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \n} \n} \n"}
{"5275": "public class ChunkWriter { \npublic void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nclosed = true ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nif ( mode == RequestMode . DMR ) { \nreturn ; \n} \nif ( chunk == null || chunk . position ( ) == 0 ) { \nreturn ; \n} \nverifystate ( ) ; \nstate = State . DATA ; \nint flags = DapUtil . CHUNK_END ; \nwriteChunk ( flags ) ; \nstate = State . END ; \nthis . output . flush ( ) ; \nif ( this . saveoutput != null ) { \nthis . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; \n} \n} \n} \n"}
{"5276": "public class ChunkWriter { \n@ Override public void flush ( ) throws IOException { \nif ( mode == RequestMode . DMR ) { \nreturn ; \n} \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \n} \n} \n"}
{"5278": "public class Range { \npublic boolean contains ( int want ) { \nif ( want < first ( ) ) { \nreturn false ; \n} \nif ( want > last ( ) ) { \nreturn false ; \n} \nif ( stride == 1 ) { \nreturn true ; \n} \nreturn ( want - first ) % stride == 0 ; \n} \n} \n"}
{"5279": "public class Range { \npublic int element ( int i ) throws InvalidRangeException { \nif ( i < 0 ) { \nthrow new InvalidRangeException ( \"i must be >= 0\" ) ; \n} \nif ( i >= length ) { \nthrow new InvalidRangeException ( \"i must be < length\" ) ; \n} \nreturn first + i * stride ; \n} \n} \n"}
{"5280": "public class Range { \npublic Range shiftOrigin ( int origin ) throws InvalidRangeException { \nif ( this == VLEN ) { \nreturn VLEN ; \n} \nint first = first ( ) - origin ; \nint last = last ( ) - origin ; \nreturn new Range ( name , first , last , stride ) ; \n} \n} \n"}
{"5284": "public class CatalogTracker { \npublic Iterable < ? extends CatalogExt > getCatalogs ( ) { \nif ( catalogs == null ) { \nreadCatalogs ( ) ; \n} \nList < CatalogExt > result = new ArrayList < > ( ) ; \nfor ( CatalogExt ext : catalogs . values ( ) ) result . add ( ext ) ; \nCollections . sort ( result , ( o1 , o2 ) -> o1 . getCatRelLocation ( ) . compareTo ( o2 . getCatRelLocation ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \ntnum > 0 ; \ntnum -- ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) { \nbreak ; \n} \nif ( oldDatabaseFile . delete ( ) ) { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n"}
{"5290": "public class NcssGridController { \nprivate void checkRequestedVars ( CoverageCollection gcd , NcssGridParamsBean params ) throws VariableNotContainedInDatasetException { \nif ( params . getVar ( ) . get ( 0 ) . equalsIgnoreCase ( \"all\" ) ) { \nparams . setVar ( getAllGridNames ( gcd ) ) ; \nreturn ; \n} \nfor ( String gridName : params . getVar ( ) ) { \nCoverage grid = gcd . findCoverage ( gridName ) ; \nif ( grid == null ) { \nthrow new VariableNotContainedInDatasetException ( \"Variable: \" + gridName + \" is not contained in the requested dataset\" ) ; \n} \n} \n} \n} \n"}
{"5291": "public class DatasetSourceStructure { \npublic static DatasetSourceStructure getStructure ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nreturn ( DatasetSourceStructure ) hash . get ( name ) ; \n} \n} \n"}
{"5292": "public class Dap4Controller { \n@ Override public String getResourcePath ( DapRequest drq , String location ) throws DapException { \nString realpath ; \nif ( TdsRequestedDataset . getDatasetManager ( ) != null ) { \nrealpath = TdsRequestedDataset . getLocationFromRequestPath ( location ) ; \n} \nelse { \nassert TdsRequestedDataset . getDatasetManager ( ) == null ; \nString prefix = drq . getResourceRoot ( ) ; \nassert ( prefix != null ) ; \nrealpath = DapUtil . canonjoin ( prefix , location ) ; \n} \nif ( ! TESTING ) { \nif ( ! TdsRequestedDataset . resourceControlOk ( drq . getRequest ( ) , drq . getResponse ( ) , realpath ) ) { \nthrow new DapException ( \"Not authorized: \" + location ) . setCode ( DapCodes . SC_FORBIDDEN ) ; \n} \n} \nFile f = new File ( realpath ) ; \nif ( ! f . exists ( ) || ! f . canRead ( ) ) { \nthrow new DapException ( \"Not found: \" + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; \n} \nreturn realpath ; \n} \n} \n"}
{"5296": "public class InvDatasetImpl { \nprivate void transferInheritable2PublicMetadata ( InvDatasetImpl parent ) { \nif ( parent == null ) { \nreturn ; \n} \nlogger . debug ( \" inheritFromParent= \" + parent . getID ( ) ) ; \ntransfer2PublicMetadata ( parent . getLocalMetadataInheritable ( ) , true ) ; \ntransferInheritable2PublicMetadata ( ( InvDatasetImpl ) parent . getParent ( ) ) ; \n} \n} \n"}
{"5297": "public class InvDatasetImpl { \npublic void transferMetadata ( InvDatasetImpl fromDs , boolean copyInheritedMetadataFromParents ) { \nif ( fromDs == null ) { \nreturn ; \n} \nlogger . debug ( \" transferMetadata= \" + fromDs . getName ( ) ) ; \nif ( this != fromDs ) { \ngetLocalMetadata ( ) . add ( fromDs . getLocalMetadata ( ) , false ) ; \n} \ntransferInheritableMetadata ( fromDs , getLocalMetadataInheritable ( ) , copyInheritedMetadataFromParents ) ; \nsetResourceControl ( fromDs . getRestrictAccess ( ) ) ; \n} \n} \n"}
{"5298": "public class InvDatasetImpl { \nprivate void transferInheritableMetadata ( InvDatasetImpl fromDs , ThreddsMetadata target , boolean copyInheritedMetadataFromParents ) { \nif ( fromDs == null ) { \nreturn ; \n} \nlogger . debug ( \" transferInheritedMetadata= \" + fromDs . getName ( ) ) ; \ntarget . add ( fromDs . getLocalMetadataInheritable ( ) , true ) ; \nif ( copyInheritedMetadataFromParents ) { \ntransferInheritableMetadata ( ( InvDatasetImpl ) fromDs . getParent ( ) , target , true ) ; \n} \n} \n} \n"}
{"5299": "public class InvDatasetImpl { \npublic void setContributors ( List < ThreddsMetadata . Contributor > a ) { \nList < ThreddsMetadata . Contributor > dest = tm . getContributors ( ) ; \nfor ( ThreddsMetadata . Contributor item : a ) { \nif ( ! dest . contains ( item ) ) { \ndest . add ( item ) ; \n} \n} \nhashCode = 0 ; \n} \n} \n"}
{"5300": "public class InvDatasetImpl { \npublic void addDataset ( int index , InvDatasetImpl ds ) { \nif ( ds == null ) { \nreturn ; \n} \nds . setParent ( this ) ; \ndatasets . add ( index , ds ) ; \nhashCode = 0 ; \n} \n} \n"}
{"5301": "public class InvDatasetImpl { \npublic boolean removeDataset ( InvDatasetImpl ds ) { \nif ( this . datasets . remove ( ds ) ) { \nds . setParent ( null ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( ds ) ; \n} \nreturn ( true ) ; \n} \nreturn ( false ) ; \n} \n} \n"}
{"5307": "public class InvDatasetImpl { \npublic Object getUserProperty ( Object key ) { \nif ( userMap == null ) { \nreturn null ; \n} \nreturn userMap . get ( key ) ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nind < versionParts . length ; \nind ++ ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) { \nif ( versionParts [ 0 ] . equals ( \"2\" ) ) { \nvalidVersion = true ; \n} \n} \nif ( versionParts . length >= 2 ) { \nif ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) { \nvalidVersion = true ; \n} \n} \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) { \nparamNames . add ( paramNamesE . nextElement ( ) ) ; \n} \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) { \ndataset = NetcdfDataset . openDataset ( actualPath ) ; \n} \nelse { \nreturn ; \n} \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) { \nif ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5318": "public class Generator { \npublic void dataset ( DapDataset dmr ) throws DapException { \nfor ( DapVariable var : this . dmr . getTopVariables ( ) ) { \nif ( ! this . ce . references ( var ) ) { \ncontinue ; \n} \nvariable ( var ) ; \n} \n} \n} \n"}
{"5323": "public class ServletUtil { \npublic static String getRequestPath ( HttpServletRequest req ) { \nStringBuilder buff = new StringBuilder ( ) ; \nif ( req . getServletPath ( ) != null ) { \nbuff . append ( req . getServletPath ( ) ) ; \n} \nif ( req . getPathInfo ( ) != null ) { \nbuff . append ( req . getPathInfo ( ) ) ; \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5325": "public class ServletUtil { \npublic static String getParameterIgnoreCase ( HttpServletRequest req , String paramName ) { \nEnumeration e = req . getParameterNames ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nString s = ( String ) e . nextElement ( ) ; \nif ( s . equalsIgnoreCase ( paramName ) ) { \nreturn req . getParameter ( s ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5326": "public class CatalogChooser { \npublic void save ( ) { \nif ( catListBox != null ) { \ncatListBox . save ( ) ; \n} \nif ( prefs != null ) { \nif ( fileChooser != null ) { \nfileChooser . save ( ) ; \n} \nif ( catgenFileChooser != null ) { \ncatgenFileChooser . save ( ) ; \n} \nprefs . putInt ( HDIVIDER , split . getDividerLocation ( ) ) ; \n} \n} \n} \n"}
{"5328": "public class BitCounterUncompressed { \npublic void setBitOffset ( DataDescriptor dkey ) { \nif ( bitPosition == null ) { \nbitPosition = new HashMap < DataDescriptor , Integer > ( 2 * parent . getSubKeys ( ) . size ( ) ) ; \n} \nbitPosition . put ( dkey , bitOffset ) ; \nbitOffset += dkey . getBitWidth ( ) ; \n} \n} \n"}
{"5329": "public class BitCounterUncompressed { \npublic BitCounterUncompressed makeNested ( DataDescriptor subKey , int n , int row , int replicationCountSize ) { \nif ( subCounters == null ) { \nsubCounters = new HashMap < DataDescriptor , BitCounterUncompressed [ ] > ( 5 ) ; \n} \nBitCounterUncompressed [ ] subCounter = subCounters . get ( subKey ) ; \nif ( subCounter == null ) { \nsubCounter = new BitCounterUncompressed [ nrows ] ; \nsubCounters . put ( subKey , subCounter ) ; \n} \nBitCounterUncompressed rc = new BitCounterUncompressed ( subKey , n , replicationCountSize ) ; \nsubCounter [ row ] = rc ; \nreturn rc ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) { \nSystem . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \n} \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) { \ncountBits += nd . getBitWidth ( ) ; \n} \nelse { \nif ( debug ) { \nSystem . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \n} \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) { \nSystem . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) { \nthrow new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \n} \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( bb != null ) { \nstations = sobs . getStationFeatures ( bb ) ; \n} \nelse if ( names != null ) { \nstations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \n} \nelse { \nstations = sobs . getStationFeatures ( ) ; \n} \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) { \nsElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \n} \nif ( ( s . getDescription ( ) != null ) && ( s . getDescription ( ) . length ( ) > 0 ) ) { \nsElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \n} \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) { \nsElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \n} \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5333": "public class FeatureDatasetCapabilitiesWriter { \npublic Document getCapabilitiesDocument ( ) { \nElement rootElem = new Element ( \"capabilities\" ) ; \nDocument doc = new Document ( rootElem ) ; \nif ( null != path ) { \nrootElem . setAttribute ( \"location\" , path ) ; \nElement elem = new Element ( \"featureDataset\" ) ; \nFeatureType ft = fdp . getFeatureType ( ) ; \nelem . setAttribute ( \"type\" , ft . toString ( ) . toLowerCase ( ) ) ; \nString url = path . replace ( \"dataset.xml\" , ft . toString ( ) . toLowerCase ( ) + \".xml\" ) ; \nelem . setAttribute ( \"url\" , url ) ; \nrootElem . addContent ( elem ) ; \n} \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nrootElem . addContent ( writeTimeUnit ( fc . getTimeUnit ( ) ) ) ; \nrootElem . addContent ( new Element ( \"AltitudeUnits\" ) . addContent ( fc . getAltUnits ( ) ) ) ; \nList < ? extends VariableSimpleIF > vars = fdp . getDataVariables ( ) ; \nCollections . sort ( vars ) ; \nfor ( VariableSimpleIF v : vars ) { \nrootElem . addContent ( writeVariable ( v ) ) ; \n} \nLatLonRect bb = fc . getBoundingBox ( ) ; \nif ( bb != null ) { \nrootElem . addContent ( writeBoundingBox ( bb ) ) ; \n} \nCalendarDateRange dateRange = fc . getCalendarDateRange ( ) ; \nif ( dateRange != null ) { \nElement drElem = new Element ( \"TimeSpan\" ) ; \ndrElem . addContent ( new Element ( \"begin\" ) . addContent ( dateRange . getStart ( ) . toString ( ) ) ) ; \ndrElem . addContent ( new Element ( \"end\" ) . addContent ( dateRange . getEnd ( ) . toString ( ) ) ) ; \nif ( dateRange . getResolution ( ) != null ) { \ndrElem . addContent ( new Element ( \"resolution\" ) . addContent ( dateRange . getResolution ( ) . toString ( ) ) ) ; \n} \nrootElem . addContent ( drElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < getItemCount ( ) ; \ni ++ ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5337": "public class TdsErrorHandling { \n@ ExceptionHandler ( Throwable . class ) public ResponseEntity < String > handle ( Throwable ex ) throws Throwable { \nif ( AnnotationUtils . findAnnotation ( ex . getClass ( ) , ResponseStatus . class ) != null ) { \nthrow ex ; \n} \nlogger . error ( \"uncaught exception\" , ex ) ; \nHttpHeaders responseHeaders = new HttpHeaders ( ) ; \nresponseHeaders . setContentType ( MediaType . TEXT_PLAIN ) ; \nString msg = ex . getMessage ( ) ; \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter p = new PrintWriter ( sw ) ; \nex . printStackTrace ( p ) ; \np . close ( ) ; \nsw . close ( ) ; \nmsg = sw . toString ( ) ; \nreturn new ResponseEntity < > ( \"Throwable exception handled : \" + htmlEscape ( msg ) , responseHeaders , HttpStatus . INTERNAL_SERVER_ERROR ) ; \n} \n} \n"}
{"5338": "public class Odometer { \npublic Slice slice ( int i ) { \nif ( i < 0 || i >= this . rank ) { \nthrow new IllegalArgumentException ( ) ; \n} \nreturn this . slices . get ( i ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \ni >= firstpos ; \ni -- ) { \nif ( this . index . indices [ i ] > this . endpoint [ i ] ) { \nthis . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \n} \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5340": "public class NcepTables { \n@ Nullable public static Map < Integer , String > getNcepGenProcess ( ) { \nif ( genProcessMap != null ) { \nreturn genProcessMap ; \n} \nString path = \"resources/grib1/ncep/ncepTableA.xml\" ; \ntry ( InputStream is = GribResourceReader . getInputStream ( path ) ) { \nSAXBuilder builder = new SAXBuilder ( ) ; \norg . jdom2 . Document doc = builder . build ( is ) ; \nElement root = doc . getRootElement ( ) ; \nHashMap < Integer , String > result = new HashMap < > ( 200 ) ; \nList < Element > params = root . getChildren ( \"parameter\" ) ; \nfor ( Element elem1 : params ) { \nint code = Integer . parseInt ( elem1 . getAttributeValue ( \"code\" ) ) ; \nString desc = elem1 . getChildText ( \"description\" ) ; \nresult . put ( code , desc ) ; \n} \nreturn Collections . unmodifiableMap ( result ) ; \n} \ncatch ( IOException | JDOMException ioe ) { \nlogger . error ( \"Cant read NCEP Table 1 = \" + path , ioe ) ; \nreturn null ; \n} \n} \n} \n"}
{"5341": "public class CdmrFeatureDataset { \npublic static FeatureType isCdmrfEndpoint ( String endpoint ) throws IOException { \nHTTPSession httpClient = HTTPFactory . newSession ( endpoint ) ; \nString url = endpoint + \"?req=featureType\" ; \ntry ( HTTPMethod method = HTTPFactory . Get ( httpClient , url ) ) { \nmethod . setFollowRedirects ( true ) ; \nint statusCode = method . execute ( ) ; \nif ( statusCode != 200 ) { \nreturn null ; \n} \nString content = method . getResponseAsString ( ) ; \nreturn FeatureType . getType ( content ) ; \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"5343": "public class Grib1GdsPredefined { \npublic static Grib1Gds factory ( int center , int gridNumber ) { \nif ( center == 7 ) { \nreturn factoryNCEP ( gridNumber ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Dont have predefined GDS \" + gridNumber + \" from \" + center ) ; \n} \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) { \nbreak ; \n} \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5349": "public class IO { \nstatic public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { \nint bufferSize = buffer . length ; \nlong want = length ; \nraf . seek ( offset ) ; \nwhile ( want > 0 ) { \nint len = ( int ) Math . min ( want , bufferSize ) ; \nint bytesRead = raf . read ( buffer , 0 , len ) ; \nif ( bytesRead <= 0 ) { \nbreak ; \n} \nout . write ( buffer , 0 , bytesRead ) ; \nwant -= bytesRead ; \n} \nout . flush ( ) ; \nreturn length - want ; \n} \n} \n"}
{"5350": "public class IO { \nstatic public void copyDirTree ( String fromDirName , String toDirName ) throws IOException { \nFile fromDir = new File ( fromDirName ) ; \nFile toDir = new File ( toDirName ) ; \nif ( ! fromDir . exists ( ) ) { \nreturn ; \n} \nif ( ! toDir . exists ( ) ) { \nif ( ! toDir . mkdirs ( ) ) { \nthrow new IOException ( \"Could not create directory: \" + toDir ) ; \n} \n} \nFile [ ] files = fromDir . listFiles ( ) ; \nif ( files != null ) { \nfor ( File f : files ) { \nif ( f . isDirectory ( ) ) { \ncopyDirTree ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \n} \nelse { \ncopyFile ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"5355": "public class IO { \nstatic public long writeToFile ( InputStream in , String fileOutName ) throws IOException { \ntry ( FileOutputStream fout = new FileOutputStream ( fileOutName ) ) { \nOutputStream out = new BufferedOutputStream ( fout ) ; \nreturn IO . copy ( in , out ) ; \n} \nfinally { \nif ( null != in ) { \nin . close ( ) ; \n} \n} \n} \n} \n"}
{"5365": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader readNcML ( String ncmlString , Formatter errlog ) throws IOException { \nStringReader reader = new StringReader ( ncmlString ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) { \nSystem . out . println ( \" NetcdfDataset NcML String = <\" + ncmlString + \">\" ) ; \n} \ndoc = builder . build ( new StringReader ( ncmlString ) ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) { \nSystem . out . println ( \" SAXBuilder done\" ) ; \n} \nreturn readXML ( doc , errlog , null ) ; \n} \n} \n"}
{"5366": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader open ( String ncmlLocation , Formatter errlog ) throws IOException { \nif ( ! ncmlLocation . startsWith ( \"http:\" ) && ! ncmlLocation . startsWith ( \"file:\" ) ) { \nncmlLocation = \"file:\" + ncmlLocation ; \n} \nURL url = new URL ( ncmlLocation ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) { \nSystem . out . println ( \" NetcdfDataset URL = <\" + url + \">\" ) ; \n} \ndoc = builder . build ( url ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) { \nSystem . out . println ( \" SAXBuilder done\" ) ; \n} \nreturn readXML ( doc , errlog , ncmlLocation ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5368": "public class StringUtil2 { \npublic static String cleanup ( byte [ ] h ) { \nbyte [ ] bb = new byte [ h . length ] ; \nint count = 0 ; \nfor ( byte b : h ) { \nif ( b >= 32 && b < 127 ) { \nbb [ count ++ ] = b ; \n} \n} \nreturn new String ( bb , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) { \nreturn null ; \n} \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) { \nbo [ count ++ ] = c ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( c < 0x20 ) { \nok = false ; \n} \nif ( c == '/' ) { \nok = false ; \n} \nif ( c == ' ' ) { \nok = false ; \n} \nif ( ! ok ) { \nbreak ; \n} \n} \nif ( ok ) { \nreturn name ; \n} \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( int i = 0 , len = name . length ( ) ; \ni < len ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) { \nsbuff . append ( '_' ) ; \n} \nelse if ( c >= 0x20 ) { \nsbuff . append ( ( char ) c ) ; \n} \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5377": "public class StringUtil2 { \nstatic public String removeFromEnd ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) { \nreturn s ; \n} \nint len = s . length ( ) ; \nwhile ( ( s . charAt ( len - 1 ) == c ) && ( len > 0 ) ) { \nlen -- ; \n} \nif ( len == s . length ( ) ) { \nreturn s ; \n} \nreturn s . substring ( 0 , len ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nint pos = x . indexOf ( aReplaceChar ) ; \nok = ( pos < 0 ) ; \nif ( ! ok ) { \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int i = 0 ; \ni < replaceChar . length ; \ni ++ ) { \nint pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( pos >= 0 ) { \nreplace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5381": "public class StringUtil2 { \npublic static String replace ( String string , String pattern , String value ) { \nif ( pattern . length ( ) == 0 ) { \nreturn string ; \n} \nif ( ! string . contains ( pattern ) ) { \nreturn string ; \n} \nStringBuilder returnValue = new StringBuilder ( ) ; \nint patternLength = pattern . length ( ) ; \nwhile ( true ) { \nint idx = string . indexOf ( pattern ) ; \nif ( idx < 0 ) { \nbreak ; \n} \nreturnValue . append ( string . substring ( 0 , idx ) ) ; \nif ( value != null ) { \nreturnValue . append ( value ) ; \n} \nstring = string . substring ( idx + patternLength ) ; \n} \nreturnValue . append ( string ) ; \nreturn returnValue . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \ni ++ ; \n} \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( int i = 0 ; \ni < sb . length ( ) ; \ni ++ ) { \nint c = sb . charAt ( i ) ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \n} \n} \n} \n"}
{"5389": "public class InvDatasetFeatureCollection { \n@ Subscribe public void processEvent ( CollectionUpdateEvent event ) { \nif ( ! config . collectionName . equals ( event . getCollectionName ( ) ) ) { \nreturn ; \n} \ntry { \nupdate ( event . getType ( ) ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"Error processing event\" , e ) ; \n} \n} \n} \n"}
{"5396": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( ArrayStructure as , ByteOrder bo , boolean canonical ) throws IOException { \nif ( ! canonical && as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { \nArrayStructureBB abb = ( ArrayStructureBB ) as ; \nByteBuffer bb = abb . getByteBuffer ( ) ; \nif ( bo == null || bo . equals ( bb . order ( ) ) ) { \nreturn abb ; \n} \n} \nStructureMembers smo = as . getStructureMembers ( ) ; \nStructureMembers sm = new StructureMembers ( smo ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , as . getShape ( ) ) ; \nArrayStructureBB . setOffsets ( sm ) ; \nif ( bo != null ) { \nByteBuffer bb = abb . getByteBuffer ( ) ; \nbb . order ( bo ) ; \n} \ntry ( StructureDataIterator iter = as . getStructureDataIterator ( ) ) { \nwhile ( iter . hasNext ( ) ) { \ncopyToArrayBB ( iter . next ( ) , abb ) ; \n} \n} \nreturn abb ; \n} \n} \n"}
{"5397": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( Structure s , ArrayStructure as , ByteOrder bo ) throws IOException { \nStructureMembers sm = s . makeStructureMembers ( ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , as . getShape ( ) ) ; \nArrayStructureBB . setOffsets ( sm ) ; \nif ( bo != null ) { \nByteBuffer bb = abb . getByteBuffer ( ) ; \nbb . order ( bo ) ; \n} \ntry ( StructureDataIterator iter = as . getStructureDataIterator ( ) ) { \nwhile ( iter . hasNext ( ) ) { \ncopyToArrayBB ( iter . next ( ) , abb ) ; \n} \n} \nreturn abb ; \n} \n} \n"}
{"5400": "public class NwsMetDevTables { \n@ Override public double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nboolean needOverride = false ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nneedOverride = ( ti . timeRangeUnit == 255 ) ; \n} \nif ( ! needOverride ) { \nreturn super . getForecastTimeIntervalSizeInHours ( pds ) ; \n} \nreturn 12.0 ; \n} \n} \n"}
{"5402": "public class TableAnalyzer { \nstatic public TableAnalyzer factory ( TableConfigurer tc , FeatureType wantFeatureType , NetcdfDataset ds ) throws IOException { \nTableAnalyzer analyzer = new TableAnalyzer ( ds , tc ) ; \nif ( tc != null ) { \nif ( tc . getConvName ( ) == null ) { \nanalyzer . userAdvice . format ( \" No 'Conventions' global attribute.%n\" ) ; \n} \nelse { \nanalyzer . userAdvice . format ( \" Conventions global attribute = %s %n\" , tc . getConvName ( ) ) ; \n} \nif ( tc . getConvUsed ( ) != null ) { \nanalyzer . setConventionUsed ( tc . getConvUsed ( ) ) ; \nif ( ! tc . getConvUsed ( ) . equals ( tc . getConvName ( ) ) ) { \nanalyzer . userAdvice . format ( \" TableConfigurer used = \" + tc . getConvUsed ( ) + \".%n\" ) ; \n} \n} \n} \nelse { \nanalyzer . userAdvice . format ( \" No TableConfigurer found, using default analysis.%n\" ) ; \n} \nanalyzer . analyze ( wantFeatureType ) ; \nreturn analyzer ; \n} \n} \n"}
{"5403": "public class TableAnalyzer { \npublic FeatureType getFirstFeatureType ( ) { \nfor ( NestedTable nt : leaves ) { \nif ( nt . hasCoords ( ) ) { \nreturn nt . getFeatureType ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5404": "public class TableAnalyzer { \nprivate void analyze ( FeatureType wantFeatureType ) throws IOException { \nboolean structAdded = ( Boolean ) ds . sendIospMessage ( NetcdfFile . IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \nif ( tc == null ) { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \nelse { \nconfigResult = tc . getConfig ( wantFeatureType , ds , errlog ) ; \nif ( configResult != null ) { \naddTableRecurse ( configResult ) ; \n} \nelse { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \n} \nfor ( TableConfig config : tableSet ) { \nif ( config . children == null ) { \nNestedTable flatTable = new NestedTable ( ds , config , errlog ) ; \nleaves . add ( flatTable ) ; \n} \n} \nif ( PointDatasetStandardFactory . showTables ) { \ngetDetailInfo ( new Formatter ( System . out ) ) ; \n} \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i ++ ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \n} \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5411": "public class CSMConvention { \nprotected boolean addParameter2 ( CoordinateTransform rs , String paramName , NetcdfFile ds , AttributeContainer v , String attName , boolean readData ) { \nString varName ; \nif ( null == ( varName = v . findAttValueIgnoreCase ( attName , null ) ) ) { \nparseInfo . format ( \"CSMConvention No Attribute named %s%n\" , attName ) ; \nreturn false ; \n} \nvarName = varName . trim ( ) ; \nVariable dataVar ; \nif ( null == ( dataVar = ds . findVariable ( varName ) ) ) { \nparseInfo . format ( \"CSMConvention No Variable named %s%n\" , varName ) ; \nreturn false ; \n} \nif ( readData ) { \nArray data ; \ntry { \ndata = dataVar . read ( ) ; \n} \ncatch ( IOException e ) { \nparseInfo . format ( \"CSMConvention failed on read of %s err= %s%n\" , varName , e . getMessage ( ) ) ; \nreturn false ; \n} \ndouble [ ] vals = ( double [ ] ) data . get1DJavaArray ( DataType . DOUBLE ) ; \nrs . addParameter ( new Parameter ( paramName , vals ) ) ; \n} \nelse { \nrs . addParameter ( new Parameter ( paramName , varName ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"5412": "public class Group { \npublic Group commonParent ( Group other ) { \nif ( isParent ( other ) ) { \nreturn this ; \n} \nif ( other . isParent ( this ) ) { \nreturn other ; \n} \nwhile ( ! other . isParent ( this ) ) { \nother = other . getParentGroup ( ) ; \n} \nreturn other ; \n} \n} \n"}
{"5413": "public class Group { \npublic boolean isParent ( Group other ) { \nwhile ( ( other != this ) && ( other . getParentGroup ( ) != null ) ) { \nother = other . getParentGroup ( ) ; \n} \nreturn ( other == this ) ; \n} \n} \n"}
{"5414": "public class Group { \npublic void setParentGroup ( Group parent ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nsuper . setParentGroup ( parent == null ? ncfile . getRootGroup ( ) : parent ) ; \n} \n} \n"}
{"5415": "public class Group { \npublic void addDimension ( Dimension dim ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( ! dim . isShared ( ) ) { \nthrow new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \n} \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) { \nthrow new IllegalArgumentException ( \"Dimension name (\" + dim . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \n} \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \n} \n} \n"}
{"5416": "public class Group { \npublic boolean addDimensionIfNotExists ( Dimension dim ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( ! dim . isShared ( ) ) { \nthrow new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \n} \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) { \nreturn false ; \n} \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \nreturn true ; \n} \n} \n"}
{"5417": "public class Group { \npublic void addGroup ( Group g ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( findGroup ( g . getShortName ( ) ) != null ) { \nthrow new IllegalArgumentException ( \"Group name (\" + g . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \n} \ngroups . add ( g ) ; \ng . setParentGroup ( this ) ; \n} \n} \n"}
{"5418": "public class Group { \npublic void addEnumeration ( EnumTypedef e ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( e == null ) { \nreturn ; \n} \ne . setParentGroup ( this ) ; \nenumTypedefs . add ( e ) ; \n} \n} \n"}
{"5419": "public class Group { \npublic void addVariable ( Variable v ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( v == null ) { \nreturn ; \n} \nif ( findVariable ( v . getShortName ( ) ) != null ) { \nthrow new IllegalArgumentException ( \"Variable name (\" + v . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \n} \nvariables . add ( v ) ; \nv . setParentGroup ( this ) ; \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5421": "public class Group { \npublic Group makeRelativeGroup ( NetcdfFile ncf , String path , boolean ignorelast ) { \npath = path . trim ( ) ; \npath = path . replace ( \"//\" , \"/\" ) ; \nboolean isabsolute = ( path . charAt ( 0 ) == '/' ) ; \nif ( isabsolute ) { \npath = path . substring ( 1 ) ; \n} \nString pieces [ ] = path . split ( \"/\" ) ; \nif ( ignorelast ) { \npieces [ pieces . length - 1 ] = null ; \n} \nGroup current = ( isabsolute ? ncfile . getRootGroup ( ) : this ) ; \nfor ( String name : pieces ) { \nif ( name == null ) { \ncontinue ; \n} \nString clearname = NetcdfFile . makeNameUnescaped ( name ) ; \nGroup next = current . findGroup ( clearname ) ; \nif ( next == null ) { \nnext = new Group ( ncf , current , clearname ) ; \ncurrent . addGroup ( next ) ; \n} \ncurrent = next ; \n} \nreturn current ; \n} \n} \n"}
{"5422": "public class DDS { \nprivate String convertDDSAliasFieldsToDASAliasFields ( String attribute ) throws MalformedAliasException { \nString prefix = \"\" ; \nVector aNames = tokenizeAliasField ( attribute ) ; \nString topName = ( String ) aNames . get ( 1 ) ; \nboolean foundIt = false ; \nEnumeration e = getVariables ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nBaseType bt = ( BaseType ) e . nextElement ( ) ; \nString normName = normalize ( bt . getEncodedName ( ) ) ; \nif ( topName . equals ( normName ) ) { \nfoundIt = true ; \n} \n} \nif ( ! foundIt ) { \nprefix = \".\" + getLooseEndsTableName ( ) ; \n} \nreturn ( prefix + attribute ) ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) { \nthrow new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \n} \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \n} \n} \n"}
{"5430": "public class WFSExceptionWriter { \npublic void write ( HttpServletResponse hsr ) throws IOException { \nPrintWriter xmlResponse = hsr . getWriter ( ) ; \nxmlResponse . append ( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" ) ; \nxmlResponse . append ( \"<ows:ExceptionReport xml:lang=\\\"en-US\\\" xsi:schemaLocation=\\\"http://www.opengis.net/ows/1.1\" + \" http://schemas.opengis.net/ows/1.1.0/owsExceptionReport.xsd\\\" version=\\\"2.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\" ) ; \nxmlResponse . append ( \"<ows:Exception \" ) ; \nif ( locator != null ) { \nxmlResponse . append ( \"locator=\\\"\" + locator + \"\\\" \" ) ; \n} \nxmlResponse . append ( \"exceptionCode=\\\"\" + ExceptionCode + \"\\\">\" ) ; \nxmlResponse . append ( \"<ows:ExceptionText>\" + text + \"</ows:ExceptionText>\" ) ; \nxmlResponse . append ( \"</ows:Exception>\" ) ; \nxmlResponse . append ( \"</ows:ExceptionReport>\" ) ; \n} \n} \n"}
{"5431": "public class Nc4wrapper { \n@ Override public synchronized String nc_inq_libvers ( ) { \nString ret ; \ntry { \nce ( ) ; \nret = nc4 . nc_inq_libvers ( ) ; \nif ( TRACE ) { \ntrace ( ret , \"nc_inq_libvers\" , \"-\" ) ; \n} \n} \nfinally { \ncx ( ) ; \n} \nreturn ret ; \n} \n} \n"}
{"5434": "public class GribCdmIndex { \npublic static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { \nif ( logger == null ) { \nlogger = classLogger ; \n} \nlong start = System . currentTimeMillis ( ) ; \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \nPath rootPath = Paths . get ( specp . getRootDir ( ) ) ; \nboolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; \nboolean changed ; \nif ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) { \ntry ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { \nchanged = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; \n} \n} \nelse if ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) { \ntry ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { \nchanged = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; \n} \n} \nelse { \nif ( specp . wantSubdirs ( ) ) { \ntry ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { \ndpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nchanged = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; \n} \n} \nelse { \nchanged = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; \n} \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . info ( \"updateGribCollection {} changed {} took {} msecs\" , config . collectionName , changed , took ) ; \nreturn changed ; \n} \n} \n"}
{"5435": "public class GribCdmIndex { \nprivate static boolean updateLeafCollection ( boolean isGrib1 , FeatureCollectionConfig config , CollectionUpdateType updateType , boolean isTop , Logger logger , Path dirPath ) throws IOException { \nif ( config . ptype == FeatureCollectionConfig . PartitionType . file ) { \nreturn updateFilePartition ( isGrib1 , config , updateType , isTop , logger , dirPath ) ; \n} \nelse { \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \ntry ( DirectoryCollection dcm = new DirectoryCollection ( config . collectionName , dirPath , isTop , config . olderThan , logger ) ) { \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( specp . getFilter ( ) != null ) { \ndcm . setStreamFilter ( new StreamFilter ( specp . getFilter ( ) , specp . getFilterOnName ( ) ) ) ; \n} \nboolean changed = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . directory , logger , errlog ) ; \nlogger . debug ( \"  GribCdmIndex.updateDirectoryPartition was updated=%s on %s%n\" , changed , dirPath ) ; \nreturn changed ; \n} \n} \n} \n} \n"}
{"5436": "public class GribCdmIndex { \npublic static GribCollectionImmutable openGribCollectionFromRaf ( RandomAccessFile raf , FeatureCollectionConfig config , CollectionUpdateType updateType , org . slf4j . Logger logger ) throws IOException { \nGribCollectionImmutable result ; \nboolean isGrib1 = false ; \nboolean isGrib2 = Grib2RecordScanner . isValidFile ( raf ) ; \nif ( ! isGrib2 ) { \nisGrib1 = Grib1RecordScanner . isValidFile ( raf ) ; \n} \nif ( isGrib1 || isGrib2 ) { \nresult = openGribCollectionFromDataFile ( isGrib1 , raf , config , updateType , null , logger ) ; \nraf . close ( ) ; \n} \nelse { \nresult = openGribCollectionFromIndexFile ( raf , config , logger ) ; \n} \nreturn result ; \n} \n} \n"}
{"5438": "public class GribCdmIndex { \n@ Nullable public static GribCollectionImmutable openGribCollectionFromDataFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType updateType , FeatureCollectionConfig config , Formatter errlog , org . slf4j . Logger logger ) throws IOException { \nMCollection dcm = new CollectionSingleFile ( mfile , logger ) ; \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( isGrib1 ) { \nGrib1CollectionBuilder builder = new Grib1CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \nboolean changed = ( builder . updateNeeded ( updateType ) && builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ) ; \n} \nelse { \nGrib2CollectionBuilder builder = new Grib2CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \nboolean changed = ( builder . updateNeeded ( updateType ) && builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ) ; \n} \nGribCollectionImmutable result = openCdmIndex ( dcm . getIndexFilename ( NCX_SUFFIX ) , config , true , logger ) ; \nif ( result != null ) { \nreturn result ; \n} \nif ( updateType == CollectionUpdateType . never ) { \nreturn null ; \n} \nif ( updateType == CollectionUpdateType . always ) { \nreturn null ; \n} \nreturn openGribCollectionFromDataFile ( isGrib1 , mfile , CollectionUpdateType . always , config , errlog , logger ) ; \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nint relation ; \nif ( pattern == null ) { \nreturn ( url == null ) ; \n} \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) { \nreturn false ; \n} \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) { \nreturn false ; \n} \nif ( pattern . getPort ( ) > 0 && pattern . getPort ( ) != url . getPort ( ) ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5440": "public class RC { \nstatic synchronized public void add ( String key , String value , String url ) { \nif ( key == null ) { \nreturn ; \n} \nif ( ! initialized ) { \nRC . initialize ( ) ; \n} \nTriple t = new Triple ( key , value , url ) ; \ndfaltRC . insert ( t ) ; \nsetWellKnown ( ) ; \n} \n} \n"}
{"5441": "public class RC { \nstatic synchronized public String find ( String key , String url ) { \nif ( key == null ) { \nreturn null ; \n} \nif ( ! initialized ) { \nRC . initialize ( ) ; \n} \nTriple t = dfaltRC . lookup ( key , url ) ; \nreturn ( t == null ? null : t . value ) ; \n} \n} \n"}
{"5442": "public class RC { \nstatic void setWellKnown ( ) { \nif ( dfaltRC . triplestore . size ( ) == 0 ) { \nreturn ; \n} \nfor ( String key : dfaltRC . keySet ( ) ) { \nTriple triple = dfaltRC . lookup ( key ) ; \nif ( triple . url == null ) { \nRC . set ( key , triple . value ) ; \n} \n} \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) { \nlog . debug ( \"Loading rc file: \" + abspath ) ; \n} \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) { \nbreak ; \n} \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) { \ncontinue ; \n} \nif ( line . charAt ( 0 ) == '#' ) { \ncontinue ; \n} \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) { \nreturn false ; \n} \nif ( showlog ) { \nlog . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) { \nlog . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) { \nvalue = pieces [ 1 ] . trim ( ) ; \n} \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) { \nlist = new ArrayList < Triple > ( ) ; \n} \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) { \nlog . debug ( \"Loading rc file: \" + abspath ) ; \n} \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) { \nlog . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \n} \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5444": "public class RC { \npublic Triple insert ( Triple t ) { \nif ( t . key == null ) { \nreturn null ; \n} \nList < Triple > list = triplestore . get ( t . key ) ; \nif ( list == null ) { \nlist = new ArrayList < Triple > ( ) ; \n} \nTriple prev = addtriple ( list , t ) ; \ntriplestore . put ( t . key , list ) ; \nreturn prev ; \n} \n} \n"}
{"5446": "public class DatasetNode { \npublic Dataset findDatasetByName ( String name ) { \nfor ( Dataset ds : getDatasets ( ) ) { \nif ( ds . getName ( ) . equals ( name ) ) { \nreturn ds ; \n} \nDataset result = ds . findDatasetByName ( name ) ; \nif ( result != null ) { \nreturn result ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5447": "public class GisFeatureRendererMulti { \npublic void setProjection ( ProjectionImpl project ) { \ndisplayProject = project ; \nif ( featSetList == null ) { \nreturn ; \n} \nIterator iter = featSetList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nFeatureSet fs = ( FeatureSet ) iter . next ( ) ; \nfs . newProjection = true ; \n} \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) { \nscale *= 111.0 ; \n} \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) { \nfs . createFeatures ( ) ; \n} \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \nSystem . out . println ( \"GisFeature/MapDraw: makeShapes with \" + displayProject ) ; \n} \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse if ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) { \nreturn false ; \n} \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) { \nSystem . out . println ( \" task.cancel\" ) ; \n} \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) { \nSystem . out . println ( \" stop count=\" + count ) ; \n} \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) { \nmyTimer . stop ( ) ; \n} \nmyTimer = null ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \n} \nelse if ( task . isError ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \n} \nelse if ( task . isCancel ( ) ) { \nfireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \n} \nelse { \nfireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5452": "public class GribPartitionBuilder { \nprivate boolean needsUpdate ( CollectionUpdateType ff , File collectionIndexFile ) throws IOException { \nlong collectionLastModified = collectionIndexFile . lastModified ( ) ; \nSet < String > newFileSet = new HashSet < > ( ) ; \nfor ( MCollection dcm : partitionManager . makePartitions ( CollectionUpdateType . test ) ) { \nString partitionIndexFilename = StringUtil2 . replace ( dcm . getIndexFilename ( GribCdmIndex . NCX_SUFFIX ) , '\\\\' , \"/\" ) ; \nFile partitionIndexFile = GribIndexCache . getExistingFileOrCache ( partitionIndexFilename ) ; \nif ( partitionIndexFile == null ) { \nreturn true ; \n} \nif ( collectionLastModified < partitionIndexFile . lastModified ( ) ) { \nreturn true ; \n} \nnewFileSet . add ( partitionIndexFilename ) ; \n} \nif ( ff == CollectionUpdateType . testIndexOnly ) { \nreturn false ; \n} \nGribCdmIndex reader = new GribCdmIndex ( logger ) ; \nList < MFile > oldFiles = new ArrayList < > ( ) ; \nreader . readMFiles ( collectionIndexFile . toPath ( ) , oldFiles ) ; \nSet < String > oldFileSet = new HashSet < > ( ) ; \nfor ( MFile oldFile : oldFiles ) { \nif ( ! newFileSet . contains ( oldFile . getPath ( ) ) ) { \nreturn true ; \n} \noldFileSet . add ( oldFile . getPath ( ) ) ; \n} \nfor ( String newFilename : newFileSet ) { \nif ( ! oldFileSet . contains ( newFilename ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5453": "public class EnsCoord { \nstatic public void normalize ( EnsCoord result , List < EnsCoord > ecList ) { \nList < EnsCoord > extra = new ArrayList < > ( ) ; \nfor ( EnsCoord ec : ecList ) { \nif ( ! result . equalsData ( ec ) ) { \nextra . add ( ec ) ; \n} \n} \nif ( extra . size ( ) == 0 ) { \nreturn ; \n} \nfor ( EnsCoord ec : extra ) { \nif ( ec . getNEnsembles ( ) < result . getNEnsembles ( ) ) { \ncontinue ; \n} \nresult = ec ; \n} \n} \n} \n"}
{"5454": "public class ArrayStructure { \npublic void setObject ( int index , Object value ) { \nif ( sdata == null ) { \nsdata = new StructureData [ nelems ] ; \n} \nsdata [ index ] = ( StructureData ) value ; \n} \n} \n"}
{"5455": "public class ArrayStructure { \npublic StructureData getStructureData ( int index ) { \nif ( sdata == null ) { \nsdata = new StructureData [ nelems ] ; \n} \nif ( index >= sdata . length ) { \nthrow new IllegalArgumentException ( index + \" > \" + sdata . length ) ; \n} \nif ( sdata [ index ] == null ) { \nsdata [ index ] = makeStructureData ( this , index ) ; \n} \nreturn sdata [ index ] ; \n} \n} \n"}
{"5456": "public class ArrayStructure { \nprotected void copyStructures ( int recnum , StructureMembers . Member m , IndexIterator result ) { \nArray data = getArray ( recnum , m ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nwhile ( dataIter . hasNext ( ) ) { \nresult . setObjectNext ( dataIter . getObjectNext ( ) ) ; \n} \n} \n} \n"}
{"5458": "public class ArrayStructure { \npublic double convertScalarDouble ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . DOUBLE ) { \nreturn getScalarDouble ( recnum , m ) ; \n} \nif ( m . getDataType ( ) == DataType . FLOAT ) { \nreturn ( double ) getScalarFloat ( recnum , m ) ; \n} \nObject o = getScalarObject ( recnum , m ) ; \nif ( o instanceof Number ) { \nreturn ( ( Number ) o ) . doubleValue ( ) ; \n} \nthrow new ForbiddenConversionException ( \"Type is \" + m . getDataType ( ) + \", not convertible to double\" ) ; \n} \n} \n"}
{"5459": "public class ArrayStructure { \npublic int convertScalarInt ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . INT || m . getDataType ( ) == DataType . UINT ) { \nreturn getScalarInt ( recnum , m ) ; \n} \nif ( m . getDataType ( ) == DataType . SHORT ) { \nreturn ( int ) getScalarShort ( recnum , m ) ; \n} \nif ( m . getDataType ( ) == DataType . USHORT ) { \nreturn DataType . unsignedShortToInt ( getScalarShort ( recnum , m ) ) ; \n} \nif ( m . getDataType ( ) == DataType . BYTE ) { \nreturn ( int ) getScalarByte ( recnum , m ) ; \n} \nif ( m . getDataType ( ) == DataType . UBYTE ) { \nreturn ( int ) DataType . unsignedByteToShort ( getScalarByte ( recnum , m ) ) ; \n} \nif ( m . getDataType ( ) == DataType . LONG || m . getDataType ( ) == DataType . ULONG ) { \nreturn ( int ) getScalarLong ( recnum , m ) ; \n} \nObject o = getScalarObject ( recnum , m ) ; \nif ( o instanceof Number ) { \nreturn ( ( Number ) o ) . intValue ( ) ; \n} \nthrow new ForbiddenConversionException ( \"Type is \" + m . getDataType ( ) + \", not convertible to int\" ) ; \n} \n} \n"}
{"5460": "public class ArrayStructure { \npublic float getScalarFloat ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . FLOAT ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be float\" ) ; \n} \nArray data = m . getDataArray ( ) ; \nreturn data . getFloat ( recnum * m . getSize ( ) ) ; \n} \n} \n"}
{"5461": "public class ArrayStructure { \npublic byte getScalarByte ( int recnum , StructureMembers . Member m ) { \nif ( ! ( m . getDataType ( ) . getPrimitiveClassType ( ) == byte . class ) ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be byte\" ) ; \n} \nArray data = m . getDataArray ( ) ; \nreturn data . getByte ( recnum * m . getSize ( ) ) ; \n} \n} \n"}
{"5462": "public class ArrayStructure { \npublic short getScalarShort ( int recnum , StructureMembers . Member m ) { \nif ( ! ( m . getDataType ( ) . getPrimitiveClassType ( ) == short . class ) ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be short\" ) ; \n} \nArray data = m . getDataArray ( ) ; \nreturn data . getShort ( recnum * m . getSize ( ) ) ; \n} \n} \n"}
{"5463": "public class ArrayStructure { \npublic char getScalarChar ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . CHAR ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be char\" ) ; \n} \nArray data = m . getDataArray ( ) ; \nreturn data . getChar ( recnum * m . getSize ( ) ) ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \n} \nif ( m . getDataType ( ) == DataType . SEQUENCE ) { \nreturn getArraySequence ( recnum , m ) ; \n} \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nint count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nthis_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \n} \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5466": "public class ArrayStructure { \npublic ArraySequence getArraySequence ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . SEQUENCE ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Sequence\" ) ; \n} \nArrayObject array = ( ArrayObject ) m . getDataArray ( ) ; \nreturn ( ArraySequence ) array . getObject ( recnum ) ; \n} \n} \n"}
{"5467": "public class ArrayStructure { \npublic ArrayObject getArrayObject ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . OPAQUE ) { \nthrow new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Sequence\" ) ; \n} \nArrayObject array = ( ArrayObject ) m . getDataArray ( ) ; \nreturn ( ArrayObject ) array . getObject ( recnum ) ; \n} \n} \n"}
{"5468": "public class CoreTypeFcns { \nstatic protected long minmax ( long value , long min , long max ) { \nif ( value < min ) { \nreturn min ; \n} \nif ( value > max ) { \nreturn max ; \n} \nreturn value ; \n} \n} \n"}
{"5469": "public class CEConstraint { \nprotected Object eval ( DapVariable var , DapSequence seq , DataCursor record , CEAST expr ) throws DapException { \nswitch ( expr . sort ) { \ncase CONSTANT : return expr . value ; \ncase SEGMENT : return fieldValue ( var , seq , record , expr . name ) ; \ncase EXPR : Object lhs = eval ( var , seq , record , expr . lhs ) ; \nObject rhs = ( expr . rhs == null ? null : eval ( var , seq , record , expr . rhs ) ) ; \nif ( rhs != null ) { \nswitch ( expr . op ) { \ncase LT : return compare ( lhs , rhs ) < 0 ; \ncase LE : return compare ( lhs , rhs ) <= 0 ; \ncase GT : return compare ( lhs , rhs ) > 0 ; \ncase GE : return compare ( lhs , rhs ) >= 0 ; \ncase EQ : return lhs . equals ( rhs ) ; \ncase NEQ : return ! lhs . equals ( rhs ) ; \ncase REQ : return lhs . toString ( ) . matches ( rhs . toString ( ) ) ; \ncase AND : return ( ( Boolean ) lhs ) && ( ( Boolean ) rhs ) ; \n} \n} \nelse { \nswitch ( expr . op ) { \ncase NOT : return ! ( ( Boolean ) lhs ) ; \n} \n} \n} \nthrow new DapException ( \"Malformed Filter\" ) ; \n} \n} \n"}
{"5470": "public class CEConstraint { \npublic String toConstraintString ( ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = 0 ; \ni < segments . size ( ) ; \ni ++ ) { \nSegment seg = segments . get ( i ) ; \nif ( ! seg . var . isTopLevel ( ) ) { \ncontinue ; \n} \nif ( ! first ) { \nbuf . append ( \";\" ) ; \n} \nfirst = false ; \ndumpvar ( seg , buf , true ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5471": "public class CEConstraint { \npublic boolean references ( DapNode node ) { \nboolean isref = false ; \nswitch ( node . getSort ( ) ) { \ncase DIMENSION : DapDimension dim = this . redef . get ( ( DapDimension ) node ) ; \nif ( dim == null ) { \ndim = ( DapDimension ) node ; \n} \nisref = this . dimrefs . contains ( dim ) ; \nbreak ; \ncase ENUMERATION : isref = ( this . enums . contains ( ( DapEnumeration ) node ) ) ; \nbreak ; \ncase VARIABLE : isref = ( findVariableIndex ( ( DapVariable ) node ) >= 0 ) ; \nbreak ; \ncase GROUP : case DATASET : isref = ( this . groups . contains ( ( DapGroup ) node ) ) ; \nbreak ; \ndefault : break ; \n} \nreturn isref ; \n} \n} \n"}
{"5473": "public class CEConstraint { \nprotected int expansionCount ( DapStructure struct ) { \nint count = 0 ; \nfor ( DapVariable field : struct . getFields ( ) ) { \nif ( findVariableIndex ( field ) >= 0 ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) { \ncontinue ; \n} \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) { \ncontinue ; \n} \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) { \nthis . enums . add ( ( DapEnumeration ) daptype ) ; \n} \n} \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) { \nthis . groups . add ( group ) ; \n} \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) { \ncontinue ; \n} \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) { \nthis . groups . add ( group ) ; \n} \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) { \nthis . groups . add ( group ) ; \n} \n} \n} \n} \n} \n"}
{"5476": "public class CEConstraint { \nstatic public CEConstraint compile ( String sce , DapDataset dmr ) throws DapException { \nif ( sce == null || sce . length ( ) == 0 ) { \nreturn CEConstraint . getUniversal ( dmr ) ; \n} \nCEParserImpl ceparser = new CEParserImpl ( dmr ) ; \nif ( PARSEDEBUG ) { \nceparser . setDebugLevel ( 1 ) ; \n} \nif ( DEBUG ) { \nSystem . err . println ( \"Dap4Servlet: parsing constraint: |\" + sce + \"|\" ) ; \n} \nboolean ok ; \ntry { \nok = ceparser . parse ( sce ) ; \n} \ncatch ( ParseException pe ) { \nok = false ; \n} \nif ( ! ok ) { \nthrow new DapException ( \"Constraint parse failed: \" + sce ) ; \n} \nCEAST root = ceparser . getCEAST ( ) ; \nCECompiler compiler = new CECompiler ( ) ; \nCEConstraint ce = compiler . compile ( dmr , root ) ; \nce . expand ( ) ; \nce . finish ( ) ; \nreturn ce ; \n} \n} \n"}
{"5477": "public class Grib2Iosp { \n@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { \nif ( raf instanceof HTTPRandomAccessFile ) { \nif ( raf . length ( ) > raf . getBufferSize ( ) ) { \nreturn false ; \n} \n} \nelse { \nGribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; \nif ( type == GribCdmIndex . GribCollectionType . GRIB2 ) { \nreturn true ; \n} \nif ( type == GribCdmIndex . GribCollectionType . Partition2 ) { \nreturn true ; \n} \n} \nreturn Grib2RecordScanner . isValidFile ( raf ) ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \n} \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) { \nSystem . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \n} \nif ( _Debug ) { \nshowXMLElement ( e , indent ) ; \n} \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \n} \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5492": "public class DDSXMLParser { \nprivate void parseGrid ( Element gridElement , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nDGrid myGrid = ( DGrid ) parentDC ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Grid Element: \" + gridElement ) ; \nSystem . out . println ( \"Grid Elements: \" ) ; \nfor ( Element element : gridElement . getChildren ( ) ) System . out . println ( element ) ; \n} \nString eName = \"Array\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Array element.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nElement arrayElement = gridElement . getChild ( eName , opendapNameSpace ) ; \nif ( _Debug ) { \nSystem . out . println ( \"Got Array element: \" + arrayElement ) ; \n} \nDArray gridArray = ( DArray ) newBaseType ( arrayElement ) ; \nparseArray ( arrayElement , gridArray , indent + \"    \" ) ; \nmyGrid . addVariable ( gridArray , DGrid . ARRAY ) ; \neName = \"Map\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Map elements.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nList < Element > mapElements = gridElement . getChildren ( \"Map\" , opendapNameSpace ) ; \nif ( mapElements . size ( ) != gridArray . numDimensions ( ) ) { \nthrow new BadSemanticsException ( \"Error in Grid syntax: \" + \"The number of Map arrays must \" + \"equal the number of dimensions \" + \"of the data array.\" ) ; \n} \nfor ( Element mapElement : mapElements ) { \nDArray thisMap = ( DArray ) newBaseType ( mapElement ) ; \nparseArray ( mapElement , thisMap , indent + \"    \" ) ; \nif ( thisMap . numDimensions ( ) != 1 ) { \nthrow new BadSemanticsException ( \"Error in Grid syntax: \" + \"Maps may have only one dimension.\" ) ; \n} \nmyGrid . addVariable ( thisMap , DGrid . MAPS ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) { \nSystem . out . println ( indent + \"Parsing Aliases: \" ) ; \n} \nif ( _Debug ) { \nSystem . out . println ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) ) ; \n} \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . println ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" ) ; \n} \nif ( currentAT == null ) { \ncurrentBT . addAttributeAlias ( name , attributeName ) ; \n} \nelse { \ncurrentAT . addAlias ( name , attributeName ) ; \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5494": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > decode ( List < Short > keyDesc , BufrTableLookup lookup ) { \nif ( keyDesc == null ) { \nreturn null ; \n} \nList < DataDescriptor > keys = new ArrayList < DataDescriptor > ( ) ; \nfor ( short id : keyDesc ) { \nDataDescriptor dd = new DataDescriptor ( id , lookup ) ; \nkeys . add ( dd ) ; \nif ( dd . f == 3 ) { \nTableD . Descriptor tdd = lookup . getDescriptorTableD ( dd . fxy ) ; \nif ( tdd == null || tdd . getSequence ( ) == null ) { \ndd . bad = true ; \n} \nelse { \ndd . name = tdd . getName ( ) ; \ndd . subKeys = decode ( tdd . getSequence ( ) , lookup ) ; \n} \n} \n} \nreturn keys ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) { \ndk . replicationCountSize = 1 ; \n} \nelse if ( replication . y == 1 ) { \ndk . replicationCountSize = 8 ; \n} \nelse if ( replication . y == 2 ) { \ndk . replicationCountSize = 16 ; \n} \nelse if ( replication . y == 11 ) { \ndk . repetitionCountSize = 8 ; \n} \nelse if ( replication . y == 12 ) { \ndk . repetitionCountSize = 16 ; \n} \nelse { \nlog . error ( \"Unknown replication type= \" + replication ) ; \n} \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni ++ ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \n} \nSystem . out . println ( \"Methods:\" ) ; \nfor ( int i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) { \nSystem . out . print ( \", \" ) ; \n} \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) { \nSystem . out . print ( \", \" ) ; \n} \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5502": "public class AggregationTiled { \nprivate boolean isTiled ( Variable v ) { \nfor ( Dimension d : v . getDimensions ( ) ) { \nfor ( Range r : section . getRanges ( ) ) { \nif ( d . getShortName ( ) . equals ( r . getName ( ) ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"5505": "public class AccessLogTable { \nprivate void showTimeSeriesAll ( java . util . List < LogReader . Log > logs ) { \nTimeSeries bytesSentData = new TimeSeries ( \"Bytes Sent\" , Minute . class ) ; \nTimeSeries timeTookData = new TimeSeries ( \"Average Latency\" , Minute . class ) ; \nTimeSeries nreqData = new TimeSeries ( \"Number of Requests\" , Minute . class ) ; \nString intervalS = \"5 minute\" ; \nlong period = 1000 * 60 * 5 ; \ntry { \nTimeDuration tu = new TimeDuration ( intervalS ) ; \nperiod = ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"Illegal Time interval=%s %n\" , intervalS ) ; \n} \nlong current = 0 ; \nlong bytes = 0 ; \nlong timeTook = 0 ; \nlong total_count = 0 ; \nlong count = 0 ; \nfor ( LogReader . Log log : logs ) { \nlong msecs = log . date ; \nif ( msecs - current > period ) { \nif ( current > 0 ) { \ntotal_count += count ; \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \nbytes = 0 ; \ncount = 0 ; \ntimeTook = 0 ; \ncurrent = msecs ; \n} \nbytes += log . getBytes ( ) ; \ntimeTook += log . getMsecs ( ) ; \ncount ++ ; \n} \nif ( count > 0 ) { \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \ntotal_count += count ; \nSystem . out . printf ( \"showTimeSeriesAll: total_count = %d logs = %d%n\" , total_count , logs . size ( ) ) ; \nMultipleAxisChart mc = new MultipleAxisChart ( \"Access Logs\" , intervalS + \" average\" , \"Mbytes Sent\" , bytesSentData ) ; \nmc . addSeries ( \"Number of Requests\" , nreqData ) ; \nmc . addSeries ( \"Average Latency (secs)\" , timeTookData ) ; \nmc . finish ( new java . awt . Dimension ( 1000 , 1000 ) ) ; \ntimeSeriesPanel . removeAll ( ) ; \ntimeSeriesPanel . add ( mc ) ; \n} \n} \n"}
{"5506": "public class Attribute { \nstatic public Map < String , Attribute > makeMap ( List < Attribute > atts ) { \nint size = ( atts == null ) ? 1 : atts . size ( ) ; \nMap < String , Attribute > result = new HashMap < > ( size ) ; \nif ( atts == null ) { \nreturn result ; \n} \nfor ( Attribute att : atts ) result . put ( att . getShortName ( ) , att ) ; \nreturn result ; \n} \n} \n"}
{"5508": "public class Attribute { \npublic Number getNumericValue ( int index ) { \nif ( ( index < 0 ) || ( index >= nelems ) ) { \nreturn null ; \n} \nswitch ( dataType ) { \ncase STRING : try { \nreturn new Double ( getStringValue ( index ) ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn null ; \n} \ncase BYTE : case UBYTE : return values . getByte ( index ) ; \ncase SHORT : case USHORT : return values . getShort ( index ) ; \ncase INT : case UINT : return values . getInt ( index ) ; \ncase FLOAT : return values . getFloat ( index ) ; \ncase DOUBLE : return values . getDouble ( index ) ; \ncase LONG : case ULONG : return values . getLong ( index ) ; \n} \nreturn null ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) { \nf . format ( \"string \" ) ; \n} \nif ( strict && parentname != null ) { \nf . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \n} \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) { \nf . format ( \", \" ) ; \n} \nString val = getStringValue ( i ) ; \nif ( val != null ) { \nf . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) { \nf . format ( \", \" ) ; \n} \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) { \nthrow new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \n} \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) { \nf . format ( \", \" ) ; \n} \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) { \nf . format ( \"f\" ) ; \n} \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) { \nthrow new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \n} \nint len = val . length ( ) ; \nwhile ( ( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ) { \nlen -- ; \n} \nif ( len != val . length ( ) ) { \nval = val . substring ( 0 , len ) ; \n} \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \n} \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( String ) values . get ( i ) ; \n} \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Integer ) values . get ( i ) ; \n} \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Double ) values . get ( i ) ; \n} \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Float ) values . get ( i ) ; \n} \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Short ) values . get ( i ) ; \n} \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Byte ) values . get ( i ) ; \n} \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nva [ i ] = ( Long ) values . get ( i ) ; \n} \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nint totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen += bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nint pos = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos += bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) { \nthrow new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \n} \nif ( arr . getRank ( ) > 1 ) { \narr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \n} \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) { \nthrow new IllegalStateException ( \"Scan already underway.\" ) ; \n} \nif ( state >= 2 ) { \nthrow new IllegalStateException ( \"Scan has already been generated.\" ) ; \n} \nstate = 1 ; \nif ( proxyDsHandlers == null ) { \nproxyDsHandlers = Collections . EMPTY_MAP ; \n} \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) { \nsorter . sort ( crDsList ) ; \n} \nfor ( int i = 0 ; \ni < crDsList . size ( ) ; \ni ++ ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) { \ncatRefInfo . add ( dsInfo ) ; \n} \nelse { \natomicDsInfo . add ( dsInfo ) ; \n} \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) { \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5514": "public class CollectionLevelScanner { \npublic InvCatalogImpl generateProxyDsResolverCatalog ( ProxyDatasetHandler pdh ) { \nif ( state != 2 ) { \nthrow new IllegalStateException ( \"Scan has not been performed.\" ) ; \n} \nif ( ! proxyDsHandlers . containsValue ( pdh ) ) { \nthrow new IllegalArgumentException ( \"Unknown ProxyDatasetHandler.\" ) ; \n} \nInvCatalogImpl catalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topDs = ( InvDatasetImpl ) catalog . getDatasets ( ) . get ( 0 ) ; \nInvCrawlablePair actualDsInfo = pdh . getActualDataset ( atomicDsInfo ) ; \nif ( actualDsInfo == null ) { \nreturn catalog ; \n} \nInvDatasetImpl actualInvDs = ( InvDatasetImpl ) actualDsInfo . getInvDataset ( ) ; \nactualInvDs . setName ( pdh . getActualDatasetName ( actualDsInfo , topDs . getName ( ) ) ) ; \ncatalog . removeDataset ( topDs ) ; \ncatalog . addDataset ( actualInvDs ) ; \ncatalog . finish ( ) ; \nthis . addTopLevelMetadata ( catalog , false ) ; \nreturn catalog ; \n} \n} \n"}
{"5516": "public class ToolsUI { \nprivate void setThreddsDatatype ( thredds . client . catalog . Dataset invDataset , String wants ) { \nif ( invDataset == null ) { \nreturn ; \n} \nboolean wantsViewer = wants . equals ( \"File\" ) ; \nboolean wantsCoordSys = wants . equals ( \"CoordSys\" ) ; \ntry { \nif ( wantsViewer ) { \nopenNetcdfFile ( threddsDataFactory . openDataset ( invDataset , true , null , null ) ) ; \nreturn ; \n} \nif ( wantsCoordSys ) { \nNetcdfDataset ncd = threddsDataFactory . openDataset ( invDataset , true , null , null ) ; \nncd . enhance ( ) ; \nopenCoordSystems ( ncd ) ; \nreturn ; \n} \nDataFactory . Result threddsData = threddsDataFactory . openFeatureDataset ( invDataset , null ) ; \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( null , \"Failed to open err=\" + threddsData . errLog ) ; \nreturn ; \n} \njumptoThreddsDatatype ( threddsData ) ; \n} \ncatch ( IOException ioe ) { \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \nioe . printStackTrace ( ) ; \n} \n} \n} \n"}
{"5522": "public class CoordinateSystem { \nstatic public String makeName ( List < CoordinateAxis > axes ) { \nList < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; \nCollections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; \nStringBuilder buff = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < axesSorted . size ( ) ; \ni ++ ) { \nCoordinateAxis axis = axesSorted . get ( i ) ; \nif ( i > 0 ) { \nbuff . append ( \" \" ) ; \n} \nbuff . append ( axis . getFullNameEscaped ( ) ) ; \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5523": "public class CoordinateSystem { \nprivate CoordinateAxis lesserRank ( CoordinateAxis a1 , CoordinateAxis a2 ) { \nif ( a1 == null ) { \nreturn a2 ; \n} \nreturn ( a1 . getRank ( ) <= a2 . getRank ( ) ) ? a1 : a2 ; \n} \n} \n"}
{"5524": "public class CoordinateSystem { \npublic CoordinateAxis findAxis ( AxisType type ) { \nCoordinateAxis result = null ; \nfor ( CoordinateAxis axis : coordAxes ) { \nAxisType axisType = axis . getAxisType ( ) ; \nif ( ( axisType != null ) && ( axisType == type ) ) { \nresult = lesserRank ( result , axis ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5525": "public class CoordinateSystem { \npublic ProjectionCT getProjectionCT ( ) { \nfor ( CoordinateTransform ct : coordTrans ) { \nif ( ct instanceof ProjectionCT ) { \nreturn ( ProjectionCT ) ct ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5526": "public class CoordinateSystem { \npublic boolean isGeoXY ( ) { \nif ( ( xAxis == null ) || ( yAxis == null ) ) { \nreturn false ; \n} \nreturn null != getProjection ( ) && ! ( projection instanceof LatLonProjection ) ; \n} \n} \n"}
{"5527": "public class CoordinateSystem { \npublic boolean isRegular ( ) { \nfor ( CoordinateAxis axis : coordAxes ) { \nif ( ! ( axis instanceof CoordinateAxis1D ) ) { \nreturn false ; \n} \nif ( ! ( ( CoordinateAxis1D ) axis ) . isRegular ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5528": "public class CoordinateSystem { \npublic static boolean isSubset ( Collection < Dimension > subset , Collection < Dimension > set ) { \nfor ( Dimension d : subset ) { \nif ( ! ( set . contains ( d ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5529": "public class CoordinateSystem { \npublic boolean containsAxes ( List < CoordinateAxis > wantAxes ) { \nfor ( CoordinateAxis ca : wantAxes ) { \nif ( ! containsAxis ( ca . getFullName ( ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5530": "public class CoordinateSystem { \npublic boolean containsAxis ( String axisName ) { \nfor ( CoordinateAxis ca : coordAxes ) { \nif ( ca . getFullName ( ) . equals ( axisName ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5531": "public class CoordinateSystem { \npublic boolean containsDomain ( List < Dimension > wantDimensions ) { \nfor ( Dimension d : wantDimensions ) { \nif ( ! domain . contains ( d ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5532": "public class CoordinateSystem { \npublic boolean containsAxisTypes ( List < AxisType > wantAxes ) { \nfor ( AxisType wantAxisType : wantAxes ) { \nif ( ! containsAxisType ( wantAxisType ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5533": "public class CoordinateSystem { \npublic boolean containsAxisType ( AxisType wantAxisType ) { \nfor ( CoordinateAxis ca : coordAxes ) { \nif ( ca . getAxisType ( ) == wantAxisType ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5534": "public class DAPNode { \npublic DAPNode cloneDAG ( CloneMap map ) throws CloneNotSupportedException { \nDAPNode node = ( DAPNode ) super . clone ( ) ; \nmap . nodes . put ( this , node ) ; \nDAPNode tmp = map . nodes . get ( _myParent ) ; \nif ( tmp != node ) { \n_myParent = tmp ; \n} \nreturn node ; \n} \n} \n"}
{"5535": "public class BeanTable { \npublic Object getSelectedBean ( ) { \nint viewRowIndex = jtable . getSelectedRow ( ) ; \nif ( viewRowIndex < 0 ) { \nreturn null ; \n} \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nreturn ( modelRowIndex < 0 ) || ( modelRowIndex >= beans . size ( ) ) ? null : beans . get ( modelRowIndex ) ; \n} \n} \n"}
{"5536": "public class BeanTable { \npublic List getSelectedBeans ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nfor ( int viewRowIndex : viewRowIndices ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nlist . add ( beans . get ( modelRowIndex ) ) ; \nif ( debugSelected ) { \nSystem . out . println ( \" bean selected= \" + modelRowIndex + \" \" + beans . get ( modelRowIndex ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"5537": "public class BeanTable { \npublic ArrayList < Object > getSelectedCells ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nint [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; \nfor ( int i = 0 ; \ni < viewRowIndices . length ; \ni ++ ) { \nfor ( int j = 0 ; \ni < viewColumnIndices . length ; \nj ++ ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; \nint modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; \nlist . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"5538": "public class BeanTable { \npublic void setSelectedBean ( Object bean ) { \nif ( bean == null ) { \nreturn ; \n} \nint modelRowIndex = beans . indexOf ( bean ) ; \nint viewRowIndex = jtable . convertRowIndexToView ( modelRowIndex ) ; \nif ( viewRowIndex >= 0 ) { \njtable . getSelectionModel ( ) . setSelectionInterval ( viewRowIndex , viewRowIndex ) ; \n} \nmakeRowVisible ( viewRowIndex ) ; \n} \n} \n"}
{"5541": "public class HTTPMethodStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nclosed = true ; \ntry { \nconsume ( ) ; \n} \nfinally { \nsuper . close ( ) ; \n} \nif ( method != null ) { \nmethod . close ( ) ; \n} \n} \n} \n"}
{"5543": "public class NestedTable { \nprivate boolean isCoordinate ( Variable v ) { \nif ( v == null ) { \nreturn false ; \n} \nString name = v . getShortName ( ) ; \nreturn ( latVE != null && latVE . axisName . equals ( name ) ) || ( lonVE != null && lonVE . axisName . equals ( name ) ) || ( altVE != null && altVE . axisName . equals ( name ) ) || ( stnAltVE != null && stnAltVE . axisName . equals ( name ) ) || ( timeVE != null && timeVE . axisName . equals ( name ) ) || ( nomTimeVE != null && nomTimeVE . axisName . equals ( name ) ) ; \n} \n} \n"}
{"5544": "public class NestedTable { \nprivate CoordVarExtractor findCoordinateAxis ( Table . CoordName coordName , Table t , int nestingLevel ) { \nif ( t == null ) { \nreturn null ; \n} \nString axisName = t . findCoordinateVariableName ( coordName ) ; \nif ( axisName != null ) { \nVariableDS v = t . findVariable ( axisName ) ; \nif ( v != null ) { \nreturn new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \n} \nif ( t . extraJoins != null ) { \nfor ( Join j : t . extraJoins ) { \nv = j . findVariable ( axisName ) ; \nif ( v != null ) { \nreturn new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \n} \n} \n} \nif ( t instanceof Table . TableSingleton ) { \nTable . TableSingleton ts = ( Table . TableSingleton ) t ; \nreturn new CoordVarStructureData ( axisName , ts . sdata ) ; \n} \nif ( t instanceof Table . TableTop ) { \nv = ( VariableDS ) ds . findVariable ( axisName ) ; \nif ( v != null ) { \nreturn new CoordVarTop ( v ) ; \n} \nelse { \nreturn new CoordVarConstant ( coordName . toString ( ) , \"\" , axisName ) ; \n} \n} \nerrlog . format ( \"NestedTable: cant find variable '%s' for coordinate type %s %n\" , axisName , coordName ) ; \n} \nreturn findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; \n} \n} \n"}
{"5545": "public class NestedTable { \nprivate void addDataVariables ( List < VariableSimpleIF > list , Table t ) { \nif ( t . parent != null ) { \naddDataVariables ( list , t . parent ) ; \n} \nfor ( VariableSimpleIF col : t . cols . values ( ) ) { \nif ( t . nondataVars . contains ( col . getFullName ( ) ) ) { \ncontinue ; \n} \nif ( t . nondataVars . contains ( col . getShortName ( ) ) ) { \ncontinue ; \n} \nlist . add ( col ) ; \n} \n} \n} \n"}
{"5547": "public class NestedTable { \nStationFeature makeStation ( StructureData stationData ) { \nif ( stnVE . isMissing ( stationData ) ) { \nreturn null ; \n} \nString stationName = stnVE . getCoordValueAsString ( stationData ) ; \nString stationDesc = ( stnDescVE == null ) ? \"\" : stnDescVE . getCoordValueAsString ( stationData ) ; \nString stnWmoId = ( wmoVE == null ) ? \"\" : wmoVE . getCoordValueAsString ( stationData ) ; \ndouble lat = latVE . getCoordValue ( stationData ) ; \ndouble lon = lonVE . getCoordValue ( stationData ) ; \ndouble elev = ( stnAltVE == null ) ? Double . NaN : stnAltVE . getCoordValue ( stationData ) ; \nif ( Double . isNaN ( lat ) || Double . isNaN ( lon ) ) { \nreturn null ; \n} \nreturn new StationFeatureImpl ( stationName , stationDesc , stnWmoId , lat , lon , elev , - 1 , stationData ) ; \n} \n} \n"}
{"5549": "public class SimpleUnit { \nstatic public SimpleUnit factory ( String name ) { \ntry { \nreturn factoryWithExceptions ( name ) ; \n} \ncatch ( Exception e ) { \nif ( debugParse ) { \nSystem . out . println ( \"Parse \" + name + \" got Exception \" + e ) ; \n} \nreturn null ; \n} \n} \n} \n"}
{"5550": "public class SimpleUnit { \nstatic public SimpleUnit factoryWithExceptions ( String name ) throws UnitException { \nUnitFormat format = UnitFormatManager . instance ( ) ; \nUnit uu = format . parse ( name ) ; \nif ( isTimeUnit ( uu ) ) { \nreturn new TimeUnit ( name ) ; \n} \nreturn new SimpleUnit ( uu ) ; \n} \n} \n"}
{"5553": "public class SimpleUnit { \nstatic public boolean isDateUnit ( ucar . units . Unit uu ) { \nboolean ok = uu . isCompatible ( dateReferenceUnit ) ; \nif ( ! ok ) { \nreturn false ; \n} \ntry { \nuu . getConverterTo ( dateReferenceUnit ) ; \nreturn true ; \n} \ncatch ( ConversionException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5557": "public class SimpleUnit { \npublic boolean isUnknownUnit ( ) { \nucar . units . Unit uu = getUnit ( ) ; \nif ( uu instanceof ucar . units . UnknownUnit ) { \nreturn true ; \n} \nif ( uu instanceof ucar . units . DerivedUnit ) { \nreturn isUnknownUnit ( ( ucar . units . DerivedUnit ) uu ) ; \n} \nif ( uu instanceof ucar . units . ScaledUnit ) { \nucar . units . ScaledUnit scu = ( ucar . units . ScaledUnit ) uu ; \nUnit u = scu . getUnit ( ) ; \nif ( u instanceof ucar . units . UnknownUnit ) { \nreturn true ; \n} \nif ( u instanceof ucar . units . DerivedUnit ) { \nreturn isUnknownUnit ( ( ucar . units . DerivedUnit ) u ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5558": "public class SimpleUnit { \npublic double getValue ( ) { \nif ( ! ( uu instanceof ScaledUnit ) ) { \nreturn Double . NaN ; \n} \nScaledUnit offset = ( ScaledUnit ) uu ; \nreturn offset . getScale ( ) ; \n} \n} \n"}
{"5562": "public class ImageArrayAdapter { \npublic static java . awt . image . BufferedImage makeGrayscaleImage ( Array ma , IsMissingEvaluator missEval ) { \nif ( ma . getRank ( ) < 2 ) { \nreturn null ; \n} \nif ( ma . getRank ( ) == 3 ) { \nma = ma . reduce ( ) ; \n} \nif ( ma . getRank ( ) == 3 ) { \nma = ma . slice ( 0 , 0 ) ; \n} \nint h = ma . getShape ( ) [ 0 ] ; \nint w = ma . getShape ( ) [ 1 ] ; \nDataBuffer dataBuffer = makeDataBuffer ( ma , missEval ) ; \nWritableRaster raster = WritableRaster . createInterleavedRaster ( dataBuffer , w , h , w , 1 , new int [ ] { \n0 } \n, null ) ; \nColorSpace cs = ColorSpace . getInstance ( ColorSpace . CS_GRAY ) ; \nComponentColorModel colorModel = new ComponentColorModel ( cs , new int [ ] { \n8 } \n, false , false , Transparency . OPAQUE , DataBuffer . TYPE_BYTE ) ; \nreturn new BufferedImage ( colorModel , raster , false , null ) ; \n} \n} \n"}
{"5563": "public class CatalogCrawler { \npublic int crawl ( InvCatalogImpl cat , CancelTask task , PrintWriter out , Object context ) { \nif ( out != null ) { \nout . println ( \"***CATALOG \" + cat . getCreateFrom ( ) ) ; \n} \ncountCatrefs = 0 ; \nfor ( InvDataset ds : cat . getDatasets ( ) ) { \nif ( type == Type . all ) { \ncrawlDataset ( ds , task , out , context , true ) ; \n} \nelse { \ncrawlDirectDatasets ( ds , task , out , context , true ) ; \n} \nif ( ( task != null ) && task . isCancel ( ) ) { \nbreak ; \n} \n} \nreturn 1 + countCatrefs ; \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) { \n( ( InvCatalogRef ) ds ) . release ( ) ; \n} \nreturn ; \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) { \nout . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \n} \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) { \ncatref . release ( ) ; \n} \nreturn ; \n} \n} \nif ( ! isCatRef || isDataScan ) { \nlisten . getDataset ( ds , context ) ; \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) { \nlisten . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) { \nbreak ; \n} \n} \nif ( isCatRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) { \n( ( InvCatalogRef ) ds ) . release ( ) ; \n} \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) { \nout . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \n} \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) { \ncatref . release ( ) ; \n} \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) { \nleaves . add ( dds ) ; \n} \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) { \nbreak ; \n} \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) { \ncrawlDirectDatasets ( dds , task , out , context , release ) ; \n} \nif ( ( task != null ) && task . isCancel ( ) ) { \nbreak ; \n} \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5566": "public class GribIndexCache { \npublic static File getFileOrCache ( String fileLocation ) { \nFile result = getExistingFileOrCache ( fileLocation ) ; \nif ( result != null ) { \nreturn result ; \n} \nreturn getDiskCache2 ( ) . getFile ( fileLocation ) ; \n} \n} \n"}
{"5569": "public class RandomAccessFile { \nstatic public List < String > getAllFiles ( ) { \nif ( null == allFiles ) { \nreturn null ; \n} \nList < String > result = new ArrayList < > ( ) ; \nresult . addAll ( allFiles ) ; \nCollections . sort ( result ) ; \nreturn result ; \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) { \nreturn ; \n} \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) { \nSystem . out . println ( \"  close \" + location ) ; \n} \n} \nif ( file == null ) { \nreturn ; \n} \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5571": "public class RandomAccessFile { \npublic void seek ( long pos ) throws IOException { \nif ( pos < 0 ) { \nthrow new java . io . IOException ( \"Negative seek offset\" ) ; \n} \nif ( ( pos >= bufferStart ) && ( pos < dataEnd ) ) { \nfilePosition = pos ; \nreturn ; \n} \nreadBuffer ( pos ) ; \n} \n} \n"}
{"5581": "public class RandomAccessFile { \npublic String readStringMax ( int nbytes ) throws IOException { \nbyte [ ] b = new byte [ nbytes ] ; \nreadFully ( b ) ; \nint count ; \nfor ( count = 0 ; \ncount < nbytes ; \ncount ++ ) { \nif ( b [ count ] == 0 ) { \nbreak ; \n} \n} \nreturn new String ( b , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5592": "public class Selector { \npublic void appendQuery ( StringBuffer sbuff , ArrayList values ) { \nif ( template != null ) { \nappendQueryFromTemplate ( sbuff , values ) ; \n} \nelse { \nappendQueryFromParamValue ( sbuff , values ) ; \n} \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nint countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nwhile ( iterator . hasNext ( ) && count ++ < 100 ) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \ncountDir ++ ; \n} \nelse { \ncountFile ++ ; \n} \n} \n} \npartitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5596": "public class DirectoryBuilder { \npublic List < DirectoryBuilder > constructChildren ( IndexReader indexReader , CollectionUpdateType forceCollection ) throws IOException { \nif ( childrenConstructed ) { \nreturn children ; \n} \nif ( index != null && forceCollection == CollectionUpdateType . nocheck ) { \nconstructChildrenFromIndex ( indexReader , false ) ; \n} \nelse { \nscanForChildren ( ) ; \n} \npartitionStatus = ( children . size ( ) > 0 ) ? PartitionStatus . isDirectoryPartition : PartitionStatus . isLeaf ; \nchildrenConstructed = true ; \nreturn children ; \n} \n} \n"}
{"5597": "public class DirectoryBuilder { \nprivate void scanForChildren ( ) { \nif ( debug ) { \nSystem . out . printf ( \"DirectoryBuilder.scanForChildren on %s \" , dir ) ; \n} \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { \nfor ( Path p : ds ) { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \nchildren . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; \nif ( debug && ( ++ count % 10 == 0 ) ) { \nSystem . out . printf ( \"%d \" , count ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nif ( debug ) { \nSystem . out . printf ( \"done=%d%n\" , count ) ; \n} \nchildrenConstructed = true ; \n} \n} \n"}
{"5598": "public class DirectoryBuilder { \npublic List < MFile > readFilesFromIndex ( IndexReader indexReader ) throws IOException { \nList < MFile > result = new ArrayList < > ( 100 ) ; \nif ( index == null ) { \nreturn result ; \n} \nindexReader . readMFiles ( index , result ) ; \nreturn result ; \n} \n} \n"}
{"5602": "public class FileCache { \n@ Override public void eject ( Object hashKey ) { \nif ( disabled . get ( ) ) { \nreturn ; \n} \nCacheElement wantCacheElem = cache . get ( hashKey ) ; \nif ( wantCacheElem == null ) { \nreturn ; \n} \nsynchronized ( wantCacheElem ) { \nfor ( CacheElement . CacheFile want : wantCacheElem . list ) { \nfiles . remove ( want . ncfile ) ; \ntry { \nwant . ncfile . setFileCache ( null ) ; \nwant . ncfile . close ( ) ; \nlog . debug ( \"close \" + want . ncfile . getLocation ( ) ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"close failed on \" + want . ncfile . getLocation ( ) , e ) ; \n} \nwant . ncfile = null ; \nif ( debugPrint ) { \nSystem . out . println ( \"  FileCache \" + name + \" eject \" + hashKey ) ; \n} \n} \nwantCacheElem . list . clear ( ) ; \n} \ncache . remove ( hashKey ) ; \n} \n} \n"}
{"5603": "public class FileCache { \n@ Override public boolean release ( FileCacheable ncfile ) throws IOException { \nif ( ncfile == null ) { \nreturn false ; \n} \nif ( disabled . get ( ) ) { \nncfile . setFileCache ( null ) ; \nncfile . close ( ) ; \nreturn false ; \n} \nCacheElement . CacheFile file = files . get ( ncfile ) ; \nif ( file != null ) { \nif ( ! file . isLocked . get ( ) ) { \ncacheLog . warn ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \" not locked; hash= \" + ncfile . hashCode ( ) ) ; \n} \nfile . lastAccessed = System . currentTimeMillis ( ) ; \nfile . countAccessed ++ ; \nfile . isLocked . set ( false ) ; \nfile . ncfile . release ( ) ; \nif ( cacheLog . isDebugEnabled ( ) ) { \ncacheLog . debug ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \"; hash= \" + ncfile . hashCode ( ) ) ; \n} \nif ( debugPrint ) { \nSystem . out . printf ( \"  FileCache %s release %s lock=%s count=%d%n\" , name , ncfile . getLocation ( ) , file . isLocked . get ( ) , countLocked ( ) ) ; \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"5604": "public class BufrNumbers { \nprivate static int int4 ( int a , int b , int c , int d ) { \nif ( a == 0xff && b == 0xff && c == 0xff && d == 0xff ) { \nreturn UNDEFINED ; \n} \nreturn ( 1 - ( ( a & 128 ) >> 6 ) ) * ( ( a & 127 ) << 24 | b << 16 | c << 8 | d ) ; \n} \n} \n"}
{"5605": "public class FileCacheARC { \nprivate CacheElement updateInCache ( CacheElement elem ) { \nif ( shadowCache . firstKey ( ) == elem ) { \nreturn elem ; \n} \nelem . updateAccessed ( ) ; \nCacheElement prev = shadowCache . put ( elem , elem ) ; \nif ( prev != null && ( elem != prev ) ) { \nCacheElementComparator cc = new CacheElementComparator ( ) ; \nSystem . out . printf ( \"elem != prev compare=%d%n\" , cc . compare ( elem , prev ) ) ; \nSystem . out . printf ( \"hash elem =%d prev=%d%n\" , elem . hashCode ( ) , prev . hashCode ( ) ) ; \n} \nreturn elem ; \n} \n} \n"}
{"5606": "public class FileCacheARC { \npublic synchronized void clearCache ( boolean force ) { \nList < CacheElement . CacheFile > deleteList = new ArrayList < > ( 2 * cache . size ( ) ) ; \nif ( force ) { \ncache . clear ( ) ; \ndeleteList . addAll ( files . values ( ) ) ; \nfiles . clear ( ) ; \n} \nelse { \nIterator < CacheElement . CacheFile > iter = files . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCacheElement . CacheFile file = iter . next ( ) ; \nif ( file . isLocked . compareAndSet ( false , true ) ) { \nfile . remove ( ) ; \ndeleteList . add ( file ) ; \niter . remove ( ) ; \n} \n} \nfor ( CacheElement elem : cache . values ( ) ) { \nif ( elem . list . size ( ) == 0 ) { \ncache . remove ( elem . hashKey ) ; \n} \n} \n} \nfor ( CacheElement . CacheFile file : deleteList ) { \nif ( force && file . isLocked . get ( ) ) { \ncacheLog . warn ( \"FileCacheARC \" + name + \" force close locked file= \" + file ) ; \n} \nif ( file . ncfile == null ) { \ncontinue ; \n} \ntry { \nfile . ncfile . setFileCache ( null ) ; \nfile . ncfile . close ( ) ; \nfile . ncfile = null ; \n} \ncatch ( IOException e ) { \nlog . error ( \"FileCacheARC \" + name + \" close failed on \" + file ) ; \n} \n} \nif ( cacheLog . isDebugEnabled ( ) ) { \ncacheLog . debug ( \"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList . size ( ) + \" left=\" + files . size ( ) ) ; \n} \n} \n} \n"}
{"5607": "public class GridCoordSys { \nvoid makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { \nif ( vt != null ) { \nreturn ; \n} \nif ( vCT == null ) { \nreturn ; \n} \nvt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; \nif ( vt == null ) { \nif ( parseInfo != null ) { \nparseInfo . format ( \"  - ERR can't make VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \n} \nelse { \nif ( parseInfo != null ) { \nparseInfo . format ( \"  - VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \n} \n} \n} \n"}
{"5608": "public class GridCoordSys { \n@ Override public boolean isGlobalLon ( ) { \nif ( ! isLatLon ) { \nreturn false ; \n} \nif ( ! ( horizXaxis instanceof CoordinateAxis1D ) ) { \nreturn false ; \n} \nCoordinateAxis1D lon = ( CoordinateAxis1D ) horizXaxis ; \ndouble first = lon . getCoordEdge ( 0 ) ; \ndouble last = lon . getCoordEdge ( ( int ) lon . getSize ( ) ) ; \ndouble min = Math . min ( first , last ) ; \ndouble max = Math . max ( first , last ) ; \nreturn ( max - min ) >= 360 ; \n} \n} \n"}
{"5609": "public class GridCoordSys { \n@ Override public boolean isZPositive ( ) { \nif ( vertZaxis == null ) { \nreturn false ; \n} \nif ( vertZaxis . getPositive ( ) != null ) { \nreturn vertZaxis . getPositive ( ) . equalsIgnoreCase ( ucar . nc2 . constants . CF . POSITIVE_UP ) ; \n} \nif ( vertZaxis . getAxisType ( ) == AxisType . Height ) { \nreturn true ; \n} \nreturn vertZaxis . getAxisType ( ) != AxisType . Pressure ; \n} \n} \n"}
{"5610": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoord ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) { \nresult = new int [ 2 ] ; \n} \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElement ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElement ( y_coord ) ; \nreturn result ; \n} \nelse if ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) { \ng2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \n} \nint [ ] result2 = new int [ 2 ] ; \nboolean found = g2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nif ( found ) { \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \n} \nelse { \nresult [ 0 ] = - 1 ; \nresult [ 1 ] = - 1 ; \n} \nreturn result ; \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5611": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoordBounded ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) { \nresult = new int [ 2 ] ; \n} \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElementBounded ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElementBounded ( y_coord ) ; \nreturn result ; \n} \nelse if ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) { \ng2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \n} \nint [ ] result2 = new int [ 2 ] ; \ng2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \nreturn result ; \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5614": "public class MyTextField { \nprotected int getItemPos ( ) { \nif ( nitems < 1 ) { \nreturn - arrow_size ; \n} \nelse if ( nitems == 1 ) { \nreturn b . width / 2 ; \n} \nint item = table . getSelectedRowIndex ( ) ; \nint eff_width = b . width - 2 * arrow_size ; \nint pixel = ( item * eff_width ) / ( nitems - 1 ) ; \nreturn pixel + arrow_size ; \n} \n} \n"}
{"5615": "public class MyTextField { \nprotected int getItem ( int pixel ) { \nif ( nitems < 2 ) { \nreturn 0 ; \n} \nint eff_width = b . width - 2 * arrow_size ; \ndouble fitem = ( ( double ) ( pixel - arrow_size ) * ( nitems - 1 ) ) / eff_width ; \nint item = ( int ) ( fitem + .5 ) ; \nitem = Math . max ( Math . min ( item , nitems - 1 ) , 0 ) ; \nreturn item ; \n} \n} \n"}
{"5616": "public class DirectoryCollection { \npublic void iterateOverMFileCollection ( Visitor visit ) throws IOException { \nif ( debug ) { \nSystem . out . printf ( \" iterateOverMFileCollection %s \" , collectionDir ) ; \n} \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( collectionDir , new MyStreamFilter ( ) ) ) { \nfor ( Path p : ds ) { \ntry { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( ! attr . isDirectory ( ) ) { \nvisit . consume ( new MFileOS7 ( p ) ) ; \n} \nif ( debug ) { \nSystem . out . printf ( \"%d \" , count ++ ) ; \n} \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Failed to read attributes from file found in Files.newDirectoryStream \" , ioe ) ; \n} \n} \n} \nif ( debug ) { \nSystem . out . printf ( \"%d%n\" , count ) ; \n} \n} \n} \n"}
{"5617": "public class TdsDownloader { \npublic void getRemoteFiles ( final CancelTask _cancel ) { \nthis . cancel = _cancel ; \nString urls = config . getServerPrefix ( ) + \"/thredds/admin/log/\" + type + \"/\" ; \nta . append ( String . format ( \"Download URL = %s%n\" , urls ) ) ; \nString contents = null ; \ntry ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { \nint statusCode = method . execute ( ) ; \nif ( statusCode == 200 ) { \ncontents = method . getResponseAsString ( ) ; \n} \nif ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s%n%n\" , urls ) ) ; \nreturn ; \n} \nelse { \nta . append ( String . format ( \"Logs at URL = %s%n%s%n\" , urls , contents ) ) ; \n} \n} \ncatch ( Throwable t ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s error = %s%n%n\" , urls , t . getMessage ( ) ) ) ; \nt . printStackTrace ( ) ; \nreturn ; \n} \nfinal String list = contents ; \nSwingWorker worker = new SwingWorker < String , Void > ( ) { \n@ Override protected String doInBackground ( ) throws Exception { \ntry { \nta . append ( String . format ( \"Local log files stored in = %s%n%n\" , localDir ) ) ; \nString [ ] lines = list . split ( \"\\n\" ) ; \nfor ( String line : lines ) { \nnew RemoteLog ( line . trim ( ) ) ; \nif ( cancel . isCancel ( ) ) { \nbreak ; \n} \n} \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \n} \nreturn null ; \n} \npublic void done ( ) { \nif ( cancel . isCancel ( ) ) { \nta . append ( String . format ( \"Download was cancelled for %s%n\" , type ) ) ; \n} \nelse { \nta . append ( String . format ( \"Download complete for %s%n\" , type ) ) ; \n} \n} \n} \n; \nworker . execute ( ) ; \n} \n} \n"}
{"5619": "public class CalendarPeriod { \npublic static CalendarPeriod . Field fromUnitString ( String udunit ) { \nudunit = udunit . trim ( ) ; \nudunit = udunit . toLowerCase ( ) ; \nif ( udunit . equals ( \"s\" ) ) { \nreturn Field . Second ; \n} \nif ( udunit . equals ( \"ms\" ) ) { \nreturn Field . Millisec ; \n} \nif ( udunit . endsWith ( \"s\" ) ) { \nudunit = udunit . substring ( 0 , udunit . length ( ) - 1 ) ; \n} \nswitch ( udunit ) { \ncase \"second\" : case \"sec\" : return Field . Second ; \ncase \"millisecond\" : case \"millisec\" : case \"msec\" : return Field . Millisec ; \ncase \"minute\" : case \"min\" : return Field . Minute ; \ncase \"hour\" : case \"hr\" : case \"h\" : return Field . Hour ; \ncase \"day\" : case \"d\" : return Field . Day ; \ncase \"month\" : case \"mon\" : return Field . Month ; \ncase \"year\" : case \"yr\" : return Field . Year ; \ndefault : throw new IllegalArgumentException ( \"cant convert \" + udunit + \" to CalendarPeriod\" ) ; \n} \n} \n} \n"}
{"5620": "public class CalendarPeriod { \npublic static CalendarPeriod of ( int value , Field field ) { \nCalendarPeriod want = new CalendarPeriod ( value , field ) ; \nif ( cache == null ) { \nreturn want ; \n} \nCalendarPeriod got = cache . getIfPresent ( want ) ; \nif ( got != null ) { \nreturn got ; \n} \ncache . put ( want , want ) ; \nreturn want ; \n} \n} \n"}
{"5621": "public class CalendarPeriod { \npublic static CalendarPeriod of ( String udunit ) { \nint value ; \nString units ; \nString [ ] split = StringUtil2 . splitString ( udunit ) ; \nif ( split . length == 1 ) { \nvalue = 1 ; \nunits = split [ 0 ] ; \n} \nelse if ( split . length == 2 ) { \ntry { \nvalue = Integer . parseInt ( split [ 0 ] ) ; \n} \ncatch ( Throwable t ) { \nreturn null ; \n} \nunits = split [ 1 ] ; \n} \nelse { \nreturn null ; \n} \nCalendarPeriod . Field unit = CalendarPeriod . fromUnitString ( units ) ; \nreturn CalendarPeriod . of ( value , unit ) ; \n} \n} \n"}
{"5622": "public class CalendarPeriod { \npublic int subtract ( CalendarDate start , CalendarDate end ) { \nlong diff = end . getDifferenceInMsecs ( start ) ; \nint thislen = millisecs ( ) ; \nif ( ( diff % thislen != 0 ) ) { \nlog . warn ( \"roundoff error\" ) ; \n} \nreturn ( int ) ( diff / thislen ) ; \n} \n} \n"}
{"5624": "public class CalendarPeriod { \npublic double getValueInMillisecs ( ) { \nif ( field == CalendarPeriod . Field . Month ) { \nreturn 30.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \n} \nelse if ( field == CalendarPeriod . Field . Year ) { \nreturn 365.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \n} \nelse { \nreturn millisecs ( ) ; \n} \n} \n} \n"}
{"5625": "public class CalendarPeriod { \npublic int getOffset ( CalendarDate start , CalendarDate end ) { \nif ( start . equals ( end ) ) { \nreturn 0 ; \n} \nlong start_millis = start . getDateTime ( ) . getMillis ( ) ; \nlong end_millis = end . getDateTime ( ) . getMillis ( ) ; \nPeriod p ; \nif ( start_millis < end_millis ) { \np = new Period ( start_millis , end_millis + 5000 , getPeriodType ( ) ) ; \n} \nelse { \np = new Period ( start_millis + 5000 , end_millis , getPeriodType ( ) ) ; \n} \nreturn p . get ( getDurationFieldType ( ) ) ; \n} \n} \n"}
{"5629": "public class DataRootPathMatcher { \npublic String findLongestPathMatch ( String reqPath ) { \nSortedSet < String > tail = treeSet . tailSet ( reqPath ) ; \nif ( tail . isEmpty ( ) ) { \nreturn null ; \n} \nString after = tail . first ( ) ; \nif ( reqPath . startsWith ( after ) ) { \nreturn tail . first ( ) ; \n} \nfor ( String key : tail ) { \nif ( reqPath . startsWith ( key ) ) { \nreturn key ; \n} \nif ( StringUtil2 . match ( reqPath , key ) == 0 ) { \nbreak ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5630": "public class DataRootPathMatcher { \npublic DataRoot findDataRoot ( String reqPath ) { \nString path = findLongestPathMatch ( reqPath ) ; \nif ( path == null ) { \nreturn null ; \n} \nDataRootExt dataRootExt = map . get ( path ) ; \nif ( dataRootExt == null ) { \nlogger . error ( \"DataRootPathMatcher found path {} but not in map\" , path ) ; \nreturn null ; \n} \nreturn convert2DataRoot ( dataRootExt ) ; \n} \n} \n"}
{"5631": "public class DataRootPathMatcher { \npublic @ Nonnull DataRoot convert2DataRoot ( DataRootExt dataRootExt ) { \nDataRoot dataRoot = dataRootExt . getDataRoot ( ) ; \nif ( dataRoot != null ) { \nreturn dataRoot ; \n} \ndataRoot = readDataRootFromCatalog ( dataRootExt ) ; \ndataRootExt . setDataRoot ( dataRoot ) ; \nreturn dataRoot ; \n} \n} \n"}
{"5632": "public class NcssParamsBean { \npublic CalendarDateRange getCalendarDateRange ( Calendar cal ) { \nif ( dateRange == null ) { \nreturn null ; \n} \nif ( cal . equals ( Calendar . getDefault ( ) ) ) { \nreturn dateRange ; \n} \nreturn makeCalendarDateRange ( cal ) ; \n} \n} \n"}
{"5635": "public class NetcdfFileWriter { \npublic Group addGroup ( Group parent , String name ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nif ( parent == null ) { \nreturn ncfile . getRootGroup ( ) ; \n} \nGroup result = new Group ( ncfile , parent , name ) ; \nparent . addGroup ( result ) ; \nreturn result ; \n} \n} \n"}
{"5636": "public class NetcdfFileWriter { \npublic EnumTypedef addTypedef ( Group g , EnumTypedef td ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nif ( ! version . isExtendedModel ( ) ) { \nthrow new IllegalArgumentException ( \"Enum type only supported in extended model, this version is=\" + version ) ; \n} \ng . addEnumeration ( td ) ; \nreturn td ; \n} \n} \n"}
{"5637": "public class NetcdfFileWriter { \npublic Attribute deleteGroupAttribute ( Group g , String attName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nAttribute att = g . findAttribute ( attName ) ; \nif ( null == att ) { \nreturn null ; \n} \ng . remove ( att ) ; \nreturn att ; \n} \n} \n"}
{"5638": "public class NetcdfFileWriter { \npublic Attribute renameGroupAttribute ( Group g , String oldName , String newName ) { \nif ( ! defineMode ) { \nthrow new UnsupportedOperationException ( \"not in define mode\" ) ; \n} \nif ( ! isValidObjectName ( newName ) ) { \nString newnewName = createValidObjectName ( newName ) ; \nlog . warn ( \"illegal attribute name= \" + newName + \" change to \" + newnewName ) ; \nnewName = newnewName ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nAttribute att = g . findAttribute ( oldName ) ; \nif ( null == att ) { \nreturn null ; \n} \ng . remove ( att ) ; \natt = new Attribute ( newName , att . getValues ( ) ) ; \ng . addAttribute ( att ) ; \nreturn att ; \n} \n} \n"}
{"5639": "public class NetcdfFileWriter { \npublic Structure addRecordStructure ( ) { \nif ( version != Version . netcdf3 ) { \nreturn null ; \n} \nboolean ok = ( Boolean ) ncfile . sendIospMessage ( NetcdfFile . IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \nif ( ! ok ) { \nthrow new IllegalStateException ( \"can't add record variable\" ) ; \n} \nreturn ( Structure ) ncfile . findVariable ( \"record\" ) ; \n} \n} \n"}
{"5641": "public class Bean { \npublic void writeProperties ( PrintWriter out ) throws IOException { \nif ( p == null ) { \np = BeanParser . getParser ( o . getClass ( ) ) ; \n} \np . writeProperties ( o , out ) ; \n} \n} \n"}
{"5642": "public class ThreddsMetadataExtractor { \npublic ThreddsMetadata extract ( Dataset threddsDataset ) throws IOException { \nThreddsMetadata metadata = new ThreddsMetadata ( ) ; \nMap < String , Object > flds = metadata . getFlds ( ) ; \ntry ( DataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( threddsDataset , null ) ) { \nif ( result . fatalError ) { \nlogger . warn ( \" openFeatureDataset failed, errs=%s%n\" , result . errLog ) ; \nreturn null ; \n} \nif ( result . featureType . isCoverageFeatureType ( ) ) { \nGridDataset gridDataset = ( GridDataset ) result . featureDataset ; \nflds . put ( Dataset . GeospatialCoverage , extractGeospatial ( gridDataset ) ) ; \nCalendarDateRange tc = extractCalendarDateRange ( gridDataset ) ; \nif ( tc != null ) { \nflds . put ( Dataset . TimeCoverage , tc ) ; \n} \nThreddsMetadata . VariableGroup vars = extractVariables ( threddsDataset . getDataFormatName ( ) , gridDataset ) ; \nif ( vars != null ) { \nflds . put ( Dataset . VariableGroups , vars ) ; \n} \n} \nelse if ( result . featureType . isPointFeatureType ( ) ) { \nPointDatasetImpl pobsDataset = ( PointDatasetImpl ) result . featureDataset ; \nLatLonRect llbb = pobsDataset . getBoundingBox ( ) ; \nif ( null != llbb ) { \nflds . put ( Dataset . GeospatialCoverage , new ThreddsMetadata . GeospatialCoverage ( llbb , null , 0.0 , 0.0 ) ) ; \n} \nCalendarDateRange tc = extractCalendarDateRange ( pobsDataset ) ; \nif ( tc != null ) { \nflds . put ( Dataset . TimeCoverage , tc ) ; \n} \nThreddsMetadata . VariableGroup vars = extractVariables ( pobsDataset ) ; \nif ( vars != null ) { \nflds . put ( Dataset . VariableGroups , vars ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Error opening dataset \" + threddsDataset . getName ( ) , ioe ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"5647": "public class ConvertD2N { \npublic Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { \nArray data = convert ( dataV ) ; \nif ( ( dataV . darray != null ) && ( dataV . bt instanceof DString ) ) { \nif ( v . getDataType ( ) == DataType . STRING ) { \nreturn convertStringArray ( data , v ) ; \n} \nelse if ( v . getDataType ( ) == DataType . CHAR ) { \nreturn convertStringArrayToChar ( dataV . darray , v , section ) ; \n} \nelse { \nString mess = \"DODSVariable convertArray String invalid dataType= \" + v . getDataType ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalArgumentException ( mess ) ; \n} \n} \nif ( ( dataV . bt instanceof DString ) && ( v . getDataType ( ) == DataType . CHAR ) ) { \nreturn convertStringToChar ( data , v ) ; \n} \nreturn data ; \n} \n} \n"}
{"5649": "public class MetadataManager { \nstatic synchronized public void closeAll ( ) { \nList < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; \nfor ( MetadataManager mm : closeDatabases ) { \nif ( debug ) { \nSystem . out . println ( \"  close database \" + mm . collectionName ) ; \n} \nmm . close ( ) ; \n} \nopenDatabases = new ArrayList < > ( ) ; \nif ( myEnv != null ) { \ntry { \nmyEnv . close ( ) ; \nmyEnv = null ; \nlogger . info ( \"closed bdb caching\" ) ; \n} \ncatch ( DatabaseException dbe ) { \nlogger . error ( \"Error closing bdb: \" , dbe ) ; \n} \n} \n} \n} \n"}
{"5650": "public class MetadataManager { \nprivate synchronized void openDatabase ( ) { \nif ( database != null ) { \nreturn ; \n} \nDatabaseConfig dbConfig = new DatabaseConfig ( ) ; \ndbConfig . setReadOnly ( readOnly ) ; \ndbConfig . setAllowCreate ( ! readOnly ) ; \nif ( ! readOnly ) { \ndbConfig . setDeferredWrite ( true ) ; \n} \ndatabase = myEnv . openDatabase ( null , collectionName , dbConfig ) ; \nopenDatabases . add ( this ) ; \n} \n} \n"}
{"5651": "public class CalendarDuration { \nstatic org . joda . time . Period convertToPeriod ( int value , String udunit ) { \nif ( udunit . endsWith ( \"s\" ) ) { \nudunit = udunit . substring ( 0 , udunit . length ( ) - 1 ) ; \n} \nswitch ( udunit ) { \ncase \"msec\" : return Period . millis ( value ) ; \ncase \"sec\" : return Period . seconds ( value ) ; \ncase \"minute\" : return Period . minutes ( value ) ; \ncase \"hour\" : case \"hr\" : return Period . hours ( value ) ; \ncase \"day\" : return Period . days ( value ) ; \ncase \"week\" : return Period . weeks ( value ) ; \ncase \"month\" : return Period . months ( value ) ; \ncase \"year\" : return Period . years ( value ) ; \n} \nthrow new IllegalArgumentException ( \"cant convert \" + udunit + \" to Joda Period\" ) ; \n} \n} \n"}
{"5652": "public class ErddapStringArray { \npublic void ensureCapacity ( long minCapacity ) { \nif ( array . length < minCapacity ) { \nErddapMath2 . ensureArraySizeOkay ( minCapacity , \"StringArray\" ) ; \nint newCapacity = ( int ) Math . min ( Integer . MAX_VALUE - 1 , array . length + ( long ) array . length ) ; \nif ( newCapacity < minCapacity ) { \nnewCapacity = ( int ) minCapacity ; \n} \nString [ ] newArray = new String [ newCapacity ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , size ) ; \narray = newArray ; \n} \n} \n} \n"}
{"5653": "public class ErddapStringArray { \npublic String get ( int index ) { \nif ( index >= size ) { \nthrow new IllegalArgumentException ( ErddapString2 . ERROR + \" in StringArray.get: index (\" + index + \") >= size (\" + size + \").\" ) ; \n} \nreturn array [ index ] ; \n} \n} \n"}
{"5654": "public class InvDatasetScan { \npublic InvCatalogImpl makeCatalogForDirectory ( String orgPath , URI catURI ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"baseURI=\" + catURI ) ; \nlog . debug ( \"orgPath=\" + orgPath ) ; \nlog . debug ( \"rootPath=\" + rootPath ) ; \nlog . debug ( \"scanLocation=\" + scanLocation ) ; \n} \nString dsDirPath = translatePathToLocation ( orgPath ) ; \nif ( dsDirPath == null ) { \nString tmpMsg = \"makeCatalogForDirectory(): Requesting path <\" + orgPath + \"> must start with \\\"\" + rootPath + \"\\\".\" ; \nlog . error ( tmpMsg ) ; \nreturn null ; \n} \nCatalogBuilder catBuilder = buildCatalogBuilder ( ) ; \nif ( catBuilder == null ) { \nreturn null ; \n} \nString dsPath = dsDirPath . substring ( scanLocationCrDs . getPath ( ) . length ( ) ) ; \nif ( dsPath . startsWith ( \"/\" ) ) { \ndsPath = dsPath . substring ( 1 ) ; \n} \nCrawlableDataset reqCrDs = scanLocationCrDs . getDescendant ( dsPath ) ; \nCrawlableDataset parent = reqCrDs . getParentDataset ( ) ; \nif ( parent == null ) { \nlog . error ( \"makeCatalogForDirectory(): I/O error getting parent crDs level <\" + dsDirPath + \">: \" ) ; \nreturn null ; \n} \ndsDirPath = parent . getPath ( ) ; \nCrawlableDataset catalogCrDs ; \ntry { \ncatalogCrDs = catBuilder . requestCrawlableDataset ( dsDirPath ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeCatalogForDirectory(): I/O error getting catalog level <\" + dsDirPath + \">: \" + e . getMessage ( ) , e ) ; \nreturn null ; \n} \nif ( catalogCrDs == null ) { \nlog . warn ( \"makeCatalogForDirectory(): requested catalog level <\" + dsDirPath + \"> not allowed (filtered out).\" ) ; \nreturn null ; \n} \nif ( ! catalogCrDs . isCollection ( ) ) { \nlog . warn ( \"makeCatalogForDirectory(): requested catalog level <\" + dsDirPath + \"> is not a collection.\" ) ; \nreturn null ; \n} \nInvCatalogImpl catalog ; \ntry { \ncatalog = catBuilder . generateCatalog ( catalogCrDs ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeCatalogForDirectory(): catalog generation failed <\" + catalogCrDs . getPath ( ) + \">: \" + e . getMessage ( ) ) ; \nreturn null ; \n} \nif ( catalog != null ) { \ncatalog . setBaseURI ( catURI ) ; \n} \nreturn catalog ; \n} \n} \n"}
{"5655": "public class InvDatasetScan { \npublic InvCatalogImpl makeProxyDsResolverCatalog ( String path , URI baseURI ) { \nif ( path == null ) { \nreturn null ; \n} \nif ( path . endsWith ( \"/\" ) ) { \nreturn null ; \n} \nString dsDirPath = translatePathToLocation ( path ) ; \nif ( dsDirPath == null ) { \nlog . error ( \"makeProxyDsResolverCatalog(): Requesting path <\" + path + \"> must start with \\\"\" + rootPath + \"\\\".\" ) ; \nreturn null ; \n} \nint pos = dsDirPath . lastIndexOf ( '/' ) ; \nif ( pos == - 1 ) { \nlog . error ( \"makeProxyDsResolverCatalog(): Requesting path <\" + path + \"> must contain a slash (\\\"/\\\").\" ) ; \nreturn null ; \n} \nString dsName = dsDirPath . substring ( pos + 1 ) ; \ndsDirPath = dsDirPath . substring ( 0 , pos ) ; \nProxyDatasetHandler pdh = this . getProxyDatasetHandlers ( ) . get ( dsName ) ; \nif ( pdh == null ) { \nlog . error ( \"makeProxyDsResolverCatalog(): No matching proxy dataset handler found <\" + dsName + \">.\" ) ; \nreturn null ; \n} \nCatalogBuilder catBuilder = buildCatalogBuilder ( ) ; \nif ( catBuilder == null ) { \nreturn null ; \n} \nCrawlableDataset catalogCrDs ; \ntry { \ncatalogCrDs = catBuilder . requestCrawlableDataset ( dsDirPath ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeProxyDsResolverCatalog(): failed to create CrawlableDataset for catalogLevel <\" + dsDirPath + \"> and class <\" + crDsClassName + \">: \" + e . getMessage ( ) , e ) ; \nreturn null ; \n} \nif ( catalogCrDs == null ) { \nlog . warn ( \"makeProxyDsResolverCatalog(): requested catalog level <\" + dsDirPath + \"> not allowed (filtered out).\" ) ; \nreturn null ; \n} \nif ( ! catalogCrDs . isCollection ( ) ) { \nlog . warn ( \"makeProxyDsResolverCatalog(): requested catalog level <\" + dsDirPath + \"> not a collection.\" ) ; \nreturn null ; \n} \nInvCatalogImpl catalog ; \ntry { \ncatalog = ( InvCatalogImpl ) catBuilder . generateProxyDsResolverCatalog ( catalogCrDs , pdh ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"makeProxyDsResolverCatalog(): catalog generation failed <\" + catalogCrDs . getPath ( ) + \">: \" + e . getMessage ( ) ) ; \nreturn null ; \n} \nif ( catalog != null ) { \ncatalog . setBaseURI ( baseURI ) ; \n} \nreturn catalog ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nint year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; \nint month = getOctet ( startIndex ++ ) ; \nint day = getOctet ( startIndex ++ ) ; \nint hour = getOctet ( startIndex ++ ) ; \nint minute = getOctet ( startIndex ++ ) ; \nint second = getOctet ( startIndex ++ ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) { \nreturn CalendarDate . UNKNOWN ; \n} \nif ( hour > 23 ) { \nday += ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5661": "public class EcmwfLocalConcepts { \nprivate void addLocalConcept ( InputStream is , String conceptName ) throws IOException { \ntry ( BufferedReader br = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ) { \nString line = br . readLine ( ) ; \nwhile ( ! line . startsWith ( \"#\" ) ) { \nline = br . readLine ( ) ; \n} \nwhile ( true ) { \nHashMap < String , String > items = new HashMap < > ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) { \nbreak ; \n} \nif ( ( line . length ( ) == 0 ) || line . startsWith ( \"#\" ) ) { \ncontinue ; \n} \nline = cleanLine ( line ) ; \nif ( line . contains ( \"{\" ) ) { \nString paramName = line . split ( \"=\" ) [ 0 ] . trim ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) { \nbreak ; \n} \nline = cleanLine ( line ) ; \nwhile ( line . contains ( \"=\" ) ) { \nString [ ] kvp = line . split ( \"=\" ) ; \nitems . put ( kvp [ 0 ] . trim ( ) , kvp [ 1 ] . trim ( ) ) ; \nline = br . readLine ( ) ; \nif ( line == null ) { \nbreak ; \n} \nline = cleanLine ( line ) ; \n} \nString tableVersion = items . get ( TABLE_VERSION_ID ) ; \nString parameterNumber = items . get ( PARAM_NUM_ID ) ; \nstoreConcept ( tableVersion , parameterNumber , conceptName , paramName ) ; \n} \n} \n} \n} \n} \n"}
{"5668": "public class DatasetSourceType { \npublic static DatasetSourceType getType ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nreturn ( ( DatasetSourceType ) hash . get ( name ) ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) { \nreturn ; \n} \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < datasetContainer . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5674": "public class ScalablePicture { \npublic void loadPictureImd ( URL imageUrl , double rotation ) { \nTools . log ( \"loadPictureImd invoked with URL: \" + imageUrl . toString ( ) ) ; \nif ( sourcePicture != null ) { \nsourcePicture . removeListener ( this ) ; \n} \nsourcePicture = new SourcePicture ( ) ; \nsourcePicture . addListener ( this ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nscaleAfterLoad = true ; \nsourcePicture . loadPicture ( imageUrl , rotation ) ; \n} \n} \n"}
{"5679": "public class ScalablePicture { \npublic Dimension getScaledSize ( ) { \nif ( scaledPicture != null ) { \nreturn new Dimension ( scaledPicture . getWidth ( ) , scaledPicture . getHeight ( ) ) ; \n} \nelse { \nreturn new Dimension ( 0 , 0 ) ; \n} \n} \n} \n"}
{"5680": "public class ScalablePicture { \npublic String getScaledSizeString ( ) { \nif ( scaledPicture != null ) { \nreturn Integer . toString ( scaledPicture . getWidth ( ) ) + \" x \" + Integer . toString ( scaledPicture . getHeight ( ) ) ; \n} \nelse { \nreturn \"0 x 0\" ; \n} \n} \n} \n"}
{"5685": "public class DiskCache { \nstatic public void setRootDirectory ( String cacheDir ) { \nif ( ! cacheDir . endsWith ( \"/\" ) ) { \ncacheDir = cacheDir + \"/\" ; \n} \nroot = StringUtil2 . replace ( cacheDir , '\\\\' , \"/\" ) ; \nmakeRootDirectory ( ) ; \n} \n} \n"}
{"5686": "public class DiskCache { \nstatic public void makeRootDirectory ( ) { \nFile dir = new File ( root ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nthrow new IllegalStateException ( \"DiskCache.setRootDirectory(): could not create root directory <\" + root + \">.\" ) ; \n} \n} \ncheckExist = true ; \n} \n} \n"}
{"5687": "public class DiskCache { \nstatic public File getCacheFile ( String fileLocation ) { \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( f . exists ( ) ) { \nif ( ! f . setLastModified ( System . currentTimeMillis ( ) ) ) { \nlogger . warn ( \"Failed to setLastModified on \" + f . getPath ( ) ) ; \n} \n} \nif ( ! checkExist ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { \nlogger . warn ( \"Failed to mkdirs on \" + dir . getPath ( ) ) ; \n} \ncheckExist = true ; \n} \nreturn f ; \n} \n} \n"}
{"5688": "public class DiskCache { \nstatic public void cleanCache ( Date cutoff , StringBuilder sbuff ) { \nif ( sbuff != null ) { \nsbuff . append ( \"CleanCache files before \" ) . append ( cutoff ) . append ( \"\\n\" ) ; \n} \nFile dir = new File ( root ) ; \nFile [ ] children = dir . listFiles ( ) ; \nif ( children == null ) { \nreturn ; \n} \nfor ( File file : children ) { \nDate lastMod = new Date ( file . lastModified ( ) ) ; \nif ( lastMod . before ( cutoff ) ) { \nboolean ret = file . delete ( ) ; \nif ( sbuff != null ) { \nsbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( lastMod ) . append ( \")\\n\" ) ; \nif ( ! ret ) { \nsbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \n} \n} \n} \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) { \nsbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \n} \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( file . length ( ) + total > maxBytes ) { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) { \nsbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \n} \nif ( ! file . delete ( ) && sbuff != null ) { \nsbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \n} \nelse { \ntotal += file . length ( ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5691": "public class CoordinateAxis { \nstatic public CoordinateAxis factory ( NetcdfDataset ncd , VariableDS vds ) { \nif ( ( vds . getRank ( ) == 0 ) || ( vds . getRank ( ) == 1 ) || ( vds . getRank ( ) == 2 && vds . getDataType ( ) == DataType . CHAR ) ) { \nreturn new CoordinateAxis1D ( ncd , vds ) ; \n} \nelse if ( vds . getRank ( ) == 2 ) { \nreturn new CoordinateAxis2D ( ncd , vds ) ; \n} \nelse { \nreturn new CoordinateAxis ( ncd , vds ) ; \n} \n} \n} \n"}
{"5695": "public class CoordinateAxis { \npublic ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { \nAttribute cal = findAttribute ( CF . CALENDAR ) ; \nString s = ( cal == null ) ? null : cal . getStringValue ( ) ; \nif ( s == null ) { \nAttribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; \nif ( convention != null ) { \nString hasName = convention . getStringValue ( ) ; \nint version = CF1Convention . getVersion ( hasName ) ; \nif ( version >= 0 ) { \nreturn Calendar . gregorian ; \n} \nif ( COARDSConvention . isMine ( hasName ) ) { \nreturn Calendar . gregorian ; \n} \n} \n} \nreturn ucar . nc2 . time . Calendar . get ( s ) ; \n} \n} \n"}
{"5696": "public class JTableSorted { \npublic void setList ( ArrayList rowList ) { \nthis . list = rowList ; \nif ( list . size ( ) > 0 ) { \njtable . setRowSelectionInterval ( 0 , 0 ) ; \n} \nelse { \njtable . clearSelection ( ) ; \n} \nmodel . sort ( ) ; \njtable . revalidate ( ) ; \n} \n} \n"}
{"5697": "public class JTableSorted { \npublic TableRow getSelected ( ) { \nif ( list . size ( ) == 0 ) { \nreturn null ; \n} \nint sel = jtable . getSelectedRow ( ) ; \nif ( sel >= 0 ) { \nreturn ( TableRow ) list . get ( sel ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) { \nreturn ; \n} \nint curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( curr < list . size ( ) - 1 ) ) { \nsetSelected ( curr + 1 ) ; \n} \nelse if ( ! increment && ( curr > 0 ) ) { \nsetSelected ( curr - 1 ) ; \n} \n} \n} \n"}
{"5700": "public class VertScaleSlider { \nprivate void setSelectedIndex ( int idx ) { \nif ( zAxis == null ) { \nreturn ; \n} \neventOK = false ; \ncurrentIdx = idx ; \nslider . setValue ( world2slider ( zAxis . getCoordValue ( currentIdx ) ) ) ; \neventOK = true ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nint lo = lo0 ; \nint hi = hi0 ; \nString mid ; \nif ( hi0 > lo0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nwhile ( lo <= hi ) { \nwhile ( ( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ) { \n++ lo ; \n} \nwhile ( ( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ) { \n-- hi ; \n} \nif ( lo <= hi ) { \nswap ( a , lo , hi ) ; \n++ lo ; \n-- hi ; \n} \n} \nif ( lo0 < hi ) { \nquickSort ( a , lo0 , hi ) ; \n} \nif ( lo < hi0 ) { \nquickSort ( a , lo , hi0 ) ; \n} \n} \n} \n} \n"}
{"5703": "public class MFileOS { \nstatic public MFileOS getExistingFile ( String filename ) { \nif ( filename == null ) { \nreturn null ; \n} \nFile file = new File ( filename ) ; \nif ( file . exists ( ) ) { \nreturn new MFileOS ( file ) ; \n} \nreturn null ; \n} \n} \n"}
{"5705": "public class XMLStore { \nstatic public XMLStore createFromFile ( String fileName , XMLStore storedDefaults ) throws java . io . IOException { \nFile prefsFile = new File ( fileName ) ; \nInputStream primIS = null , objIS = null ; \nif ( prefsFile . exists ( ) && prefsFile . length ( ) > 0 ) { \nprimIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \nobjIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \n} \nif ( debugWhichStore ) { \nSystem . out . println ( \"XMLStore read from file \" + fileName ) ; \n} \nXMLStore store = new XMLStore ( primIS , objIS , storedDefaults ) ; \nstore . prefsFile = prefsFile ; \nreturn store ; \n} \n} \n"}
{"5706": "public class XMLStore { \nstatic public XMLStore createFromInputStream ( InputStream is1 , InputStream is2 , XMLStore storedDefaults ) throws java . io . IOException { \nif ( debugWhichStore ) { \nSystem . out . println ( \"XMLStore read from input stream \" + is1 ) ; \n} \nreturn new XMLStore ( is1 , is2 , storedDefaults ) ; \n} \n} \n"}
{"5707": "public class XMLStore { \nstatic public XMLStore createFromResource ( String resourceName , XMLStore storedDefaults ) throws java . io . IOException { \nClass c = XMLStore . class ; \nInputStream primIS = c . getResourceAsStream ( resourceName ) ; \nInputStream objIS = c . getResourceAsStream ( resourceName ) ; \nif ( primIS == null ) { \nthrow new java . io . IOException ( \"XMLStore.createFromResource cant find <\" + resourceName + \">\" ) ; \n} \nif ( debugWhichStore ) { \nSystem . out . println ( \"XMLStore read from resource \" + resourceName ) ; \n} \nreturn new XMLStore ( primIS , objIS , storedDefaults ) ; \n} \n} \n"}
{"5708": "public class XMLStore { \nstatic public String makeStandardFilename ( String appName , String storeName ) { \nString userHome = null ; \ntry { \nuserHome = System . getProperty ( \"user.home\" ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( \"XMLStore.makeStandardFilename: error System.getProperty(user.home) \" + e ) ; \n} \nif ( null == userHome ) { \nuserHome = \".\" ; \n} \nString dirFilename = userHome + \"/\" + appName ; \nFile f = new File ( dirFilename ) ; \nif ( ! f . exists ( ) ) { \nboolean ok = f . mkdirs ( ) ; \nif ( ! ok ) { \nSystem . out . println ( \"Error creating directories: \" + f . getAbsolutePath ( ) ) ; \n} \n} \nreturn dirFilename + \"/\" + storeName ; \n} \n} \n"}
{"5709": "public class XMLStore { \npublic void save ( ) throws java . io . IOException { \nif ( prefsFile == null ) { \nthrow new UnsupportedOperationException ( \"XMLStore is read-only\" ) ; \n} \nFile prefTemp ; \nString parentFilename = prefsFile . getParent ( ) ; \nif ( parentFilename == null ) { \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" ) ; \n} \nelse { \nFile parentFile = new File ( parentFilename ) ; \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" , parentFile ) ; \n} \nprefTemp . deleteOnExit ( ) ; \nFileOutputStream fos = new FileOutputStream ( prefTemp , false ) ; \nsave ( fos ) ; \nfos . close ( ) ; \nPath xmlBackup = Paths . get ( prefsFile . getAbsolutePath ( ) + \".bak\" ) ; \nPath prefsPath = prefsFile . toPath ( ) ; \nif ( Files . exists ( prefsPath ) ) { \nFiles . move ( prefsPath , xmlBackup , StandardCopyOption . REPLACE_EXISTING ) ; \n} \nFiles . move ( prefTemp . toPath ( ) , prefsFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; \n} \n} \n"}
{"5710": "public class XMLStore { \npublic void save ( OutputStream out ) throws java . io . IOException { \noutputExceptionMessage = null ; \nOutputMunger bos = new OutputMunger ( out ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bos , CDM . utf8Charset ) ) ; \nXMLEncoder beanEncoder = new XMLEncoder ( bos ) ; \nbeanEncoder . setExceptionListener ( new ExceptionListener ( ) { \npublic void exceptionThrown ( Exception exception ) { \nSystem . out . println ( \"XMLStore.save() got Exception: abort saving the preferences!\" ) ; \nexception . printStackTrace ( ) ; \noutputExceptionMessage = exception . getMessage ( ) ; \n} \n} \n) ; \npw . printf ( \"<?xml version='1.0' encoding='UTF-8'?>%n\" ) ; \npw . printf ( \"<preferences EXTERNAL_XML_VERSION='1.0'>%n\" ) ; \nif ( ! rootPrefs . isUserNode ( ) ) { \npw . printf ( \"  <root type='system'>%n\" ) ; \n} \nelse { \npw . printf ( \"  <root type='user'>%n\" ) ; \n} \nIndent indent = new Indent ( 2 ) ; \nindent . incr ( ) ; \nwriteXmlNode ( bos , pw , rootPrefs , beanEncoder , indent ) ; \nif ( outputExceptionMessage != null ) { \nthrow new IOException ( outputExceptionMessage ) ; \n} \npw . printf ( \"  </root>%n\" ) ; \npw . printf ( \"</preferences>%n\" ) ; \npw . flush ( ) ; \n} \n} \n"}
{"5711": "public class DapSerializer { \nprotected void writeAtomicVariable ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapType basetype = template . getBaseType ( ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nif ( slices == null ) { \nthrow new DapException ( \"Unknown variable: \" + template . getFQN ( ) ) ; \n} \nObject values = data . read ( slices ) ; \ndst . writeAtomicArray ( basetype , values ) ; \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) { \ncontinue ; \n} \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) { \nwhile ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) { \ncontinue ; \n} \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5716": "public class MessageScanner { \nstatic public boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nraf . seek ( 0 ) ; \nif ( ! raf . searchForward ( matcher , 40 * 1000 ) ) { \nreturn false ; \n} \nraf . skipBytes ( 4 ) ; \nBufrIndicatorSection is = new BufrIndicatorSection ( raf ) ; \nif ( is . getBufrEdition ( ) > 4 ) { \nreturn false ; \n} \nreturn ! ( is . getBufrLength ( ) > raf . length ( ) ) ; \n} \n} \n"}
{"5718": "public class DbaseData { \nint readRowN ( DataInputStream ds , int n ) { \nif ( n > nrec ) { \nreturn - 1 ; \n} \ntry { \nds . readFully ( field , 0 , desc . FieldLength ) ; \n} \ncatch ( java . io . IOException e ) { \nreturn - 1 ; \n} \nswitch ( desc . Type ) { \ncase 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; \nbreak ; \ncase 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; \nbreak ; \ncase 'F' : if ( desc . FieldLength == 4 ) { \nnumeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; \n} \nelse { \nnumeric [ n ] = Swap . swapDouble ( field , 0 ) ; \n} \nbreak ; \ncase 'L' : switch ( field [ 0 ] ) { \ncase 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; \nbreak ; \ndefault : logical [ n ] = false ; \nbreak ; \n} \ndefault : return - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) { \nthrow new DapException ( \"Cannot slice a scalar variable\" ) ; \n} \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) { \nthrow new DapException ( \"Cannot slice a scalar variable\" ) ; \n} \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( int i = 0 ; \nodom . hasNext ( ) ; \ni ++ ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5728": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pick ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null || stations . isEmpty ( ) ) { \nreturn null ; \n} \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findIntersection ( ptN ) ; \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5729": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pickClosest ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null || stations . isEmpty ( ) ) { \nreturn null ; \n} \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findClosest ( ptN ) ; \nif ( debug ) { \nSystem . out . println ( \"closest= \" + closest ) ; \n} \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nint dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( gateIdx >= dataCount ) { \nii . setShortNext ( uf_header2 . missing ) ; \n} \nelse { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nshort value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \n} \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) { \nthrow new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \n} \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nk < nelems ; \nk ++ ) { \nsum += getDouble ( k ) * v . getDouble ( k ) ; \n} \nreturn sum ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( norm <= 0.0 ) { \nreturn ; \n} \nfor ( int k = 0 ; \nk < nelems ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \n} \n} \n} \n"}
{"5748": "public class Grib1SectionGridDefinition { \npublic long calcCRC ( ) { \nlong crc ; \nif ( rawData == null ) { \ncrc = predefinedGridDefinitionCenter << 16 + predefinedGridDefinition ; \n} \nelse { \nCRC32 crc32 = new CRC32 ( ) ; \ncrc32 . update ( rawData ) ; \ncrc = crc32 . getValue ( ) ; \n} \nreturn crc ; \n} \n} \n"}
{"5749": "public class Grib1SectionGridDefinition { \npublic final boolean isThin ( ) { \nif ( rawData == null ) { \nreturn false ; \n} \nint octet5 = getOctet ( 5 ) ; \nint nv = getOctet ( 4 ) ; \nreturn ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; \n} \n} \n"}
{"5750": "public class AbstractCursor { \n@ Override public int fieldIndex ( String name ) throws DapException { \nDapStructure ds ; \nif ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) { \nds = ( DapStructure ) getTemplate ( ) ; \n} \nelse if ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) { \nds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; \n} \nelse { \nthrow new DapException ( \"Attempt to get field name on non-compound object\" ) ; \n} \nint i = ds . indexByName ( name ) ; \nif ( i < 0 ) { \nthrow new DapException ( \"Unknown field name: \" + name ) ; \n} \nreturn i ; \n} \n} \n"}
{"5753": "public class CFPolygon { \npublic void setNext ( Polygon next ) { \nif ( next instanceof CFPolygon ) { \nsetNext ( ( CFPolygon ) next ) ; \n} \nelse { \nthis . next = next ; \n} \n} \n} \n"}
{"5754": "public class CFPolygon { \npublic void setPrev ( Polygon prev ) { \nif ( prev instanceof CFPolygon ) { \nsetPrev ( ( CFPolygon ) prev ) ; \n} \nelse { \nthis . prev = prev ; \n} \n} \n} \n"}
{"5755": "public class InvService { \npublic String findProperty ( String name ) { \nInvProperty result = null ; \nfor ( InvProperty p : properties ) { \nif ( p . getName ( ) . equals ( name ) ) { \nresult = p ; \n} \n} \nreturn ( result == null ) ? null : result . getValue ( ) ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( 0 <= ( row = model . search ( proj ) ) ) { \nif ( debug ) { \nSystem . out . println ( \" PTsetCurrentProjection found = \" + row ) ; \n} \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) { \nSystem . out . println ( \" PTsetCurrentProjection not found = \" + row ) ; \n} \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \n} \n} \n"}
{"5757": "public class TimeOffsetAxis { \npublic Optional < TimeOffsetAxis > subsetFromTime ( SubsetParams params , CalendarDate runDate ) { \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \nCoverageCoordAxisBuilder builder = null ; \nif ( params . isTrue ( SubsetParams . timePresent ) ) { \ndouble offset = getOffsetInTimeUnits ( runDate , CalendarDate . present ( ) ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nCalendarDate dateWanted = ( CalendarDate ) params . get ( SubsetParams . time ) ; \nif ( dateWanted != null ) { \ndouble offset = getOffsetInTimeUnits ( runDate , dateWanted ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nInteger stride = ( Integer ) params . get ( SubsetParams . timeStride ) ; \nif ( stride == null || stride < 0 ) { \nstride = 1 ; \n} \nCalendarDateRange dateRange = ( CalendarDateRange ) params . get ( SubsetParams . timeRange ) ; \nif ( dateRange != null ) { \ndouble min = getOffsetInTimeUnits ( runDate , dateRange . getStart ( ) ) ; \ndouble max = getOffsetInTimeUnits ( runDate , dateRange . getEnd ( ) ) ; \nOptional < CoverageCoordAxisBuilder > buildero = helper . subset ( min , max , stride ) ; \nif ( buildero . isPresent ( ) ) { \nbuilder = buildero . get ( ) ; \n} \nelse { \nreturn Optional . empty ( buildero . getErrorMessage ( ) ) ; \n} \n} \nassert ( builder != null ) ; \nbuilder . setReferenceDate ( runDate ) ; \nreturn Optional . of ( new TimeOffsetAxis ( builder ) ) ; \n} \n} \n"}
{"5759": "public class NetcdfFile { \nstatic public void registerIOProvider ( Class iospClass , boolean last ) throws IllegalAccessException , InstantiationException { \nIOServiceProvider spi ; \nspi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nif ( userLoads && ! last ) { \nregisteredProviders . add ( 0 , spi ) ; \n} \nelse { \nregisteredProviders . add ( spi ) ; \n} \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nint pos = - 1 ; \nfor ( int i = 0 ; \ni < registeredProviders . size ( ) ; \ni ++ ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( pos < i ) { \npos = i ; \n} \nbreak ; \n} \n} \nif ( pos < 0 ) { \npos = 0 ; \n} \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \n} \n} \n"}
{"5761": "public class NetcdfFile { \nstatic public boolean iospRegistered ( Class iospClass ) { \nfor ( IOServiceProvider spi : registeredProviders ) { \nif ( spi . getClass ( ) == iospClass ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5763": "public class NetcdfFile { \nstatic public boolean canOpen ( String location ) throws IOException { \nucar . unidata . io . RandomAccessFile raf = null ; \ntry { \nraf = getRaf ( location , - 1 ) ; \nreturn ( raf != null ) && canOpen ( raf ) ; \n} \nfinally { \nif ( raf != null ) { \nraf . close ( ) ; \n} \n} \n} \n} \n"}
{"5768": "public class NetcdfFile { \npublic Attribute findGlobalAttributeIgnoreCase ( String name ) { \nfor ( Attribute a : gattributes ) { \nif ( name . equalsIgnoreCase ( a . getShortName ( ) ) ) { \nreturn a ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5773": "public class NetcdfFile { \npublic Attribute addAttribute ( Group parent , Attribute att ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( parent == null ) { \nparent = rootGroup ; \n} \nparent . addAttribute ( att ) ; \nreturn att ; \n} \n} \n"}
{"5774": "public class NetcdfFile { \npublic Attribute addAttribute ( Group parent , String name , String value ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( value == null ) { \nreturn null ; \n} \nif ( parent == null ) { \nparent = rootGroup ; \n} \nAttribute att = new Attribute ( name , value ) ; \nparent . addAttribute ( att ) ; \nreturn att ; \n} \n} \n"}
{"5775": "public class NetcdfFile { \npublic Group addGroup ( Group parent , Group g ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( parent == null ) { \nparent = rootGroup ; \n} \nparent . addGroup ( g ) ; \nreturn g ; \n} \n} \n"}
{"5776": "public class NetcdfFile { \npublic Dimension addDimension ( Group parent , Dimension d ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( parent == null ) { \nparent = rootGroup ; \n} \nparent . addDimension ( d ) ; \nreturn d ; \n} \n} \n"}
{"5777": "public class NetcdfFile { \npublic boolean removeDimension ( Group g , String dimName ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( g == null ) { \ng = rootGroup ; \n} \nreturn g . removeDimension ( dimName ) ; \n} \n} \n"}
{"5778": "public class NetcdfFile { \npublic Variable addVariable ( Group g , Variable v ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( g == null ) { \ng = rootGroup ; \n} \nif ( v != null ) { \ng . addVariable ( v ) ; \n} \nreturn v ; \n} \n} \n"}
{"5779": "public class NetcdfFile { \npublic Variable addVariable ( Group g , String shortName , DataType dtype , String dims ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( g == null ) { \ng = rootGroup ; \n} \nVariable v = new Variable ( this , g , null , shortName ) ; \nv . setDataType ( dtype ) ; \nv . setDimensions ( dims ) ; \ng . addVariable ( v ) ; \nreturn v ; \n} \n} \n"}
{"5780": "public class NetcdfFile { \npublic Variable addStringVariable ( Group g , String shortName , String dims , int strlen ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( g == null ) { \ng = rootGroup ; \n} \nString dimName = shortName + \"_strlen\" ; \naddDimension ( g , new Dimension ( dimName , strlen ) ) ; \nVariable v = new Variable ( this , g , null , shortName ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( dims + \" \" + dimName ) ; \ng . addVariable ( v ) ; \nreturn v ; \n} \n} \n"}
{"5781": "public class NetcdfFile { \npublic boolean removeVariable ( Group g , String varName ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nif ( g == null ) { \ng = rootGroup ; \n} \nreturn g . removeVariable ( varName ) ; \n} \n} \n"}
{"5782": "public class NetcdfFile { \npublic Object sendIospMessage ( Object message ) { \nif ( null == message ) { \nreturn null ; \n} \nif ( message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nreturn gotit || makeRecordStructure ( ) ; \n} \nelse if ( message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE ) { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nif ( gotit ) { \nrootGroup . remove ( v ) ; \nvariables . remove ( v ) ; \nremoveRecordStructure ( ) ; \n} \nreturn ( gotit ) ; \n} \nif ( spi != null ) { \nreturn spi . sendIospMessage ( message ) ; \n} \nreturn null ; \n} \n} \n"}
{"5783": "public class NetcdfFile { \nprotected Boolean makeRecordStructure ( ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nBoolean didit = false ; \nif ( ( spi != null ) && ( spi instanceof N3iosp ) && hasUnlimitedDimension ( ) ) { \ndidit = ( Boolean ) spi . sendIospMessage ( IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \n} \nreturn didit ; \n} \n} \n"}
{"5784": "public class NetcdfFile { \npublic void finish ( ) { \nif ( immutable ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nvariables = new ArrayList < > ( ) ; \ndimensions = new ArrayList < > ( ) ; \ngattributes = new ArrayList < > ( ) ; \nfinishGroup ( rootGroup ) ; \n} \n} \n"}
{"5785": "public class NetcdfFile { \npublic Array readSection ( String variableSection ) throws IOException , InvalidRangeException { \nParsedSectionSpec cer = ParsedSectionSpec . parseVariableSection ( this , variableSection ) ; \nif ( cer . child == null ) { \nreturn cer . v . read ( cer . section ) ; \n} \nif ( spi == null ) { \nreturn IospHelper . readSection ( cer ) ; \n} \nelse { \nreturn spi . readSection ( cer ) ; \n} \n} \n} \n"}
{"5786": "public class NetcdfFile { \nprotected long readToByteChannel ( ucar . nc2 . Variable v , Section section , WritableByteChannel wbc ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nif ( ( spi == null ) || v . hasCachedData ( ) ) { \nreturn IospHelper . copyToByteChannel ( v . read ( section ) , wbc ) ; \n} \nreturn spi . readToByteChannel ( v , section , wbc ) ; \n} \n} \n"}
{"5788": "public class NetcdfFile { \npublic Array read ( String variableSection , boolean flatten ) throws IOException , InvalidRangeException { \nif ( ! flatten ) { \nthrow new UnsupportedOperationException ( \"NetdfFile.read(String variableSection, boolean flatten=false)\" ) ; \n} \nreturn readSection ( variableSection ) ; \n} \n} \n"}
{"5789": "public class NetcdfFile { \nstatic protected String makeFullName ( CDMNode node , String reservedChars ) { \nGroup parent = node . getParentGroup ( ) ; \nif ( ( ( parent == null ) || parent . isRoot ( ) ) && ! node . isMemberOfStructure ( ) ) { \nreturn EscapeStrings . backslashEscape ( node . getShortName ( ) , reservedChars ) ; \n} \nStringBuilder sbuff = new StringBuilder ( ) ; \nappendGroupName ( sbuff , parent , reservedChars ) ; \nappendStructureName ( sbuff , node , reservedChars ) ; \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5791": "public class CompositeMFileFilter { \nprivate boolean include ( MFile mfile ) { \nif ( includeFilters == null ) { \nreturn true ; \n} \nfor ( MFileFilter filter : includeFilters ) { \nif ( filter . accept ( mfile ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5792": "public class CompositeMFileFilter { \nprivate boolean exclude ( MFile mfile ) { \nif ( excludeFilters == null ) { \nreturn false ; \n} \nfor ( MFileFilter filter : excludeFilters ) { \nif ( filter . accept ( mfile ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5793": "public class CompositeMFileFilter { \nprivate boolean andFilter ( MFile mfile ) { \nif ( andFilters == null ) { \nreturn true ; \n} \nfor ( MFileFilter filter : andFilters ) { \nif ( ! filter . accept ( mfile ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5794": "public class Attribute { \npublic void appendValue ( String value , boolean check ) throws NoSuchAttributeException , AttributeBadValueException { \ncheckVectorUsage ( ) ; \nif ( check ) { \nvalue = forceValue ( type , value ) ; \n} \n( ( Vector ) attr ) . addElement ( value ) ; \n} \n} \n"}
{"5795": "public class Attribute { \nprivate static void dispatchCheckValue ( int type , String value ) throws AttributeBadValueException { \nswitch ( type ) { \ncase BYTE : if ( ! checkByte ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not a Byte value.\" ) ; \n} \nbreak ; \ncase INT16 : if ( ! checkShort ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not an Int16 value.\" ) ; \n} \nbreak ; \ncase UINT16 : if ( ! checkUShort ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not an UInt16 value.\" ) ; \n} \nbreak ; \ncase INT32 : if ( ! checkInt ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not an Int32 value.\" ) ; \n} \nbreak ; \ncase UINT32 : if ( ! checkUInt ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not an UInt32 value.\" ) ; \n} \nbreak ; \ncase FLOAT32 : if ( ! checkFloat ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not a Float32 value.\" ) ; \n} \nbreak ; \ncase FLOAT64 : if ( ! checkDouble ( value ) ) { \nthrow new AttributeBadValueException ( \"`\" + value + \"' is not a Float64 value.\" ) ; \n} \nbreak ; \ndefault : } \n} \n} \n"}
{"5796": "public class Attribute { \nprivate static String forceValue ( int type , String value ) throws AttributeBadValueException { \ntry { \ndispatchCheckValue ( type , value ) ; \n} \ncatch ( AttributeBadValueException abe ) { \nif ( type == BYTE ) { \nshort val = Short . parseShort ( value ) ; \nif ( val > 255 && val < - 128 ) { \nthrow new AttributeBadValueException ( \"Cannot convert to byte: \" + value ) ; \n} \nvalue = Integer . toString ( ( val & 0xFF ) ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nlog . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( val > 0xFF || val < 0 ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5800": "public class Attribute { \nprivate static final boolean checkUInt ( String s ) { \ntry { \nlong val = Long . parseLong ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkUInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( val > 0xFFFFFFFFL ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5801": "public class Attribute { \nprivate static final boolean checkFloat ( String s ) { \ntry { \nfloat val = Float . parseFloat ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkFloat() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n} \n"}
{"5802": "public class Attribute { \nprivate static final boolean checkDouble ( String s ) { \ntry { \ndouble val = Double . parseDouble ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n} \n"}
{"5805": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"SimplifiableIfStatement\" } \n) public static boolean validBooleanString ( String boolString ) { \nif ( boolString == null ) { \nreturn false ; \n} \nMatcher m = VALID_CHARACTERS_FOR_BOOLEAN_STRING_PATTERN . matcher ( boolString ) ; \nif ( ! m . matches ( ) ) { \nreturn false ; \n} \nreturn boolString . equalsIgnoreCase ( \"true\" ) || boolString . equalsIgnoreCase ( \"false\" ) ; \n} \n} \n"}
{"5806": "public class StringValidateEncodeUtils { \npublic static boolean validAlphanumericString ( String alphNumString ) { \nif ( alphNumString == null ) { \nreturn false ; \n} \nMatcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; \nreturn m . matches ( ) ; \n} \n} \n"}
{"5807": "public class StringValidateEncodeUtils { \npublic static boolean validAlphanumericStringConstrainedSet ( String alphNumString , String [ ] constrainedSet , boolean ignoreCase ) { \nif ( alphNumString == null || constrainedSet == null || constrainedSet . length == 0 ) { \nreturn false ; \n} \nMatcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; \nif ( ! m . matches ( ) ) { \nreturn false ; \n} \nfor ( String s : constrainedSet ) { \nif ( ignoreCase ? alphNumString . equalsIgnoreCase ( s ) : alphNumString . equals ( s ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) { \ncontinue ; \n} \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) { \nreturn false ; \n} \ni -- ; \n} \nelse { \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5809": "public class StringValidateEncodeUtils { \npublic static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { \nif ( ! Character . isDefined ( codePoint ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] not assigned to an abstract character.\" , codePoint ) ) ; \n} \nif ( Character . getType ( codePoint ) == Character . SURROGATE ) { \nthrow new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character.\" , codePoint ) ) ; \n} \nCharset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; \nif ( charset == null ) { \nthrow new IllegalArgumentException ( String . format ( \"Unsupported charset [%s].\" , charsetName ) ) ; \n} \nchar [ ] chars = Character . toChars ( codePoint ) ; \nByteBuffer byteBuffer = null ; \ntry { \nbyteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; \n} \ncatch ( CharacterCodingException e ) { \nString message = String . format ( \"Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s].\" , codePoint , charsetName ) ; \nthrow new IllegalArgumentException ( message , e ) ; \n} \nbyteBuffer . rewind ( ) ; \nStringBuilder encodedString = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < byteBuffer . limit ( ) ; \ni ++ ) { \nString asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; \nencodedString . append ( \"%\" ) . append ( asHex . length ( ) == 1 ? \"0\" : \"\" ) . append ( asHex ) ; \n} \nreturn encodedString . toString ( ) ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) { \nreturn false ; \n} \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) { \ncontinue ; \n} \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) { \nreturn false ; \n} \n} \nelse if ( val . matches ( \"^[0-9]+\" ) ) { \nif ( ! val . equals ( oval ) ) { \nreturn false ; \n} \n} \nelse { \nif ( ! val . equals ( oval ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"5812": "public class MessageBroker { \npublic void process ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = process ( b , is ) ; \nif ( b . done ) { \nbreak ; \n} \n} \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) { \nreturn b . have - 3 ; \n} \nelse { \nreturn start ; \n} \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) { \nmessQ . put ( task ) ; \n} \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5814": "public class Ceparse { \nString removeQuotes ( String s ) { \nif ( s . startsWith ( \"\\\"\" ) && s . endsWith ( \"\\\"\" ) ) { \nreturn s . substring ( 1 , s . length ( ) - 1 ) ; \n} \nelse { \nreturn s ; \n} \n} \n} \n"}
{"5817": "public class TdsConfigMapper { \nprivate static String getValueFromThreddsConfig ( String key , String alternateKey , String defaultValue ) { \nString value = ThreddsConfig . get ( key , null ) ; \nif ( value == null && alternateKey != null ) { \nvalue = ThreddsConfig . get ( alternateKey , null ) ; \n} \nif ( value == null ) { \nvalue = defaultValue ; \n} \nreturn value ; \n} \n} \n"}
{"5821": "public class Cinrad2Record { \npublic float getAzimuth ( ) { \nif ( message_type != 1 ) { \nreturn - 1.0f ; \n} \nif ( Cinrad2IOServiceProvider . isSC ) { \nreturn 360.0f * azimuth_ang / 65536.0f ; \n} \nelse if ( Cinrad2IOServiceProvider . isCC ) { \nreturn 360.0f * azimuth_ang / 512.0f ; \n} \nelse if ( Cinrad2IOServiceProvider . isCC20 ) { \nreturn azimuth_ang * 0.01f ; \n} \nreturn 180.0f * azimuth_ang / 32768.0f ; \n} \n} \n"}
{"5822": "public class Cinrad2Record { \npublic float getElevation ( ) { \nif ( message_type != 1 ) { \nreturn - 1.0f ; \n} \nif ( Cinrad2IOServiceProvider . isSC ) { \nreturn 120.0f * elevation_ang / 65536.0f ; \n} \nelse if ( Cinrad2IOServiceProvider . isCC ) { \nreturn elevation_ang * 0.01f ; \n} \nelse if ( Cinrad2IOServiceProvider . isCC20 ) { \nreturn elevation_ang * 0.01f ; \n} \nreturn 180.0f * elevation_ang / 32768.0f ; \n} \n} \n"}
{"5823": "public class DoradeSWIB { \npublic float [ ] getLatitudes ( ) { \nif ( myASIBs == null ) { \nreturn null ; \n} \nfloat [ ] lats = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni ++ ) { \nlats [ i ] = myASIBs [ i ] . getLatitude ( ) ; \n} \nreturn lats ; \n} \n} \n"}
{"5824": "public class DoradeSWIB { \npublic float [ ] getLongitudes ( ) { \nif ( myASIBs == null ) { \nreturn null ; \n} \nfloat [ ] lons = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni ++ ) { \nlons [ i ] = myASIBs [ i ] . getLongitude ( ) ; \n} \nreturn lons ; \n} \n} \n"}
{"5825": "public class DoradeSWIB { \npublic float [ ] getAltitudes ( ) { \nif ( myASIBs == null ) { \nreturn null ; \n} \nfloat [ ] alts = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni ++ ) { \nalts [ i ] = myASIBs [ i ] . getAltitude ( ) ; \n} \nreturn alts ; \n} \n} \n"}
{"5828": "public class Structure { \npublic Structure select ( List < String > memberNames ) { \nStructure result = ( Structure ) copy ( ) ; \nList < Variable > members = new ArrayList < > ( ) ; \nfor ( String name : memberNames ) { \nVariable m = findVariable ( name ) ; \nif ( null != m ) { \nmembers . add ( m ) ; \n} \n} \nresult . setMemberVariables ( members ) ; \nresult . isSubset = true ; \nreturn result ; \n} \n} \n"}
{"5830": "public class Structure { \npublic Variable addMemberVariable ( Variable v ) { \nif ( isImmutable ( ) ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nmembers . add ( v ) ; \nmemberHash . put ( v . getShortName ( ) , v ) ; \nv . setParentStructure ( this ) ; \nreturn v ; \n} \n} \n"}
{"5831": "public class Structure { \npublic void setMemberVariables ( List < Variable > vars ) { \nif ( isImmutable ( ) ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nmembers = new ArrayList < > ( ) ; \nmemberHash = new HashMap < > ( 2 * vars . size ( ) ) ; \nfor ( Variable v : vars ) { \naddMemberVariable ( v ) ; \n} \n} \n} \n"}
{"5832": "public class Structure { \n@ Override public void setParentGroup ( Group group ) { \nif ( isImmutable ( ) ) { \nthrow new IllegalStateException ( \"Cant modify\" ) ; \n} \nsuper . setParentGroup ( group ) ; \nif ( members != null ) { \nfor ( Variable v : members ) { \nv . setParentGroup ( group ) ; \n} \n} \n} \n} \n"}
{"5835": "public class Structure { \npublic ArrayStructure readStructure ( int start , int count ) throws IOException , ucar . ma2 . InvalidRangeException { \nif ( getRank ( ) != 1 ) { \nthrow new java . lang . UnsupportedOperationException ( \"not a vector structure\" ) ; \n} \nint [ ] origin = new int [ ] { \nstart } \n; \nint [ ] shape = new int [ ] { \ncount } \n; \nif ( NetcdfFile . debugStructureIterator ) { \nSystem . out . println ( \"readStructure \" + start + \" \" + count ) ; \n} \nreturn ( ArrayStructure ) read ( origin , shape ) ; \n} \n} \n"}
{"5837": "public class TableA { \nstatic public String getDataCategory ( int cat ) { \nif ( tableA == null ) { \ninit ( ) ; \n} \nString result = tableA . get ( cat ) ; \nreturn result != null ? result : \"Unknown category=\" + cat ; \n} \n} \n"}
{"5842": "public class CF1Convention { \npublic static int getVersion ( String hasConvName ) { \nint result = extractVersion ( hasConvName ) ; \nif ( result >= 0 ) { \nreturn result ; \n} \nList < String > names = breakupConventionNames ( hasConvName ) ; \nfor ( String name : names ) { \nresult = extractVersion ( name ) ; \nif ( result >= 0 ) { \nreturn result ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5843": "public class CF1Convention { \npublic static String getZisPositive ( String zaxisName , String vertCoordUnits ) { \nif ( vertCoordUnits == null ) { \nreturn CF . POSITIVE_UP ; \n} \nif ( vertCoordUnits . isEmpty ( ) ) { \nreturn CF . POSITIVE_UP ; \n} \nif ( SimpleUnit . isCompatible ( \"millibar\" , vertCoordUnits ) ) { \nreturn CF . POSITIVE_DOWN ; \n} \nif ( SimpleUnit . isCompatible ( \"m\" , vertCoordUnits ) ) { \nreturn CF . POSITIVE_UP ; \n} \nreturn CF . POSITIVE_UP ; \n} \n} \n"}
{"5844": "public class ImageFactoryRandom { \npublic boolean delete ( ) { \nif ( nextFile == null ) { \nreturn false ; \n} \nfileList . remove ( nextFile ) ; \nFile f = new File ( \"C:/tmp/deleted/\" + nextFile . getName ( ) ) ; \nreturn nextFile . renameTo ( f ) ; \n} \n} \n"}
{"5845": "public class CoverageRenderer { \nprivate void setColorScaleParams ( ) { \nif ( dataMinMaxType == ColorScale . MinMaxType . hold && ! isNewField ) { \nreturn ; \n} \nisNewField = false ; \nGeoReferencedArray dataArr = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataArr != null ) { \nMAMath . MinMax minmax = MAMath . getMinMaxSkipMissingData ( dataArr . getData ( ) , dataState . grid ) ; \ncolorScale . setMinMax ( minmax . min , minmax . max ) ; \ncolorScale . setGeoGrid ( dataState . grid ) ; \n} \n} \n} \n"}
{"5846": "public class CoverageRenderer { \npublic void renderPlanView ( java . awt . Graphics2D g , AffineTransform dFromN ) { \nif ( ( dataState . grid == null ) || ( colorScale == null ) || ( drawProjection == null ) ) { \nreturn ; \n} \nif ( ! drawGrid && ! drawContours ) { \nreturn ; \n} \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ndataH = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataH == null ) { \nreturn ; \n} \nsetColorScaleParams ( ) ; \nif ( drawGrid ) { \ndrawGridHoriz ( g , dataH ) ; \n} \nif ( drawGridLines ) { \ndrawGridLines ( g , dataH ) ; \n} \nif ( drawBB ) { \ndrawGridBB ( g , this . dataState . coverageDataset . getLatlonBoundingBox ( ) ) ; \n} \n} \n} \n"}
{"5847": "public class H5Group { \nboolean isChildOf ( H5Group that ) { \nif ( parent == null ) { \nreturn false ; \n} \nif ( parent == that ) { \nreturn true ; \n} \nreturn parent . isChildOf ( that ) ; \n} \n} \n"}
{"5848": "public class MessageType { \npublic static MessageType getType ( String name ) { \nif ( name == null ) { \nreturn null ; \n} \nreturn hash . get ( name ) ; \n} \n} \n"}
{"6184": "public class SSLContextFactoryBean { \nprivate KeyManager [ ] createKeyManagers ( ContextAware context ) throws NoSuchProviderException , NoSuchAlgorithmException , UnrecoverableKeyException , KeyStoreException { \nif ( getKeyStore ( ) == null ) { \nreturn null ; \n} \nKeyStore keyStore = getKeyStore ( ) . createKeyStore ( ) ; \ncontext . addInfo ( \"key store of type '\" + keyStore . getType ( ) + \"' provider '\" + keyStore . getProvider ( ) + \"': \" + getKeyStore ( ) . getLocation ( ) ) ; \nKeyManagerFactory kmf = getKeyManagerFactory ( ) . createKeyManagerFactory ( ) ; \ncontext . addInfo ( \"key manager algorithm '\" + kmf . getAlgorithm ( ) + \"' provider '\" + kmf . getProvider ( ) + \"'\" ) ; \nchar [ ] passphrase = getKeyStore ( ) . getPassword ( ) . toCharArray ( ) ; \nkmf . init ( keyStore , passphrase ) ; \nreturn kmf . getKeyManagers ( ) ; \n} \n} \n"}
{"6185": "public class SSLContextFactoryBean { \nprivate TrustManager [ ] createTrustManagers ( ContextAware context ) throws NoSuchProviderException , NoSuchAlgorithmException , KeyStoreException { \nif ( getTrustStore ( ) == null ) { \nreturn null ; \n} \nKeyStore trustStore = getTrustStore ( ) . createKeyStore ( ) ; \ncontext . addInfo ( \"trust store of type '\" + trustStore . getType ( ) + \"' provider '\" + trustStore . getProvider ( ) + \"': \" + getTrustStore ( ) . getLocation ( ) ) ; \nTrustManagerFactory tmf = getTrustManagerFactory ( ) . createTrustManagerFactory ( ) ; \ncontext . addInfo ( \"trust manager algorithm '\" + tmf . getAlgorithm ( ) + \"' provider '\" + tmf . getProvider ( ) + \"'\" ) ; \ntmf . init ( trustStore ) ; \nreturn tmf . getTrustManagers ( ) ; \n} \n} \n"}
{"6186": "public class SSLContextFactoryBean { \nprivate KeyStoreFactoryBean keyStoreFromSystemProperties ( String property ) { \nif ( System . getProperty ( property ) == null ) { \nreturn null ; \n} \nKeyStoreFactoryBean keyStore = new KeyStoreFactoryBean ( ) ; \nkeyStore . setLocation ( locationFromSystemProperty ( property ) ) ; \nkeyStore . setProvider ( System . getProperty ( property + \"Provider\" ) ) ; \nkeyStore . setPassword ( System . getProperty ( property + \"Password\" ) ) ; \nkeyStore . setType ( System . getProperty ( property + \"Type\" ) ) ; \nreturn keyStore ; \n} \n} \n"}
{"6195": "public class AbstractComponentTracker { \nprivate Entry < C > getFromEitherMap ( String key ) { \nEntry < C > entry = liveMap . get ( key ) ; \nif ( entry != null ) { \nreturn entry ; \n} \nelse { \nreturn lingerersMap . get ( key ) ; \n} \n} \n} \n"}
{"6196": "public class AbstractComponentTracker { \npublic void endOfLife ( String key ) { \nEntry < C > entry = liveMap . remove ( key ) ; \nif ( entry == null ) { \nreturn ; \n} \nlingerersMap . put ( key , entry ) ; \n} \n} \n"}
{"6205": "public class CallerData { \nprivate static boolean isInFrameworkSpaceList ( String currentClass , List < String > frameworkPackageList ) { \nif ( frameworkPackageList == null ) { \nreturn false ; \n} \nfor ( String s : frameworkPackageList ) { \nif ( currentClass . startsWith ( s ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6210": "public class SystemPropertiesProxy { \npublic void setClassLoader ( ClassLoader cl ) throws ClassNotFoundException , SecurityException , NoSuchMethodException { \nif ( cl == null ) { \ncl = this . getClass ( ) . getClassLoader ( ) ; \n} \nSystemProperties = cl . loadClass ( \"android.os.SystemProperties\" ) ; \ngetString = SystemProperties . getMethod ( \"get\" , new Class [ ] { \nString . class , String . class } \n) ; \ngetBoolean = SystemProperties . getMethod ( \"getBoolean\" , new Class [ ] { \nString . class , boolean . class } \n) ; \n} \n} \n"}
{"6211": "public class SystemPropertiesProxy { \npublic String get ( String key , String def ) throws IllegalArgumentException { \nif ( SystemProperties == null || getString == null ) { \nreturn null ; \n} \nString ret = null ; \ntry { \nret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { \nkey , def } \n) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \n} \nif ( ret == null || ret . length ( ) == 0 ) { \nret = def ; \n} \nreturn ret ; \n} \n} \n"}
{"6212": "public class SystemPropertiesProxy { \npublic Boolean getBoolean ( String key , boolean def ) throws IllegalArgumentException { \nif ( SystemProperties == null || getBoolean == null ) { \nreturn def ; \n} \nBoolean ret = def ; \ntry { \nret = ( Boolean ) getBoolean . invoke ( SystemProperties , new Object [ ] { \nkey , def } \n) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \n} \nreturn ret ; \n} \n} \n"}
{"6226": "public class ActionUtil { \nstatic public Scope stringToScope ( String scopeStr ) { \nif ( Scope . SYSTEM . toString ( ) . equalsIgnoreCase ( scopeStr ) ) { \nreturn Scope . SYSTEM ; \n} \nif ( Scope . CONTEXT . toString ( ) . equalsIgnoreCase ( scopeStr ) ) { \nreturn Scope . CONTEXT ; \n} \nreturn Scope . LOCAL ; \n} \n} \n"}
{"6244": "public class Loader { \npublic static ClassLoader getClassLoaderAsPrivileged ( final Class < ? > clazz ) { \nif ( ! HAS_GET_CLASS_LOADER_PERMISSION ) { \nreturn null ; \n} \nelse { \nreturn AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { \npublic ClassLoader run ( ) { \nreturn clazz . getClassLoader ( ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"6249": "public class LoggerNameUtil { \npublic static int getSeparatorIndexOf ( String name , int fromIndex ) { \nint dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; \nint dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; \nif ( dotIndex == - 1 && dollarIndex == - 1 ) { \nreturn - 1 ; \n} \nif ( dotIndex == - 1 ) { \nreturn dollarIndex ; \n} \nif ( dollarIndex == - 1 ) { \nreturn dotIndex ; \n} \nreturn dotIndex < dollarIndex ? dotIndex : dollarIndex ; \n} \n} \n"}
{"6266": "public class ContextBase { \npublic String getProperty ( String key ) { \nif ( CONTEXT_NAME_KEY . equals ( key ) ) { \nreturn getName ( ) ; \n} \nreturn ( String ) this . propertyMap . get ( key ) ; \n} \n} \n"}
{"6268": "public class StatusUtil { \nstatic public boolean contextHasStatusListener ( Context context ) { \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nreturn false ; \n} \nList < StatusListener > listeners = sm . getCopyOfStatusListenerList ( ) ; \nif ( listeners == null || listeners . size ( ) == 0 ) { \nreturn false ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) { \nreturn - 1 ; \n} \nint len = statusList . size ( ) ; \nfor ( int i = len - 1 ; \ni >= 0 ; \ni -- ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { \nreturn s . getDate ( ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6285": "public class OnPrintStreamStatusListenerBase { \nprivate void retrospectivePrint ( ) { \nif ( context == null ) { \nreturn ; \n} \nlong now = System . currentTimeMillis ( ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nfor ( Status status : statusList ) { \nlong timestampOfStatusMesage = status . getDate ( ) ; \nif ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) { \nprint ( status ) ; \n} \n} \n} \n} \n"}
{"6309": "public class MirroredIndex { \npublic void sync ( ) { \nif ( getDataSelectionQueries ( ) . length == 0 ) { \nthrow new IllegalStateException ( \"Cannot sync with empty data selection queries\" ) ; \n} \nsynchronized ( this ) { \nif ( syncing ) { \nreturn ; \n} \nsyncing = true ; \n} \ngetClient ( ) . localBuildExecutorService . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \n_sync ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) { \nreturn ; \n} \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6353": "public class PropertyBehavior { \npublic void setIsKeepAllAlive ( boolean isKeepAllAlive ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyKeepAllAlive = false ; \nif ( isDAVElement ( child , \"keepalive\" ) ) { \nisAlreadyKeepAllAlive = \"*\" . equals ( getFirstText ( child ) ) ; \n} \nif ( isKeepAllAlive ) { \nif ( ! isAlreadyKeepAllAlive ) { \nif ( child != null ) { \nroot . removeChild ( child ) ; \n} \nappendChild ( root , \"keepalive\" , \"*\" ) ; \n} \n} \nelse if ( isAlreadyKeepAllAlive ) { \nroot . removeChild ( child ) ; \n} \n} \n} \n"}
{"6354": "public class PropertyBehavior { \npublic void setIsOmit ( boolean isOmit ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyOmit = isDAVElement ( child , \"omit\" ) ; \nif ( isOmit ) { \nif ( ! isAlreadyOmit ) { \nif ( child != null ) { \nroot . removeChild ( child ) ; \n} \nappendChild ( root , \"omit\" ) ; \n} \n} \nelse if ( isAlreadyOmit ) { \nroot . removeChild ( child ) ; \n} \n} \n} \n"}
{"6356": "public class ConditionTerm { \npublic void addConditionFactor ( ConditionFactor factor ) throws WebDAVException { \nif ( conditionFactors . contains ( factor ) ) { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseDuplicateEntry\" ) ) ; \n} \nconditionFactors . addElement ( factor ) ; \n} \n} \n"}
{"6357": "public class ConditionTerm { \npublic static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { \nConditionTerm term = new ConditionTerm ( ) ; \ntry { \nint token = tokenizer . ttype ; \nif ( token == '(' ) { \ntoken = tokenizer . nextToken ( ) ; \n} \nelse { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"(\" ) ) ; \n} \nwhile ( token == StreamTokenizer . TT_WORD || token == '<' || token == '[' ) { \nterm . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; \ntoken = tokenizer . ttype ; \n} \nif ( token == ')' ) { \ntoken = tokenizer . nextToken ( ) ; \n} \nelse { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \")\" ) ) ; \n} \n} \ncatch ( IOException exc ) { \n} \nif ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingStateOrEntity\" ) ) ; \n} \nreturn term ; \n} \n} \n"}
{"6364": "public class HrefSet { \npublic void addHref ( String href ) { \nString encodedHref = encodeHref ( href ) ; \nif ( isDuplicate ( encodedHref ) ) { \nreturn ; \n} \nappendChild ( root , \"href\" , encodedHref ) ; \n} \n} \n"}
{"6365": "public class HrefSet { \npublic void insertHrefBefore ( String newHref , String refHref ) { \nString refHrefEncoded = encodeHref ( refHref ) ; \nString newHrefEncoded = encodeHref ( newHref ) ; \nif ( isDuplicate ( newHrefEncoded ) ) { \nreturn ; \n} \nElement child = getFirstChild ( root , \"href\" ) ; \nwhile ( child != null ) { \nif ( refHrefEncoded . equals ( getFirstText ( child ) ) ) { \ninsertBefore ( child , \"href\" , newHrefEncoded ) ; \nreturn ; \n} \nchild = getNextSibling ( child , \"href\" ) ; \n} \nAssert . isTrue ( false , Policy . bind ( \"assert.noHrefRef\" ) ) ; \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( file == null ) { \n( ( ByteArrayInputStream ) is ) . reset ( ) ; \n} \nelse { \nif ( fos != null ) { \nwhile ( skip ( 4096 ) > 0 ) { \n; \n} \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) { \nlength = totalBytesRead ; \n} \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \ntotalBytesRead = 0 ; \n} \n} \n"}
{"6389": "public class DroolsEclipsePlugin { \npublic ResourceBundle getResourceBundle ( ) { \ntry { \nif ( resourceBundle == null ) { \nresourceBundle = ResourceBundle . getBundle ( \"droolsIDE.DroolsIDEPluginResources\" ) ; \n} \n} \ncatch ( MissingResourceException x ) { \nresourceBundle = null ; \n} \nreturn resourceBundle ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( int i = 0 ; \ni < patterns . length ; \ni ++ ) { \nif ( setDateTime ( date , patterns [ i ] ) ) { \nbreak ; \n} \n} \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \nfor ( int i = 0 ; \ni < listeners . length ; \ni ++ ) { \n( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \n} \n} \n} \n"}
{"6404": "public class DAVClient { \nprotected IContext newContext ( IContext userContext , ILocator locator ) throws MalformedURLException { \nAssert . isNotNull ( userContext ) ; \nAssert . isNotNull ( locator ) ; \nIContext context = davFactory . newContext ( userContext ) ; \nif ( locator . getLabel ( ) != null ) { \ncontext . setLabel ( locator . getLabel ( ) ) ; \n} \nreturn context ; \n} \n} \n"}
{"6409": "public class URLTable { \nprivate void put ( URLKey url , Object value ) { \nAssert . isNotNull ( url ) ; \nAssert . isNotNull ( value ) ; \nif ( table . get ( url ) != null ) { \ntable . remove ( url ) ; \n} \ntable . put ( url , value ) ; \n} \n} \n"}
{"6413": "public class Precondition { \npublic void addCondition ( Condition condition ) throws WebDAVException { \nEnumeration conditions = getConditions ( ) ; \nif ( condition . getResourceURI ( ) != null ) { \nwhile ( conditions . hasMoreElements ( ) ) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nif ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMultipleSpecification\" , condition . getResourceURI ( ) ) ) ; \n} \n} \n} \nthis . conditions . addElement ( condition ) ; \n} \n} \n"}
{"6423": "public class Policy { \npublic static String bind ( String id , String [ ] bindings ) { \nif ( id == null ) { \nreturn \"No message available\" ; \n} \nString message = null ; \ntry { \nmessage = bundle . getString ( id ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn \"Missing message: \" + id + \"in: \" + bundleName ; \n} \nif ( bindings == null ) { \nreturn message ; \n} \nreturn MessageFormat . format ( message , bindings ) ; \n} \n} \n"}
{"6434": "public class Status { \npublic boolean sameAs ( Object obj ) { \nif ( obj == null || ! ( obj instanceof Status ) ) { \nreturn false ; \n} \nStatus other = ( Status ) obj ; \nif ( other . code != code || ! other . message . equals ( message ) ) { \nreturn false ; \n} \nreturn other . extendedStatus . equals ( extendedStatus ) ; \n} \n} \n"}
{"6436": "public class StateToken { \npublic static ConditionFactor create ( StreamTokenizer tokenizer ) throws WebDAVException { \nStateToken stateToken = new StateToken ( ) ; \ntry { \nint token = tokenizer . ttype ; \nif ( token == '<' ) { \ntoken = tokenizer . nextToken ( ) ; \n} \nelse { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \"<\" ) ) ; \n} \nif ( token == StreamTokenizer . TT_WORD ) { \nstateToken . setURI ( tokenizer . sval ) ; \ntoken = tokenizer . nextToken ( ) ; \n} \nelse { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissingURI\" , String . valueOf ( token ) ) ) ; \n} \nif ( token == '>' ) { \ntoken = tokenizer . nextToken ( ) ; \n} \nelse { \nthrow new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMissing\" , String . valueOf ( token ) , \">\" ) ) ; \n} \n} \ncatch ( IOException exc ) { \n} \nreturn stateToken ; \n} \n} \n"}
{"6438": "public class KieServiceDelegate { \nprotected String httpDelete ( String request ) throws IOException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[DELETE] \" + url . toString ( ) ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setRequestMethod ( \"DELETE\" ) ; \nconn . setRequestProperty ( \"Content\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[DELETE] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP DELETE failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) { \nthrow new IOException ( \"HTTP DELETE failed : Request status code : \" + status ) ; \n} \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) { \nreturn jobId ; \n} \nreturn response ; \n} \n} \n"}
{"6439": "public class KieServiceDelegate { \nprotected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[POST] \" + url . toString ( ) + \" body: \" + body ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setDoOutput ( body != null ) ; \nconn . setRequestMethod ( \"POST\" ) ; \nconn . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nif ( body != null ) { \njava . io . OutputStream os = conn . getOutputStream ( ) ; \nWriter writer = new OutputStreamWriter ( os , \"UTF-8\" ) ; \nbody . writeTo ( writer ) ; \nwriter . close ( ) ; \nos . flush ( ) ; \n} \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[POST] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP POST failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) { \nthrow new IOException ( \"HTTP POST failed : Request status code : \" + status ) ; \n} \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) { \nreturn jobId ; \n} \nreturn response ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) { \nif ( ! \"SUCCESS\" . equals ( status ) ) { \nresult = null ; \n} \n} \nif ( status != null && result != null ) { \nar . set ( status + \":\" + result ) ; \n} \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . println ( \"status=\" + status ) ; \nActivator . println ( \"result=\" + result ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) { \nthrow new InterruptedException ( \"Operation canceled\" ) ; \n} \n} \nwhile ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; \npm . done ( ) ; \nActivator . println ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" ) ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6441": "public class PullOperationUI { \n@ SuppressWarnings ( \"restriction\" ) public void execute ( IProgressMonitor monitor ) { \ntry { \npullOperation . execute ( monitor ) ; \nresults . putAll ( pullOperation . getResults ( ) ) ; \n} \ncatch ( CoreException e ) { \nif ( e . getStatus ( ) . getSeverity ( ) == IStatus . CANCEL ) { \nresults . putAll ( pullOperation . getResults ( ) ) ; \n} \nelse { \nrepoNode . handleException ( ( Throwable ) e ) ; \n} \n} \n} \n} \n"}
{"6442": "public class PullOperationUI { \nprivate void handlePullResults ( final Map < Repository , Object > resultsMap ) { \nif ( tasksToWaitFor . decrementAndGet ( ) == 0 && ! results . isEmpty ( ) ) { \nshowResults ( ) ; \n} \n} \n} \n"}
{"6463": "public class AbstractResourceHandle { \npublic void copy ( ILocator destination , String depth , boolean overwrite , Collection propertyNames ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setDepth ( depth ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( propertyNames == null ) { \npropertyBehavior . setIsKeepAllAlive ( true ) ; \n} \nelse { \nIterator namesItr = propertyNames . iterator ( ) ; \nwhile ( namesItr . hasNext ( ) ) { \nQualifiedName name = ( QualifiedName ) namesItr . next ( ) ; \nString nameURI = name . getQualifier ( ) + \"/\" + name . getLocalName ( ) ; \npropertyBehavior . addProperty ( nameURI ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . copy ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6464": "public class AbstractResourceHandle { \nprotected void examineMultiStatusResponse ( IResponse response ) throws DAVException { \nif ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) { \nreturn ; \n} \nif ( ! response . hasDocumentBody ( ) ) { \nthrow new DAVException ( Policy . bind ( \"exception.responseMustHaveDocBody\" ) ) ; \n} \nElement documentElement ; \ntry { \ndocumentElement = response . getDocumentBody ( ) . getDocumentElement ( ) ; \nif ( documentElement == null ) { \nthrow new DAVException ( Policy . bind ( \"exception.invalidDoc\" ) ) ; \n} \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \ntry { \nMultiStatus multistatus = new MultiStatus ( documentElement ) ; \nEnumeration responseEnum = multistatus . getResponses ( ) ; \nwhile ( responseEnum . hasMoreElements ( ) ) { \nResponseBody responseBody = ( ResponseBody ) responseEnum . nextElement ( ) ; \nEnumeration propstatEnum = responseBody . getPropStats ( ) ; \nwhile ( propstatEnum . hasMoreElements ( ) ) { \nPropStat propstat = ( PropStat ) propstatEnum . nextElement ( ) ; \nexamineStatusCode ( propstat . getStatusCode ( ) , propstat . getResponseDescription ( ) ) ; \n} \n} \n} \ncatch ( MalformedElementException e ) { \nthrow new SystemException ( e ) ; \n} \n} \n} \n"}
{"6467": "public class AbstractResourceHandle { \npublic Enumeration getLocks ( ) throws DAVException { \nLockDiscovery lockdiscovery = null ; \ntry { \nElement element = getProperty ( DAV_LOCK_DISCOVERY ) . getProperty ( ) ; \nlockdiscovery = new LockDiscovery ( element ) ; \nreturn lockdiscovery . getActiveLocks ( ) ; \n} \ncatch ( WebDAVException exception ) { \nif ( exception . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) { \nreturn new EmptyEnumeration ( ) ; \n} \nthrow exception ; \n} \ncatch ( MalformedElementException elemException ) { \nthrow new SystemException ( elemException ) ; \n} \n} \n} \n"}
{"6468": "public class AbstractResourceHandle { \npublic PropertyStatus getProperty ( QualifiedName propertyName ) throws DAVException { \nCollection names = new HashSet ( ) ; \nnames . add ( propertyName ) ; \nURLTable result = getProperties ( names , IContext . DEPTH_ZERO ) ; \nURL url = null ; \ntry { \nurl = new URL ( locator . getResourceURL ( ) ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new SystemException ( e ) ; \n} \nHashtable propTable = ( Hashtable ) result . get ( url ) ; \nif ( propTable == null ) { \nthrow new DAVException ( Policy . bind ( \"exception.lookup\" , url . toExternalForm ( ) ) ) ; \n} \nreturn ( PropertyStatus ) propTable . get ( propertyName ) ; \n} \n} \n"}
{"6474": "public class AbstractResourceHandle { \npublic void removeProperties ( Collection propertyNames ) throws DAVException { \nAssert . isNotNull ( propertyNames ) ; \nif ( propertyNames . isEmpty ( ) ) { \nreturn ; \n} \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addRemove ( ) ; \nIterator namesItr = propertyNames . iterator ( ) ; \nwhile ( namesItr . hasNext ( ) ) { \nprop . addPropertyName ( ( QualifiedName ) namesItr . next ( ) ) ; \n} \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6477": "public class AbstractResourceHandle { \npublic void setProperties ( Collection properties ) throws DAVException { \nAssert . isNotNull ( properties ) ; \nif ( properties . isEmpty ( ) ) { \nreturn ; \n} \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addSet ( ) ; \nIterator propertiesItr = properties . iterator ( ) ; \nwhile ( propertiesItr . hasNext ( ) ) { \nElement element = ( Element ) propertiesItr . next ( ) ; \ntry { \nprop . addProperty ( element ) ; \n} \ncatch ( MalformedElementException exception ) { \nthrow new SystemException ( exception ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6482": "public class AbstractResourceHandle { \npublic void delete ( boolean mustExist ) throws DAVException { \nIResponse response = null ; \ntry { \nresponse = davClient . delete ( locator , newContext ( ) ) ; \nif ( ! mustExist && ( response . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) ) { \nreturn ; \n} \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6483": "public class AbstractResourceHandle { \nprotected void examineStatusCode ( int code , String message ) throws WebDAVException { \nif ( code >= 300 && code <= 399 ) { \nthrow new RedirectionException ( code , message ) ; \n} \nif ( code >= 400 && code <= 499 ) { \nthrow new ClientException ( code , message ) ; \n} \nif ( code >= 500 && code <= 599 ) { \nthrow new ServerException ( code , message ) ; \n} \n} \n} \n"}
{"6484": "public class AbstractResourceHandle { \nprotected boolean propertyHasChild ( QualifiedName propertyName , QualifiedName childName ) throws DAVException { \nPropertyStatus propertyStat = getProperty ( propertyName ) ; \nif ( propertyStat . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) { \nreturn false ; \n} \nexamineStatusCode ( propertyStat . getStatusCode ( ) , propertyStat . getStatusMessage ( ) ) ; \ntry { \nreturn ElementEditor . hasChild ( propertyStat . getProperty ( ) , childName ) ; \n} \ncatch ( MalformedElementException exception ) { \nthrow new SystemException ( exception ) ; \n} \n} \n} \n"}
{"6488": "public class PropFind { \npublic void setIsAllProp ( boolean isAllProp ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyAllProp = isDAVElement ( child , \"allprop\" ) ; \nif ( isAllProp ) { \nif ( ! isAlreadyAllProp ) { \nif ( child != null ) { \nroot . removeChild ( child ) ; \n} \nappendChild ( root , \"allprop\" ) ; \n} \n} \nelse if ( isAlreadyAllProp ) { \nroot . removeChild ( child ) ; \n} \n} \n} \n"}
{"6489": "public class PropFind { \npublic void setIsPropName ( boolean isPropName ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyPropName = isDAVElement ( child , \"propname\" ) ; \nif ( isPropName ) { \nif ( ! isAlreadyPropName ) { \nif ( child != null ) { \nroot . removeChild ( child ) ; \n} \nappendChild ( root , \"propname\" ) ; \n} \n} \nelse if ( isAlreadyPropName ) { \nroot . removeChild ( child ) ; \n} \n} \n} \n"}
{"6496": "public class Parser { \npublic void skipWhiteSpace ( ) { \nwhile ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) { \n++ pos ; \n} \n} \n} \n"}
{"6504": "public class Context { \npublic int getTimeout ( ) { \nString timeoutString = get ( TIMEOUT ) ; \nif ( timeoutString == null ) { \nreturn - 1 ; \n} \nif ( timeoutString . equalsIgnoreCase ( DEPTH_INFINITY ) ) { \nreturn - 2 ; \n} \nif ( timeoutString . regionMatches ( true , 1 , \"Second-\" , 1 , 7 ) ) { \nreturn Integer . parseInt ( timeoutString . substring ( 7 ) ) ; \n} \nreturn - 2 ; \n} \n} \n"}
{"6505": "public class Context { \npublic void put ( String key , String value ) { \nContextKey ckey = new ContextKey ( key ) ; \nif ( ( value == null ) || ( value . length ( ) == 0 ) ) { \nproperties . remove ( ckey ) ; \n} \nelse { \nproperties . put ( ckey , value ) ; \n} \n} \n} \n"}
{"6506": "public class Context { \npublic void setTimeout ( int value ) { \nif ( value == - 1 ) { \nput ( TIMEOUT , \"\" ) ; \n} \nelse { \nput ( TIMEOUT , ( value == - 2 ) ? DEPTH_INFINITY : \"Second-\" + Integer . toString ( value ) ) ; \n} \n} \n} \n"}
{"6526": "public class IUTreeViewer { \npublic List < IInstallableUnit > getSelectedIUs ( ) { \nList < IInstallableUnit > result = new ArrayList < IInstallableUnit > ( ) ; \nfor ( Object o : getCheckedElements ( ) ) { \nif ( o instanceof IUTreeItem ) { \nIUTreeItem item = ( IUTreeItem ) o ; \nif ( item . parent != null ) { \nresult . add ( item . iu ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6534": "public class CollectionHandle { \npublic ILocator getMember ( String memberName ) { \nAssert . isTrue ( locator . getLabel ( ) == null ) ; \nAssert . isTrue ( ! locator . isStable ( ) ) ; \nString parentName = locator . getResourceURL ( ) ; \nString childName ; \nif ( parentName . endsWith ( \"/\" ) ) { \nchildName = parentName + memberName ; \n} \nelse { \nchildName = parentName + \"/\" + memberName ; \n} \nreturn davClient . getDAVFactory ( ) . newLocator ( childName ) ; \n} \n} \n"}
{"6551": "public class OgnlRuntime { \npublic static boolean isJdk15 ( ) { \nif ( _jdkChecked ) { \nreturn _jdk15 ; \n} \ntry { \nClass . forName ( \"java.lang.annotation.Annotation\" ) ; \n_jdk15 = true ; \n} \ncatch ( Exception e ) { \n} \n_jdkChecked = true ; \nreturn _jdk15 ; \n} \n} \n"}
{"6555": "public class OgnlRuntime { \npublic static final Class getArgClass ( Object arg ) { \nif ( arg == null ) { \nreturn null ; \n} \nClass c = arg . getClass ( ) ; \nif ( c == Boolean . class ) { \nreturn Boolean . TYPE ; \n} \nelse if ( c . getSuperclass ( ) == Number . class ) { \nif ( c == Integer . class ) { \nreturn Integer . TYPE ; \n} \nif ( c == Double . class ) { \nreturn Double . TYPE ; \n} \nif ( c == Byte . class ) { \nreturn Byte . TYPE ; \n} \nif ( c == Long . class ) { \nreturn Long . TYPE ; \n} \nif ( c == Float . class ) { \nreturn Float . TYPE ; \n} \nif ( c == Short . class ) { \nreturn Short . TYPE ; \n} \n} \nelse if ( c == Character . class ) { \nreturn Character . TYPE ; \n} \nreturn c ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \nindex < count ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) { \ncontinue ; \n} \nelse if ( c1 . isPrimitive ( ) ) { \nreturn true ; \n} \nelse if ( c1 . isAssignableFrom ( c2 ) ) { \nreturn false ; \n} \nelse if ( c2 . isAssignableFrom ( c1 ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6558": "public class OgnlRuntime { \npublic static final Object getMethodValue ( OgnlContext context , Object target , String propertyName , boolean checkAccessAndExistence ) throws OgnlException , IllegalAccessException , NoSuchMethodException , IntrospectionException { \nObject result = null ; \nMethod m = getGetMethod ( context , ( target == null ) ? null : target . getClass ( ) , propertyName ) ; \nif ( m == null ) { \nm = getReadMethod ( ( target == null ) ? null : target . getClass ( ) , propertyName , null ) ; \n} \nif ( checkAccessAndExistence ) { \nif ( ( m == null ) || ! context . getMemberAccess ( ) . isAccessible ( context , target , m , propertyName ) ) { \nresult = NotFound ; \n} \n} \nif ( result == null ) { \nif ( m != null ) { \ntry { \nresult = invokeMethod ( target , m , NoArguments ) ; \n} \ncatch ( InvocationTargetException ex ) { \nthrow new OgnlException ( propertyName , ex . getTargetException ( ) ) ; \n} \n} \nelse { \nthrow new NoSuchMethodException ( propertyName ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) { \nbufpos = 0 ; \n} \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) { \nAdjustBuffSize ( ) ; \n} \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) { \nAdjustBuffSize ( ) ; \n} \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) { \nbufpos = bufsize - 1 ; \n} \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) { \nbackup ( backSlashCnt - 1 ) ; \n} \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) { \n++ column ; \n} \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) { \nreturn c ; \n} \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6563": "public class OgnlParser { \nfinal public void projection ( ) throws ParseException { \nASTProject jjtn000 = new ASTProject ( JJTPROJECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse { \njjtree . popNode ( ) ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) { \nthrow ( RuntimeException ) jjte000 ; \n} \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) { \nthrow ( ParseException ) jjte000 ; \n} \n} \n} \n{ \nif ( true ) { \nthrow ( Error ) jjte000 ; \n} \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n} \n"}
{"6564": "public class OgnlParser { \nfinal public void selectAll ( ) throws ParseException { \nASTSelect jjtn000 = new ASTSelect ( JJTSELECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \njj_consume_token ( 3 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse { \njjtree . popNode ( ) ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) { \nthrow ( RuntimeException ) jjte000 ; \n} \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) { \nthrow ( ParseException ) jjte000 ; \n} \n} \n} \n{ \nif ( true ) { \nthrow ( Error ) jjte000 ; \n} \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n} \n"}
{"6565": "public class OgnlOps { \npublic static long longValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \nreturn 0L ; \n} \nClass c = value . getClass ( ) ; \nif ( c . getSuperclass ( ) == Number . class ) { \nreturn ( ( Number ) value ) . longValue ( ) ; \n} \nif ( c == Boolean . class ) { \nreturn ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ; \n} \nif ( c == Character . class ) { \nreturn ( ( Character ) value ) . charValue ( ) ; \n} \nreturn Long . parseLong ( stringValue ( value , true ) ) ; \n} \n} \n"}
{"6566": "public class OgnlOps { \npublic static double doubleValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \nreturn 0.0 ; \n} \nClass c = value . getClass ( ) ; \nif ( c . getSuperclass ( ) == Number . class ) { \nreturn ( ( Number ) value ) . doubleValue ( ) ; \n} \nif ( c == Boolean . class ) { \nreturn ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ; \n} \nif ( c == Character . class ) { \nreturn ( ( Character ) value ) . charValue ( ) ; \n} \nString s = stringValue ( value , true ) ; \nreturn ( s . length ( ) == 0 ) ? 0.0 : Double . parseDouble ( s ) ; \n} \n} \n"}
{"6567": "public class OgnlOps { \npublic static BigInteger bigIntValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \nreturn BigInteger . valueOf ( 0L ) ; \n} \nClass c = value . getClass ( ) ; \nif ( c == BigInteger . class ) { \nreturn ( BigInteger ) value ; \n} \nif ( c == BigDecimal . class ) { \nreturn ( ( BigDecimal ) value ) . toBigInteger ( ) ; \n} \nif ( c . getSuperclass ( ) == Number . class ) { \nreturn BigInteger . valueOf ( ( ( Number ) value ) . longValue ( ) ) ; \n} \nif ( c == Boolean . class ) { \nreturn BigInteger . valueOf ( ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ) ; \n} \nif ( c == Character . class ) { \nreturn BigInteger . valueOf ( ( ( Character ) value ) . charValue ( ) ) ; \n} \nreturn new BigInteger ( stringValue ( value , true ) ) ; \n} \n} \n"}
{"6568": "public class OgnlOps { \npublic static BigDecimal bigDecValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \nreturn BigDecimal . valueOf ( 0L ) ; \n} \nClass c = value . getClass ( ) ; \nif ( c == BigDecimal . class ) { \nreturn ( BigDecimal ) value ; \n} \nif ( c == BigInteger . class ) { \nreturn new BigDecimal ( ( BigInteger ) value ) ; \n} \nif ( c == Boolean . class ) { \nreturn BigDecimal . valueOf ( ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ) ; \n} \nif ( c == Character . class ) { \nreturn BigDecimal . valueOf ( ( ( Character ) value ) . charValue ( ) ) ; \n} \nreturn new BigDecimal ( stringValue ( value , true ) ) ; \n} \n} \n"}
{"6570": "public class OgnlOps { \npublic static int getNumericType ( Object value ) { \nif ( value != null ) { \nClass c = value . getClass ( ) ; \nif ( c == Integer . class ) { \nreturn INT ; \n} \nif ( c == Double . class ) { \nreturn DOUBLE ; \n} \nif ( c == Boolean . class ) { \nreturn BOOL ; \n} \nif ( c == Byte . class ) { \nreturn BYTE ; \n} \nif ( c == Character . class ) { \nreturn CHAR ; \n} \nif ( c == Short . class ) { \nreturn SHORT ; \n} \nif ( c == Long . class ) { \nreturn LONG ; \n} \nif ( c == Float . class ) { \nreturn FLOAT ; \n} \nif ( c == BigInteger . class ) { \nreturn BIGINT ; \n} \nif ( c == BigDecimal . class ) { \nreturn BIGDEC ; \n} \n} \nreturn NONNUMERIC ; \n} \n} \n"}
{"6572": "public class OgnlOps { \npublic static int getIntValue ( Object value ) { \ntry { \nif ( value == null ) { \nreturn - 1 ; \n} \nif ( Number . class . isInstance ( value ) ) { \nreturn ( ( Number ) value ) . intValue ( ) ; \n} \nString str = String . class . isInstance ( value ) ? ( String ) value : value . toString ( ) ; \nreturn Integer . parseInt ( str ) ; \n} \ncatch ( Throwable t ) { \nthrow new RuntimeException ( \"Error converting \" + value + \" to integer:\" , t ) ; \n} \n} \n} \n"}
{"6573": "public class OgnlOps { \npublic static int getNumericType ( int t1 , int t2 , boolean canBeNonNumeric ) { \nif ( t1 == t2 ) { \nreturn t1 ; \n} \nif ( canBeNonNumeric && ( t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR ) ) { \nreturn NONNUMERIC ; \n} \nif ( t1 == NONNUMERIC ) { \nt1 = DOUBLE ; \n} \nif ( t2 == NONNUMERIC ) { \nt2 = DOUBLE ; \n} \nif ( t1 >= MIN_REAL_TYPE ) { \nif ( t2 >= MIN_REAL_TYPE ) { \nreturn Math . max ( t1 , t2 ) ; \n} \nif ( t2 < INT ) { \nreturn t1 ; \n} \nif ( t2 == BIGINT ) { \nreturn BIGDEC ; \n} \nreturn Math . max ( DOUBLE , t1 ) ; \n} \nelse if ( t2 >= MIN_REAL_TYPE ) { \nif ( t1 < INT ) { \nreturn t2 ; \n} \nif ( t1 == BIGINT ) { \nreturn BIGDEC ; \n} \nreturn Math . max ( DOUBLE , t2 ) ; \n} \nelse { \nreturn Math . max ( t1 , t2 ) ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nif ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse { \n++ newSize ; \n} \n} \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) { \nnewChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \n} \nelse { \nnewChildren [ j ++ ] = c ; \n} \n} \nif ( j != newSize ) { \nthrow new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n} \n_children = newChildren ; \n} \n} \n} \n"}
{"6581": "public class OgnlParserTokenManager { \nprivate char escapeChar ( ) { \nint ofs = image . length ( ) - 1 ; \nswitch ( image . charAt ( ofs ) ) { \ncase 'n' : return '\\n' ; \ncase 'r' : return '\\r' ; \ncase 't' : return '\\t' ; \ncase 'b' : return '\\b' ; \ncase 'f' : return '\\f' ; \ncase '\\\\' : return '\\\\' ; \ncase '\\'' : return '\\'' ; \ncase '\\\"' : return '\\\"' ; \n} \nwhile ( image . charAt ( -- ofs ) != '\\\\' ) { \n} \nint value = 0 ; \nwhile ( ++ ofs < image . length ( ) ) { \nvalue = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; \n} \nreturn ( char ) value ; \n} \n} \n"}
{"6615": "public class ConverterSpannedToHtml { \nprivate void withinParagraph ( final Spanned text , int start , int end ) { \nSortedSet < CharacterStyle > sortedSpans = new TreeSet < > ( ( s1 , s2 ) -> { \nint start1 = text . getSpanStart ( s1 ) ; \nint start2 = text . getSpanStart ( s2 ) ; \nif ( start1 != start2 ) { \nreturn start1 - start2 ; \n} \nint end1 = text . getSpanEnd ( s1 ) ; \nint end2 = text . getSpanEnd ( s2 ) ; \nif ( end1 != end2 ) { \nreturn end2 - end1 ; \n} \nreturn s1 . getClass ( ) . getName ( ) . compareTo ( s2 . getClass ( ) . getName ( ) ) ; \n} \n) ; \nList < CharacterStyle > spanList = Arrays . asList ( text . getSpans ( start , end , CharacterStyle . class ) ) ; \nsortedSpans . addAll ( spanList ) ; \nconvertText ( text , start , end , sortedSpans ) ; \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) || name . startsWith ( \"xmlns:\" ) ) { \nreturn ; \n} \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nint i = atts . getIndex ( name ) ; \nif ( i == - 1 ) { \nname = name . intern ( ) ; \nif ( type == null ) { \ntype = \"CDATA\" ; \n} \nif ( ! type . equals ( \"CDATA\" ) ) { \nvalue = normalize ( value ) ; \n} \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \nelse { \nif ( type == null ) { \ntype = atts . getType ( i ) ; \n} \nif ( ! type . equals ( \"CDATA\" ) ) { \nvalue = normalize ( value ) ; \n} \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \n} \n} \n"}
{"6637": "public class Schema { \n@ SuppressLint ( \"DefaultLocale\" ) public void elementType ( String name , int model , int memberOf , int flags ) { \nElementType e = new ElementType ( name , model , memberOf , flags , this ) ; \ntheElementTypes . put ( name . toLowerCase ( ) , e ) ; \nif ( memberOf == M_ROOT ) { \ntheRoot = e ; \n} \n} \n} \n"}
{"6641": "public class Schema { \npublic int getEntity ( String name ) { \nInteger ch = ( Integer ) theEntities . get ( name ) ; \nif ( ch == null ) { \nreturn 0 ; \n} \nreturn ch . intValue ( ) ; \n} \n} \n"}
{"6654": "public class FontManager { \nprivate static Map < String , String > getSystemFonts ( ) { \nsynchronized ( SYSTEM_FONTS_BY_NAME ) { \nfor ( String fontDir : FONT_DIRS ) { \nFile dir = new File ( fontDir ) ; \nif ( ! dir . exists ( ) ) { \ncontinue ; \n} \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \ncontinue ; \n} \nfor ( File file : files ) { \nString filePath = file . getAbsolutePath ( ) ; \nif ( ! SYSTEM_FONTS_BY_PATH . containsKey ( filePath ) ) { \nString fontName = TTFAnalyzer . getFontName ( file . getAbsolutePath ( ) ) ; \nif ( fontName == null ) { \nfontName = getFileName ( filePath ) ; \n} \nSYSTEM_FONTS_BY_PATH . put ( filePath , fontName ) ; \nSYSTEM_FONTS_BY_NAME . put ( fontName , filePath ) ; \n} \n} \n} \nreturn SYSTEM_FONTS_BY_NAME ; \n} \n} \n} \n"}
{"6655": "public class Parser { \nprivate void setup ( ) { \nif ( theSchema == null ) { \ntheSchema = new HTMLSchema ( ) ; \n} \nif ( theScanner == null ) { \ntheScanner = new HTMLScanner ( ) ; \n} \nif ( theAutoDetector == null ) { \ntheAutoDetector = new AutoDetector ( ) { \npublic Reader autoDetectingReader ( InputStream i ) { \nreturn new InputStreamReader ( i ) ; \n} \n} \n; \n} \ntheStack = new Element ( theSchema . getElementType ( \"<root>\" ) , defaultAttributes ) ; \nthePCDATA = new Element ( theSchema . getElementType ( \"<pcdata>\" ) , defaultAttributes ) ; \ntheNewElement = null ; \ntheAttributeName = null ; \nthePITarget = null ; \ntheSaved = null ; \ntheEntity = 0 ; \nvirginStack = true ; \ntheDoctypeName = theDoctypePublicId = theDoctypeSystemId = null ; \n} \n} \n"}
{"6656": "public class Parser { \nprivate Reader getReader ( InputSource s ) throws SAXException , IOException { \nReader r = s . getCharacterStream ( ) ; \nInputStream i = s . getByteStream ( ) ; \nString encoding = s . getEncoding ( ) ; \nString publicid = s . getPublicId ( ) ; \nString systemid = s . getSystemId ( ) ; \nif ( r == null ) { \nif ( i == null ) { \ni = getInputStream ( publicid , systemid ) ; \n} \nif ( encoding == null ) { \nr = theAutoDetector . autoDetectingReader ( i ) ; \n} \nelse { \ntry { \nr = new InputStreamReader ( i , encoding ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nr = new InputStreamReader ( i ) ; \n} \n} \n} \nreturn r ; \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nint result = 0 ; \nif ( length < 1 ) { \nreturn result ; \n} \nif ( buff [ offset ] == '#' ) { \nif ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) { \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) { \nreturn ; \n} \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) { \nnamespace = localName = \"\" ; \n} \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \nfor ( int i = atts . getLength ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6664": "public class Parser { \nprivate String prefixOf ( String name ) { \nint i = name . indexOf ( ':' ) ; \nString prefix = \"\" ; \nif ( i != - 1 ) { \nprefix = name . substring ( 0 , i ) ; \n} \nreturn prefix ; \n} \n} \n"}
{"6666": "public class Parser { \nprivate static String trimquotes ( String in ) { \nif ( in == null ) { \nreturn in ; \n} \nint length = in . length ( ) ; \nif ( length == 0 ) { \nreturn in ; \n} \nchar s = in . charAt ( 0 ) ; \nchar e = in . charAt ( length - 1 ) ; \nif ( s == e && ( s == '\\'' || s == '\"' ) ) { \nin = in . substring ( 1 , in . length ( ) - 1 ) ; \n} \nreturn in ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) { \ns = e ; \n} \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) { \ns = e ; \n} \n} \nelse if ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) { \nl . add ( val . substring ( s , e ) ) ; \n} \ns = - 1 ; \n} \nelse if ( s < 0 && c != ' ' ) { \ns = e ; \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nwhile ( true ) { \nfor ( sp = theStack ; \nsp != null ; \nsp = sp . next ( ) ) { \nif ( sp . canContain ( e ) ) { \nbreak ; \n} \n} \nif ( sp != null ) { \nbreak ; \n} \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) { \nbreak ; \n} \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) { \nreturn ; \n} \nwhile ( theStack != sp ) { \nif ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) { \nbreak ; \n} \nrestartablyPop ( ) ; \n} \nwhile ( e != null ) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) { \npush ( e ) ; \n} \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength -- > 0 ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) { \ndst . append ( '_' ) ; \n} \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) { \ndst . append ( '_' ) ; \n} \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) { \ndst . append ( '_' ) ; \n} \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) { \nname = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \n} \nif ( ! name . equals ( value ) ) { \nreturn false ; \n} \nfor ( int j = 0 ; \nj < booleans . length ; \nj ++ ) { \nif ( name . equals ( booleans [ j ] ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6823": "public class ClassExpressionSaturationFactory { \npublic void printStatistics ( ) { \nruleApplicationFactory_ . getSaturationStatistics ( ) . print ( LOGGER_ ) ; \nif ( LOGGER_ . isDebugEnabled ( ) ) { \nif ( aggregatedStats_ . jobsSubmittedNo > 0 ) { \nLOGGER_ . debug ( \"Saturation Jobs Submitted=Done+Processed: {}={}+{}\" , aggregatedStats_ . jobsSubmittedNo , aggregatedStats_ . jobsAlreadyDoneNo , aggregatedStats_ . jobsProcessedNo ) ; \n} \nLOGGER_ . debug ( \"Locks: \" + aggregatedStats_ . locks ) ; \n} \n} \n} \n"}
{"6827": "public class ClassExpressionSaturationFactory { \nprivate static boolean updateIfSmaller ( AtomicInteger counter , int value ) { \nfor ( ; \n; \n) { \nint snapshotCoutner = counter . get ( ) ; \nif ( snapshotCoutner >= value ) { \nreturn false ; \n} \nif ( counter . compareAndSet ( snapshotCoutner , value ) ) { \nreturn true ; \n} \n} \n} \n} \n"}
{"6836": "public class AbstractReasonerStage { \n@ Override public boolean preExecute ( ) { \nif ( isInitialized_ ) { \nreturn false ; \n} \nLOGGER_ . trace ( \"{}: initialized\" , this ) ; \nthis . workerNo = reasoner . getNumberOfWorkers ( ) ; \nreturn isInitialized_ = true ; \n} \n} \n"}
{"6841": "public class LinearProbing { \nstatic < E > void remove ( E [ ] d , int pos ) { \nfor ( ; \n; \n) { \nint next = getMovedPosition ( d , pos ) ; \nE moved = d [ pos ] = d [ next ] ; \nif ( moved == null ) { \nreturn ; \n} \npos = next ; \n} \n} \n} \n"}
{"6842": "public class LinearProbing { \nstatic < K , V > void remove ( K [ ] k , V [ ] v , int pos ) { \nfor ( ; \n; \n) { \nint next = getMovedPosition ( k , pos ) ; \nK moved = k [ pos ] = k [ next ] ; \nv [ pos ] = v [ next ] ; \nif ( moved == null ) { \nreturn ; \n} \npos = next ; \n} \n} \n} \n"}
{"6843": "public class LinearProbing { \nstatic < E > int getMovedPosition ( E [ ] d , int del ) { \nint j = del ; \nfor ( ; \n; \n) { \nif ( ++ j == d . length ) { \nj = 0 ; \n} \nE test = d [ j ] ; \nif ( test == null ) { \nreturn j ; \n} \nint k = getIndex ( test , d . length ) ; \nif ( ( del < j ) ? ( del < k ) && ( k <= j ) : ( del < k ) || ( k <= j ) ) { \ncontinue ; \n} \nreturn j ; \n} \n} \n} \n"}
{"6844": "public class LinearProbing { \nstatic < E > boolean contains ( E [ ] d , Object o ) { \nint pos = getPosition ( d , o ) ; \nif ( d [ pos ] == null ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"6846": "public class CachedIndexedComplexClassExpressionImpl { \npublic final void checkOccurrenceNumbers ( ) { \nif ( LOGGER_ . isTraceEnabled ( ) ) { \nLOGGER_ . trace ( toString ( ) + \" occurences: \" + printOccurrenceNumbers ( ) ) ; \n} \nif ( positiveOccurrenceNo < 0 || negativeOccurrenceNo < 0 ) { \nthrow new ElkUnexpectedIndexingException ( toString ( ) + \" has a negative occurrence: \" + printOccurrenceNumbers ( ) ) ; \n} \n} \n} \n"}
{"6850": "public class ArrayHashMap { \nprivate static < K , V > V removeEntry ( K [ ] keys , V [ ] values , Object key ) { \nint pos = LinearProbing . getPosition ( keys , key ) ; \nif ( keys [ pos ] == null ) { \nreturn null ; \n} \nV result = values [ pos ] ; \nLinearProbing . remove ( keys , values , pos ) ; \nreturn result ; \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) { \nthrow new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \n} \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) { \nputKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) { \nreturn ; \n} \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) { \nputKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount ++ ; \nE [ ] tab = buckets ; \nfor ( int i = 0 ; \ni < tab . length ; \ni ++ ) { \ntab [ i ] = null ; \n} \nsize = 0 ; \n} \n} \n"}
{"6862": "public class ConcurrentComputationWithInputs { \npublic synchronized boolean submit ( I input ) throws InterruptedException { \nif ( termination || isInterrupted ( ) ) { \nreturn false ; \n} \nbuffer_ . put ( input ) ; \nreturn true ; \n} \n} \n"}
{"6866": "public class AbstractMatch { \nprotected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { \nfullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { \nvoid fail ( ) { \nthrow new IllegalArgumentException ( fullChain + \", \" + startPos ) ; \n} \nVoid defaultVisit ( ElkObjectPropertyExpression expression ) { \nif ( startPos != 0 ) { \nfail ( ) ; \n} \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectPropertyChain expression ) { \nif ( startPos < 0 || startPos >= expression . getObjectPropertyExpressions ( ) . size ( ) ) { \nfail ( ) ; \n} \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectInverseOf expression ) { \nreturn defaultVisit ( expression ) ; \n} \n@ Override public Void visit ( ElkObjectProperty expression ) { \nreturn defaultVisit ( expression ) ; \n} \n} \n) ; \n} \n} \n"}
{"6867": "public class Operations { \npublic static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { \nreturn new Set < T > ( ) { \n@ Override public int size ( ) { \nreturn size ; \n} \n@ Override public boolean isEmpty ( ) { \nreturn size == 0 ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public boolean contains ( Object o ) { \nif ( ! input . contains ( o ) ) { \nreturn false ; \n} \nT elem = null ; \ntry { \nelem = ( T ) o ; \n} \ncatch ( ClassCastException cce ) { \nreturn false ; \n} \nreturn condition . holds ( elem ) ; \n} \n@ Override public Iterator < T > iterator ( ) { \nreturn filter ( input , condition ) . iterator ( ) ; \n} \n@ Override public Object [ ] toArray ( ) { \nObject [ ] result = new Object [ size ] ; \nint i = 0 ; \nfor ( Object o : filter ( input , condition ) ) { \nresult [ i ++ ] = o ; \n} \nreturn result ; \n} \n@ Override public < S > S [ ] toArray ( S [ ] a ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean add ( T e ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean containsAll ( Collection < ? > c ) { \nfor ( Object o : c ) { \nif ( contains ( o ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n@ Override public boolean addAll ( Collection < ? extends T > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean retainAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public void clear ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) { \nthrow new NullPointerException ( ) ; \n} \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( newMask == oldMask ) { \nreturn false ; \n} \nelse if ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) { \nenlarge ( ) ; \n} \nsizes [ s ] ++ ; \nreturn true ; \n} \n} \n"}
{"6870": "public class ArraySlicedSet { \npublic boolean remove ( int s , Object o ) { \nif ( o == null ) { \nthrow new NullPointerException ( ) ; \n} \nint mask = 1 << s ; \nint oldMask = removeMask ( logs , data , masks , o , mask ) ; \nint newMask = oldMask & ~ mask ; \nif ( newMask == oldMask ) { \nreturn false ; \n} \nif ( newMask == 0 && -- occupied == LinearProbing . getLowerSize ( data . length ) ) { \nshrink ( ) ; \n} \nsizes [ s ] -- ; \nreturn true ; \n} \n} \n"}
{"6885": "public class Affordance { \npublic void setType ( String mediaType ) { \nif ( mediaType != null ) { \nlinkParams . set ( TYPE . paramName , mediaType ) ; \n} \nelse { \nlinkParams . remove ( TYPE . paramName ) ; \n} \n} \n} \n"}
{"6899": "public class SpringActionInputParameter { \n@ Override public String getParameterName ( ) { \nString ret = null ; \nif ( requestParam != null ) { \nString requestParamName = requestParam . value ( ) ; \nif ( ! requestParamName . isEmpty ( ) ) { \nret = requestParamName ; \n} \n} \nif ( pathVariable != null ) { \nString pathVariableName = pathVariable . value ( ) ; \nif ( ! pathVariableName . isEmpty ( ) ) { \nret = pathVariableName ; \n} \n} \nif ( ret == null ) { \nString parameterName = methodParameter . getParameterName ( ) ; \nif ( parameterName == null ) { \nmethodParameter . initParameterNameDiscovery ( new LocalVariableTableParameterNameDiscoverer ( ) ) ; \nret = methodParameter . getParameterName ( ) ; \n} \nelse { \nret = parameterName ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"6942": "public class ConcreteClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , CtClass superClass ) { \nif ( superClass == null ) { \nreturn ; \n} \ntry { \nconcreteClass . setSuperclass ( superClass ) ; \nlogger . trace ( concreteClass . getName ( ) + \" Inheritance link with \" + superClass . getName ( ) + \" class created\" ) ; \n} \ncatch ( CannotCompileException cce ) { \ncce . printStackTrace ( ) ; \n} \n} \n} \n"}
{"6952": "public class ServiceUsageMBeanImpl { \npublic synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { \nif ( sbbId == null ) { \nthrow new NullPointerException ( \"Sbb ID is null!\" ) ; \n} \nSbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; \nif ( sbbComponent == null ) { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) ) ; \n} \nelse { \nif ( sbbComponent . getUsageParametersInterface ( ) == null ) { \nthrow new InvalidArgumentException ( \"no usage parameter interface for \" + sbbId ) ; \n} \n} \nServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; \nif ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) + \" is not part of \" + getService ( ) ) ; \n} \nSet < String > resultSet = new HashSet < String > ( ) ; \nfor ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { \nif ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { \nString name = usageMBeanImpl . getUsageParameterSet ( ) ; \nif ( name != null ) { \nresultSet . add ( name ) ; \n} \n} \n} \nreturn resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; \n} \n} \n"}
{"6965": "public class TraceLevel { \npublic boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { \nif ( other == null ) { \nthrow new NullPointerException ( \"other is null\" ) ; \n} \nreturn this . level < other . level ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \nfor ( JarEntry entry = jarIs . getNextJarEntry ( ) ; \njarIs . available ( ) > 0 && entry != null ; \nentry = jarIs . getNextJarEntry ( ) ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( entry . isDirectory ( ) ) { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \nelse { \nlogger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \n} \nelse { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse { \nlogger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \n} \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) { \ntry { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"6967": "public class DeployableUnitJarComponentBuilder { \nprivate void pipeStream ( InputStream is , OutputStream os ) throws IOException { \nsynchronized ( buffer ) { \ntry { \nfor ( int bytesRead = is . read ( buffer ) ; \nbytesRead != - 1 ; \nbytesRead = is . read ( buffer ) ) { \nos . write ( buffer , 0 , bytesRead ) ; \n} \nis . close ( ) ; \nos . close ( ) ; \n} \ncatch ( IOException ioe ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \ntry { \nos . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \nthrow ioe ; \n} \n} \n} \n} \n"}
{"6991": "public class DeploymentManager { \npublic String showStatus ( ) { \nupdateDeployedComponents ( ) ; \nString output = \"\" ; \noutput += \"<p>Deployable Units Waiting For Install:</p>\" ; \nfor ( DeployableUnit waitingDU : waitingForInstallDUs ) { \noutput += \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; \nfor ( String dependency : waitingDU . getExternalDependencies ( ) ) { \nif ( ! deployedComponents . contains ( dependency ) ) { \ndependency += \" <strong>MISSING!</strong>\" ; \n} \noutput += \"  +-- depends on \" + dependency + \"<br>\" ; \n} \n} \noutput += \"<p>Deployable Units Waiting For Uninstall:</p>\" ; \nfor ( DeployableUnit waitingDU : waitingForUninstallDUs ) { \noutput += \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; \n} \nreturn output ; \n} \n} \n"}
{"7022": "public class AbstractUsageMBeanImplParent { \npublic ObjectName getUsageMBean ( String paramSetName ) throws NullPointerException , UnrecognizedUsageParameterSetNameException , ManagementException { \nif ( paramSetName == null ) { \nthrow new NullPointerException ( \"Sbb usage param set is null\" ) ; \n} \nreturn _getUsageMBean ( paramSetName ) ; \n} \n} \n"}
{"7025": "public class SbbAbstractMethodHandler { \npublic static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { \nif ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) { \nthrow new SLEEException ( \"congestion control refused event\" ) ; \n} \nif ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null || sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) { \nthrow new IllegalStateException ( \"SbbObject not assigned!\" ) ; \n} \nif ( eventObject == null ) { \nthrow new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \n} \nif ( aci == null ) { \nthrow new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \n} \nfinal SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; \ntxManager . mandateTransaction ( ) ; \nActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"invoke(): firing event on \" + ac ) ; \n} \nif ( ac . isEnding ( ) ) { \nthrow new IllegalStateException ( \"activity context \" + ac . getActivityContextHandle ( ) + \" is ending\" ) ; \n} \nfinal EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; \nif ( transactionData != null ) { \nfinal EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; \nif ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; \nreturn ; \n} \n} \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; \n} \n} \n"}
{"7026": "public class SbbAbstractMethodHandler { \npublic static Object getProfileCMPMethod ( SbbEntity sbbEntity , String getProfileCMPMethodName , ProfileID profileID ) throws UnrecognizedProfileTableNameException , UnrecognizedProfileNameException { \nGetProfileCMPMethodDescriptor mGetProfileCMPMethod = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getGetProfileCMPMethods ( ) . get ( getProfileCMPMethodName ) ; \nif ( mGetProfileCMPMethod == null ) { \nthrow new AbstractMethodError ( \"Profile CMP Method not found\" ) ; \n} \nif ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) { \nthrow new IllegalStateException ( \"Could not invoke getProfileCMP Method, Sbb Object is not in the READY state!\" ) ; \n} \nProfileManagement sleeProfileManager = sleeContainer . getSleeProfileTableManager ( ) ; \nProfileTable profileTable = sleeProfileManager . getProfileTable ( profileID . getProfileTableName ( ) ) ; \nif ( ! profileTable . profileExists ( profileID . getProfileName ( ) ) ) { \nthrow new UnrecognizedProfileNameException ( profileID . toString ( ) ) ; \n} \nreturn profileTable . getProfile ( profileID . getProfileName ( ) ) . getProfileCmpSlee10Wrapper ( ) ; \n} \n} \n"}
{"7032": "public class AlarmMBeanImpl { \npublic boolean isSourceOwnerOfAlarm ( NotificationSourceWrapper notificationSource , String alarmID ) { \nAlarmPlaceHolder aph = this . alarmIdToAlarm . get ( alarmID ) ; \nif ( aph == null ) { \nreturn false ; \n} \nreturn aph . getNotificationSource ( ) . getNotificationSource ( ) . equals ( notificationSource . getNotificationSource ( ) ) ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) { \nbeginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \n} \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) { \nbeginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \n} \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7046": "public class TracerStorage { \npublic String [ ] getDefinedTracerNames ( ) { \nSet < String > names = new HashSet < String > ( ) ; \nfor ( TracerImpl t : this . tracers . values ( ) ) { \nif ( t . isExplicitlySetTracerLevel ( ) ) { \nnames . add ( t . getTracerName ( ) ) ; \n} \n} \nif ( names . isEmpty ( ) ) { \nreturn new String [ 0 ] ; \n} \nreturn names . toArray ( new String [ names . size ( ) ] ) ; \n} \n} \n"}
{"7047": "public class TracerStorage { \npublic Tracer createTracer ( String tracerName , boolean requestedBySource ) { \nTracerImpl tparent = null ; \nTracerImpl t = tracers . get ( tracerName ) ; \nif ( t == null ) { \nString [ ] split = tracerName . split ( \"\\\\.\" ) ; \nString currentName = \"\" ; \nfor ( String s : split ) { \nif ( tparent == null ) { \ntparent = rootTracer ; \ncurrentName = s ; \n} \nelse { \ncurrentName = currentName + \".\" + s ; \n} \nt = tracers . get ( currentName ) ; \nif ( t == null ) { \nt = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; \nfinal TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; \nif ( u != null ) { \nt = u ; \n} \n} \ntparent = t ; \n} \n} \nif ( requestedBySource ) { \nt . setRequestedBySource ( requestedBySource ) ; \n} \nreturn t ; \n} \n} \n"}
{"7056": "public class SleeEndpointImpl { \nprivate void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { \nif ( event == null ) { \nthrow new NullPointerException ( \"event is null\" ) ; \n} \nif ( handle == null ) { \nthrow new NullPointerException ( \"handle is null\" ) ; \n} \nif ( eventType == null ) { \nthrow new NullPointerException ( \"eventType is null\" ) ; \n} \nfinal EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; \nif ( eventTypeComponent == null ) { \nthrow new IllegalEventException ( \"event type not installed (more on SLEE 1.1 specs 15.14.8)\" ) ; \n} \nif ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) { \nthrow new IllegalEventException ( \"the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) \" ) ; \n} \nif ( eventType . getClass ( ) != FireableEventTypeImpl . class ) { \nthrow new IllegalEventException ( \"unknown implementation of FireableEventType\" ) ; \n} \nif ( raEntity . getAllowedEventTypes ( ) != null && ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) { \nthrow new IllegalEventException ( \"Resource Adaptor configured to not ignore ra type event checking and the event \" + eventType . getEventType ( ) + \" does not belongs to any of the ra types implemented by the resource adaptor\" ) ; \n} \n} \n} \n"}
{"7058": "public class ConcreteSbbLocalObjectGenerator { \npublic Class generateSbbLocalObjectConcreteClass ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"generateSbbLocalObjectConcreteClass: sbbLocalObjectInterface = \" + sbbLocalObjectName + \" deployPath = \" + deployPath ) ; \n} \ntry { \nconcreteSbbLocalObject = pool . makeClass ( ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_PREFIX + sbbLocalObjectName + ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_SUFFIX ) ; \ntry { \nsleeSbbLocalObject = pool . get ( SbbLocalObjectImpl . class . getName ( ) ) ; \nsbbLocalObjectInterface = pool . get ( sbbLocalObjectName ) ; \n} \ncatch ( NotFoundException nfe ) { \nnfe . printStackTrace ( ) ; \nString s = \"Problem with pool \" ; \nlogger . error ( s , nfe ) ; \nthrow new RuntimeException ( s , nfe ) ; \n} \nCtClass concreteClassInterface ; \ntry { \nconcreteClassInterface = pool . get ( SbbLocalObjectConcrete . class . getName ( ) ) ; \n} \ncatch ( NotFoundException nfe ) { \nnfe . printStackTrace ( ) ; \nString s = \"Problem with the pool! \" ; \nlogger . error ( s , nfe ) ; \nthrow new RuntimeException ( s , nfe ) ; \n} \nConcreteClassGeneratorUtils . createInterfaceLinks ( concreteSbbLocalObject , new CtClass [ ] { \nsbbLocalObjectInterface , concreteClassInterface } \n) ; \nConcreteClassGeneratorUtils . createInheritanceLink ( concreteSbbLocalObject , sleeSbbLocalObject ) ; \nMap interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( sbbLocalObjectInterface ) ; \ngenerateConcreteMethods ( interfaceMethods , sbbAbstractClassName ) ; \ntry { \nconcreteSbbLocalObject . writeFile ( deployPath ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Concrete Class \" + concreteSbbLocalObject . getName ( ) + \" generated in the following path \" + deployPath ) ; \n} \n} \ncatch ( CannotCompileException e ) { \nString s = \" Unexpected exception ! \" ; \nlogger . fatal ( s , e ) ; \nthrow new RuntimeException ( s , e ) ; \n} \ncatch ( IOException e ) { \nString s = \"IO Exception!\" ; \nlogger . error ( s , e ) ; \nreturn null ; \n} \ntry { \nreturn Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteSbbLocalObject . getName ( ) ) ; \n} \ncatch ( ClassNotFoundException e ) { \nlogger . error ( \"unable to load sbb local object impl class\" , e ) ; \nreturn null ; \n} \n} \nfinally { \nif ( this . concreteSbbLocalObject != null ) { \nthis . concreteSbbLocalObject . defrost ( ) ; \n} \n} \n} \n} \n"}
{"7061": "public class ProfileID { \npublic final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { \nif ( profileTableName == null ) { \nthrow new NullPointerException ( \"profileTableName is null\" ) ; \n} \nif ( profileName == null ) { \nthrow new NullPointerException ( \"profileName is null\" ) ; \n} \nif ( profileTableName . indexOf ( '/' ) >= 0 ) { \nthrow new IllegalArgumentException ( \"profileTableName cannot contain the '/' character\" ) ; \n} \nthis . profileTableName = profileTableName ; \nthis . profileName = profileName ; \nthis . address = null ; \n} \n} \n"}
{"7063": "public class ChildRelationImpl { \npublic boolean contains ( Object object ) { \nif ( ! ( object instanceof SbbLocalObject ) ) { \nreturn false ; \n} \nfinal SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; \nfinal SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; \nif ( ! idBelongsToChildRelation ( sbbEntityId ) ) { \nreturn false ; \n} \nreturn new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; \n} \n} \n"}
{"7064": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean containsAll ( Collection c ) { \nif ( c == null ) { \nthrow new NullPointerException ( \"null collection!\" ) ; \n} \nfor ( Iterator it = c . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nif ( ! contains ( it . next ( ) ) ) { \nreturn false ; \n} \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"containsAll : collection = \" + c + \" > all in child relation\" ) ; \n} \nreturn true ; \n} \n} \n"}
{"7065": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean removeAll ( Collection c ) { \nboolean flag = true ; \nif ( c == null ) { \nthrow new NullPointerException ( \" null collection ! \" ) ; \n} \nfor ( Iterator it = c . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nflag &= this . remove ( it . next ( ) ) ; \n} \nreturn flag ; \n} \n} \n"}
{"7066": "public class Level { \npublic boolean isHigherLevel ( Level other ) throws NullPointerException { \nif ( other == null ) { \nthrow new NullPointerException ( \"other is null\" ) ; \n} \nreturn this . level < other . level ; \n} \n} \n"}
{"7067": "public class Level { \nprivate Object readResolve ( ) throws StreamCorruptedException { \nif ( level == LEVEL_OFF ) { \nreturn OFF ; \n} \nif ( level == LEVEL_SEVERE ) { \nreturn SEVERE ; \n} \nif ( level == LEVEL_WARNING ) { \nreturn WARNING ; \n} \nif ( level == LEVEL_INFO ) { \nreturn INFO ; \n} \nif ( level == LEVEL_CONFIG ) { \nreturn CONFIG ; \n} \nif ( level == LEVEL_FINE ) { \nreturn FINE ; \n} \nif ( level == LEVEL_FINER ) { \nreturn FINER ; \n} \nif ( level == LEVEL_FINEST ) { \nreturn FINEST ; \n} \nthrow new StreamCorruptedException ( \"Invalid internal state found\" ) ; \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) { \nreturn ; \n} \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) { \ncontinue ; \n} \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nelse if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7085": "public class DeployableUnit { \npublic void addComponent ( DeployableComponent dc ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Adding Component \" + dc . getComponentKey ( ) ) ; \n} \ncomponents . add ( dc ) ; \ncomponentIDs . add ( dc . getComponentKey ( ) ) ; \ndependencies . addAll ( dc . getDependencies ( ) ) ; \ninstallActions . addAll ( dc . getInstallActions ( ) ) ; \nCollection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( postInstallActionsStrings != null && ! postInstallActionsStrings . isEmpty ( ) ) { \ninstallActions . addAll ( postInstallActionsStrings ) ; \n} \nCollection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( preUninstallActionsStrings != null ) { \nuninstallActions . addAll ( preUninstallActionsStrings ) ; \n} \nuninstallActions . addAll ( dc . getUninstallActions ( ) ) ; \n} \n} \n"}
{"7087": "public class DeployableUnit { \npublic boolean hasDependenciesSatisfied ( boolean showMissing ) { \nif ( isSelfSufficient ( ) ) { \nreturn true ; \n} \nCollection < String > externalDependencies = getExternalDependencies ( ) ; \nexternalDependencies . removeAll ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) ) ; \nif ( ! externalDependencies . isEmpty ( ) ) { \nif ( showMissing ) { \nString missingDepList = \"\" ; \nfor ( String missingDep : externalDependencies ) missingDepList += \"\\r\\n +-- \" + missingDep ; \nlogger . info ( \"Missing dependencies for \" + this . diShortName + \":\" + missingDepList ) ; \n} \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) { \nreturn ; \n} \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni ++ ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7107": "public class CompositeQueryExpression { \nprotected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { \nif ( expr == null ) { \nthrow new NullPointerException ( \"expr is null\" ) ; \n} \nif ( expr instanceof CompositeQueryExpression ) { \n( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; \n} \nelse if ( expr instanceof Not ) { \n( ( Not ) expr ) . checkForCycles ( this ) ; \n} \nexprs . add ( expr ) ; \n} \n} \n"}
{"7108": "public class NonSerializableFactory { \npublic static synchronized void bind ( String key , Object target ) throws NameAlreadyBoundException { \nif ( wrapperMap . containsKey ( key ) == true ) { \nthrow new NameAlreadyBoundException ( key + \" already exists in the NonSerializableFactory map\" ) ; \n} \nwrapperMap . put ( key , target ) ; \n} \n} \n"}
{"7115": "public class ProfileObjectImpl { \npublic void setProfileContext ( ProfileContextImpl profileContext ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[setProfileContext] \" + this ) ; \n} \nif ( profileContext == null ) { \nthrow new NullPointerException ( \"Passed context must not be null.\" ) ; \n} \nif ( state != ProfileObjectState . DOES_NOT_EXIST ) { \nthrow new IllegalStateException ( \"Wrong state: \" + this . state + \",on profile set context operation, for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; \n} \nthis . profileContext = profileContext ; \nthis . profileContext . setProfileObject ( this ) ; \nif ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \ntry { \nif ( isSlee11 ) { \ntry { \nprofileConcrete . setProfileContext ( profileContext ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Exception encountered while setting profile context for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; \n} \n} \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \n} \nstate = ProfileObjectState . POOLED ; \n} \n} \n"}
{"7130": "public class ClassUtils { \npublic static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { \nClass returnValue = null ; \nif ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { \nreturn classOrInterfaceWithInterfaces ; \n} \nfor ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { \nif ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { \nreturnValue = iface ; \n} \nelse { \nreturnValue = checkInterfaces ( iface , interfaceSearched ) ; \n} \nif ( returnValue != null ) { \nbreak ; \n} \n} \nif ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { \nClass superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; \nif ( superClass != null ) { \nreturnValue = checkInterfaces ( superClass , interfaceSearched ) ; \n} \n} \nreturn returnValue ; \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) { \nabstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nabstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7157": "public class VendorExtensionUtils { \npublic static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { \nout . defaultWriteObject ( ) ; \nif ( vendorData != null ) { \nout . writeBoolean ( true ) ; \nout . writeObject ( new MarshalledObject ( vendorData ) ) ; \n} \nelse { \nout . writeBoolean ( false ) ; \n} \n} \n} \n"}
{"7159": "public class URLClassLoaderDomainImpl { \npublic void addDirectDependency ( URLClassLoaderDomainImpl domain ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( toString ( ) + \" adding domain \" + domain + \" to direct dependencies\" ) ; \n} \ndirectDependencies . add ( domain ) ; \n} \n} \n"}
{"7162": "public class URLClassLoaderDomainImpl { \nprotected URL findResourceLocally ( String name ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( toString ( ) + \" findResourceLocally: \" + name ) ; \n} \nreturn super . findResource ( name ) ; \n} \n} \n"}
{"7163": "public class URLClassLoaderDomainImpl { \nprotected Enumeration < URL > findResourcesLocally ( String name ) throws IOException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( toString ( ) + \" findResourcesLocally: \" + name ) ; \n} \nreturn super . findResources ( name ) ; \n} \n} \n"}
{"7171": "public class ConcreteProfileGenerator { \nprivate void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { \nString methodName = \"getUsageParameterSet\" ; \nfor ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { \nif ( ctMethod . getName ( ) . equals ( methodName ) ) { \ntry { \nCtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; \nString methodBody = \"{ return ($r)\" + ClassGeneratorUtils . MANAGEMENT_HANDLER + \".getUsageParameterSet(profileObject,$1); }\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Implemented method \" + methodName + \" , body = \" + methodBody ) ; \n} \nctMethodCopy . setBody ( methodBody ) ; \nprofileConcreteClass . addMethod ( ctMethodCopy ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n} \n"}
{"7205": "public class BitVectorUtil { \npublic static void appendBitStrings ( BitVector bv , String [ ] bs ) { \nfor ( String s : bs ) { \nif ( s . length ( ) != 8 ) { \nthrow new RuntimeException ( \"The length of bit string must be 8  while \" + s . length ( ) ) ; \n} \nfor ( char c : s . toCharArray ( ) ) { \nif ( c == '0' ) { \nbv . append0 ( ) ; \n} \nelse if ( c == '1' ) { \nbv . append1 ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"invalid char '\" + c + \"' for bit string.\" ) ; \n} \n} \n} \n} \n} \n"}
{"7364": "public class CouchDbContext { \npublic void deleteDB ( String dbName , String confirm ) { \nassertNotEmpty ( dbName , \"dbName\" ) ; \nif ( ! \"delete database\" . equals ( confirm ) ) { \nthrow new IllegalArgumentException ( \"Invalid confirm!\" ) ; \n} \ndbc . delete ( buildUri ( dbc . getBaseUri ( ) ) . path ( dbName ) . build ( ) ) ; \n} \n} \n"}
{"7374": "public class CouchDbDesign { \npublic DesignDocument getFromDesk ( String id ) { \nassertNotEmpty ( id , \"id\" ) ; \nfinal DesignDocument dd = new DesignDocument ( ) ; \nfinal String rootPath = format ( \"%s/%s/\" , DESIGN_DOCS_DIR , id ) ; \nfinal List < String > elements = listResources ( rootPath ) ; \nif ( elements == null ) { \nthrow new IllegalArgumentException ( \"Design docs directory cannot be empty.\" ) ; \n} \nMap < String , MapReduce > views = null ; \nif ( elements . contains ( VIEWS ) ) { \nviews = new HashMap < String , MapReduce > ( ) ; \nfinal String viewsPath = format ( \"%s%s/\" , rootPath , VIEWS ) ; \nfor ( String viewDirName : listResources ( viewsPath ) ) { \nfinal MapReduce mr = new MapReduce ( ) ; \nfinal String viewPath = format ( \"%s%s/\" , viewsPath , viewDirName ) ; \nfinal List < String > dirList = listResources ( viewPath ) ; \nfor ( String fileName : dirList ) { \nfinal String def = readFile ( format ( \"/%s%s\" , viewPath , fileName ) ) ; \nif ( MAP_JS . equals ( fileName ) ) { \nmr . setMap ( def ) ; \n} \nelse if ( REDUCE_JS . equals ( fileName ) ) { \nmr . setReduce ( def ) ; \n} \n} \nviews . put ( viewDirName , mr ) ; \n} \n} \ndd . setId ( DESIGN_PREFIX + id ) ; \ndd . setLanguage ( JAVASCRIPT ) ; \ndd . setViews ( views ) ; \ndd . setFilters ( populateMap ( rootPath , elements , FILTERS ) ) ; \ndd . setShows ( populateMap ( rootPath , elements , SHOWS ) ) ; \ndd . setLists ( populateMap ( rootPath , elements , LISTS ) ) ; \ndd . setUpdates ( populateMap ( rootPath , elements , UPDATES ) ) ; \ndd . setValidateDocUpdate ( readContent ( elements , rootPath , VALIDATE_DOC ) ) ; \ndd . setRewrites ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , REWRITES ) , JsonArray . class ) ) ; \ndd . setFulltext ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , FULLTEXT ) , JsonObject . class ) ) ; \ndd . setIndexes ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , INDEXES ) , JsonObject . class ) ) ; \nreturn dd ; \n} \n} \n"}
{"7389": "public class Document { \npublic void addAttachment ( String name , Attachment attachment ) { \nif ( attachments == null ) { \nattachments = new HashMap < String , Attachment > ( ) ; \n} \nattachments . put ( name , attachment ) ; \n} \n} \n"}
{"7391": "public class Changes { \nprivate boolean readNextRow ( ) { \nboolean hasNext = false ; \ntry { \nif ( ! stop ) { \nString row = \"\" ; \ndo { \nrow = getReader ( ) . readLine ( ) ; \n} \nwhile ( row . length ( ) == 0 ) ; \nif ( ! row . startsWith ( \"{\\\"last_seq\\\":\" ) ) { \nsetNextRow ( gson . fromJson ( row , Row . class ) ) ; \nhasNext = true ; \n} \n} \n} \ncatch ( Exception e ) { \nterminate ( ) ; \nthrow new CouchDbException ( \"Error reading continuous stream.\" , e ) ; \n} \nif ( ! hasNext ) { \nterminate ( ) ; \n} \nreturn hasNext ; \n} \n} \n"}
{"7447": "public class UploadManager { \nprivate void sign ( RequestHandler requestHandler ) throws QSException { \nif ( callBack != null ) { \nString signed = callBack . onSignature ( requestHandler . getStringToSignature ( ) ) ; \nif ( ! QSStringUtil . isEmpty ( signed ) ) { \nrequestHandler . setSignature ( callBack . onAccessKey ( ) , signed ) ; \n} \nString correctTime = callBack . onCorrectTime ( requestHandler . getStringToSignature ( ) ) ; \nif ( correctTime != null && correctTime . trim ( ) . length ( ) > 0 ) { \nrequestHandler . getBuilder ( ) . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , correctTime ) ; \n} \n} \n} \n} \n"}
{"7448": "public class UploadManager { \nprivate void setData ( String objectKey , Recorder recorder ) { \nif ( recorder == null ) { \nreturn ; \n} \nString upload = new Gson ( ) . toJson ( uploadModel ) ; \nrecorder . set ( objectKey , upload . getBytes ( ) ) ; \n} \n} \n"}
{"7449": "public class UploadManager { \nprivate void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { \nCompleteMultipartUploadInput completeMultipartUploadInput = new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; \ncompleteMultipartUploadInput . setContentLength ( length ) ; \nif ( ! QSStringUtil . isEmpty ( fileName ) ) { \ntry { \nString keyName = QSStringUtil . percentEncode ( fileName , \"UTF-8\" ) ; \ncompleteMultipartUploadInput . setContentDisposition ( String . format ( \"attachment; filename=\\\"%s\\\"; filename*=utf-8''%s\" , keyName , keyName ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \n} \nif ( ! QSStringUtil . isEmpty ( eTag ) ) { \ncompleteMultipartUploadInput . setETag ( eTag ) ; \n} \nRequestHandler requestHandler = bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; \nsign ( requestHandler ) ; \nBucket . CompleteMultipartUploadOutput send = ( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; \nif ( send . getStatueCode ( ) == 200 || send . getStatueCode ( ) == 201 ) { \nuploadModel . setUploadComplete ( true ) ; \nsetData ( objectKey , recorder ) ; \n} \nif ( callBack != null ) { \ncallBack . onAPIResponse ( objectKey , send ) ; \n} \n} \n} \n"}
{"7483": "public class UtilPolygons2D_F64 { \npublic static void convert ( Rectangle2D_F64 input , Polygon2D_F64 output ) { \nif ( output . size ( ) != 4 ) { \nthrow new IllegalArgumentException ( \"polygon of order 4 expected\" ) ; \n} \noutput . get ( 0 ) . set ( input . p0 . x , input . p0 . y ) ; \noutput . get ( 1 ) . set ( input . p1 . x , input . p0 . y ) ; \noutput . get ( 2 ) . set ( input . p1 . x , input . p1 . y ) ; \noutput . get ( 3 ) . set ( input . p0 . x , input . p1 . y ) ; \n} \n} \n"}
{"7484": "public class UtilPolygons2D_F64 { \npublic static void convert ( Polygon2D_F64 input , Quadrilateral_F64 output ) { \nif ( input . size ( ) != 4 ) { \nthrow new IllegalArgumentException ( \"Expected 4-sided polygon as input\" ) ; \n} \noutput . a . set ( input . get ( 0 ) ) ; \noutput . b . set ( input . get ( 1 ) ) ; \noutput . c . set ( input . get ( 2 ) ) ; \noutput . d . set ( input . get ( 3 ) ) ; \n} \n} \n"}
{"7487": "public class UtilPolygons2D_F64 { \npublic static Point2D_F64 center ( Quadrilateral_F64 quad , Point2D_F64 center ) { \nif ( center == null ) { \ncenter = new Point2D_F64 ( ) ; \n} \ncenter . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; \ncenter . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; \ncenter . x /= 4.0 ; \ncenter . y /= 4.0 ; \nreturn center ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) { \ni = polygon . vertexes . size ( ) - 1 ; \n} \n} \nelse { \ni ++ ; \n} \n} \n} \n} \n"}
{"7494": "public class Intersection2D_F64 { \npublic static boolean containTriangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c , Point2D_F64 pt ) { \nboolean ret = false ; \nif ( ( ( a . y > pt . y ) != ( b . y > pt . y ) ) && ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ) { \nret = true ; \n} \nif ( ( ( b . y > pt . y ) != ( c . y > pt . y ) ) && ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ) { \nret = ! ret ; \n} \nif ( ( ( c . y > pt . y ) != ( a . y > pt . y ) ) && ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ) { \nret = ! ret ; \n} \nreturn ret ; \n} \n} \n"}
{"7495": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineParametric2D_F64 a , LineParametric2D_F64 b , Point2D_F64 ret ) { \ndouble t_b = a . getSlopeX ( ) * ( b . getY ( ) - a . getY ( ) ) - a . getSlopeY ( ) * ( b . getX ( ) - a . getX ( ) ) ; \ndouble bottom = a . getSlopeY ( ) * b . getSlopeX ( ) - b . getSlopeY ( ) * a . getSlopeX ( ) ; \nif ( bottom == 0 ) { \nreturn null ; \n} \nt_b /= bottom ; \ndouble x = b . getSlopeX ( ) * t_b + b . getX ( ) ; \ndouble y = b . getSlopeY ( ) * t_b + b . getY ( ) ; \nif ( ret == null ) { \nret = new Point2D_F64 ( ) ; \n} \nret . set ( x , y ) ; \nreturn ret ; \n} \n} \n"}
{"7496": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { \ndouble a0 = l_0 . b . x - l_0 . a . x ; \ndouble b0 = l_0 . b . y - l_0 . a . y ; \ndouble a1 = l_1 . b . x - l_1 . a . x ; \ndouble b1 = l_1 . b . y - l_1 . a . y ; \ndouble top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; \ndouble bottom = a0 * b1 - b0 * a1 ; \nif ( bottom == 0 ) { \nreturn null ; \n} \ndouble t_1 = top / bottom ; \nif ( t_1 < 0 || t_1 > 1 ) { \nreturn null ; \n} \ntop = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; \nbottom = a1 * b0 - b1 * a0 ; \ndouble t_0 = top / bottom ; \nif ( t_0 < 0 || t_0 > 1 ) { \nreturn null ; \n} \nif ( ret == null ) { \nret = new Point2D_F64 ( ) ; \n} \nret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; \nreturn ret ; \n} \n} \n"}
{"7497": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( Point2D_F64 lineA0 , Point2D_F64 lineA1 , Point2D_F64 lineB0 , Point2D_F64 lineB1 , Point2D_F64 output ) { \nif ( output == null ) { \noutput = new Point2D_F64 ( ) ; \n} \ndouble slopeAx = lineA1 . x - lineA0 . x ; \ndouble slopeAy = lineA1 . y - lineA0 . y ; \ndouble slopeBx = lineB1 . x - lineB0 . x ; \ndouble slopeBy = lineB1 . y - lineB0 . y ; \ndouble top = slopeAy * ( lineB0 . x - lineA0 . x ) + slopeAx * ( lineA0 . y - lineB0 . y ) ; \ndouble bottom = slopeAx * slopeBy - slopeAy * slopeBx ; \nif ( bottom == 0 ) { \nreturn null ; \n} \ndouble t = top / bottom ; \noutput . x = lineB0 . x + t * slopeBx ; \noutput . y = lineB0 . y + t * slopeBy ; \nreturn output ; \n} \n} \n"}
{"7498": "public class Intersection2D_F64 { \npublic static double intersection ( LineParametric2D_F64 target , LineSegment2D_F64 l ) { \ndouble a1 = l . b . x - l . a . x ; \ndouble b1 = l . b . y - l . a . y ; \ndouble top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; \ndouble bottom = target . slope . x * b1 - target . slope . y * a1 ; \nif ( bottom == 0 ) { \nreturn Double . NaN ; \n} \ndouble t_1 = top / bottom ; \nif ( t_1 < 0 || t_1 > 1 ) { \nreturn Double . NaN ; \n} \ntop = b1 * ( target . p . x - l . a . x ) + a1 * ( l . a . y - target . p . y ) ; \nbottom = a1 * target . slope . y - b1 * target . slope . x ; \nreturn top / bottom ; \n} \n} \n"}
{"7501": "public class Intersection2D_F64 { \npublic static double intersectionArea ( Rectangle2D_F64 a , Rectangle2D_F64 b ) { \nif ( ! intersects ( a , b ) ) { \nreturn 0 ; \n} \ndouble x0 = Math . max ( a . p0 . x , b . p0 . x ) ; \ndouble x1 = Math . min ( a . p1 . x , b . p1 . x ) ; \ndouble y0 = Math . max ( a . p0 . y , b . p0 . y ) ; \ndouble y1 = Math . min ( a . p1 . y , b . p1 . y ) ; \nreturn ( x1 - x0 ) * ( y1 - y0 ) ; \n} \n} \n"}
{"7503": "public class ConvertRotation3D_F64 { \npublic static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { \nif ( quat == null ) { \nquat = new Quaternion_F64 ( ) ; \n} \ndouble m00 = R . unsafe_get ( 0 , 0 ) ; \ndouble m01 = R . unsafe_get ( 0 , 1 ) ; \ndouble m02 = R . unsafe_get ( 0 , 2 ) ; \ndouble m10 = R . unsafe_get ( 1 , 0 ) ; \ndouble m11 = R . unsafe_get ( 1 , 1 ) ; \ndouble m12 = R . unsafe_get ( 1 , 2 ) ; \ndouble m20 = R . unsafe_get ( 2 , 0 ) ; \ndouble m21 = R . unsafe_get ( 2 , 1 ) ; \ndouble m22 = R . unsafe_get ( 2 , 2 ) ; \ndouble trace = m00 + m11 + m22 ; \nif ( trace > 0 ) { \ndouble S = Math . sqrt ( trace + 1.0 ) * 2 ; \nquat . w = 0.25 * S ; \nquat . x = ( m21 - m12 ) / S ; \nquat . y = ( m02 - m20 ) / S ; \nquat . z = ( m10 - m01 ) / S ; \n} \nelse if ( ( m00 > m11 ) & ( m00 > m22 ) ) { \ndouble S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; \nquat . w = ( m21 - m12 ) / S ; \nquat . x = 0.25 * S ; \nquat . y = ( m01 + m10 ) / S ; \nquat . z = ( m02 + m20 ) / S ; \n} \nelse if ( m11 > m22 ) { \ndouble S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; \nquat . w = ( m02 - m20 ) / S ; \nquat . x = ( m01 + m10 ) / S ; \nquat . y = 0.25 * S ; \nquat . z = ( m12 + m21 ) / S ; \n} \nelse { \ndouble S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; \nquat . w = ( m10 - m01 ) / S ; \nquat . x = ( m02 + m20 ) / S ; \nquat . y = ( m12 + m21 ) / S ; \nquat . z = 0.25 * S ; \n} \nreturn quat ; \n} \n} \n"}
{"7504": "public class ConvertRotation3D_F64 { \npublic static DMatrixRMaj rotX ( double ang , DMatrixRMaj R ) { \nif ( R == null ) { \nR = new DMatrixRMaj ( 3 , 3 ) ; \n} \nsetRotX ( ang , R ) ; \nreturn R ; \n} \n} \n"}
{"7512": "public class TwistOps_F64 { \npublic static TwistCoordinate_F64 twist ( Se3_F64 motion , TwistCoordinate_F64 twist ) { \nif ( twist == null ) { \ntwist = new TwistCoordinate_F64 ( ) ; \n} \nif ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) { \ntwist . w . set ( 0 , 0 , 0 ) ; \ntwist . v . set ( motion . T ) ; \n} \nelse { \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; \ntwist . w . set ( rod . unitAxisRotation ) ; \ndouble theta = rod . theta ; \nDMatrixRMaj A = CommonOps_DDRM . identity ( 3 ) ; \nCommonOps_DDRM . subtract ( A , motion . R , A ) ; \nDMatrixRMaj w_hat = GeometryMath_F64 . crossMatrix ( twist . w , null ) ; \nDMatrixRMaj tmp = A . copy ( ) ; \nCommonOps_DDRM . mult ( tmp , w_hat , A ) ; \nVector3D_F64 w = twist . w ; \nA . data [ 0 ] += w . x * w . x * theta ; \nA . data [ 1 ] += w . x * w . y * theta ; \nA . data [ 2 ] += w . x * w . z * theta ; \nA . data [ 3 ] += w . y * w . x * theta ; \nA . data [ 4 ] += w . y * w . y * theta ; \nA . data [ 5 ] += w . y * w . z * theta ; \nA . data [ 6 ] += w . z * w . x * theta ; \nA . data [ 7 ] += w . z * w . y * theta ; \nA . data [ 8 ] += w . z * w . z * theta ; \nDMatrixRMaj y = new DMatrixRMaj ( 3 , 1 ) ; \ny . data [ 0 ] = motion . T . x ; \ny . data [ 1 ] = motion . T . y ; \ny . data [ 2 ] = motion . T . z ; \nDMatrixRMaj x = new DMatrixRMaj ( 3 , 1 ) ; \nCommonOps_DDRM . solve ( A , y , x ) ; \ntwist . w . scale ( rod . theta ) ; \ntwist . v . x = ( double ) x . data [ 0 ] ; \ntwist . v . y = ( double ) x . data [ 1 ] ; \ntwist . v . z = ( double ) x . data [ 2 ] ; \ntwist . v . scale ( rod . theta ) ; \n} \nreturn twist ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nint index = 0 ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index ++ ] = p . x - pointOnPlane . x ; \nA . data [ index ++ ] = p . y - pointOnPlane . y ; \nA . data [ index ++ ] = p . z - pointOnPlane . z ; \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) { \nreturn false ; \n} \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \nreturn true ; \n} \n} \n"}
{"7519": "public class UtilCurves_F64 { \npublic static DMatrixRMaj convert ( ConicGeneral_F64 src , DMatrixRMaj dst ) { \nif ( dst == null ) { \ndst = new DMatrixRMaj ( 3 , 3 ) ; \n} \nelse { \ndst . reshape ( 3 , 3 ) ; \n} \ndouble B = src . B / 2.0 ; \ndouble D = src . D / 2.0 ; \ndouble E = src . E / 2.0 ; \ndst . data [ 0 ] = src . A ; \ndst . data [ 1 ] = B ; \ndst . data [ 2 ] = D ; \ndst . data [ 3 ] = B ; \ndst . data [ 4 ] = src . C ; \ndst . data [ 5 ] = E ; \ndst . data [ 6 ] = D ; \ndst . data [ 7 ] = E ; \ndst . data [ 8 ] = src . F ; \nreturn dst ; \n} \n} \n"}
{"7520": "public class UtilCurves_F64 { \npublic static DMatrix3x3 convert ( ConicGeneral_F64 src , DMatrix3x3 dst ) { \nif ( dst == null ) { \ndst = new DMatrix3x3 ( ) ; \n} \ndouble B = src . B / 2.0 ; \ndouble D = src . D / 2.0 ; \ndouble E = src . E / 2.0 ; \ndst . a11 = src . A ; \ndst . a12 = B ; \ndst . a13 = D ; \ndst . a21 = B ; \ndst . a22 = src . C ; \ndst . a23 = E ; \ndst . a31 = D ; \ndst . a32 = E ; \ndst . a33 = src . F ; \nreturn dst ; \n} \n} \n"}
{"7521": "public class UtilCurves_F64 { \npublic static ParabolaGeneral_F64 convert ( ConicGeneral_F64 src , ParabolaGeneral_F64 dst ) { \nif ( dst == null ) { \ndst = new ParabolaGeneral_F64 ( ) ; \n} \ndst . A = Math . signum ( src . A ) * Math . sqrt ( Math . abs ( src . A ) ) ; \ndst . C = Math . signum ( src . C ) * Math . sqrt ( Math . abs ( src . C ) ) ; \ndst . D = src . D ; \ndst . E = src . E ; \ndst . F = src . F ; \nreturn dst ; \n} \n} \n"}
{"7522": "public class UtilCurves_F64 { \npublic static ConicGeneral_F64 convert ( ParabolaGeneral_F64 src , ConicGeneral_F64 dst ) { \nif ( dst == null ) { \ndst = new ConicGeneral_F64 ( ) ; \n} \ndst . A = src . A * src . A ; \ndst . B = src . A * src . C * 2.0 ; \ndst . C = src . C * src . C ; \ndst . D = src . D ; \ndst . E = src . E ; \ndst . F = src . F ; \nreturn dst ; \n} \n} \n"}
{"7524": "public class GeometryMath_F64 { \npublic static DMatrixRMaj toMatrix ( GeoTuple3D_F64 in , DMatrixRMaj out ) { \nif ( out == null ) { \nout = new DMatrixRMaj ( 3 , 1 ) ; \n} \nelse if ( out . getNumElements ( ) != 3 ) { \nthrow new IllegalArgumentException ( \"Vector with 3 elements expected\" ) ; \n} \nout . data [ 0 ] = in . x ; \nout . data [ 1 ] = in . y ; \nout . data [ 2 ] = in . z ; \nreturn out ; \n} \n} \n"}
{"7527": "public class UtilAngle { \npublic static double distHalf ( double angA , double angB ) { \ndouble a = Math . abs ( angA - angB ) ; \nif ( a <= Math . PI / 2 ) { \nreturn a ; \n} \nelse { \nreturn Math . PI - a ; \n} \n} \n} \n"}
{"7528": "public class Intersection3D_F64 { \npublic static boolean intersect ( PlaneGeneral3D_F64 a , PlaneGeneral3D_F64 b , LineParametric3D_F64 line ) { \nGeometryMath_F64 . cross ( a . A , a . B , a . C , b . A , b . B , b . C , line . slope ) ; \nif ( line . slope . normSq ( ) == 0 ) { \nreturn false ; \n} \ndouble n2 = a . A * a . A + a . B * a . B + a . C * a . C ; \ndouble closestX = a . A * a . D / n2 ; \ndouble closestY = a . B * a . D / n2 ; \ndouble closestZ = a . C * a . D / n2 ; \ndouble slopeX = a . B * line . slope . z - a . C * line . slope . y ; \ndouble slopeY = a . C * line . slope . x - a . A * line . slope . z ; \ndouble slopeZ = a . A * line . slope . y - a . B * line . slope . x ; \ndouble top = b . D - b . A * closestX - b . B * closestY - b . C * closestZ ; \ndouble bottom = b . A * slopeX + b . B * slopeY + b . C * slopeZ ; \ndouble d = top / bottom ; \nline . p . x = closestX + d * slopeX ; \nline . p . y = closestY + d * slopeY ; \nline . p . z = closestZ + d * slopeZ ; \nreturn true ; \n} \n} \n"}
{"7529": "public class Intersection3D_F64 { \nprivate static boolean containedPlane ( Point3D_F64 T_v0 , Point3D_F64 output , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { \ndouble uu , uv , vv , wu , wv , D ; \nuu = u . dot ( u ) ; \nuv = u . dot ( v ) ; \nvv = v . dot ( v ) ; \nw0 . minus ( output , T_v0 ) ; \nwu = w0 . dot ( u ) ; \nwv = w0 . dot ( v ) ; \nD = uv * uv - uu * vv ; \ndouble s , t ; \ns = ( uv * wv - vv * wu ) / D ; \nif ( s < 0.0 || s > 1.0 ) { \nreturn false ; \n} \nt = ( uv * wu - uu * wv ) / D ; \nreturn ! ( t < 0.0 ) && ! ( ( s + t ) > 1.0 ) ; \n} \n} \n"}
{"7530": "public class Intersection3D_F64 { \npublic static boolean intersect ( LineParametric3D_F64 line , Sphere3D_F64 sphere , Point3D_F64 a , Point3D_F64 b ) { \ndouble r2 = sphere . radius * sphere . radius ; \ndouble PP = GeometryMath_F64 . dot ( line . p , line . p ) ; \ndouble PV = GeometryMath_F64 . dot ( line . p , line . slope ) ; \ndouble PX = GeometryMath_F64 . dot ( line . p , sphere . center ) ; \ndouble VV = GeometryMath_F64 . dot ( line . slope , line . slope ) ; \ndouble VX = GeometryMath_F64 . dot ( line . slope , sphere . center ) ; \ndouble XX = GeometryMath_F64 . dot ( sphere . center , sphere . center ) ; \ndouble A = VV ; \ndouble B = 2.0 * ( PV - VX ) ; \ndouble C = PP + XX - 2.0 * PX - r2 ; \ndouble inner = B * B - 4.0 * A * C ; \nif ( inner < 0 ) { \nreturn false ; \n} \ndouble sqrt = Math . sqrt ( inner ) ; \ndouble t0 = ( - B + sqrt ) / ( 2.0 * A ) ; \ndouble t1 = ( - B - sqrt ) / ( 2.0 * A ) ; \nline . setPointOnLine ( t0 , a ) ; \nline . setPointOnLine ( t1 , b ) ; \nreturn true ; \n} \n} \n"}
{"7535": "public class SpecialEuclideanOps_F64 { \npublic static DMatrixRMaj toHomogeneous ( Se3_F64 se , DMatrixRMaj ret ) { \nif ( ret == null ) { \nret = new DMatrixRMaj ( 4 , 4 ) ; \n} \nelse { \nret . set ( 3 , 0 , 0 ) ; \nret . set ( 3 , 1 , 0 ) ; \nret . set ( 3 , 2 , 0 ) ; \n} \nCommonOps_DDRM . insert ( se . getR ( ) , ret , 0 , 0 ) ; \nVector3D_F64 T = se . getT ( ) ; \nret . set ( 0 , 3 , T . x ) ; \nret . set ( 1 , 3 , T . y ) ; \nret . set ( 2 , 3 , T . z ) ; \nret . set ( 3 , 3 , 1 ) ; \nreturn ret ; \n} \n} \n"}
{"7536": "public class SpecialEuclideanOps_F64 { \npublic static DMatrixRMaj toHomogeneous ( Se2_F64 se , DMatrixRMaj ret ) { \nif ( ret == null ) { \nret = new DMatrixRMaj ( 3 , 3 ) ; \n} \nelse { \nret . set ( 2 , 0 , 0 ) ; \nret . set ( 2 , 1 , 0 ) ; \n} \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nret . set ( 0 , 0 , c ) ; \nret . set ( 0 , 1 , - s ) ; \nret . set ( 1 , 0 , s ) ; \nret . set ( 1 , 1 , c ) ; \nret . set ( 0 , 2 , se . getX ( ) ) ; \nret . set ( 1 , 2 , se . getY ( ) ) ; \nret . set ( 2 , 2 , 1 ) ; \nreturn ret ; \n} \n} \n"}
{"7537": "public class SpecialEuclideanOps_F64 { \npublic static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , Se3_F64 se ) { \nif ( se == null ) { \nse = new Se3_F64 ( ) ; \n} \ndouble theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; \nif ( theta == 0 ) { \nCommonOps_DDRM . setIdentity ( se . R ) ; \n} \nelse { \nConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; \n} \nVector3D_F64 T = se . getT ( ) ; \nT . x = dx ; \nT . y = dy ; \nT . z = dz ; \nreturn se ; \n} \n} \n"}
{"7538": "public class SpecialEuclideanOps_F64 { \npublic static boolean isIdentical ( Se3_F64 a , Se3_F64 b , double tolT , double tolR ) { \nif ( Math . abs ( a . T . x - b . T . x ) > tolT ) { \nreturn false ; \n} \nif ( Math . abs ( a . T . y - b . T . y ) > tolT ) { \nreturn false ; \n} \nif ( Math . abs ( a . T . z - b . T . z ) > tolT ) { \nreturn false ; \n} \nDMatrixRMaj D = new DMatrixRMaj ( 3 , 3 ) ; \nCommonOps_DDRM . multTransA ( a . R , b . R , D ) ; \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( D , rod ) ; \nreturn rod . theta <= tolR ; \n} \n} \n"}
{"7539": "public class ConvertCoordinates3D_F64 { \npublic static < T extends GeoTuple3D_F64 < T > > T latlonToUnitVector ( double lat , double lon , T vector ) { \nif ( vector == null ) { \nvector = ( T ) new Vector3D_F64 ( ) ; \n} \nvector . x = Math . cos ( lat ) * Math . cos ( lon ) ; \nvector . y = Math . cos ( lat ) * Math . sin ( lon ) ; \nvector . z = - Math . sin ( lat ) ; \nreturn vector ; \n} \n} \n"}
{"7540": "public class UtilCircle2D_F64 { \npublic static boolean circle ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 , Circle2D_F64 circle ) { \ndouble xa = ( x0 . x + x1 . x ) / 2.0 ; \ndouble ya = ( x0 . y + x1 . y ) / 2.0 ; \ndouble xb = ( x1 . x + x2 . x ) / 2.0 ; \ndouble yb = ( x1 . y + x2 . y ) / 2.0 ; \ndouble m2 = x0 . x - x1 . x ; \ndouble m1 = x1 . y - x0 . y ; \ndouble n2 = x2 . x - x1 . x ; \ndouble n1 = x1 . y - x2 . y ; \ndouble bottom = m2 * n1 - n2 * m1 ; \nif ( bottom == 0 ) { \nreturn false ; \n} \ndouble alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; \ncircle . center . x = xb + n1 * alpha ; \ncircle . center . y = yb + n2 * alpha ; \ncircle . radius = circle . center . distance ( x0 ) ; \nreturn true ; \n} \n} \n"}
{"7541": "public class UtilCircle2D_F64 { \npublic static double circleRadiusSq ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 ) { \ndouble xa = ( x0 . x + x1 . x ) / 2.0 ; \ndouble ya = ( x0 . y + x1 . y ) / 2.0 ; \ndouble xb = ( x1 . x + x2 . x ) / 2.0 ; \ndouble yb = ( x1 . y + x2 . y ) / 2.0 ; \ndouble m2 = x0 . x - x1 . x ; \ndouble m1 = x1 . y - x0 . y ; \ndouble n2 = x2 . x - x1 . x ; \ndouble n1 = x1 . y - x2 . y ; \ndouble bottom = m2 * n1 - n2 * m1 ; \nif ( bottom == 0 ) { \nreturn Double . NaN ; \n} \ndouble alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; \ndouble dx = xb + n1 * alpha - x0 . x ; \ndouble dy = yb + n2 * alpha - x0 . y ; \nreturn dx * dx + dy * dy ; \n} \n} \n"}
{"7542": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 , Point3D_F64 ret ) { \nif ( ret == null ) { \nret = new Point3D_F64 ( ) ; \n} \nret . x = l0 . p . x - l1 . p . x ; \nret . y = l0 . p . y - l1 . p . y ; \nret . z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \nif ( bottom == 0 ) { \nreturn null ; \n} \nt0 /= bottom ; \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \nret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; \nret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; \nret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; \nreturn ret ; \n} \n} \n"}
{"7544": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPointOrigin ( PlaneGeneral3D_F64 plane , Point3D_F64 found ) { \nif ( found == null ) { \nfound = new Point3D_F64 ( ) ; \n} \ndouble n2 = plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ; \nfound . x = plane . A * plane . D / n2 ; \nfound . y = plane . B * plane . D / n2 ; \nfound . z = plane . C * plane . D / n2 ; \nreturn found ; \n} \n} \n"}
{"7549": "public class Quadrilateral_F64 { \npublic boolean isEquals ( Quadrilateral_F64 quad , double tol ) { \ntol *= tol ; \nif ( a . distance2 ( quad . a ) > tol ) { \nreturn false ; \n} \nif ( b . distance2 ( quad . b ) > tol ) { \nreturn false ; \n} \nif ( c . distance2 ( quad . c ) > tol ) { \nreturn false ; \n} \nreturn d . distance2 ( quad . d ) <= tol ; \n} \n} \n"}
{"7550": "public class UtilLine2D_F64 { \npublic static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { \ndouble la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; \ndouble lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; \ndouble value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; \nif ( value < - 1.0 ) { \nvalue = - 1.0 ; \n} \nelse if ( value > 1.0 ) { \nvalue = 1.0 ; \n} \nreturn Math . acos ( value ) ; \n} \n} \n"}
{"7551": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( LinePolar2D_F64 src , LineParametric2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineParametric2D_F64 ( ) ; \n} \ndouble c = ( double ) Math . cos ( src . angle ) ; \ndouble s = ( double ) Math . sin ( src . angle ) ; \nret . p . set ( c * src . distance , s * src . distance ) ; \nret . slope . set ( - s , c ) ; \nreturn ret ; \n} \n} \n"}
{"7552": "public class UtilLine2D_F64 { \npublic static LinePolar2D_F64 convert ( LineGeneral2D_F64 src , LinePolar2D_F64 ret ) { \nif ( ret == null ) { \nret = new LinePolar2D_F64 ( ) ; \n} \ndouble r = Math . sqrt ( src . A * src . A + src . B * src . B ) ; \ndouble sign = src . C < 0 ? - 1 : 1 ; \nret . angle = Math . atan2 ( - sign * src . B / r , - sign * src . A / r ) ; \nret . distance = sign * src . C / r ; \nreturn ret ; \n} \n} \n"}
{"7553": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( LineSegment2D_F64 src , LineParametric2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineParametric2D_F64 ( ) ; \n} \nret . p . set ( src . a ) ; \nret . slope . set ( src . slopeX ( ) , src . slopeY ( ) ) ; \nreturn ret ; \n} \n} \n"}
{"7555": "public class UtilLine2D_F64 { \npublic static LineGeneral2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineGeneral2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineGeneral2D_F64 ( ) ; \n} \nret . A = a . y - b . y ; \nret . B = b . x - a . x ; \nret . C = - ( ret . A * a . x + ret . B * a . y ) ; \nreturn ret ; \n} \n} \n"}
{"7556": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineParametric2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineParametric2D_F64 ( ) ; \n} \nret . p . set ( a ) ; \nret . slope . x = b . x - a . x ; \nret . slope . y = b . y - a . y ; \nreturn ret ; \n} \n} \n"}
{"7557": "public class UtilLine2D_F64 { \npublic static LinePolar2D_F64 convert ( LineParametric2D_F64 src , LinePolar2D_F64 ret ) { \nif ( ret == null ) { \nret = new LinePolar2D_F64 ( ) ; \n} \ndouble top = src . slope . y * src . p . x - src . slope . x * src . p . y ; \nret . distance = top / src . slope . norm ( ) ; \nret . angle = Math . atan2 ( - src . slope . x , src . slope . y ) ; \nif ( ret . distance < 0 ) { \nret . distance = - ret . distance ; \nret . angle = UtilAngle . bound ( ret . angle + Math . PI ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7560": "public class UtilPlane3D_F64 { \npublic static PlaneGeneral3D_F64 convert ( PlaneNormal3D_F64 input , PlaneGeneral3D_F64 output ) { \nif ( output == null ) { \noutput = new PlaneGeneral3D_F64 ( ) ; \n} \nVector3D_F64 n = input . n ; \nPoint3D_F64 p = input . p ; \noutput . A = n . x ; \noutput . B = n . y ; \noutput . C = n . z ; \noutput . D = n . x * p . x + n . y * p . y + n . z * p . z ; \nreturn output ; \n} \n} \n"}
{"7561": "public class UtilPlane3D_F64 { \npublic static PlaneNormal3D_F64 convert ( PlaneTangent3D_F64 input , PlaneNormal3D_F64 output ) { \nif ( output == null ) { \noutput = new PlaneNormal3D_F64 ( ) ; \n} \noutput . n . x = input . x ; \noutput . n . y = input . y ; \noutput . n . z = input . z ; \noutput . p . set ( input ) ; \nreturn output ; \n} \n} \n"}
{"7562": "public class UtilPlane3D_F64 { \npublic static PlaneNormal3D_F64 convert ( Se3_F64 planeToWorld , PlaneNormal3D_F64 output ) { \nif ( output == null ) { \noutput = new PlaneNormal3D_F64 ( ) ; \n} \noutput . n . x = planeToWorld . R . unsafe_get ( 0 , 2 ) ; \noutput . n . y = planeToWorld . R . unsafe_get ( 1 , 2 ) ; \noutput . n . z = planeToWorld . R . unsafe_get ( 2 , 2 ) ; \noutput . p . set ( planeToWorld . T . x , planeToWorld . T . y , planeToWorld . T . z ) ; \nreturn output ; \n} \n} \n"}
{"7564": "public class UtilPlane3D_F64 { \npublic static Se3_F64 planeToWorld ( PlaneGeneral3D_F64 plane , Se3_F64 planeToWorld ) { \nif ( planeToWorld == null ) { \nplaneToWorld = new Se3_F64 ( ) ; \n} \nVector3D_F64 axisZ = new Vector3D_F64 ( plane . A , plane . B , plane . C ) ; \naxisZ . normalize ( ) ; \nVector3D_F64 axisX = new Vector3D_F64 ( ) ; \nVector3D_F64 axisY = new Vector3D_F64 ( ) ; \nUtilPlane3D_F64 . selectAxis2D ( axisZ , axisX , axisY ) ; \nreturn planeToWorld ( plane , axisX , axisY , axisZ , planeToWorld ) ; \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) { \nreturn false ; \n} \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( diff > tol ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7570": "public class ParabolaGeneral_F64 { \npublic boolean isEquivalent ( ParabolaGeneral_F64 parabola , double tol ) { \ndouble scale = relativeScale ( parabola ) ; \nif ( Math . abs ( A * scale - parabola . A ) > tol ) { \nreturn false ; \n} \nif ( Math . abs ( C * scale - parabola . C ) > tol ) { \nreturn false ; \n} \nif ( Math . abs ( D * scale - parabola . D ) > tol ) { \nreturn false ; \n} \nif ( Math . abs ( E * scale - parabola . E ) > tol ) { \nreturn false ; \n} \nif ( Math . abs ( F * scale - parabola . F ) > tol ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"7571": "public class Box3D_F64 { \npublic Point3D_F64 center ( Point3D_F64 storage ) { \nif ( storage == null ) { \nstorage = new Point3D_F64 ( ) ; \n} \nstorage . x = ( p0 . x + p1 . x ) / 2.0 ; \nstorage . y = ( p0 . y + p1 . y ) / 2.0 ; \nstorage . z = ( p0 . z + p1 . z ) / 2.0 ; \nreturn storage ; \n} \n} \n"}
{"7576": "public class UtilVector2D_F64 { \npublic static Vector2D_F64 minus ( Point2D_F64 a , Point2D_F64 b , Vector2D_F64 output ) { \nif ( output == null ) { \noutput = new Vector2D_F64 ( ) ; \n} \noutput . x = a . x - b . x ; \noutput . y = a . y - b . y ; \nreturn output ; \n} \n} \n"}
{"7579": "public class UtilEllipse_F64 { \npublic static EllipseQuadratic_F64 convert ( EllipseRotated_F64 input , EllipseQuadratic_F64 output ) { \nif ( output == null ) { \noutput = new EllipseQuadratic_F64 ( ) ; \n} \ndouble x0 = input . center . x ; \ndouble y0 = input . center . y ; \ndouble a = input . a ; \ndouble b = input . b ; \ndouble phi = input . phi ; \ndouble cphi = Math . cos ( phi ) ; \ndouble sphi = Math . sin ( phi ) ; \ndouble cphi2 = cphi * cphi ; \ndouble sphi2 = sphi * sphi ; \ndouble a2 = a * a ; \ndouble b2 = b * b ; \ndouble x02 = x0 * x0 ; \ndouble y02 = y0 * y0 ; \noutput . A = cphi2 / a2 + sphi2 / b2 ; \noutput . B = sphi * cphi / a2 - sphi * cphi / b2 ; \noutput . C = sphi2 / a2 + cphi2 / b2 ; \noutput . D = - x0 * cphi2 / a2 - y0 * sphi * cphi / a2 - x0 * sphi2 / b2 + y0 * sphi * cphi / b2 ; \noutput . E = - x0 * sphi * cphi / a2 - y0 * sphi2 / a2 + x0 * sphi * cphi / b2 - y0 * cphi2 / b2 ; \noutput . F = x02 * cphi2 / a2 + 2 * x0 * y0 * sphi * cphi / a2 + y02 * sphi2 / a2 + x02 * sphi2 / b2 - 2 * x0 * y0 * sphi * cphi / b2 + y02 * cphi2 / b2 - 1 ; \nreturn output ; \n} \n} \n"}
{"7580": "public class UtilEllipse_F64 { \npublic static Point2D_F64 computePoint ( double t , EllipseRotated_F64 ellipse , Point2D_F64 output ) { \nif ( output == null ) { \noutput = new Point2D_F64 ( ) ; \n} \ndouble ct = Math . cos ( t ) ; \ndouble st = Math . sin ( t ) ; \ndouble cphi = Math . cos ( ellipse . phi ) ; \ndouble sphi = Math . sin ( ellipse . phi ) ; \ndouble x = ellipse . a * ct ; \ndouble y = ellipse . b * st ; \noutput . x = ellipse . center . x + x * cphi - y * sphi ; \noutput . y = ellipse . center . y + x * sphi + y * cphi ; \nreturn output ; \n} \n} \n"}
{"7582": "public class UtilEllipse_F64 { \npublic static Vector2D_F64 computeTangent ( double t , EllipseRotated_F64 ellipse , Vector2D_F64 output ) { \nif ( output == null ) { \noutput = new Vector2D_F64 ( ) ; \n} \ndouble ct = Math . cos ( t ) ; \ndouble st = Math . sin ( t ) ; \ndouble cphi = Math . cos ( ellipse . phi ) ; \ndouble sphi = Math . sin ( ellipse . phi ) ; \ndouble x = ellipse . a * ct * ellipse . b * ellipse . b ; \ndouble y = ellipse . b * st * ellipse . a * ellipse . a ; \ndouble rx = x * cphi - y * sphi ; \ndouble ry = x * sphi + y * cphi ; \ndouble r = Math . sqrt ( rx * rx + ry * ry ) ; \noutput . x = - ry / r ; \noutput . y = rx / r ; \nreturn output ; \n} \n} \n"}
{"7583": "public class TangentLinesTwoEllipses_F64 { \nboolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , EllipseRotated_F64 ellipse , Point2D_F64 tangent , boolean cross ) { \nif ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) { \nreturn false ; \n} \ntempLine . a = a ; \ntempLine . b = temp0 ; \nboolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \ntempLine . b = temp1 ; \nboolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \nif ( crossed0 == crossed1 ) { \nthrow new RuntimeException ( \"Well this didn't work\" ) ; \n} \nif ( cross == crossed0 ) { \nsumDifference += previousTangent . distance2 ( temp0 ) ; \ntangent . set ( temp0 ) ; \n} \nelse { \nsumDifference += previousTangent . distance2 ( temp1 ) ; \ntangent . set ( temp1 ) ; \n} \nreturn true ; \n} \n} \n"}
{"7584": "public class BoxLength3D_F64 { \npublic Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { \nif ( corner == null ) { \ncorner = new Point3D_F64 ( ) ; \n} \ncorner . set ( p ) ; \nif ( ( index & 0x01 ) != 0 ) { \ncorner . x += lengthX ; \n} \nif ( ( index & 0x02 ) != 0 ) { \ncorner . y += lengthY ; \n} \nif ( ( index & 0x04 ) != 0 ) { \ncorner . z += lengthZ ; \n} \nreturn corner ; \n} \n} \n"}
{"7585": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { \ndouble x = l0 . p . x - l1 . p . x ; \ndouble y = l0 . p . y - l1 . p . y ; \ndouble z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \ndouble t0 ; \nif ( bottom == 0 ) { \nt0 = 0 ; \n} \nelse { \nt0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; \n} \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \ndouble dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; \ndouble dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; \ndouble dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; \ndouble distanceSq = dx * dx + dy * dy + dz * dz ; \nif ( distanceSq < 0 ) { \nreturn 0 ; \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) { \nreturn p . distance ( l . a ) ; \n} \nelse if ( d >= n ) { \nreturn p . distance ( l . b ) ; \n} \ndouble distanceSq = cc - d * d ; \nif ( distanceSq < 0 ) { \nreturn 0 ; \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7591": "public class Distance2D_F64 { \npublic static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { \ndouble slopeAX = segmentA . slopeX ( ) ; \ndouble slopeAY = segmentA . slopeY ( ) ; \ndouble slopeBX = segmentB . slopeX ( ) ; \ndouble slopeBY = segmentB . slopeY ( ) ; \ndouble ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; \ndouble bottom = slopeBY * slopeAX - slopeAY * slopeBX ; \nif ( bottom != 0 ) { \nta /= bottom ; \nif ( ta >= 0 && ta <= 1.0 ) { \ndouble tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; \ntb /= slopeAY * slopeBX - slopeBY * slopeAX ; \nif ( tb >= 0 && tb <= 1.0 ) { \nreturn 0 ; \n} \n} \n} \ndouble closest = Double . MAX_VALUE ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; \nreturn closest ; \n} \n} \n"}
{"7595": "public class Distance2D_F64 { \npublic static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { \nif ( storage == null ) { \nstorage = LineSegment2D_F64 . wrap ( null , null ) ; \n} \ndouble minimum = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < poly . size ( ) ; \ni ++ ) { \nint j = ( i + 1 ) % poly . size ( ) ; \nstorage . a = poly . vertexes . data [ i ] ; \nstorage . b = poly . vertexes . data [ j ] ; \ndouble d = distanceSq ( storage , p ) ; \nif ( d < minimum ) { \nminimum = d ; \n} \n} \nreturn minimum ; \n} \n} \n"}
{"7600": "public class ClosestPoint2D_F64 { \npublic static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { \nif ( output == null ) { \noutput = new Point2D_F64 ( ) ; \n} \ndouble slopeX = line . b . x - line . a . x ; \ndouble slopeY = line . b . y - line . a . y ; \ndouble t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; \nt /= slopeX * slopeX + slopeY * slopeY ; \nif ( t < 0 ) { \nt = 0 ; \n} \nelse if ( t > 1 ) { \nt = 1 ; \n} \noutput . x = line . a . x + slopeX * t ; \noutput . y = line . a . y + slopeY * t ; \nreturn output ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \ni < end ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nj < numCoefs ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) { \nreturn false ; \n} \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \ni < numCoefs ; \ni ++ ) { \noutput . set ( i , x . data [ i ] ) ; \n} \nreturn true ; \n} \n} \n"}
{"7604": "public class UtilVector3D_F64 { \npublic static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { \nif ( output == null ) { \noutput = new Vector3D_F64 ( ) ; \n} \ndouble scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; \nif ( scale == 0 ) { \noutput . set ( 0 , 0 , 0 ) ; \n} \nelse { \ndouble x = A . x / scale ; \ndouble y = A . y / scale ; \ndouble z = A . z / scale ; \nif ( Math . abs ( x ) > Math . abs ( y ) ) { \noutput . set ( z , 0 , - x ) ; \n} \nelse { \noutput . set ( 0 , z , - y ) ; \n} \n} \nreturn output ; \n} \n} \n"}
{"7605": "public class UtilVector3D_F64 { \npublic static boolean isIdentical ( Vector3D_F64 a , Vector3D_F64 b , double tol ) { \nif ( Math . abs ( a . x - b . x ) > tol ) { \nreturn false ; \n} \nif ( Math . abs ( a . y - b . y ) > tol ) { \nreturn false ; \n} \nreturn Math . abs ( a . z - b . z ) <= tol ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) { \nmean = new Point2D_F64 ( ) ; \n} \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \n} \nx /= length ; \ny /= length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7618": "public class UtilPolygons2D_I32 { \npublic static boolean isConvex ( Polygon2D_I32 poly ) { \nfinal int N = poly . size ( ) ; \nint numPositive = 0 ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nint j = ( i + 1 ) % N ; \nint k = ( i + 2 ) % N ; \nPoint2D_I32 a = poly . vertexes . data [ i ] ; \nPoint2D_I32 b = poly . vertexes . data [ j ] ; \nPoint2D_I32 c = poly . vertexes . data [ k ] ; \nint dx0 = a . x - b . x ; \nint dy0 = a . y - b . y ; \nint dx1 = c . x - b . x ; \nint dy1 = c . y - b . y ; \nint z = dx0 * dy1 - dy0 * dx1 ; \nif ( z > 0 ) { \nnumPositive ++ ; \n} \n} \nreturn ( numPositive == 0 || numPositive == N ) ; \n} \n} \n"}
{"7620": "public class GeoTuple4D_F64 { \npublic double maxAbs ( ) { \ndouble absX = Math . abs ( x ) ; \ndouble absY = Math . abs ( y ) ; \ndouble absZ = Math . abs ( z ) ; \ndouble absW = Math . abs ( w ) ; \ndouble found = Math . max ( absX , absY ) ; \nif ( found < absZ ) { \nfound = absZ ; \n} \nif ( found < absW ) { \nfound = absW ; \n} \nreturn found ; \n} \n} \n"}
{"7626": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , Point3D_F64 mean ) { \nif ( mean == null ) { \nmean = new Point3D_F64 ( ) ; \n} \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( Point3D_F64 p : points ) { \nx += p . x ; \ny += p . y ; \nz += p . z ; \n} \nmean . x = x / points . size ( ) ; \nmean . y = y / points . size ( ) ; \nmean . z = z / points . size ( ) ; \nreturn mean ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) { \nmean = new Point3D_F64 ( ) ; \n} \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nx += p . x ; \ny += p . y ; \nz += p . z ; \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7661": "public class StdRandom { \npublic static int uniform ( int a , int b ) { \nif ( b <= a ) { \nthrow new IllegalArgumentException ( \"Invalid range\" ) ; \n} \nif ( ( long ) b - a >= Integer . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"Invalid range\" ) ; \n} \nreturn a + uniform ( b - a ) ; \n} \n} \n"}
{"7662": "public class StdRandom { \npublic static double uniform ( double a , double b ) { \nif ( ! ( a < b ) ) { \nthrow new IllegalArgumentException ( \"Invalid range\" ) ; \n} \nreturn a + uniform ( ) * ( b - a ) ; \n} \n} \n"}
{"7663": "public class StdRandom { \npublic static int poisson ( double lambda ) { \nif ( ! ( lambda > 0.0 ) ) { \nthrow new IllegalArgumentException ( \"Parameter lambda must be positive\" ) ; \n} \nif ( Double . isInfinite ( lambda ) ) { \nthrow new IllegalArgumentException ( \"Parameter lambda must not be infinite\" ) ; \n} \nint k = 0 ; \ndouble p = 1.0 ; \ndouble L = Math . exp ( - lambda ) ; \ndo { \nk ++ ; \np *= uniform ( ) ; \n} \nwhile ( p >= L ) ; \nreturn k - 1 ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) { \nthrow new NullPointerException ( \"argument array is null\" ) ; \n} \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nif ( ! ( a [ i ] >= 0.0 ) ) { \nthrow new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \n} \nsum = sum + a [ i ] ; \n} \nif ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) { \nthrow new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \n} \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) { \nreturn i ; \n} \n} \n} \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) { \nStdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \n} \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \n} \n} \n"}
{"7668": "public class FileAssetServlet { \nprivate String fixPath ( String path ) { \nif ( ! path . isEmpty ( ) ) { \nif ( ! path . endsWith ( \"/\" ) ) { \nreturn path + '/' ; \n} \nelse { \nreturn path ; \n} \n} \nelse { \nreturn path ; \n} \n} \n} \n"}
{"7670": "public class TokenBasedAuthResponseFilter { \npublic static String getTokenSentence ( BasicToken token ) throws Exception { \nif ( token == null ) { \nreturn tokenKey + \"=\" + cookieSentence ; \n} \nString sentence = tokenKey + \"=\" + token . getTokenString ( ) + cookieSentence ; \nreturn sentence ; \n} \n} \n"}
{"7677": "public class JobInfoProvider { \npublic static Trigger convert2Trigger ( TriggerInfo trig , JobInfo job ) { \nTriggerBuilder < Trigger > builder = newTrigger ( ) ; \nbuilder . withIdentity ( trig . getName ( ) , trig . getGroup ( ) ) ; \nbuilder . forJob ( job . getName ( ) , job . getGroup ( ) ) ; \nswitch ( trig . getType ( ) ) { \ncase CRON : setStartEndTime ( trig , builder ) ; \nif ( ! trig . getCron ( ) . isEmpty ( ) ) { \nbuilder . withSchedule ( CronScheduleBuilder . cronSchedule ( trig . getCron ( ) ) ) ; \n} \nbreak ; \ncase SIMPLE : setStartEndTime ( trig , builder ) ; \nsetCountIntervalValues ( trig , builder ) ; \nbreak ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"7678": "public class JobInfoProvider { \nprivate static void setCountIntervalValues ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nSimpleScheduleBuilder builderSc = SimpleScheduleBuilder . simpleSchedule ( ) ; \nif ( dto . getRepeatCount ( ) != 0 ) { \nbuilderSc . withRepeatCount ( dto . getRepeatCount ( ) ) ; \n} \nif ( dto . getRepeatInterval ( ) > 0 ) { \nbuilderSc . withIntervalInMilliseconds ( dto . getRepeatInterval ( ) ) ; \n} \nbuilder . withSchedule ( builderSc ) ; \n} \n} \n"}
{"7679": "public class JobInfoProvider { \nprivate static void setStartEndTime ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nif ( dto . getStartTime ( ) > - 1 ) { \nbuilder . startAt ( new Date ( dto . getStartTime ( ) ) ) ; \n} \nelse { \nbuilder . startNow ( ) ; \n} \nif ( dto . getEndTime ( ) > - 1 ) { \nbuilder . endAt ( new Date ( dto . getEndTime ( ) ) ) ; \n} \n} \n} \n"}
{"7696": "public class SearchFactory { \n@ Override public SearchModel provide ( ) { \nSearchModel searchModel = new SearchModel ( ) ; \nsearchModel . setResponse ( response ) ; \nString method = getMethod ( ) ; \nif ( \"GET\" . equals ( method ) ) { \nMultivaluedMap < String , String > queryParameters = getUriInfo ( ) . getQueryParameters ( ) ; \nfor ( Map . Entry < String , List < String > > param : queryParameters . entrySet ( ) ) { \nif ( param . getValue ( ) . get ( 0 ) == null ) { \ncontinue ; \n} \nif ( \"_q\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setQ ( param . getValue ( ) . get ( 0 ) ) ; \n} \nelse if ( \"_limit\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setLimit ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse if ( \"_offset\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setOffset ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse if ( \"_fields\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setFields ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse if ( \"_sort\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setSort ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse if ( \"_filter\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setFilterExpression ( param . getValue ( ) . get ( 0 ) ) ; \n} \n} \n} \nreturn searchModel ; \n} \n} \n"}
{"7700": "public class Query { \npublic static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { \nif ( Validations . isEmptyOrNull ( name ) ) { \nreturn null ; \n} \nString [ ] names = name . split ( \"\\\\.\" ) ; \nString currentName ; \nint step = 0 ; \nCriteriaParent < E > currentCriteria = criteria ; \nFieldMeta currentFieldMeta ; \nStringJoiner aliasJoiner = new StringJoiner ( \"$\" ) ; \ndo { \ncurrentName = names [ step ] ; \nif ( Validations . isEmptyOrNull ( currentName ) ) { \nthrow new RuntimeException ( currentName + \" defined name is wrong ! \" ) ; \n} \ncurrentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; \nstep ++ ; \naliasJoiner . add ( currentCriteria . getAlias ( ) ) ; \nif ( step >= names . length ) { \nbreak ; \n} \nif ( currentFieldMeta . getReference ( ) == null ) { \nthrow new RuntimeException ( \"\" + currentName + \" join field of \" + name + \"'s reference target information must defined ! \" ) ; \n} \nCriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; \nif ( criteriaJoin == null ) { \ncurrentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; \n} \ncurrentCriteria = criteriaJoin ; \n} \nwhile ( step >= names . length ) ; \nHolder < E > holder = new Holder < > ( ) ; \nholder . currentFieldName = currentName ; \nholder . currentCriteria = currentCriteria ; \nholder . currentFieldMeta = currentFieldMeta ; \nreturn holder ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( int i = 1 ; \ni < stack . length ; \ni ++ ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) { \nbreak ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7880": "public class JSPContextFinder { \nprivate boolean checkClassLoader ( ClassLoader classloader ) { \nif ( classloader == null || classloader == getParent ( ) ) { \nreturn false ; \n} \nfor ( ClassLoader parent = classloader . getParent ( ) ; \nparent != null ; \nparent = parent . getParent ( ) ) { \nif ( parent == this ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7881": "public class JSPContextFinder { \nprivate boolean startLoading ( String name ) { \nSet classesAndResources = ( Set ) cycleDetector . get ( ) ; \nif ( classesAndResources != null && classesAndResources . contains ( name ) ) { \nreturn false ; \n} \nif ( classesAndResources == null ) { \nclassesAndResources = new HashSet ( 3 ) ; \ncycleDetector . set ( classesAndResources ) ; \n} \nclassesAndResources . add ( name ) ; \nreturn true ; \n} \n} \n"}
{"7891": "public class SeekableXZInputStream { \npublic void seekToBlock ( int blockNumber ) throws IOException { \nif ( in == null ) { \nthrow new XZIOException ( \"Stream closed\" ) ; \n} \nif ( blockNumber < 0 || blockNumber >= blockCount ) { \nthrow new XZIOException ( \"Invalid XZ Block number: \" + blockNumber ) ; \n} \nseekPos = getBlockPos ( blockNumber ) ; \nseekNeeded = true ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 || pos >= uncompressedSize ) { \nthrow new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \n} \nIndexDecoder index ; \nfor ( int i = 0 ; \n; \n++ i ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) { \nbreak ; \n} \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) { \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nopts [ optCur ] . state . updateMatch ( ) ; \n} \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) { \nopts [ optCur ] . state . updateShortRep ( ) ; \n} \nelse { \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) { \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nopts [ optCur ] . state . updateMatch ( ) ; \n} \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nrep <= back ; \n++ rep ) { \nopts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \n} \nfor ( ; \nrep < REPS ; \n++ rep ) { \nopts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nwhile ( optEnd < i ) { \nopts [ ++ optEnd ] . reset ( ) ; \n} \nif ( price < opts [ i ] . price ) { \nopts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \nfor ( int rep = 0 ; \nrep < REPS ; \n++ rep ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) { \ncontinue ; \n} \nwhile ( optEnd < optCur + len ) { \nopts [ ++ optEnd ] . reset ( ) ; \n} \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( int i = len ; \ni >= MATCH_LEN_MIN ; \n-- i ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) { \nopts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \n} \nif ( rep == 0 ) { \nstartLen = len + 1 ; \n} \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) { \nopts [ ++ optEnd ] . reset ( ) ; \n} \nif ( price < opts [ i ] . price ) { \nopts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) { \n++ matches . count ; \n} \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) { \nreturn ; \n} \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) { \nopts [ ++ optEnd ] . reset ( ) ; \n} \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( startLen > matches . len [ match ] ) { \n++ match ; \n} \nfor ( int len = startLen ; \n; \n++ len ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) { \nopts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \n} \nif ( len != matches . len [ match ] ) { \ncontinue ; \n} \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) { \nopts [ ++ optEnd ] . reset ( ) ; \n} \nif ( price < opts [ i ] . price ) { \nopts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \n} \nif ( ++ match == matches . count ) { \nbreak ; \n} \n} \n} \n} \n"}
{"7908": "public class JspRuntimeContext { \nprivate void initClassPath ( ) { \nStringBuilder cpath = new StringBuilder ( ) ; \nString sep = System . getProperty ( \"path.separator\" ) ; \ncpath . append ( options . getScratchDir ( ) + sep ) ; \nString cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; \nif ( cp == null || cp . equals ( \"\" ) ) { \ncp = options . getClassPath ( ) ; \n} \nif ( cp != null ) { \nclasspath = cpath . toString ( ) + cp ; \n} \nif ( classpath != null ) { \ntry { \nclasspath = URLDecoder . decode ( classpath , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nif ( log . isLoggable ( Level . FINE ) ) { \nlog . log ( Level . FINE , \"Exception decoding classpath : \" + classpath , e ) ; \n} \n} \n} \n} \n} \n"}
{"7922": "public class TreeNode { \npublic void addAttribute ( String name , String value ) { \nif ( attributes == null ) { \nattributes = new HashMap < String , String > ( ) ; \n} \nattributes . put ( name , value ) ; \n} \n} \n"}
{"7923": "public class TreeNode { \npublic void addChild ( TreeNode node ) { \nif ( children == null ) { \nchildren = new ArrayList < TreeNode > ( ) ; \n} \nchildren . add ( node ) ; \n} \n} \n"}
{"7924": "public class TreeNode { \npublic Iterator < String > findAttributes ( ) { \nSet < String > attrs ; \nif ( attributes == null ) { \nattrs = Collections . emptySet ( ) ; \n} \nelse { \nattrs = attributes . keySet ( ) ; \n} \nreturn attrs . iterator ( ) ; \n} \n} \n"}
{"7925": "public class TreeNode { \npublic Iterator < TreeNode > findChildren ( ) { \nList < TreeNode > nodes ; \nif ( children == null ) { \nnodes = Collections . emptyList ( ) ; \n} \nelse { \nnodes = children ; \n} \nreturn nodes . iterator ( ) ; \n} \n} \n"}
{"7926": "public class TreeNode { \npublic Iterator < TreeNode > findChildren ( String name ) { \nList < TreeNode > results ; \nif ( children == null ) { \nresults = Collections . emptyList ( ) ; \n} \nelse { \nresults = new ArrayList < TreeNode > ( ) ; \nfor ( TreeNode item : children ) { \nif ( name . equals ( item . getName ( ) ) ) { \nresults . add ( item ) ; \n} \n} \n} \nreturn results . iterator ( ) ; \n} \n} \n"}
{"7928": "public class JspContextWrapper { \nprivate String findAlias ( String varName ) { \nif ( aliases == null ) { \nreturn varName ; \n} \nString alias = aliases . get ( varName ) ; \nif ( alias == null ) { \nreturn varName ; \n} \nreturn alias ; \n} \n} \n"}
{"7947": "public class LZMAEncoder { \npublic boolean encodeForLZMA2 ( ) { \ntry { \nif ( ! lz . isStarted ( ) && ! encodeInit ( ) ) { \nreturn false ; \n} \nwhile ( uncompressedSize <= LZMA2_UNCOMPRESSED_LIMIT && rc . getPendingSize ( ) <= LZMA2_COMPRESSED_LIMIT ) { \nif ( ! encodeSymbol ( ) ) { \nreturn false ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new Error ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"7951": "public class LZMAOutputStream { \npublic void finish ( ) throws IOException { \nif ( ! finished ) { \nif ( exception != null ) { \nthrow exception ; \n} \ntry { \nif ( expectedUncompressedSize != - 1 && expectedUncompressedSize != currentUncompressedSize ) { \nthrow new XZIOException ( \"Expected uncompressed size (\" + expectedUncompressedSize + \") doesn't equal \" + \"the number of bytes written to the stream (\" + currentUncompressedSize + \")\" ) ; \n} \nlz . setFinishing ( ) ; \nlzma . encodeForLZMA1 ( ) ; \nif ( useEndMarker ) { \nlzma . encodeLZMA1EndMarker ( ) ; \n} \nrc . finish ( ) ; \n} \ncatch ( IOException e ) { \nexception = e ; \nthrow e ; \n} \nfinished = true ; \nlzma . putArraysToCache ( arrayCache ) ; \nlzma = null ; \nlz = null ; \n} \n} \n} \n"}
{"7964": "public class HC4 { \nprivate int movePos ( ) { \nint avail = movePos ( 4 , 4 ) ; \nif ( avail != 0 ) { \nif ( ++ lzPos == Integer . MAX_VALUE ) { \nint normalizationOffset = Integer . MAX_VALUE - cyclicSize ; \nhash . normalize ( normalizationOffset ) ; \nnormalize ( chain , cyclicSize , normalizationOffset ) ; \nlzPos -= normalizationOffset ; \n} \nif ( ++ cyclicPos == cyclicSize ) { \ncyclicPos = 0 ; \n} \n} \nreturn avail ; \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) { \nnextChar ( ) ; \n} \nelse { \nreset ( restart ) ; \ncontinue skip ; \n} \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) { \nnextChar ( ) ; \n} \nelse { \ncontinue skip ; \n} \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7969": "public class JspReader { \nMark skipUntilETag ( String tag ) throws JasperException { \nMark ret = skipUntil ( \"</\" + tag ) ; \nif ( ret != null ) { \nskipSpaces ( ) ; \nif ( nextChar ( ) != '>' ) { \nret = null ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nint ch = peekChar ( ) ; \nif ( quoted ) { \nif ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) { \nch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \nelse { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \n} \nelse { \nif ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) { \nch = nextChar ( ) ; \n} \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) { \ncontinue ; \n} \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) { \ntreeNode . setBody ( body ) ; \n} \n} \n} \nelse { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7984": "public class BasicArrayCache { \npublic byte [ ] getByteArray ( int size , boolean fillWithZeros ) { \nbyte [ ] array = getArray ( byteArrayCache , size ) ; \nif ( array == null ) { \narray = new byte [ size ] ; \n} \nelse if ( fillWithZeros ) { \nArrays . fill ( array , ( byte ) 0x00 ) ; \n} \nreturn array ; \n} \n} \n"}
{"7985": "public class BasicArrayCache { \npublic int [ ] getIntArray ( int size , boolean fillWithZeros ) { \nint [ ] array = getArray ( intArrayCache , size ) ; \nif ( array == null ) { \narray = new int [ size ] ; \n} \nelse if ( fillWithZeros ) { \nArrays . fill ( array , 0 ) ; \n} \nreturn array ; \n} \n} \n"}
{"7988": "public class TagLibraryInfoImpl { \npublic ValidationMessage [ ] validate ( PageData thePage ) { \nTagLibraryValidator tlv = getTagLibraryValidator ( ) ; \nif ( tlv == null ) { \nreturn null ; \n} \nString uri = getURI ( ) ; \nif ( uri . startsWith ( \"/\" ) ) { \nuri = URN_JSPTLD + uri ; \n} \nValidationMessage [ ] messages = tlv . validate ( getPrefixString ( ) , uri , thePage ) ; \ntlv . release ( ) ; \nreturn messages ; \n} \n} \n"}
{"7993": "public class JspCServletContext { \npublic String getRealPath ( String path ) { \nif ( ! myResourceBaseURL . getProtocol ( ) . equals ( \"file\" ) ) { \nreturn ( null ) ; \n} \nif ( ! path . startsWith ( \"/\" ) ) { \nreturn ( null ) ; \n} \ntry { \nreturn ( getResource ( path ) . getFile ( ) . replace ( '/' , File . separatorChar ) ) ; \n} \ncatch ( Throwable t ) { \nreturn ( null ) ; \n} \n} \n} \n"}
{"7994": "public class JspCServletContext { \npublic URL getResource ( String path ) throws MalformedURLException { \nif ( ! path . startsWith ( \"/\" ) ) { \nthrow new MalformedURLException ( \"Path '\" + path + \"' does not start with '/'\" ) ; \n} \nURL url = new URL ( myResourceBaseURL , path . substring ( 1 ) ) ; \nInputStream is = null ; \ntry { \nis = url . openStream ( ) ; \n} \ncatch ( Throwable t ) { \nurl = null ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t2 ) { \n} \n} \n} \nreturn url ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) { \npath += \"/\" ; \n} \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) { \nreturn ( thePaths ) ; \n} \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) { \nreturn ( thePaths ) ; \n} \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) { \nthePaths . add ( path + theFiles [ i ] ) ; \n} \nelse if ( testFile . isDirectory ( ) ) { \nthePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8003": "public class LZEncoder { \npublic int fillWindow ( byte [ ] in , int off , int len ) { \nassert ! finishing ; \nif ( readPos >= bufSize - keepSizeAfter ) { \nmoveWindow ( ) ; \n} \nif ( len > bufSize - writePos ) { \nlen = bufSize - writePos ; \n} \nSystem . arraycopy ( in , off , buf , writePos , len ) ; \nwritePos += len ; \nif ( writePos >= keepSizeAfter ) { \nreadLimit = writePos - keepSizeAfter ; \n} \nprocessPendingBytes ( ) ; \nreturn len ; \n} \n} \n"}
{"8005": "public class LZEncoder { \npublic int getMatchLen ( int dist , int lenLimit ) { \nint backPos = readPos - dist - 1 ; \nint len = 0 ; \nwhile ( len < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ) { \n++ len ; \n} \nreturn len ; \n} \n} \n"}
{"8006": "public class LZEncoder { \npublic int getMatchLen ( int forward , int dist , int lenLimit ) { \nint curPos = readPos + forward ; \nint backPos = curPos - dist - 1 ; \nint len = 0 ; \nwhile ( len < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ) { \n++ len ; \n} \nreturn len ; \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nint lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \nfor ( int i = 0 ; \ni < matches . count ; \n++ i ) { \nif ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8010": "public class JspWriterImpl { \nprotected final void flushBuffer ( ) throws IOException { \nif ( bufferSize == 0 ) { \nreturn ; \n} \nflushed = true ; \nensureOpen ( ) ; \nif ( buf . pos == buf . offset ) { \nreturn ; \n} \ninitOut ( ) ; \nout . write ( buf . buf , buf . offset , buf . pos - buf . offset ) ; \nbuf . pos = buf . offset ; \n} \n} \n"}
{"8011": "public class JspWriterImpl { \npublic final void clear ( ) throws IOException { \nif ( ( bufferSize == 0 ) && ( out != null ) ) { \nthrow new IllegalStateException ( getLocalizeMessage ( \"jsp.error.ise_on_clear\" ) ) ; \n} \nif ( flushed ) { \nthrow new IOException ( getLocalizeMessage ( \"jsp.error.attempt_to_clear_flushed_buffer\" ) ) ; \n} \nensureOpen ( ) ; \nif ( buf != null ) { \nbuf . pos = buf . offset ; \n} \n} \n} \n"}
{"8013": "public class JspWriterImpl { \npublic void close ( ) throws IOException { \nif ( response == null || closed ) { \nreturn ; \n} \nflush ( ) ; \nif ( out != null ) { \nout . close ( ) ; \n} \nout = null ; \nbyteOut = null ; \nclosed = true ; \n} \n} \n"}
{"8015": "public class JspWriterImpl { \nprivate void allocateCharBuffer ( ) { \nif ( bufferSize == 0 ) { \nreturn ; \n} \nif ( bufferSize > MAX_BUFFER_SIZE ) { \nbuf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; \n} \nelse { \nbuf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; \n} \n} \n} \n"}
{"8020": "public class Compiler { \npublic void removeGeneratedFiles ( ) { \ntry { \nString classFileName = ctxt . getClassFileName ( ) ; \nif ( classFileName != null ) { \nFile classFile = new File ( classFileName ) ; \nif ( log . isLoggable ( Level . FINE ) ) { \nlog . fine ( \"Deleting \" + classFile ) ; \n} \nclassFile . delete ( ) ; \n} \n} \ncatch ( Exception e ) { \n} \ntry { \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nif ( javaFileName != null ) { \nFile javaFile = new File ( javaFileName ) ; \nif ( log . isLoggable ( Level . FINE ) ) { \nlog . fine ( \"Deleting \" + javaFile ) ; \n} \njavaFile . delete ( ) ; \n} \n} \ncatch ( Exception e ) { \n} \n} \n} \n"}
{"8023": "public class Generator { \nstatic String quote ( char c ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( '\\'' ) ; \nif ( c == '\\'' ) { \nb . append ( '\\\\' ) . append ( '\\'' ) ; \n} \nelse if ( c == '\\\\' ) { \nb . append ( '\\\\' ) . append ( '\\\\' ) ; \n} \nelse if ( c == '\\n' ) { \nb . append ( '\\\\' ) . append ( 'n' ) ; \n} \nelse if ( c == '\\r' ) { \nb . append ( '\\\\' ) . append ( 'r' ) ; \n} \nelse { \nb . append ( c ) ; \n} \nb . append ( '\\'' ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"8024": "public class Generator { \nprivate void generateDeclarations ( Node . Nodes page ) throws JasperException { \nclass DeclarationVisitor extends Node . Visitor { \nprivate boolean getServletInfoGenerated = false ; \npublic void visit ( Node . PageDirective n ) throws JasperException { \nif ( getServletInfoGenerated ) { \nreturn ; \n} \nString info = n . getAttributeValue ( \"info\" ) ; \nif ( info == null ) { \nreturn ; \n} \ngetServletInfoGenerated = true ; \nout . printil ( \"public String getServletInfo() {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return \" ) ; \nout . print ( quote ( info ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \npublic void visit ( Node . Declaration n ) throws JasperException { \nn . setBeginJavaLine ( out . getJavaLine ( ) ) ; \nout . printMultiLn ( n . getText ( ) ) ; \nout . println ( ) ; \nn . setEndJavaLine ( out . getJavaLine ( ) ) ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( n . useTagPlugin ( ) ) { \nif ( n . getAtSTag ( ) != null ) { \nn . getAtSTag ( ) . visit ( this ) ; \n} \nvisitBody ( n ) ; \nif ( n . getAtETag ( ) != null ) { \nn . getAtETag ( ) . visit ( this ) ; \n} \n} \nelse { \nvisitBody ( n ) ; \n} \n} \n} \nout . println ( ) ; \npage . visit ( new DeclarationVisitor ( ) ) ; \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) { \ncontinue ; \n} \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \ni < errors . length ; \ni ++ ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) { \nfor ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) { \nwriter . print ( chars [ i ++ ] ) ; \n} \n} \n} \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse if ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse if ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse if ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse if ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8057": "public class MetadataCache { \npublic boolean put ( Locator locator , String key , String value ) throws CacheException { \nif ( value == null ) { \nreturn false ; \n} \nTimer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; \nboolean dbWrite = false ; \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nString oldValue = cache . getIfPresent ( cacheKey ) ; \ncache . put ( cacheKey , value ) ; \nif ( oldValue == null || ! oldValue . equals ( value ) ) { \ndbWrite = true ; \n} \nif ( dbWrite ) { \nupdatedMetricMeter . mark ( ) ; \nif ( ! batchedWrites ) { \ndatabasePut ( locator , key , value ) ; \n} \nelse { \ndatabaseLazyWrite ( locator , key ) ; \n} \n} \nreturn dbWrite ; \n} \nfinally { \ncachePutTimerContext . stop ( ) ; \n} \n} \n} \n"}
{"8058": "public class MetadataCache { \nprivate String databaseLoad ( Locator locator , String key ) throws CacheException { \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nMap < String , String > metadata = io . getAllValues ( locator ) ; \nif ( metadata == null || metadata . isEmpty ( ) ) { \ncache . put ( cacheKey , NULL ) ; \nreturn NULL ; \n} \nint metadataRowSize = 0 ; \nfor ( Map . Entry < String , String > meta : metadata . entrySet ( ) ) { \nmetadataRowSize += meta . getKey ( ) . getBytes ( ) . length + locator . toString ( ) . getBytes ( ) . length ; \nif ( meta . getValue ( ) != null ) { \nmetadataRowSize += meta . getValue ( ) . getBytes ( ) . length ; \n} \nif ( meta . getKey ( ) . equals ( key ) ) { \ncontinue ; \n} \nCacheKey metaKey = new CacheKey ( locator , meta . getKey ( ) ) ; \ncache . put ( metaKey , meta . getValue ( ) ) ; \n} \ntotalMetadataSize . update ( metadataRowSize ) ; \nString value = metadata . get ( key ) ; \nif ( value == null ) { \ncache . put ( cacheKey , NULL ) ; \nvalue = NULL ; \n} \nreturn value ; \n} \ncatch ( IOException ex ) { \nthrow new CacheException ( ex ) ; \n} \n} \n} \n"}
{"8066": "public class AbstractSerDes { \nprotected Number getUnversionedDoubleOrLong ( CodedInputStream in ) throws IOException { \nbyte type = in . readRawByte ( ) ; \nif ( type == Constants . B_DOUBLE ) { \nreturn in . readDouble ( ) ; \n} \nelse { \nreturn in . readRawVarint64 ( ) ; \n} \n} \n} \n"}
{"8083": "public class ConfigTtlProvider { \nprivate boolean put ( ImmutableTable . Builder < Granularity , RollupType , TimeValue > ttlMapBuilder , Configuration config , Granularity gran , RollupType rollupType , TtlConfig configKey ) { \nint value ; \ntry { \nvalue = config . getIntegerProperty ( configKey ) ; \nif ( value < 0 ) { \nreturn false ; \n} \n} \ncatch ( NumberFormatException ex ) { \nlog . trace ( String . format ( \"No valid TTL config set for granularity: %s, rollup type: %s\" , gran . name ( ) , rollupType . name ( ) ) , ex ) ; \nreturn false ; \n} \nttlMapBuilder . put ( gran , rollupType , new TimeValue ( value , TimeUnit . DAYS ) ) ; \nreturn true ; \n} \n} \n"}
{"8084": "public class OutputFormatter { \npublic static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { \nint [ ] max = new int [ headers . length ] ; \nfor ( int i = 0 ; \ni < headers . length ; \ni ++ ) { \nmax [ i ] = headers [ i ] . length ( ) ; \n} \nfor ( OutputFormatter output : outputs ) { \nmax [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; \nfor ( int i = 1 ; \ni < headers . length ; \ni ++ ) { \nmax [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; \n} \n} \nreturn max ; \n} \n} \n"}
{"8085": "public class OutputFormatter { \npublic static String formatHeader ( int [ ] maximums , String [ ] headers ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < headers . length ; \ni ++ ) { \nsb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8086": "public class OutputFormatter { \npublic static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { \nString [ ] formattedStrings = new String [ outputs . length ] ; \nint pos = 0 ; \nfor ( OutputFormatter output : outputs ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; \nfor ( int i = 0 ; \ni < output . results . length ; \ni ++ ) { \nsb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; \n} \nformattedStrings [ pos ++ ] = sb . toString ( ) ; \n} \nreturn formattedStrings ; \n} \n} \n"}
{"8091": "public class Token { \npublic static List < Token > getTokens ( Locator locator ) { \nif ( StringUtils . isEmpty ( locator . getMetricName ( ) ) || StringUtils . isEmpty ( locator . getTenantId ( ) ) ) { \nreturn new ArrayList < > ( ) ; \n} \nString [ ] tokens = locator . getMetricName ( ) . split ( Locator . METRIC_TOKEN_SEPARATOR_REGEX ) ; \nreturn IntStream . range ( 0 , tokens . length ) . mapToObj ( index -> new Token ( locator , tokens , index ) ) . collect ( toList ( ) ) ; \n} \n} \n"}
{"8093": "public class Granularity { \npublic static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { \nif ( from >= to ) { \nthrow new RuntimeException ( \"Invalid interval specified for fromPointsInInterval\" ) ; \n} \ndouble requestedDuration = to - from ; \nif ( algorithm . startsWith ( \"GEOMETRIC\" ) ) { \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \nelse if ( algorithm . startsWith ( \"LINEAR\" ) ) { \nreturn granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \n} \nelse if ( algorithm . startsWith ( \"LESSTHANEQUAL\" ) ) { \nreturn granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; \n} \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \n} \n"}
{"8111": "public class Range { \npublic static Map < Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { \nif ( range . getStart ( ) >= range . getStop ( ) ) { \nthrow new IllegalArgumentException ( \"start cannot be greater than end. Start: \" + range . getStart ( ) + \" Stop:\" + range . getStop ( ) ) ; \n} \nfinal long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; \nfinal long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; \nHashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; \nlong tempStartMillis = snappedStartMillis ; \nint numberOfMillis = g . milliseconds ( ) ; \nwhile ( tempStartMillis <= ( snappedStopMillis - numberOfMillis ) ) { \nRange slotRange = new Range ( tempStartMillis , tempStartMillis + numberOfMillis ) ; \nrangeMap . put ( slotRange , new IntervalRangeIterator ( g . finer ( ) , slotRange . start , slotRange . stop ) ) ; \ntempStartMillis = tempStartMillis + numberOfMillis ; \n} \nreturn rangeMap ; \n} \n} \n"}
{"8113": "public class AstyanaxWriter { \npublic void insertFull ( Collection < ? extends IMetric > metrics , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { \nTimer . Context ctx = Instrumentation . getWriteTimerContext ( CassandraModel . CF_METRICS_FULL_NAME ) ; \ntry { \nMutationBatch mutationBatch = keyspace . prepareMutationBatch ( ) ; \nfor ( IMetric metric : metrics ) { \nfinal Locator locator = metric . getLocator ( ) ; \nif ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { \nif ( mutationBatch != null ) { \ninsertLocator ( locator , mutationBatch ) ; \n} \nLocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; \n} \nif ( isRecordingDelayedMetrics ) { \nif ( mutationBatch != null ) { \ninsertLocatorIfDelayed ( metric , mutationBatch , clock ) ; \n} \n} \ninsertMetric ( metric , mutationBatch ) ; \nInstrumentation . markFullResMetricWritten ( ) ; \n} \ntry { \nmutationBatch . execute ( ) ; \n} \ncatch ( ConnectionException e ) { \nInstrumentation . markWriteError ( e ) ; \nlog . error ( \"Connection exception during insertFull\" , e ) ; \nthrow e ; \n} \n} \nfinally { \nctx . stop ( ) ; \n} \n} \n} \n"}
{"8118": "public class Serializers { \npublic static < T > AbstractSerializer < T > serializerFor ( Class < T > type ) { \nif ( type == null ) { \nthrow new RuntimeException ( \"serializable type cannot be null\" , new SerializationException ( \"serializable type cannot be null\" ) ) ; \n} \nelse if ( type . equals ( String . class ) ) { \nthrow new RuntimeException ( \"We don't serialize strings anymore\" , new SerializationException ( \"We don't serialize strings anymore\" ) ) ; \n} \nif ( type . equals ( BasicRollup . class ) ) { \nreturn ( AbstractSerializer < T > ) basicRollupInstance ; \n} \nelse if ( type . equals ( BluefloodTimerRollup . class ) ) { \nreturn ( AbstractSerializer < T > ) timerRollupInstance ; \n} \nelse if ( type . equals ( BluefloodCounterRollup . class ) ) { \nreturn ( AbstractSerializer < T > ) counterRollupInstance ; \n} \nelse if ( type . equals ( BluefloodGaugeRollup . class ) ) { \nreturn ( AbstractSerializer < T > ) gaugeRollupInstance ; \n} \nelse if ( type . equals ( BluefloodSetRollup . class ) ) { \nreturn ( AbstractSerializer < T > ) setRollupInstance ; \n} \nelse if ( type . equals ( SimpleNumber . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( Integer . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( Long . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( Double . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( Float . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( byte [ ] . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse if ( type . equals ( Object . class ) ) { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \nelse { \nreturn ( AbstractSerializer < T > ) fullInstance ; \n} \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) { \nreturn ; \n} \nif ( fileManager == null ) { \nreturn ; \n} \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \nelse { \nlog . debug ( \"Download in progress\" ) ; \n} \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) { \nreturn false ; \n} \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) { \nstart ++ ; \n} \nboolean fraction = false ; \nfor ( int i = start ; \ni < value . length ( ) ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \ncontinue ; \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8181": "public class LocaleUtils { \npublic static String getCountryISO2 ( String country ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) { \nreturn null ; \n} \nif ( country . length ( ) == 2 ) { \nreturn country ; \n} \nString [ ] iso2Codes = Locale . getISOCountries ( ) ; \nif ( country . length ( ) == 3 ) { \nString iso2Code = LocaleUtils . getCountryISO2FromISO3 ( country ) ; \nif ( iso2Code != null ) { \nreturn iso2Code ; \n} \n} \nfor ( String iso2Code : iso2Codes ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null && name . equalsIgnoreCase ( country ) ) { \nreturn iso2Code ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8182": "public class LocaleUtils { \npublic static String getCountryISO2FromISO3 ( String iso3Code ) { \niso3Code = StringUtils . trimToNull ( iso3Code ) ; \nif ( iso3Code == null ) { \nreturn null ; \n} \nif ( iso3Code . length ( ) == 3 ) { \nfor ( String iso2Code : Locale . getISOCountries ( ) ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString countryISO3 = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( countryISO3 != null && countryISO3 . equalsIgnoreCase ( iso3Code ) ) { \nreturn iso2Code ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8183": "public class LocaleUtils { \npublic static String getCountryISO3 ( String country ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) { \nreturn null ; \n} \nif ( country . length ( ) == 3 ) { \nreturn country ; \n} \nString [ ] iso2Codes = Locale . getISOCountries ( ) ; \nif ( country . length ( ) == 2 ) { \nString iso3code = LocaleUtils . getCountryISO3FromISO2 ( country ) ; \nif ( iso3code != null ) { \nreturn iso3code ; \n} \n} \nfor ( String iso2Code : iso2Codes ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString iso3Code = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( iso3Code == null ) { \ncontinue ; \n} \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null && name . equalsIgnoreCase ( country ) ) { \nreturn iso3Code ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8184": "public class LocaleUtils { \npublic static String getCountryISO3FromISO2 ( String iso2Code ) { \niso2Code = StringUtils . trimToNull ( iso2Code ) ; \nif ( iso2Code == null ) { \nreturn null ; \n} \nif ( iso2Code . length ( ) == 2 ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString iso3Code = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( iso3Code != null ) { \nreturn iso3Code ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8185": "public class LocaleUtils { \npublic static String getCountryName ( String country , Locale language ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) { \nreturn null ; \n} \nString iso2Code = LocaleUtils . getCountryISO2 ( country ) ; \nif ( iso2Code != null ) { \nString name = StringUtils . trimToNull ( new Locale ( iso2Code , iso2Code ) . getDisplayCountry ( language ) ) ; \nif ( name != null ) { \nreturn name ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8186": "public class LocaleUtils { \npublic static String translateCountryName ( String country , Locale language ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) { \nreturn null ; \n} \nfor ( String iso2Code : Locale . getISOCountries ( ) ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null && name . equalsIgnoreCase ( country ) ) { \nname = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( language ) ) ; \nif ( name != null ) { \nreturn name ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) { \nthrow new IllegalArgumentException ( \"No validation event was provided!\" ) ; \n} \nint line = - 1 ; \nint col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( line > - 1 && col > - 1 ) { \nLOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \nreturn false ; \n} \nif ( ValidationEvent . WARNING == event . getSeverity ( ) ) { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( line > - 1 && col > - 1 ) { \nLOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation error\" ) ; \nif ( line > - 1 && col > - 1 ) { \nLOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \nfor ( int i = 0 ; \ni < this . getRecordLenth ( ) ; \ni ++ ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( txt . length ( ) > 0 ) { \ntxt . append ( lineSeparator ) ; \n} \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \n} \n} \n} \n"}
{"8208": "public class CsvRecord { \nprotected final void set ( int pos , String value ) { \nvalue = StringUtils . trimToNull ( value ) ; \nif ( value != null ) { \nthis . values . put ( pos , value ) ; \n} \nelse if ( this . values . containsKey ( pos ) ) { \nthis . values . remove ( pos ) ; \n} \n} \n} \n"}
{"8360": "public class CmdLineParser { \npublic final Option addOption ( Option opt ) { \nif ( opt . shortForm ( ) != null ) { \nthis . options . put ( \"-\" + opt . shortForm ( ) , opt ) ; \n} \nthis . options . put ( \"--\" + opt . longForm ( ) , opt ) ; \nreturn opt ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) { \nthrow new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \n} \nif ( opt . wantsValue ( ) ) { \nthrow new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \n} \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8395": "public class ServerMethods { \npublic String [ ] get_keyword_names ( ) { \ntry { \nString [ ] names = servlet . getLibrary ( ) . getKeywordNames ( ) ; \nif ( names == null || names . length == 0 ) { \nthrow new RuntimeException ( \"No keywords found in the test library\" ) ; \n} \nString [ ] newNames = Arrays . copyOf ( names , names . length + 1 ) ; \nnewNames [ names . length ] = \"stop_remote_server\" ; \nreturn newNames ; \n} \ncatch ( Throwable e ) { \nlog . warn ( \"\" , e ) ; \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"8411": "public class AbstractOcspClient { \nprotected X509Certificate findIntermediate ( X509Certificate certificate ) throws OcspException { \nfor ( X509Certificate issuer : properties . get ( INTERMEDIATES ) ) if ( issuer . getSubjectX500Principal ( ) . equals ( certificate . getIssuerX500Principal ( ) ) ) { \nreturn issuer ; \n} \nthrow new OcspException ( \"Unable to find issuer '%s'.\" , certificate . getIssuerX500Principal ( ) . getName ( ) ) ; \n} \n} \n"}
{"8427": "public class UseActivityInterceptor { \n@ SuppressWarnings ( \"unchecked\" ) private void launchActivity ( ) { \nif ( activity != null && ActivityRunMode . SPECIFICATION . equals ( activityRunMode ) ) { \nreturn ; \n} \nString targetPackage = instrumentation . getTargetContext ( ) . getPackageName ( ) ; \nIntent intent = getLaunchIntent ( targetPackage , activityClass , bundleCreator ) ; \nactivity = instrumentation . startActivitySync ( intent ) ; \ninstrumentation . waitForIdleSync ( ) ; \n} \n} \n"}
{"8438": "public class GraphqlApi { \npublic GraphQLResult processGraphQLMultipart ( String graphQLRequest , File file ) throws ApiException { \nObject localVarPostBody = null ; \nif ( graphQLRequest == null ) { \nthrow new ApiException ( 400 , \"Missing the required parameter 'graphQLRequest' when calling processGraphQLMultipart\" ) ; \n} \nif ( file == null ) { \nthrow new ApiException ( 400 , \"Missing the required parameter 'file' when calling processGraphQLMultipart\" ) ; \n} \nString localVarPath = \"/graphql/upload\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) ; \nList < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; \nMap < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; \nif ( graphQLRequest != null ) { \nlocalVarFormParams . put ( \"graphQLRequest\" , graphQLRequest ) ; \n} \nif ( file != null ) { \nlocalVarFormParams . put ( \"file\" , file ) ; \n} \nfinal String [ ] localVarAccepts = { \n\"application/json\" } \n; \nfinal String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; \nfinal String [ ] localVarContentTypes = { \n\"multipart/form-data\" } \n; \nfinal String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; \nString [ ] localVarAuthNames = new String [ ] { \n\"token\" } \n; \nGenericType < GraphQLResult > localVarReturnType = new GenericType < GraphQLResult > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( localVarPath , \"POST\" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; \n} \n} \n"}
{"8456": "public class UnitConverter { \npublic static TimeUnit extractTimeUnitFromString ( String timeString ) { \ntimeString = timeString . toLowerCase ( ) ; \nif ( timeString . contains ( \"minute\" ) ) { \nreturn TimeUnit . MINUTES ; \n} \nelse if ( timeString . contains ( \"microsecond\" ) ) { \nreturn TimeUnit . MICROSECONDS ; \n} \nelse if ( timeString . contains ( \"millisecond\" ) ) { \nreturn TimeUnit . MILLISECONDS ; \n} \nelse if ( timeString . contains ( \"second\" ) ) { \nreturn TimeUnit . SECONDS ; \n} \nelse if ( timeString . contains ( \"hour\" ) ) { \nreturn TimeUnit . HOURS ; \n} \nelse if ( timeString . toLowerCase ( ) . contains ( \"day\" ) ) { \nreturn TimeUnit . DAYS ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"8801": "public class Utils { \npublic static < T > Constructor < T > commonConstructor ( Class < T > type ) throws NoMethodForDependency { \nConstructor < ? > [ ] cs = type . getDeclaredConstructors ( ) ; \nif ( cs . length == 0 ) { \nthrow new NoMethodForDependency ( raw ( type ) ) ; \n} \nConstructor < ? > mostParamsConstructor = null ; \nfor ( Constructor < ? > c : cs ) { \nif ( ! arrayContains ( c . getParameterTypes ( ) , type , ( a , b ) -> a == b ) && ( mostParamsConstructor == null || ( moreVisible ( c , mostParamsConstructor ) == c && ( moreVisible ( mostParamsConstructor , c ) == c || c . getParameterCount ( ) > mostParamsConstructor . getParameterCount ( ) ) ) ) ) { \nmostParamsConstructor = c ; \n} \n} \nif ( mostParamsConstructor == null ) { \nthrow new NoMethodForDependency ( raw ( type ) ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Constructor < T > c = ( Constructor < T > ) mostParamsConstructor ; \nreturn c ; \n} \n} \n"}
{"8832": "public class WebsockifyProxyHandler { \nprivate String isRedirect ( String uri ) throws URISyntaxException , MalformedURLException { \nURI url = new URI ( uri ) ; \nif ( REDIRECT_PATH . equals ( url . getPath ( ) ) ) { \nString query = url . getRawQuery ( ) ; \nMap < String , String > params = getQueryMap ( query ) ; \nString urlParam = params . get ( URL_PARAMETER ) ; \nif ( urlParam == null ) { \nreturn null ; \n} \ntry { \nreturn URLDecoder . decode ( urlParam , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nLogger . getLogger ( WebsockifyProxyHandler . class . getName ( ) ) . severe ( e . getMessage ( ) ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8881": "public class Statistics { \npublic void addLexeme ( int lexemeId ) { \nint count = 1 ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) { \ncount = lexemeFrequency . get ( lexemeId ) + 1 ; \n} \nlexemeFrequency . put ( lexemeId , count ) ; \n} \n} \n"}
{"8882": "public class Statistics { \npublic void addEnding ( int endingId ) { \nint count = 1 ; \nif ( endingFrequency . get ( endingId ) != null ) { \ncount = endingFrequency . get ( endingId ) + 1 ; \n} \nendingFrequency . put ( endingId , count ) ; \n} \n} \n"}
{"8883": "public class Statistics { \npublic double getEstimate ( AttributeValues wordform ) { \ndouble estimate = 0.1 ; \nString endingIdStr = wordform . getValue ( AttributeNames . i_EndingID ) ; \nint endingId = ( endingIdStr == null ) ? - 1 : Integer . parseInt ( endingIdStr ) ; \nif ( endingFrequency . get ( endingId ) != null ) { \nestimate += endingFrequency . get ( endingId ) ; \n} \nString lexemeIdStr = wordform . getValue ( AttributeNames . i_LexemeID ) ; \nint lexemeId = ( lexemeIdStr == null ) ? - 1 : Integer . parseInt ( lexemeIdStr ) ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) { \nestimate += lexemeFrequency . get ( lexemeId ) * lexemeWeight ; \n} \nreturn estimate ; \n} \n} \n"}
{"8885": "public class MarkupConverter { \nprivate static void verifyAndSetKamolsAttribute ( AttributeValues avs , StringBuilder tag , int index , char tagValue , String attribute , String attributeValue ) { \nif ( avs . isMatchingStrong ( attribute , attributeValue ) ) { \ntag . setCharAt ( index , tagValue ) ; \n} \n} \n} \n"}
{"8886": "public class MarkupConverter { \npublic static String toKamolsMarkup ( AttributeValues avs ) { \nStringBuilder res = toKamolsMarkup ( avs , defaulti ) ; \nif ( res . length ( ) < 1 ) { \nreturn res . toString ( ) ; \n} \nreturn res . toString ( ) ; \n} \n} \n"}
{"8887": "public class MarkupConverter { \nprivate static void verifyAndSetAVSAttribute ( String tag , FeatureStructure avs , int index , char tagValue , String attribute , String attributeValue ) { \nif ( index >= tag . length ( ) ) { \nreturn ; \n} \nif ( tag . charAt ( index ) == tagValue ) { \navs . addAttribute ( attribute , attributeValue ) ; \n} \n} \n} \n"}
{"8888": "public class MarkupConverter { \npublic static String removeKamolsMarkupFormating ( String tag ) { \nString result = \"\" ; \nif ( ! tag . contains ( \",\" ) ) { \nreturn \"x\" ; \n} \nint depth = 0 ; \nint commas = 0 ; \nfor ( char c : tag . toCharArray ( ) ) { \nif ( c == '[' ) { \ndepth ++ ; \n} \nif ( c == ']' ) { \ndepth -- ; \n} \nif ( depth == 1 && c == ',' ) { \ncommas ++ ; \n} \nif ( commas == 2 ) { \nresult = result + c ; \n} \n} \nresult = result . replaceAll ( \"_[A-Z0-9]*\" , \"_\" ) ; \nresult = result . replaceAll ( \"(\\\\[|\\\\]|\\\\,| )\" , \"\" ) ; \nreturn result ; \n} \n} \n"}
{"8901": "public class Genericode10Helper { \n@ Nonnull public static String getColumnElementID ( @ Nonnull final Object aColumnElement ) { \nif ( aColumnElement instanceof ColumnRef ) { \nreturn ( ( ColumnRef ) aColumnElement ) . getId ( ) ; \n} \nif ( aColumnElement instanceof Column ) { \nreturn ( ( Column ) aColumnElement ) . getId ( ) ; \n} \nif ( aColumnElement instanceof Key ) { \nfinal List < KeyColumnRef > aKeyColumnRefs = ( ( Key ) aColumnElement ) . getColumnRef ( ) ; \nfinal KeyColumnRef aKeyColumnRef = CollectionHelper . getFirstElement ( aKeyColumnRefs ) ; \nif ( aKeyColumnRef == null ) { \nthrow new IllegalArgumentException ( \"Key contains not KeyColumnRef!!\" ) ; \n} \nfinal Object aRef = aKeyColumnRef . getRef ( ) ; \nif ( aRef instanceof Column ) { \nreturn ( ( Column ) aRef ) . getId ( ) ; \n} \nthrow new IllegalArgumentException ( \"Unsupported referenced object: \" + aRef + \" - \" + ClassHelper . getSafeClassName ( aRef ) ) ; \n} \nthrow new IllegalArgumentException ( \"Illegal column element: \" + aColumnElement + \" - \" + ClassHelper . getSafeClassName ( aColumnElement ) ) ; \n} \n} \n"}
{"8903": "public class Genericode10Helper { \n@ Nullable public static Column getColumnOfID ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) { \nif ( sID != null ) { \nfor ( final Column aColumn : getAllColumns ( aColumnSet ) ) if ( aColumn . getId ( ) . equals ( sID ) ) { \nreturn aColumn ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8905": "public class Genericode10Helper { \n@ Nullable public static Key getKeyOfID ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) { \nif ( sID != null ) { \nfor ( final Key aKey : getAllKeys ( aColumnSet ) ) if ( aKey . getId ( ) . equals ( sID ) ) { \nreturn aKey ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8906": "public class Genericode10Helper { \npublic static boolean isKeyColumn ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sColumnID ) { \nif ( sColumnID != null ) { \nfor ( final Key aKey : getAllKeys ( aColumnSet ) ) for ( final KeyColumnRef aColumnRef : aKey . getColumnRef ( ) ) if ( aColumnRef . getRef ( ) instanceof Column ) { \nif ( ( ( Column ) aColumnRef . getRef ( ) ) . getId ( ) . equals ( sColumnID ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8907": "public class Genericode10Helper { \n@ Nonnull public static Column createColumn ( @ Nonnull @ Nonempty final String sColumnID , @ Nonnull final UseType eUseType , @ Nonnull @ Nonempty final String sShortName , @ Nullable final String sLongName , @ Nonnull @ Nonempty final String sDataType ) { \nValueEnforcer . notEmpty ( sColumnID , \"ColumnID\" ) ; \nValueEnforcer . notNull ( eUseType , \"useType\" ) ; \nValueEnforcer . notEmpty ( sShortName , \"ShortName\" ) ; \nValueEnforcer . notEmpty ( sDataType , \"DataType\" ) ; \nfinal Column aColumn = s_aFactory . createColumn ( ) ; \naColumn . setId ( sColumnID ) ; \naColumn . setUse ( eUseType ) ; \naColumn . setShortName ( createShortName ( sShortName ) ) ; \nif ( StringHelper . hasText ( sLongName ) ) { \naColumn . getLongName ( ) . add ( createLongName ( sLongName ) ) ; \n} \nfinal Data aData = s_aFactory . createData ( ) ; \naData . setType ( sDataType ) ; \naColumn . setData ( aData ) ; \nreturn aColumn ; \n} \n} \n"}
{"8908": "public class Genericode10Helper { \n@ Nonnull public static Key createKey ( @ Nonnull @ Nonempty final String sColumnID , @ Nonnull @ Nonempty final String sShortName , @ Nullable final String sLongName , @ Nonnull final Column aColumn ) { \nValueEnforcer . notEmpty ( sColumnID , \"ColumnID\" ) ; \nValueEnforcer . notEmpty ( sShortName , \"ShortName\" ) ; \nValueEnforcer . notNull ( aColumn , \"Column\" ) ; \nfinal Key aKey = s_aFactory . createKey ( ) ; \naKey . setId ( sColumnID ) ; \naKey . setShortName ( createShortName ( sShortName ) ) ; \nif ( StringHelper . hasText ( sLongName ) ) { \naKey . getLongName ( ) . add ( createLongName ( sLongName ) ) ; \n} \naKey . getColumnRef ( ) . add ( createKeyColumnRef ( aColumn ) ) ; \nreturn aKey ; \n} \n} \n"}
{"8910": "public class ExcelReadOptions { \n@ Nonnull public ExcelReadOptions < USE_TYPE > addColumn ( @ Nonnegative final int nIndex , @ Nonnull @ Nonempty final String sColumnID , @ Nonnull final USE_TYPE eUseType , @ Nonnull @ Nonempty final String sDataType , final boolean bKeyColumn ) { \nValueEnforcer . isGE0 ( nIndex , \"Index\" ) ; \nfinal Integer aIndex = Integer . valueOf ( nIndex ) ; \nif ( m_aColumns . containsKey ( aIndex ) ) { \nthrow new IllegalArgumentException ( \"The column at index \" + nIndex + \" is already mapped!\" ) ; \n} \nm_aColumns . put ( aIndex , new ExcelReadColumn < > ( nIndex , sColumnID , eUseType , sDataType , bKeyColumn ) ) ; \nreturn this ; \n} \n} \n"}
{"8941": "public class StatsToChart { \npublic Chart convert ( File file ) { \nif ( file == null ) { \nreturn null ; \n} \ntry { \nif ( file . isDirectory ( ) ) { \nSet < File > statsFiles = IO . listFileRecursive ( file , \"*.gfs\" ) ; \nif ( statsFiles == null || statsFiles . isEmpty ( ) ) { \nreturn null ; \n} \nfor ( File statFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( statFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \n} \nelse { \nGfStatsReader reader = new GfStatsReader ( file . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \nreturn visitor . getChart ( ) ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( \"File:\" + file + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8942": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForServer ( String serverName , JMX jmx ) throws InstanceNotFoundException { \nPool pool = PoolManager . find ( serverName ) ; \nif ( pool != null ) { \nreturn pool ; \n} \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nObjectName objectName = new ObjectName ( new StringBuilder ( \"GemFire:type=Member,member=\" ) . append ( serverName ) . toString ( ) ) ; \nString host = jmx . getAttribute ( objectName , \"Host\" ) ; \nif ( host == null || host . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"host not found for serverName:\" + serverName + \" not found\" ) ; \n} \nhost = lookupNetworkHost ( host ) ; \nString findJmxPort = new StringBuilder ( \"GemFire:service=CacheServer,port=*,type=Member,member=\" ) . append ( serverName ) . toString ( ) ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( findJmxPort ) ; \nif ( objectNames == null || objectNames . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( \"Unable to to find port with server name:\" + serverName ) ; \n} \nObjectName portObjectName = objectNames . iterator ( ) . next ( ) ; \nInteger port = jmx . getAttribute ( portObjectName , \"Port\" ) ; \nif ( port == null ) { \nthrow new IllegalArgumentException ( \"Unable to obtain port for objectName:\" + portObjectName + \" for server:\" + serverName ) ; \n} \nSystem . out . println ( \"Found cache server host\" + host + \" port:\" + port ) ; \npoolFactory = poolFactory . addServer ( host , port . intValue ( ) ) ; \nreturn poolFactory . create ( serverName ) ; \n} \ncatch ( InstanceNotFoundException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for servername:\" + serverName + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8943": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForLocator ( JMX jmx ) { \nString locatorsPoolName = jmx . getHost ( ) + \"[\" + jmx . getPort ( ) + \"]\" ; \nPool pool = PoolManager . find ( locatorsPoolName ) ; \nif ( pool != null ) { \nreturn pool ; \n} \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nint port = getLocatorPort ( jmx ) ; \npoolFactory = poolFactory . addLocator ( jmx . getHost ( ) , port ) ; \nreturn poolFactory . create ( locatorsPoolName ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for locator:\" + jmx . getHost ( ) + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8945": "public class GemFireJmxClient { \npublic static MemberMXBean getMember ( String name , JMX jmx ) { \ntry { \nString pattern = \"GemFire:type=Member,member=\" + name ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( pattern ) ; \nif ( objectNames == null || objectNames . isEmpty ( ) ) { \nreturn null ; \n} \nObjectName serverName = new ObjectName ( pattern ) ; \nreturn jmx . newBean ( MemberMXBean . class , serverName ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to get member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8947": "public class GemFireJmxClient { \nstatic synchronized String lookupNetworkHost ( String host ) { \ntry { \nif ( _bundle == null ) { \nURL url = GemFireJmxClient . class . getResource ( hostPropFileName ) ; \nString filePath = null ; \nif ( url == null ) { \nfilePath = hostPropFileName ; \n} \nelse { \nfilePath = url . toString ( ) ; \n} \nSystem . out . println ( new StringBuilder ( \"Loading IP addresses from \" ) . append ( filePath ) . toString ( ) ) ; \n_bundle = ResourceBundle . getBundle ( \"host\" ) ; \n} \nSystem . out . println ( new StringBuilder ( \"Looking for host name \\\"\" ) . append ( host ) . append ( \"\\\" IP address in \" ) . append ( hostPropFileName ) . toString ( ) ) ; \nString newHost = _bundle . getString ( host ) ; \nSystem . out . println ( new StringBuilder ( host ) . append ( \"=\" ) . append ( newHost ) . toString ( ) ) ; \nreturn newHost ; \n} \ncatch ( RuntimeException e ) { \nSystem . out . println ( \"Using host:\" + host ) ; \nreturn host ; \n} \n} \n} \n"}
{"8949": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > Collection < T > exeWithResults ( Execution < ? , ? , ? > execution , Function < ? > function ) throws Exception { \nResultCollector < ? , ? > resultCollector ; \ntry { \nresultCollector = execution . execute ( function ) ; \n} \ncatch ( FunctionException e ) { \nif ( e . getCause ( ) instanceof NullPointerException ) { \nthrow new RuntimeException ( \"Unable to execute function:\" + function . getId ( ) + \" assert hostnames(s) for locators and cache server can be resovled. \" + \" If you do not have access to the host file, create host.properties and add to the CLASSPATH. \" + \" Example: locahost=127.1.0.0 \" + \" also assert that all cache servers have been initialized. Check if the server's cache.xml has all required <initializer>..</initializer> configurations\" , e ) ; \n} \nelse { \nthrow e ; \n} \n} \nObject resultsObject = resultCollector . getResult ( ) ; \nCollection < Object > collectionResults = ( Collection < Object > ) resultsObject ; \nif ( collectionResults . isEmpty ( ) ) { \nreturn null ; \n} \nCollection < Object > list = new ArrayList < Object > ( collectionResults . size ( ) ) ; \nflatten ( collectionResults , list ) ; \nif ( list . isEmpty ( ) ) { \nreturn null ; \n} \nreturn ( Collection < T > ) list ; \n} \n} \n"}
{"8950": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > void flatten ( Collection < Object > input , Collection < Object > flattenOutput ) throws Exception { \nif ( input == null || input . isEmpty ( ) || flattenOutput == null ) { \nreturn ; \n} \nfor ( Object inputObj : input ) { \nif ( inputObj instanceof Exception ) { \nthrow ( Exception ) inputObj ; \n} \nif ( inputObj == null ) { \ncontinue ; \n} \nif ( inputObj instanceof Collection ) { \nflatten ( ( Collection < Object > ) inputObj , flattenOutput ) ; \n} \nelse { \nflattenOutput . add ( inputObj ) ; \n} \n} \n} \n} \n"}
{"8951": "public class Querier { \n@ SuppressWarnings ( \"unchecked\" ) public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { \nSelectResults < ReturnType > selectResults ; \nif ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) { \nif ( params == null || params . length == 0 ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; \n} \nif ( selectResults == null || selectResults . isEmpty ( ) ) { \nreturn null ; \n} \nArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; \nresults . addAll ( selectResults . asList ( ) ) ; \nreturn results ; \n} \nelse { \nif ( params == null || params . length == 0 ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; \n} \nif ( selectResults == null || selectResults . isEmpty ( ) ) { \nreturn null ; \n} \nreturn selectResults ; \n} \n} \n} \n"}
{"8955": "public class FunctionFacts { \npublic OnRegionFilterKeyFacts [ ] getOnRegionFilterKeyFacts ( ) { \nif ( onRegionFilterKeyFacts == null ) { \nreturn null ; \n} \nreturn Arrays . copyOf ( onRegionFilterKeyFacts , onRegionFilterKeyFacts . length ) ; \n} \n} \n"}
{"8956": "public class ReadExportFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \nResultSender < Object > sender = functionContext . getResultSender ( ) ; \nCache cache = CacheFactory . getAnyInstance ( ) ; \nLogger logWriter = LogManager . getLogger ( getClass ( ) ) ; \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null || args . length != 2 ) { \nthrow new FunctionException ( \"Required array args: [region,extension]\" ) ; \n} \nString extensionArg = args [ 0 ] ; \nif ( extensionArg == null || extensionArg . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"File extension required\" ) ; \n} \nExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; \nString regionName = args [ 1 ] ; \nRegion < Object , Object > region = cache . getRegion ( regionName ) ; \nif ( region == null ) { \nsender . lastResult ( null ) ; \nreturn ; \n} \nFile file = new File ( new StringBuilder ( directoryPath ) . append ( \"/\" ) . append ( regionName ) . append ( \".\" ) . append ( extensionArg ) . toString ( ) ) ; \nString serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; \nswitch ( extension ) { \ncase gfd : new GfdExportFunction ( ) . exportRegion ( region ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Unsupported extension file type:\" + extension ) ; \n} \nSerializable content = readContent ( file , extension , logWriter ) ; \nSerializable [ ] arrayResults = { \nserverName , content , file . getAbsolutePath ( ) } \n; \nsender . lastResult ( arrayResults ) ; \n} \ncatch ( Exception e ) { \nString stackTrace = Debugger . stackTrace ( e ) ; \nlogWriter . error ( stackTrace ) ; \nthrow new FunctionException ( stackTrace ) ; \n} \n} \n} \n"}
{"8958": "public class LuceneSearchFunction { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) @ Override public void execute ( FunctionContext functionContext ) { \nCache cache = CacheFactory . getAnyInstance ( ) ; \ntry { \nif ( ! ( functionContext instanceof RegionFunctionContext ) ) { \nthrow new FunctionException ( \"Execute on a region\" ) ; \n} \nObject args = functionContext . getArguments ( ) ; \nif ( args == null ) { \nthrow new FunctionException ( \"arguments is required\" ) ; \n} \nTextPageCriteria criteria = null ; \nif ( args instanceof PdxInstance ) { \nPdxInstance pdxInstance = ( PdxInstance ) args ; \ntry { \ncriteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; \n} \ncatch ( PdxSerializationException e ) { \nthrow new FunctionException ( e . getMessage ( ) + \" JSON:\" + JSONFormatter . toJSON ( pdxInstance ) ) ; \n} \n} \nelse { \ncriteria = ( TextPageCriteria ) args ; \n} \nRegion < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; \nRegion < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; \nGeodePagination pagination = new GeodePagination ( ) ; \nTextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; \ngeodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; \nCollection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , criteria . isSortDescending ( ) , criteria . getBeginIndex ( ) , ( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; \nif ( collection == null ) { \nfunctionContext . getResultSender ( ) . lastResult ( null ) ; \nreturn ; \n} \nPagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; \nfunctionContext . getResultSender ( ) . lastResult ( pageCollection ) ; \n} \ncatch ( RuntimeException e ) { \nLogger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; \nlogger . error ( Debugger . stackTrace ( e ) ) ; \nthrow e ; \n} \n} \n} \n"}
{"8959": "public class StatsUtil { \npublic static String getAppName ( ResourceInst [ ] resources ) { \nif ( resources == null || resources . length == 0 ) { \nreturn null ; \n} \nResourceType rt = null ; \nfor ( ResourceInst resourceInst : resources ) { \nif ( resourceInst == null ) { \ncontinue ; \n} \nrt = resourceInst . getType ( ) ; \nif ( rt == null ) { \ncontinue ; \n} \nif ( ! \"CacheServerStats\" . equals ( rt . getName ( ) ) ) { \ncontinue ; \n} \nreturn resourceInst . getName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8960": "public class GeodeClient { \nprotected static void constructSecurity ( Properties props ) throws IOException { \nprops . setProperty ( \"security-client-auth-init\" , GeodeConfigAuthInitialize . class . getName ( ) + \".create\" ) ; \nFile sslFile = saveEnvFile ( GeodeConfigConstants . SSL_KEYSTORE_CLASSPATH_FILE_PROP ) ; \nSystem . out . println ( \"sslFile:\" + sslFile ) ; \nFile sslTrustStoreFile = saveEnvFile ( GeodeConfigConstants . SSL_TRUSTSTORE_CLASSPATH_FILE_PROP ) ; \nString sslTrustStoreFilePath = \"\" ; \nif ( sslTrustStoreFile != null ) { \nsslTrustStoreFilePath = sslTrustStoreFile . getAbsolutePath ( ) ; \n} \nprops . setProperty ( \"ssl-keystore\" , ( sslFile != null ) ? sslFile . getAbsolutePath ( ) : \"\" ) ; \nprops . setProperty ( \"ssl-keystore-password\" , Config . getPropertyEnv ( \"ssl-keystore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore\" , sslTrustStoreFilePath ) ; \nprops . setProperty ( \"ssl-protocols\" , Config . getPropertyEnv ( \"ssl-protocols\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore-password\" , Config . getPropertyEnv ( \"ssl-truststore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-keystore-type\" , Config . getPropertyEnv ( \"ssl-keystore-type\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-ciphers\" , Config . getPropertyEnv ( \"ssl-ciphers\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-require-authentication\" , Config . getPropertyEnv ( \"ssl-require-authentication\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-enabled-components\" , Config . getPropertyEnv ( \"ssl-enabled-components\" , \"\" ) ) ; \n} \n} \n"}
{"8961": "public class GeodeClient { \n@ SuppressWarnings ( \"unchecked\" ) public < K , V > Region < K , V > getRegion ( String regionName ) { \nif ( regionName == null || regionName . length ( ) == 0 ) { \nreturn null ; \n} \nRegion < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; \nif ( region != null ) { \nreturn ( Region < K , V > ) region ; \n} \nregion = ( Region < K , V > ) this . createRegion ( regionName ) ; \nif ( cachingProxy ) { \nregion . registerInterestRegex ( \".*\" ) ; \n} \nreturn region ; \n} \n} \n"}
{"8962": "public class GeodeClient { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Region < K , V > getRegion ( ClientCache clientCache , String regionName ) { \nif ( regionName == null || regionName . length ( ) == 0 ) { \nreturn null ; \n} \nRegion < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; \nif ( region != null ) { \nreturn ( Region < K , V > ) region ; \n} \nregion = ( Region < K , V > ) clientCache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) . create ( regionName ) ; \nreturn region ; \n} \n} \n"}
{"8966": "public class GfStatsReader { \npublic static void toCvsFiles ( File directory ) throws IOException { \nSet < File > statsFiles = IO . listFileRecursive ( directory , \"*.gfs\" ) ; \nif ( statsFiles == null || statsFiles . isEmpty ( ) ) { \nreturn ; \n} \nfor ( File archiveFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \n} \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( args . length < 1 ) { \nSystem . err . println ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( args . length < 2 ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( args . length > 3 ) { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nelse { \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \n} \nSystem . out . println ( \"accepting\" ) ; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) { \nreturn 0 ; \n} \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8972": "public class GemFireMgmt { \npublic static void shutDownRedundancyZone ( String redundancyZone ) { \nif ( redundancyZone == null || redundancyZone . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"redundancyZone required\" ) ; \n} \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp exp = Query . eq ( Query . attr ( \"RedundancyZone\" ) , Query . value ( redundancyZone ) ) ; \nCollection < ObjectName > memberObjectNames = SingletonGemFireJmx . getJmx ( ) . searchObjectNames ( objectNamePattern , exp ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nGemFireMgmt . shutDownMember ( objectName . getKeyProperty ( \"member\" ) ) ; \n} \n} \n} \n"}
{"8973": "public class GeodePagination { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public < K , V > List < String > storePaginationMap ( String id , int pageSize , Region < String , Collection < K > > pageKeysRegion , List < Map . Entry < K , V > > results ) { \nif ( results == null || results . isEmpty ( ) ) { \nreturn null ; \n} \nList < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; \nint pageIndex = 1 ; \nString key = null ; \nArrayList < String > keys = new ArrayList < String > ( pageSize ) ; \nfor ( Collection < K > page : pagesCollection ) { \nkey = toPageKey ( id , pageIndex ++ ) ; \npageKeysRegion . put ( key , page ) ; \nkeys . add ( key ) ; \n} \nkeys . trimToSize ( ) ; \nreturn keys ; \n} \n} \n"}
{"8974": "public class GeodePagination { \npublic < K , V > Map < K , V > readResultsByPage ( TextPageCriteria criteria , int pageNumber , Region < K , V > region , Region < String , Collection < ? > > pageRegion ) { \nif ( pageRegion == null ) { \nreturn null ; \n} \nCollection < ? > regionKeys = pageRegion . get ( criteria . toPageKey ( pageNumber ) ) ; \nif ( regionKeys == null || regionKeys . isEmpty ( ) ) { \nreturn null ; \n} \nreturn region . getAll ( regionKeys ) ; \n} \n} \n"}
{"8975": "public class GfdImportFunction { \nprivate boolean importRegion ( Region < Object , Object > region ) throws Exception { \nFile file = DataOpsSecretary . determineFile ( ExportFileType . gfd , region . getName ( ) ) ; \nif ( ! file . exists ( ) ) { \nreturn false ; \n} \nregion . getSnapshotService ( ) . load ( file , SnapshotFormat . GEMFIRE ) ; \nreturn true ; \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null || remoteLocators . length ( ) == 0 ) { \nreturn false ; \n} \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) { \nreturn true ; \n} \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null || locators . length ( ) == 0 ) { \nreturn false ; \n} \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nint remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null || remoteLocator . length ( ) == 0 ) { \ncontinue ; \n} \nfor ( String locator : locatorsArray ) { \nif ( locator == null || locator . length ( ) == 0 ) { \ncontinue ; \n} \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) { \nreturn true ; \n} \nelse { \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8977": "public class GetEntriesChecksumFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null || args . length == 0 ) { \nthrow new IllegalArgumentException ( \"region argument required\" ) ; \n} \nString regionName = args [ 0 ] ; \nif ( regionName == null || regionName . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"region name argument required\" ) ; \n} \nRegion < Serializable , Object > region = CacheFactory . getAnyInstance ( ) . getRegion ( regionName ) ; \nif ( region == null ) { \nthrow new IllegalArgumentException ( \"region:\" + regionName + \" not found\" ) ; \n} \nfunctionContext . getResultSender ( ) . lastResult ( buildCheckSumMap ( region ) ) ; \n} \ncatch ( Exception e ) { \nString stack = Debugger . stackTrace ( e ) ; \nLogManager . getLogger ( getClass ( ) ) . error ( stack ) ; \nthrow new FunctionException ( stack ) ; \n} \n} \n} \n"}
{"8978": "public class GetEntriesChecksumFunction { \nHashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) { \nif ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) { \nregion = PartitionRegionHelper . getLocalData ( region ) ; \n} \nSet < Serializable > keySet = region . keySet ( ) ; \nif ( keySet == null || keySet . isEmpty ( ) ) { \nreturn null ; \n} \nHashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; \nObject object = null ; \nObject tmp = null ; \nfor ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { \nobject = entry . getValue ( ) ; \nif ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) { \ntmp = ( ( PdxInstance ) object ) . getObject ( ) ; \nif ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) { \nobject = tmp ; \n} \n} \nif ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) { \nregionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; \n} \nelse { \nregionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; \n} \n} \nreturn regionCheckSumMap ; \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) { \nreturn ; \n} \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) && ! columnType . startsWith ( \"java.util.List\" ) ) { \nlogger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \n} \nelse if ( tableColumn . isOneToMany ( ) ) { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { \nlogger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \n} \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) { \nlogger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \ntableColumn . setOneToOne ( true ) ; \n} \ntableObject . addColumn ( tableColumn ) ; \n} \n} \n"}
{"9004": "public class IntPower { \npublic static double raise ( final double px , final int pexponent ) { \ndouble x = px ; \nint exponent = pexponent ; \nif ( exponent < 0 ) { \nreturn 1 / raise ( x , - exponent ) ; \n} \ndouble power = 1 ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) { \npower *= x ; \n} \nx *= x ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( ( r < m_fMin ) || ( r > m_fMax ) ) { \nreturn ; \n} \nfinal int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \n++ m_aCounters [ i ] ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \n++ j ) { \nSystem . out . print ( \"*\" ) ; \n} \nSystem . out . println ( ) ; \n} \n} \n} \n"}
{"9034": "public class RegressionLine { \nprivate void _validateCoefficients ( ) { \nif ( m_bCoefsValid ) { \nreturn ; \n} \nif ( m_nDataPoints >= 2 ) { \nfinal float xBar = ( float ) m_dSumX / m_nDataPoints ; \nfinal float yBar = ( float ) m_dSumY / m_nDataPoints ; \nm_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; \nm_fA0 = yBar - m_fA1 * xBar ; \n} \nelse { \nm_fA0 = m_fA1 = Float . NaN ; \n} \nm_bCoefsValid = true ; \n} \n} \n"}
{"9047": "public class LinearSystem { \npublic ColumnVector solve ( final ColumnVector b , final boolean improve ) throws MatrixException { \nif ( b . m_nRows != m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \ndecompose ( ) ; \nfinal ColumnVector y = _forwardSubstitution ( b ) ; \nfinal ColumnVector x = _backSubstitution ( y ) ; \nif ( improve ) { \n_improve ( b , x ) ; \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) { \nlargestX = absX ; \n} \n} \nif ( largestX == 0 ) { \nreturn ; \n} \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( int iter = 0 ; \niter < MAX_ITER ; \n++ iter ) { \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \ndouble dot = 0 ; \nfor ( int c = 0 ; \nc < m_nRows ; \n++ c ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) { \nlargestDiff = diff ; \n} \n} \nif ( largestDiff < largestX * TOLERANCE ) { \nreturn ; \n} \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9055": "public class RegulaFalsiRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) { \nreturn ; \n} \nif ( m_fFalse < 0 ) { \nm_fXNeg = m_fXFalse ; \nm_fNeg = m_fFalse ; \n} \nelse { \nm_fXPos = m_fXFalse ; \nm_fPos = m_fFalse ; \n} \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) { \nif ( m_fFalse < 0 ) { \nm_bDecreasePos = true ; \n} \nelse { \nm_bDecreaseNeg = true ; \n} \n} \n} \n} \n"}
{"9059": "public class AbstractRootFinder { \npublic void checkInterval ( final float x1 , final float x2 ) throws InvalidIntervalException { \nfinal float y1 = m_aFunction . at ( x1 ) ; \nfinal float y2 = m_aFunction . at ( x2 ) ; \nif ( y1 * y2 > 0 ) { \nthrow new InvalidIntervalException ( ) ; \n} \n} \n} \n"}
{"9063": "public class SecantRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) { \nreturn ; \n} \nm_fXnm1 = m_fXn ; \nm_fXn = m_fXnp1 ; \nm_fFnm1 = m_fFn ; \nm_fFn = m_fFnp1 ; \n} \n} \n"}
{"9067": "public class IEEE754 { \npublic void print ( @ Nonnull final PrintStream aPW ) { \naPW . println ( \"------------------------------\" ) ; \nif ( isDouble ( ) ) { \naPW . println ( \"double value = \" + doubleValue ( ) ) ; \n} \nelse { \naPW . println ( \"float value = \" + floatValue ( ) ) ; \n} \naPW . print ( \"sign=\" + signBit ( ) ) ; \naPW . print ( \", exponent=\" + exponentBits ( ) + \" (biased=\" + biasedExponent ( ) ) ; \nif ( isZero ( ) ) { \naPW . println ( \", zero)\" ) ; \n} \nelse if ( isExponentReserved ( ) ) { \naPW . println ( \", reserved)\" ) ; \n} \nelse if ( isDenormalized ( ) ) { \naPW . println ( \", denormalized, use \" + unbiasedExponent ( ) + \")\" ) ; \n} \nelse { \naPW . println ( \", normalized, unbiased=\" + unbiasedExponent ( ) + \")\" ) ; \n} \naPW . println ( \"significand=\" + significandBits ( ) ) ; \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \nfor ( int j = 0 ; \nj < 12 ; \n++ j ) { \nsum += GENERATOR . nextFloat ( ) ; \n} \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( int i = 2 ; \ni <= n ; \n++ i ) { \nsieve [ i ] = true ; \n} \nint prime = 2 ; \nwhile ( prime < halfN ) { \nfor ( int composite = prime << 1 ; \ncomposite <= n ; \ncomposite += prime ) { \nsieve [ composite ] = false ; \n} \nwhile ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9078": "public class BisectionRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) { \nreturn ; \n} \nif ( m_fMid < 0 ) { \nm_fXNeg = m_fXMid ; \nm_fNeg = m_fMid ; \n} \nelse { \nm_fXPos = m_fXMid ; \nm_fPos = m_fMid ; \n} \n} \n} \n"}
{"9082": "public class Calabash { \npublic void setConfiguration ( File configFile ) { \nif ( configFile == null ) { \nnextConfig = null ; \n} \nelse { \ntry { \nXProcConfiguration config = new XProcConfiguration ( \"he\" , false ) ; \nnextConfig = config . getProcessor ( ) . newDocumentBuilder ( ) . build ( new SAXSource ( new InputSource ( new FileReader ( configFile ) ) ) ) ; \n} \ncatch ( FileNotFoundException e ) { \nthrow new IllegalArgumentException ( \"Config file does not exist\" , e ) ; \n} \ncatch ( SaxonApiException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n} \n"}
{"9091": "public class GeocodeRequestBuilder { \npublic GeocodeRequestBuilder componenets ( Map < String , String > components ) { \nStringBuffer filters = new StringBuffer ( ) ; \nfor ( Iterator < Map . Entry < String , String > > iterator = components . entrySet ( ) . iterator ( ) ; \niterator . hasNext ( ) ; \n) { \nMap . Entry < String , String > entry = iterator . next ( ) ; \nfilters . append ( entry . getKey ( ) + \":\" + entry . getValue ( ) != null ? entry . getValue ( ) . replace ( ' ' , '+' ) : entry . getValue ( ) ) ; \nif ( iterator . hasNext ( ) ) { \nfilters . append ( \"|\" ) ; \n} \n} \nparameters . put ( \"components\" , filters . toString ( ) ) ; \nreturn this ; \n} \n} \n"}
{"9250": "public class LazyMap { \nprivate Map < K , V > createImplementation ( ) { \nif ( delegate instanceof HashMap == false ) { \nreturn new HashMap < K , V > ( delegate ) ; \n} \nreturn delegate ; \n} \n} \n"}
{"9256": "public class WeakTypeCache { \n@ SuppressWarnings ( { \n\"unchecked\" , \"cast\" } \n) public T get ( Type type ) { \nif ( type == null ) { \nthrow new IllegalArgumentException ( \"Null type\" ) ; \n} \nif ( type instanceof ParameterizedType ) { \nreturn getParameterizedType ( ( ParameterizedType ) type ) ; \n} \nelse if ( type instanceof Class ) { \nreturn getClass ( ( Class < ? > ) type ) ; \n} \nelse if ( type instanceof TypeVariable ) { \nreturn ( T ) getTypeVariable ( ( TypeVariable ) type ) ; \n} \nelse if ( type instanceof GenericArrayType ) { \nreturn getGenericArrayType ( ( GenericArrayType ) type ) ; \n} \nelse if ( type instanceof WildcardType ) { \nreturn getWildcardType ( ( WildcardType ) type ) ; \n} \nelse { \nthrow new UnsupportedOperationException ( \"Unknown type: \" + type + \" class=\" + type . getClass ( ) ) ; \n} \n} \n} \n"}
{"9257": "public class WeakTypeCache { \nprotected T getParameterizedType ( ParameterizedType type ) { \nT result = peek ( type ) ; \nif ( result != null ) { \nreturn result ; \n} \nresult = instantiate ( type ) ; \nput ( type , result ) ; \ngenerate ( type , result ) ; \nreturn result ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( startTimeout > 0l && runTime >= startTimeout ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( state == TASK_STOPPED ) { \nstopped = true ; \n} \nelse { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) { \nstateLock . notifyAll ( ) ; \n} \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) { \nstateLock . notifyAll ( ) ; \n} \n} \n} \n} \n"}
{"9263": "public class BasicTaskWrapper { \nprotected void setTask ( Task task ) { \nif ( task == null ) { \nthrow new IllegalArgumentException ( \"Null task\" ) ; \n} \nthis . task = task ; \nthis . taskString = task . toString ( ) ; \nthis . startTime = System . currentTimeMillis ( ) ; \nthis . waitType = task . getWaitType ( ) ; \nthis . priority = task . getPriority ( ) ; \nthis . startTimeout = task . getStartTimeout ( ) ; \nthis . completionTimeout = task . getCompletionTimeout ( ) ; \n} \n} \n"}
{"9265": "public class BasicTaskWrapper { \nprotected boolean taskRejected ( RuntimeException e ) { \ntry { \ntask . rejected ( getElapsedTime ( ) , e ) ; \nreturn true ; \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'rejected' for task: \" + taskString , t ) ; \nif ( e != null ) { \nlog . warn ( \"Original reason for rejection of task: \" + taskString , e ) ; \n} \nreturn false ; \n} \n} \n} \n"}
{"9267": "public class BasicTaskWrapper { \nprotected boolean taskCompleted ( Throwable throwable ) { \ntry { \ntask . completed ( getElapsedTime ( ) , throwable ) ; \nreturn true ; \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'completed' for task: \" + taskString , t ) ; \nif ( throwable != null ) { \nlog . warn ( \"Original error during 'run' for task: \" + taskString , throwable ) ; \n} \nreturn false ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) { \nparsePendingCatalogs ( ) ; \n} \n} \n} \n"}
{"9292": "public class SoftValueRef { \nstatic < K , V > SoftValueRef < K , V > create ( K key , V val , ReferenceQueue < V > q ) { \nif ( val == null ) { \nreturn null ; \n} \nelse { \nreturn new SoftValueRef < K , V > ( key , val , q ) ; \n} \n} \n} \n"}
{"9294": "public class ThrowableHandler { \npublic static void add ( int type , Throwable t ) { \nif ( t == null ) { \nreturn ; \n} \ntry { \nfireOnThrowable ( type , t ) ; \n} \ncatch ( Throwable bad ) { \nSystem . err . println ( \"Unable to handle throwable: \" + t + \" because of:\" ) ; \nbad . printStackTrace ( ) ; \n} \n} \n} \n"}
{"9295": "public class LazyList { \nprivate List < T > createImplementation ( ) { \nif ( delegate instanceof ArrayList == false ) { \nreturn new ArrayList < T > ( delegate ) ; \n} \nreturn delegate ; \n} \n} \n"}
{"9296": "public class TimerTask { \npublic int compareTo ( Object other ) { \nif ( other == this ) { \nreturn 0 ; \n} \nTimerTask t = ( TimerTask ) other ; \nlong diff = getNextExecutionTime ( ) - t . getNextExecutionTime ( ) ; \nreturn ( int ) diff ; \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \n-- size ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \n-- size ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) { \nreturn res ; \n} \nlong t = queue [ index ] . time ; \nint c = index << 1 ; \nwhile ( c <= size ) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( c + 1 <= size ) { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( l . time <= r . time ) { \nif ( t <= l . time ) { \nbreak ; \n} \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nif ( t <= r . time ) { \nbreak ; \n} \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \n} \nelse { \nif ( t <= l . time ) { \nbreak ; \n} \nswap ( index , c ) ; \nindex = c ; \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9308": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl cleanupTimeoutExtImpl ( TimeoutExtImpl timeout ) { \nif ( timeout != null ) { \ntimeout . target = null ; \n} \nreturn null ; \n} \n} \n"}
{"9309": "public class DelegatingClassLoader { \nprotected Class < ? > loadClass ( String className , boolean resolve ) throws ClassNotFoundException { \nif ( standard ) { \nreturn super . loadClass ( className , resolve ) ; \n} \nClass < ? > clazz = null ; \ntry { \nclazz = parent . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException e ) { \nclazz = findLoadedClass ( className ) ; \nif ( clazz == null ) { \nthrow e ; \n} \n} \nif ( resolve ) { \nresolveClass ( clazz ) ; \n} \nreturn clazz ; \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) { \nreturn handler ; \n} \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) { \nreturn null ; \n} \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( int p = 0 ; \np < handlerPkgs . length ; \np ++ ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9312": "public class URLStreamHandlerFactory { \nprivate synchronized void checkHandlerPkgs ( ) { \nString handlerPkgsProp = System . getProperty ( \"java.protocol.handler.pkgs\" ) ; \nif ( handlerPkgsProp != null && handlerPkgsProp . equals ( lastHandlerPkgs ) == false ) { \nStringTokenizer tokeninzer = new StringTokenizer ( handlerPkgsProp , \"|\" ) ; \nArrayList < String > tmp = new ArrayList < String > ( ) ; \nwhile ( tokeninzer . hasMoreTokens ( ) ) { \nString pkg = tokeninzer . nextToken ( ) . intern ( ) ; \nif ( tmp . contains ( pkg ) == false ) { \ntmp . add ( pkg ) ; \n} \n} \nif ( tmp . contains ( PACKAGE_PREFIX ) == false ) { \ntmp . add ( PACKAGE_PREFIX ) ; \n} \nhandlerPkgs = new String [ tmp . size ( ) ] ; \ntmp . toArray ( handlerPkgs ) ; \nlastHandlerPkgs = handlerPkgsProp ; \n} \n} \n} \n"}
{"9314": "public class LazySet { \nprivate Set < T > createImplementation ( ) { \nif ( delegate instanceof HashSet == false ) { \nreturn new HashSet < T > ( delegate ) ; \n} \nreturn delegate ; \n} \n} \n"}
{"9318": "public class NotifyingBufferedOutputStream { \npublic void checkNotification ( int result ) { \nchunk += result ; \nif ( chunk >= chunkSize ) { \nif ( listener != null ) { \nlistener . onStreamNotification ( this , chunk ) ; \n} \nchunk = 0 ; \n} \n} \n} \n"}
{"9321": "public class Strings { \npublic static String subst ( final StringBuffer buff , final String string , final Map map , final String beginToken , final String endToken ) { \nint begin = 0 , rangeEnd = 0 ; \nRange range ; \nwhile ( ( range = rangeOf ( beginToken , endToken , string , rangeEnd ) ) != null ) { \nbuff . append ( string . substring ( begin , range . begin ) ) ; \nString key = string . substring ( range . begin + beginToken . length ( ) , range . end ) ; \nObject value = map . get ( key ) ; \nif ( value == null ) { \nvalue = EMPTY ; \n} \nbuff . append ( value ) ; \nbegin = range . end + endToken . length ( ) ; \nrangeEnd = begin ; \n} \nbuff . append ( string . substring ( begin , string . length ( ) ) ) ; \nreturn buff . toString ( ) ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) { \nend = string . length ( ) ; \n} \nif ( end == 0 ) { \nstrings [ i ] = EMPTY ; \n} \nelse { \nstrings [ i ] = string . substring ( begin , end ) ; \n} \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9324": "public class Strings { \npublic static final void defaultToString ( JBossStringBuilder buffer , Object object ) { \nif ( object == null ) { \nbuffer . append ( \"null\" ) ; \n} \nelse { \nbuffer . append ( object . getClass ( ) . getName ( ) ) ; \nbuffer . append ( '@' ) ; \nbuffer . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; \n} \n} \n} \n"}
{"9326": "public class TimedCachePolicy { \npublic void create ( ) { \nif ( threadSafe ) { \nentryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \n} \nelse { \nentryMap = new HashMap ( ) ; \n} \nnow = System . currentTimeMillis ( ) ; \n} \n} \n"}
{"9327": "public class TimedCachePolicy { \npublic Object get ( Object key ) { \nTimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; \nif ( entry == null ) { \nreturn null ; \n} \nif ( entry . isCurrent ( now ) == false ) { \nif ( entry . refresh ( ) == false ) { \nentry . destroy ( ) ; \nentryMap . remove ( key ) ; \nreturn null ; \n} \n} \nObject value = entry . getValue ( ) ; \nreturn value ; \n} \n} \n"}
{"9328": "public class TimedCachePolicy { \npublic Object peek ( Object key ) { \nTimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; \nObject value = null ; \nif ( entry != null ) { \nvalue = entry . getValue ( ) ; \n} \nreturn value ; \n} \n} \n"}
{"9329": "public class TimedCachePolicy { \npublic void remove ( Object key ) { \nTimedEntry entry = ( TimedEntry ) entryMap . remove ( key ) ; \nif ( entry != null ) { \nentry . destroy ( ) ; \n} \n} \n} \n"}
{"9330": "public class TimedCachePolicy { \npublic void flush ( ) { \nMap tmpMap = null ; \nsynchronized ( this ) { \ntmpMap = entryMap ; \nif ( threadSafe ) { \nentryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \n} \nelse { \nentryMap = new HashMap ( ) ; \n} \n} \nIterator iter = tmpMap . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nTimedEntry entry = ( TimedEntry ) iter . next ( ) ; \nentry . destroy ( ) ; \n} \ntmpMap . clear ( ) ; \n} \n} \n"}
{"9331": "public class TimedCachePolicy { \npublic List getValidKeys ( ) { \nArrayList validKeys = new ArrayList ( ) ; \nsynchronized ( entryMap ) { \nIterator iter = entryMap . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nTimedEntry value = ( TimedEntry ) entry . getValue ( ) ; \nif ( value . isCurrent ( now ) == true ) { \nvalidKeys . add ( entry . getKey ( ) ) ; \n} \n} \n} \nreturn validKeys ; \n} \n} \n"}
{"9332": "public class TimedCachePolicy { \npublic synchronized void setResolution ( int resolution ) { \nif ( resolution <= 0 ) { \nresolution = 60 ; \n} \nif ( resolution != this . resolution ) { \nthis . resolution = resolution ; \ntheTimer . cancel ( ) ; \ntheTimer = new ResolutionTimer ( ) ; \nresolutionTimer . scheduleAtFixedRate ( theTimer , 0 , 1000 * resolution ) ; \n} \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) { \nreturn null ; \n} \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) { \nreturn defaultStr ; \n} \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9341": "public class BasicThreadPool { \npublic void setBlockingMode ( String name ) { \nblockingMode = BlockingMode . toBlockingMode ( name ) ; \nif ( blockingMode == null ) { \nblockingMode = BlockingMode . ABORT ; \n} \n} \n} \n"}
{"9342": "public class BasicThreadPool { \npublic void setBlockingModeString ( String name ) { \nblockingMode = BlockingMode . toBlockingMode ( name ) ; \nif ( blockingMode == null ) { \nblockingMode = BlockingMode . ABORT ; \n} \n} \n} \n"}
{"9343": "public class BasicThreadPool { \nprotected void execute ( TaskWrapper wrapper ) { \nif ( trace ) { \nlog . trace ( \"execute, wrapper=\" + wrapper ) ; \n} \ntry { \nexecutor . execute ( wrapper ) ; \n} \ncatch ( Throwable t ) { \nwrapper . rejectTask ( new ThreadPoolFullException ( \"Error scheduling work: \" + wrapper , t ) ) ; \n} \n} \n} \n"}
{"9357": "public class FileURLConnection { \npublic void connect ( ) throws IOException { \nif ( connected ) { \nreturn ; \n} \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . getPath ( ) ) ; \n} \nconnected = true ; \n} \n} \n"}
{"9360": "public class Node { \nvoid helpDelete ( Node < K , V > b , Node < K , V > f ) { \nif ( f == next && this == b . next ) { \nif ( f == null || f . value != f ) { \nappendMarker ( f ) ; \n} \nelse { \nb . casNext ( this , f . next ) ; \n} \n} \n} \n} \n"}
{"9361": "public class Node { \nV getValidValue ( ) { \nObject v = value ; \nif ( v == this || v == BASE_HEADER ) { \nreturn null ; \n} \nreturn ( V ) v ; \n} \n} \n"}
{"9362": "public class Node { \nSnapshotEntry < K , V > createSnapshot ( ) { \nV v = getValidValue ( ) ; \nif ( v == null ) { \nreturn null ; \n} \nreturn new SnapshotEntry ( key , v ) ; \n} \n} \n"}
{"9365": "public class JBossObject { \npublic static void list ( JBossStringBuilder buffer , Collection objects ) { \nif ( objects == null ) { \nreturn ; \n} \nbuffer . append ( '[' ) ; \nif ( objects . isEmpty ( ) == false ) { \nfor ( Iterator i = objects . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nObject object = i . next ( ) ; \nif ( object instanceof JBossObject ) { \n( ( JBossObject ) object ) . toShortString ( buffer ) ; \n} \nelse { \nbuffer . append ( object . toString ( ) ) ; \n} \nif ( i . hasNext ( ) ) { \nbuffer . append ( \", \" ) ; \n} \n} \n} \nbuffer . append ( ']' ) ; \n} \n} \n"}
{"9366": "public class JBossObject { \npublic String getClassShortName ( ) { \nString longName = getClass ( ) . getName ( ) ; \nint dot = longName . lastIndexOf ( '.' ) ; \nif ( dot != - 1 ) { \nreturn longName . substring ( dot + 1 ) ; \n} \nreturn longName ; \n} \n} \n"}
{"9368": "public class PropertyManager { \npublic static Iterator names ( ) { \nSecurityManager sm = System . getSecurityManager ( ) ; \nif ( sm != null ) { \nsm . checkPropertiesAccess ( ) ; \n} \nreturn props . names ( ) ; \n} \n} \n"}
{"9369": "public class PropertyManager { \npublic static PropertyGroup getPropertyGroup ( final String basename ) { \nSecurityManager sm = System . getSecurityManager ( ) ; \nif ( sm != null ) { \nsm . checkPropertiesAccess ( ) ; \n} \nreturn props . getPropertyGroup ( basename ) ; \n} \n} \n"}
{"9372": "public class Objects { \npublic static < T > T deref ( final Object obj , Class < T > expected ) { \nObject result = deref ( obj ) ; \nif ( result == null ) { \nreturn null ; \n} \nreturn expected . cast ( result ) ; \n} \n} \n"}
{"9373": "public class PropertyMap { \nprivate void init ( ) { \nunboundListeners = Collections . synchronizedList ( new ArrayList ( ) ) ; \nboundListeners = Collections . synchronizedMap ( new HashMap ( ) ) ; \njndiMap = new HashMap ( ) ; \nPrivilegedAction action = new PrivilegedAction ( ) { \npublic Object run ( ) { \nObject value = System . getProperty ( Context . PROVIDER_URL ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . PROVIDER_URL , value ) ; \nvalue = System . getProperty ( Context . INITIAL_CONTEXT_FACTORY ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . INITIAL_CONTEXT_FACTORY , value ) ; \nvalue = System . getProperty ( Context . OBJECT_FACTORIES ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . OBJECT_FACTORIES , value ) ; \nvalue = System . getProperty ( Context . URL_PKG_PREFIXES ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . URL_PKG_PREFIXES , value ) ; \nvalue = System . getProperty ( Context . STATE_FACTORIES ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . STATE_FACTORIES , value ) ; \nvalue = System . getProperty ( Context . DNS_URL ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( Context . DNS_URL , value ) ; \nvalue = System . getProperty ( LdapContext . CONTROL_FACTORIES ) ; \nif ( value == null ) { \nvalue = NULL_VALUE ; \n} \njndiMap . put ( LdapContext . CONTROL_FACTORIES , value ) ; \nreturn null ; \n} \n} \n; \nAccessController . doPrivileged ( action ) ; \n} \n} \n"}
{"9374": "public class PropertyMap { \nprivate void updateJndiCache ( String name , String value ) { \nif ( name == null ) { \nreturn ; \n} \nboolean isJndiProperty = name . equals ( Context . PROVIDER_URL ) || name . equals ( Context . INITIAL_CONTEXT_FACTORY ) || name . equals ( Context . OBJECT_FACTORIES ) || name . equals ( Context . URL_PKG_PREFIXES ) || name . equals ( Context . STATE_FACTORIES ) || name . equals ( Context . DNS_URL ) || name . equals ( LdapContext . CONTROL_FACTORIES ) ; \nif ( isJndiProperty == true ) { \njndiMap . put ( name , value ) ; \n} \n} \n} \n"}
{"9377": "public class PropertyMap { \npublic boolean removePropertyListener ( PropertyListener listener ) { \nif ( listener == null ) { \nthrow new NullArgumentException ( \"listener\" ) ; \n} \nboolean removed = false ; \nif ( listener instanceof BoundPropertyListener ) { \nremoved = removePropertyListener ( ( BoundPropertyListener ) listener ) ; \n} \nelse { \nremoved = unboundListeners . remove ( listener ) ; \n} \nreturn removed ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) { \nreturn ; \n} \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \n} \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) { \nreturn ; \n} \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \n} \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) { \nreturn ; \n} \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \n} \n} \n} \n"}
{"9383": "public class PropertyMap { \npublic void load ( PropertyReader reader ) throws PropertyException , IOException { \nif ( reader == null ) { \nthrow new NullArgumentException ( \"reader\" ) ; \n} \nload ( reader . readProperties ( ) ) ; \n} \n} \n"}
{"9384": "public class PropertyMap { \npublic void load ( String className ) throws PropertyException , IOException { \nif ( className == null ) { \nthrow new NullArgumentException ( \"className\" ) ; \n} \nPropertyReader reader = null ; \ntry { \nClass type = Class . forName ( className ) ; \nreader = ( PropertyReader ) type . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new PropertyException ( e ) ; \n} \nload ( reader ) ; \n} \n} \n"}
{"9387": "public class JBossEntityResolver { \nprotected InputSource resolveSystemID ( String systemId , boolean trace ) { \nif ( systemId == null ) { \nreturn null ; \n} \nif ( trace ) { \nlog . trace ( \"resolveSystemID, systemId=\" + systemId ) ; \n} \nInputSource inputSource = null ; \nString filename = null ; \nif ( localEntities != null ) { \nfilename = ( String ) localEntities . get ( systemId ) ; \n} \nif ( filename == null ) { \nfilename = ( String ) entities . get ( systemId ) ; \n} \nif ( filename != null ) { \nif ( trace ) { \nlog . trace ( \"Found entity systemId=\" + systemId + \" fileName=\" + filename ) ; \n} \nInputStream ins = loadClasspathResource ( filename , trace ) ; \nif ( ins != null ) { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nelse { \nlog . warn ( \"Cannot load systemId from resource: \" + filename ) ; \n} \n} \nreturn inputSource ; \n} \n} \n"}
{"9388": "public class JBossEntityResolver { \nprotected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { \nif ( systemId == null ) { \nreturn null ; \n} \nif ( trace ) { \nlog . trace ( \"resolveSystemIDasURL, systemId=\" + systemId ) ; \n} \nInputSource inputSource = null ; \ntry { \nif ( trace ) { \nlog . trace ( \"Trying to resolve systemId as a URL\" ) ; \n} \nif ( isReplaceSystemProperties ( ) ) { \nsystemId = StringPropertyReplacer . replaceProperties ( systemId ) ; \n} \nURL url = new URL ( systemId ) ; \nif ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( \"file\" ) == false && url . getProtocol ( ) . equalsIgnoreCase ( \"vfszip\" ) == false ) { \nlog . warn ( \"Trying to resolve systemId as a non-file URL: \" + systemId ) ; \n} \nInputStream ins = url . openStream ( ) ; \nif ( ins != null ) { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nelse { \nlog . warn ( \"Cannot load systemId as URL: \" + systemId ) ; \n} \nif ( trace ) { \nlog . trace ( \"Resolved systemId as a URL\" ) ; \n} \n} \ncatch ( MalformedURLException ignored ) { \nif ( trace ) { \nlog . trace ( \"SystemId is not a url: \" + systemId , ignored ) ; \n} \n} \ncatch ( IOException e ) { \nif ( trace ) { \nlog . trace ( \"Failed to obtain URL.InputStream from systemId: \" + systemId , e ) ; \n} \n} \nreturn inputSource ; \n} \n} \n"}
{"9389": "public class JBossEntityResolver { \nprotected InputSource resolveClasspathName ( String systemId , boolean trace ) { \nif ( systemId == null ) { \nreturn null ; \n} \nif ( trace ) { \nlog . trace ( \"resolveClasspathName, systemId=\" + systemId ) ; \n} \nString filename = systemId ; \ntry { \nURI url = new URI ( systemId ) ; \nString path = url . getPath ( ) ; \nif ( path == null ) { \npath = url . getSchemeSpecificPart ( ) ; \n} \nint slash = path . lastIndexOf ( '/' ) ; \nif ( slash >= 0 ) { \nfilename = path . substring ( slash + 1 ) ; \n} \nelse { \nfilename = path ; \n} \nif ( filename . length ( ) == 0 ) { \nreturn null ; \n} \nif ( trace ) { \nlog . trace ( \"Mapped systemId to filename: \" + filename ) ; \n} \n} \ncatch ( URISyntaxException e ) { \nif ( trace ) { \nlog . trace ( \"systemId: is not a URI, using systemId as resource\" , e ) ; \n} \n} \nInputStream is = loadClasspathResource ( filename , trace ) ; \nInputSource inputSource = null ; \nif ( is != null ) { \ninputSource = new InputSource ( is ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9395": "public class StopWatch { \npublic void start ( final boolean reset ) { \nif ( ! running ) { \nif ( reset ) { \nreset ( ) ; \n} \nstart = System . currentTimeMillis ( ) ; \nrunning = true ; \n} \n} \n} \n"}
{"9406": "public class Graph { \npublic void setRootVertex ( Vertex < T > root ) { \nthis . rootVertex = root ; \nif ( verticies . containsValue ( root ) == false ) { \naddVertex ( root ) ; \n} \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) { \nreturn false ; \n} \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) { \nrootVertex = null ; \n} \nfor ( int n = 0 ; \nn < v . getOutgoingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \n} \nfor ( int n = 0 ; \nn < v . getIncomingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \n} \nreturn true ; \n} \n} \n"}
{"9408": "public class Graph { \npublic void depthFirstSearch ( Vertex < T > v , final Visitor < T > visitor ) { \nVisitorEX < T , RuntimeException > wrapper = new VisitorEX < T , RuntimeException > ( ) { \npublic void visit ( Graph < T > g , Vertex < T > v ) throws RuntimeException { \nif ( visitor != null ) { \nvisitor . visit ( g , v ) ; \n} \n} \n} \n; \nthis . depthFirstSearch ( v , wrapper ) ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) { \nvisitor . visit ( this , v ) ; \n} \nfor ( int i = 0 ; \ni < v . getOutgoingEdgeCount ( ) ; \ni ++ ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) { \nvisitor . visit ( this , v , e ) ; \n} \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \n} \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nint colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( colIndex > 0 ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( \"xmlns\" . equals ( prefix ) ) { \nnamespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \n} \nelse { \nElement nsElement = el ; \nwhile ( namespaceURI . equals ( \"\" ) && nsElement != null ) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) { \nnsElement = getParentElement ( nsElement ) ; \n} \n} \n} \nif ( namespaceURI . equals ( \"\" ) ) { \nthrow new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9420": "public class DOMUtils { \npublic static Iterator getChildElements ( Node node ) { \nArrayList list = new ArrayList ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { \nlist . add ( child ) ; \n} \n} \nreturn list . iterator ( ) ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null && replaceProps ) { \ntext = StringPropertyReplacer . replaceProperties ( text ) ; \n} \nreturn text ; \n} \n} \n"}
{"9429": "public class SystemPropertyClassValue { \npublic static Throwable setSystemPropertyClassValue ( String property , String className ) { \nif ( property == null || property . trim ( ) . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"Null or empty property\" ) ; \n} \nif ( className == null || className . trim ( ) . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"Null or empty class name\" ) ; \n} \ntry { \nThread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; \n} \ncatch ( Throwable problem ) { \nreturn problem ; \n} \nSystem . setProperty ( property , className ) ; \nreturn null ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nu < length ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) { \nparent = parent . getParent ( ) ; \n} \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse { \nresults . append ( \"\\n++++Null CodeSource\" ) ; \n} \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < ifaces . length ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse { \nresults . append ( \"\\n++++Null CodeSource\" ) ; \n} \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) { \nbuffer . append ( \"**null**\" ) ; \n} \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( int i = 0 ; \ni < intfs . length ; \n++ i ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) { \nbuffer . append ( \", \" ) ; \n} \n} \n} \nbuffer . append ( \"}\" ) ; \n} \n} \n} \n"}
{"9432": "public class Classes { \npublic static String stripPackageName ( final String classname ) { \nint idx = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; \nif ( idx != - 1 ) { \nreturn classname . substring ( idx + 1 , classname . length ( ) ) ; \n} \nreturn classname ; \n} \n} \n"}
{"9433": "public class Classes { \npublic static String getPackageName ( final String classname ) { \nif ( classname . length ( ) == 0 ) { \nthrow new EmptyStringException ( ) ; \n} \nint index = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; \nif ( index != - 1 ) { \nreturn classname . substring ( 0 , index ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) { \nthrow new NullArgumentException ( \"type\" ) ; \n} \nif ( type . isPrimitive ( ) ) { \nreturn ; \n} \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) { \nthrow new IllegalArgumentException ( \"type is not a primitive class\" ) ; \n} \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) { \nreturn PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \n} \n} \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9439": "public class Classes { \npublic static Object instantiate ( Class expected , String property , String defaultClassName ) { \nString className = getProperty ( property , defaultClassName ) ; \nClass clazz = null ; \ntry { \nclazz = loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new NestedRuntimeException ( \"Cannot load class \" + className , e ) ; \n} \nObject result = null ; \ntry { \nresult = clazz . newInstance ( ) ; \n} \ncatch ( InstantiationException e ) { \nthrow new NestedRuntimeException ( \"Error instantiating \" + className , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new NestedRuntimeException ( \"Error instantiating \" + className , e ) ; \n} \nif ( expected . isAssignableFrom ( clazz ) == false ) { \nthrow new NestedRuntimeException ( \"Class \" + className + \" from classloader \" + clazz . getClassLoader ( ) + \" is not of the expected class \" + expected + \" loaded from \" + expected . getClassLoader ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) { \nreturn true ; \n} \nwhile ( next == null ) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) { \nthrow new java . util . NoSuchElementException ( ) ; \n} \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9450": "public class PropertyGroup { \nprotected boolean removePropertyListener ( final BoundPropertyListener listener ) { \nString name = makePropertyName ( listener . getPropertyName ( ) ) ; \nList list = ( List ) boundListeners . get ( name ) ; \nboolean removed = false ; \nif ( list != null ) { \nremoved = list . remove ( listener ) ; \nif ( removed ) { \nlistener . propertyUnbound ( this ) ; \n} \n} \nreturn removed ; \n} \n} \n"}
{"9451": "public class PropertyEditors { \npublic static final boolean isNull ( final String value , final boolean trim , final boolean empty ) { \nif ( disableIsNull ) { \nreturn false ; \n} \nif ( value == null ) { \nreturn true ; \n} \nString trimmed = trim ? value . trim ( ) : value ; \nif ( empty && trimmed . length ( ) == 0 ) { \nreturn true ; \n} \nreturn NULL . equalsIgnoreCase ( trimmed ) ; \n} \n} \n"}
{"9457": "public class TimeoutFactory { \npublic Timeout schedule ( long time , TimeoutTarget target ) { \nif ( cancelled . get ( ) ) { \nthrow new IllegalStateException ( \"TimeoutFactory has been cancelled\" ) ; \n} \nif ( time < 0 ) { \nthrow new IllegalArgumentException ( \"Negative time\" ) ; \n} \nif ( target == null ) { \nthrow new IllegalArgumentException ( \"Null timeout target\" ) ; \n} \nreturn queue . offer ( time , target ) ; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \n++ i ) { \nif ( i > 0 ) { \nbuffer . append ( \", \" ) ; \n} \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n} \nbuffer . append ( \"}]\" ) ; \n} \n} \n"}
{"9465": "public class CatalogManager { \nprivate int queryVerbosity ( ) { \nString verbStr = System . getProperty ( pVerbosity ) ; \nif ( verbStr == null ) { \nif ( resources == null ) { \nreadProperties ( ) ; \n} \nif ( resources == null ) { \nreturn defaultVerbosity ; \n} \ntry { \nverbStr = resources . getString ( \"verbosity\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultVerbosity ; \n} \n} \ntry { \nint verb = Integer . parseInt ( verbStr . trim ( ) ) ; \nreturn verb ; \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"Cannot parse verbosity: \\\"\" + verbStr + \"\\\"\" ) ; \nreturn defaultVerbosity ; \n} \n} \n} \n"}
{"9466": "public class CatalogManager { \nprivate boolean queryRelativeCatalogs ( ) { \nif ( resources == null ) { \nreadProperties ( ) ; \n} \nif ( resources == null ) { \nreturn defaultRelativeCatalogs ; \n} \ntry { \nString allow = resources . getString ( \"relative-catalogs\" ) ; \nreturn ( allow . equalsIgnoreCase ( \"true\" ) || allow . equalsIgnoreCase ( \"yes\" ) || allow . equalsIgnoreCase ( \"1\" ) ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultRelativeCatalogs ; \n} \n} \n} \n"}
{"9467": "public class CatalogManager { \nprivate String queryCatalogFiles ( ) { \nString catalogList = System . getProperty ( pFiles ) ; \nfromPropertiesFile = false ; \nif ( catalogList == null ) { \nif ( resources == null ) { \nreadProperties ( ) ; \n} \nif ( resources != null ) { \ntry { \ncatalogList = resources . getString ( \"catalogs\" ) ; \nfromPropertiesFile = true ; \n} \ncatch ( MissingResourceException e ) { \nSystem . err . println ( propertyFile + \": catalogs not found.\" ) ; \ncatalogList = null ; \n} \n} \n} \nif ( catalogList == null ) { \ncatalogList = defaultCatalogFiles ; \n} \nreturn catalogList ; \n} \n} \n"}
{"9469": "public class CatalogManager { \nprivate boolean queryPreferPublic ( ) { \nString prefer = System . getProperty ( pPrefer ) ; \nif ( prefer == null ) { \nif ( resources == null ) { \nreadProperties ( ) ; \n} \nif ( resources == null ) { \nreturn defaultPreferPublic ; \n} \ntry { \nprefer = resources . getString ( \"prefer\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultPreferPublic ; \n} \n} \nif ( prefer == null ) { \nreturn defaultPreferPublic ; \n} \nreturn ( prefer . equalsIgnoreCase ( \"public\" ) ) ; \n} \n} \n"}
{"9470": "public class CatalogManager { \nprivate boolean queryUseStaticCatalog ( ) { \nString staticCatalog = System . getProperty ( pStatic ) ; \nif ( useStaticCatalog == null ) { \nif ( resources == null ) { \nreadProperties ( ) ; \n} \nif ( resources == null ) { \nreturn defaultUseStaticCatalog ; \n} \ntry { \nstaticCatalog = resources . getString ( \"static-catalog\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultUseStaticCatalog ; \n} \n} \nif ( staticCatalog == null ) { \nreturn defaultUseStaticCatalog ; \n} \nreturn ( staticCatalog . equalsIgnoreCase ( \"true\" ) || staticCatalog . equalsIgnoreCase ( \"yes\" ) || staticCatalog . equalsIgnoreCase ( \"1\" ) ) ; \n} \n} \n"}
{"9474": "public class MarshalledValueInputStream { \nprotected Class < ? > resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nString className = v . getName ( ) ; \ntry { \nreturn Class . forName ( className , false , loader ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nClass cl = primClasses . get ( className ) ; \nif ( cl == null ) { \nthrow cnfe ; \n} \nelse { \nreturn cl ; \n} \n} \n} \n} \n"}
{"9479": "public class CollectionsUtil { \npublic static List list ( Enumeration e ) { \nArrayList result = new ArrayList ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nresult . add ( e . nextElement ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"9481": "public class FilePropertyReader { \nprotected void loadProperties ( Properties props , String filename ) throws IOException { \nif ( filename == null ) { \nthrow new NullArgumentException ( \"filename\" ) ; \n} \nif ( filename . equals ( \"\" ) ) { \nthrow new IllegalArgumentException ( \"filename\" ) ; \n} \nInputStream in = new BufferedInputStream ( getInputStream ( filename ) ) ; \nprops . load ( in ) ; \nin . close ( ) ; \n} \n} \n"}
{"9483": "public class Vertex { \npublic boolean addEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) { \noutgoingEdges . add ( e ) ; \n} \nelse if ( e . getTo ( ) == this ) { \nincomingEdges . add ( e ) ; \n} \nelse { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9486": "public class Vertex { \npublic boolean hasEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) { \nreturn outgoingEdges . contains ( e ) ; \n} \nelse if ( e . getTo ( ) == this ) { \nreturn incomingEdges . contains ( e ) ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"9487": "public class Vertex { \npublic boolean remove ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) { \noutgoingEdges . remove ( e ) ; \n} \nelse if ( e . getTo ( ) == this ) { \nincomingEdges . remove ( e ) ; \n} \nelse { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9488": "public class Vertex { \npublic Edge < T > findEdge ( Vertex < T > dest ) { \nfor ( Edge < T > e : outgoingEdges ) { \nif ( e . getTo ( ) == dest ) { \nreturn e ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9489": "public class Vertex { \npublic Edge < T > findEdge ( Edge < T > e ) { \nif ( outgoingEdges . contains ( e ) ) { \nreturn e ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9490": "public class Vertex { \npublic int cost ( Vertex < T > dest ) { \nif ( dest == this ) { \nreturn 0 ; \n} \nEdge < T > e = findEdge ( dest ) ; \nint cost = Integer . MAX_VALUE ; \nif ( e != null ) { \ncost = e . getCost ( ) ; \n} \nreturn cost ; \n} \n} \n"}
{"9493": "public class TinyMachine { \npublic void fireEvent ( Object event ) { \nif ( event == null ) { \nthrow new IllegalArgumentException ( \"Event must not be null.\" ) ; \n} \nmTaskQueue . offer ( Task . obtainTask ( Task . CODE_FIRE_EVENT , event , - 1 ) ) ; \nif ( ! mQueueProcessed ) { \nprocessTaskQueue ( ) ; \n} \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) { \nfilter = ACCEPT_ALL_FILTER ; \n} \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) { \nreturn false ; \n} \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) { \nreturn false ; \n} \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9531": "public class CsvUtils { \npublic static String unescapeCsv ( String str ) { \nif ( str == null ) { \nreturn null ; \n} \nif ( ! ( str . charAt ( 0 ) == QUOTE && str . charAt ( str . length ( ) - 1 ) == QUOTE ) ) { \nreturn str ; \n} \nString quoteless = str . substring ( 1 , str . length ( ) - 1 ) ; \nreturn quoteless . replace ( QUOTE_STR + QUOTE_STR , QUOTE_STR ) ; \n} \n} \n"}
{"9532": "public class CsvUtils { \npublic static List < String > getValues ( String csvRow ) { \nList < String > values = new ArrayList < String > ( ) ; \nStringReader in = new StringReader ( csvRow ) ; \nString value ; \ntry { \nvalue = nextValue ( in ) ; \nwhile ( true ) { \nvalues . add ( value ) ; \nvalue = nextValue ( in ) ; \n} \n} \ncatch ( IOException e ) { \nif ( csvRow . lastIndexOf ( ',' ) == csvRow . length ( ) - 1 ) { \nvalues . add ( null ) ; \n} \nreturn values ; \n} \n} \n} \n"}
{"9540": "public class EntityProcessor { \nprivate static BaseDaoModel getBaseDaoClass ( Entity entity ) { \nString qualifiedName = SQLiteDao . class . getName ( ) ; \nTypeMirror typeMirror = getBaseDaoTypeMirror ( entity ) ; \nif ( typeMirror != null ) { \nqualifiedName = typeMirror . toString ( ) ; \n} \nreturn new BaseDaoModel ( qualifiedName ) ; \n} \n} \n"}
{"9788": "public class Summary { \npublic void setScore ( double v ) { \nif ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_score == null ) { \njcasType . jcas . throwFeatMissing ( \"score\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \njcasType . ll_cas . ll_setDoubleValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_score , v ) ; \n} \n} \n"}
{"9789": "public class Summary { \npublic StringList getVariants ( ) { \nif ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_variants == null ) { \njcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_variants ) ) ) ; \n} \n} \n"}
{"9790": "public class Summary { \npublic void setVariants ( StringList v ) { \nif ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_variants == null ) { \njcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9791": "public class Question { \npublic String getQuestionType ( ) { \nif ( Question_Type . featOkTst && ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) { \njcasType . jcas . throwFeatMissing ( \"questionType\" , \"edu.cmu.lti.oaqa.type.input.Question\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType ) ; \n} \n} \n"}
{"9792": "public class Question { \npublic void setQuestionType ( String v ) { \nif ( Question_Type . featOkTst && ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) { \njcasType . jcas . throwFeatMissing ( \"questionType\" , \"edu.cmu.lti.oaqa.type.input.Question\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType , v ) ; \n} \n} \n"}
{"9793": "public class Focus { \npublic Token getToken ( ) { \nif ( Focus_Type . featOkTst && ( ( Focus_Type ) jcasType ) . casFeat_token == null ) { \njcasType . jcas . throwFeatMissing ( \"token\" , \"edu.cmu.lti.oaqa.type.nlp.Focus\" ) ; \n} \nreturn ( Token ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Focus_Type ) jcasType ) . casFeatCode_token ) ) ) ; \n} \n} \n"}
{"9794": "public class Token { \npublic String getDepLabel ( ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) { \njcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel ) ; \n} \n} \n"}
{"9795": "public class Token { \npublic void setDepLabel ( String v ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) { \njcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel , v ) ; \n} \n} \n"}
{"9796": "public class Token { \npublic String getSemanticType ( ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) { \njcasType . jcas . throwFeatMissing ( \"semanticType\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType ) ; \n} \n} \n"}
{"9797": "public class Token { \npublic void setSemanticType ( String v ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) { \njcasType . jcas . throwFeatMissing ( \"semanticType\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType , v ) ; \n} \n} \n"}
{"9798": "public class Document { \npublic StringArray getSections ( ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) { \njcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \nreturn ( StringArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) ) ) ; \n} \n} \n"}
{"9799": "public class Document { \npublic void setSections ( StringArray v ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) { \njcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9800": "public class Document { \npublic String getSections ( int i ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) { \njcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \nreturn jcasType . ll_cas . ll_getStringArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \n} \n} \n"}
{"9801": "public class Document { \npublic void setSections ( int i , String v ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) { \njcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \njcasType . ll_cas . ll_setStringArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i , v ) ; \n} \n} \n"}
{"9802": "public class Concept { \npublic StringList getUris ( ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) { \njcasType . jcas . throwFeatMissing ( \"uris\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris ) ) ) ; \n} \n} \n"}
{"9803": "public class Concept { \npublic void setUris ( StringList v ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) { \njcasType . jcas . throwFeatMissing ( \"uris\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9804": "public class Concept { \npublic FSList getTypes ( ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_types == null ) { \njcasType . jcas . throwFeatMissing ( \"types\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types ) ) ) ; \n} \n} \n"}
{"9805": "public class Concept { \npublic void setTypes ( FSList v ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_types == null ) { \njcasType . jcas . throwFeatMissing ( \"types\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9806": "public class AnswerType { \npublic Annotation getTargetType ( ) { \nif ( AnswerType_Type . featOkTst && ( ( AnswerType_Type ) jcasType ) . casFeat_targetType == null ) { \njcasType . jcas . throwFeatMissing ( \"targetType\" , \"edu.cmu.lti.oaqa.type.answer.AnswerType\" ) ; \n} \nreturn ( Annotation ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( AnswerType_Type ) jcasType ) . casFeatCode_targetType ) ) ) ; \n} \n} \n"}
{"9807": "public class AnswerType { \npublic void setTargetType ( Annotation v ) { \nif ( AnswerType_Type . featOkTst && ( ( AnswerType_Type ) jcasType ) . casFeat_targetType == null ) { \njcasType . jcas . throwFeatMissing ( \"targetType\" , \"edu.cmu.lti.oaqa.type.answer.AnswerType\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AnswerType_Type ) jcasType ) . casFeatCode_targetType , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9808": "public class SearchResult { \npublic int getRank ( ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) { \njcasType . jcas . throwFeatMissing ( \"rank\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank ) ; \n} \n} \n"}
{"9809": "public class SearchResult { \npublic void setRank ( int v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) { \njcasType . jcas . throwFeatMissing ( \"rank\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank , v ) ; \n} \n} \n"}
{"9810": "public class SearchResult { \npublic String getQueryString ( ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_queryString == null ) { \njcasType . jcas . throwFeatMissing ( \"queryString\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_queryString ) ; \n} \n} \n"}
{"9811": "public class SearchResult { \npublic void setQueryString ( String v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_queryString == null ) { \njcasType . jcas . throwFeatMissing ( \"queryString\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_queryString , v ) ; \n} \n} \n"}
{"9812": "public class SearchResult { \npublic FSArray getCandidateAnswers ( ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) { \njcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn ( FSArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) ) ) ; \n} \n} \n"}
{"9813": "public class SearchResult { \npublic void setCandidateAnswers ( FSArray v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) { \njcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9814": "public class SearchResult { \npublic CandidateAnswerVariant getCandidateAnswers ( int i ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) { \njcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ; \nreturn ( CandidateAnswerVariant ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ) ) ; \n} \n} \n"}
{"9815": "public class SearchResult { \npublic void setCandidateAnswers ( int i , CandidateAnswerVariant v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) { \njcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9816": "public class Search { \npublic String getQuery ( ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_query == null ) { \njcasType . jcas . throwFeatMissing ( \"query\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_query ) ; \n} \n} \n"}
{"9817": "public class Search { \npublic void setQuery ( String v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_query == null ) { \njcasType . jcas . throwFeatMissing ( \"query\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_query , v ) ; \n} \n} \n"}
{"9818": "public class Search { \npublic FSArray getHitList ( ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) { \njcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn ( FSArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) ) ) ; \n} \n} \n"}
{"9819": "public class Search { \npublic void setHitList ( FSArray v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) { \njcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9820": "public class Search { \npublic SearchResult getHitList ( int i ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) { \njcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ; \nreturn ( SearchResult ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ) ) ; \n} \n} \n"}
{"9821": "public class Search { \npublic void setHitList ( int i , SearchResult v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) { \njcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9822": "public class Search { \npublic AbstractQuery getAbstractQuery ( ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_abstractQuery == null ) { \njcasType . jcas . throwFeatMissing ( \"abstractQuery\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn ( AbstractQuery ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery ) ) ) ; \n} \n} \n"}
{"9823": "public class Search { \npublic void setAbstractQuery ( AbstractQuery v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_abstractQuery == null ) { \njcasType . jcas . throwFeatMissing ( \"abstractQuery\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9824": "public class Search { \npublic String getSearchId ( ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) { \njcasType . jcas . throwFeatMissing ( \"searchId\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId ) ; \n} \n} \n"}
{"9825": "public class Search { \npublic void setSearchId ( String v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) { \njcasType . jcas . throwFeatMissing ( \"searchId\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId , v ) ; \n} \n} \n"}
{"9826": "public class Passage { \npublic void setDocId ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_docId == null ) { \njcasType . jcas . throwFeatMissing ( \"docId\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_docId , v ) ; \n} \n} \n"}
{"9827": "public class Passage { \npublic int getOffsetInBeginSection ( ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) { \njcasType . jcas . throwFeatMissing ( \"offsetInBeginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection ) ; \n} \n} \n"}
{"9828": "public class Passage { \npublic void setOffsetInBeginSection ( int v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) { \njcasType . jcas . throwFeatMissing ( \"offsetInBeginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection , v ) ; \n} \n} \n"}
{"9829": "public class Passage { \npublic int getOffsetInEndSection ( ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) { \njcasType . jcas . throwFeatMissing ( \"offsetInEndSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection ) ; \n} \n} \n"}
{"9830": "public class Passage { \npublic void setOffsetInEndSection ( int v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) { \njcasType . jcas . throwFeatMissing ( \"offsetInEndSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection , v ) ; \n} \n} \n"}
{"9831": "public class Passage { \npublic String getBeginSection ( ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) { \njcasType . jcas . throwFeatMissing ( \"beginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection ) ; \n} \n} \n"}
{"9832": "public class Passage { \npublic void setBeginSection ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) { \njcasType . jcas . throwFeatMissing ( \"beginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection , v ) ; \n} \n} \n"}
{"9833": "public class Passage { \npublic String getEndSection ( ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_endSection == null ) { \njcasType . jcas . throwFeatMissing ( \"endSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_endSection ) ; \n} \n} \n"}
{"9834": "public class Passage { \npublic void setEndSection ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_endSection == null ) { \njcasType . jcas . throwFeatMissing ( \"endSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_endSection , v ) ; \n} \n} \n"}
{"9835": "public class Passage { \npublic String getAspects ( ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_aspects == null ) { \njcasType . jcas . throwFeatMissing ( \"aspects\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_aspects ) ; \n} \n} \n"}
{"9836": "public class Passage { \npublic void setAspects ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_aspects == null ) { \njcasType . jcas . throwFeatMissing ( \"aspects\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_aspects , v ) ; \n} \n} \n"}
{"9837": "public class TripleSearchResult { \npublic Triple getTriple ( ) { \nif ( TripleSearchResult_Type . featOkTst && ( ( TripleSearchResult_Type ) jcasType ) . casFeat_triple == null ) { \njcasType . jcas . throwFeatMissing ( \"triple\" , \"edu.cmu.lti.oaqa.type.retrieval.TripleSearchResult\" ) ; \n} \nreturn ( Triple ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple ) ) ) ; \n} \n} \n"}
{"9838": "public class TripleSearchResult { \npublic void setTriple ( Triple v ) { \nif ( TripleSearchResult_Type . featOkTst && ( ( TripleSearchResult_Type ) jcasType ) . casFeat_triple == null ) { \njcasType . jcas . throwFeatMissing ( \"triple\" , \"edu.cmu.lti.oaqa.type.retrieval.TripleSearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9839": "public class PassageFromRelation { \npublic Triple getSourceRelation ( ) { \nif ( PassageFromRelation_Type . featOkTst && ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) { \njcasType . jcas . throwFeatMissing ( \"sourceRelation\" , \"edu.cmu.lti.oaqa.type.retrieval.PassageFromRelation\" ) ; \n} \nreturn ( Triple ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation ) ) ) ; \n} \n} \n"}
{"9840": "public class PassageFromRelation { \npublic void setSourceRelation ( Triple v ) { \nif ( PassageFromRelation_Type . featOkTst && ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) { \njcasType . jcas . throwFeatMissing ( \"sourceRelation\" , \"edu.cmu.lti.oaqa.type.retrieval.PassageFromRelation\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9841": "public class Triple { \npublic String getSubject ( ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) { \njcasType . jcas . throwFeatMissing ( \"subject\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject ) ; \n} \n} \n"}
{"9842": "public class Triple { \npublic void setSubject ( String v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) { \njcasType . jcas . throwFeatMissing ( \"subject\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject , v ) ; \n} \n} \n"}
{"9843": "public class Triple { \npublic String getPredicate ( ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_predicate == null ) { \njcasType . jcas . throwFeatMissing ( \"predicate\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_predicate ) ; \n} \n} \n"}
{"9844": "public class Triple { \npublic void setPredicate ( String v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_predicate == null ) { \njcasType . jcas . throwFeatMissing ( \"predicate\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_predicate , v ) ; \n} \n} \n"}
{"9845": "public class Triple { \npublic boolean getIsObjUri ( ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_isObjUri == null ) { \njcasType . jcas . throwFeatMissing ( \"isObjUri\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getBooleanValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri ) ; \n} \n} \n"}
{"9846": "public class Triple { \npublic void setIsObjUri ( boolean v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_isObjUri == null ) { \njcasType . jcas . throwFeatMissing ( \"isObjUri\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setBooleanValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri , v ) ; \n} \n} \n"}
{"9847": "public class ComplexQueryConcept { \npublic QueryOperator getOperator ( ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operator == null ) { \njcasType . jcas . throwFeatMissing ( \"operator\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \nreturn ( QueryOperator ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator ) ) ) ; \n} \n} \n"}
{"9848": "public class ComplexQueryConcept { \npublic void setOperator ( QueryOperator v ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operator == null ) { \njcasType . jcas . throwFeatMissing ( \"operator\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9849": "public class ComplexQueryConcept { \npublic FSList getOperatorArgs ( ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operatorArgs == null ) { \njcasType . jcas . throwFeatMissing ( \"operatorArgs\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs ) ) ) ; \n} \n} \n"}
{"9850": "public class ComplexQueryConcept { \npublic void setOperatorArgs ( FSList v ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operatorArgs == null ) { \njcasType . jcas . throwFeatMissing ( \"operatorArgs\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9851": "public class ConceptMention { \npublic Concept getConcept ( ) { \nif ( ConceptMention_Type . featOkTst && ( ( ConceptMention_Type ) jcasType ) . casFeat_concept == null ) { \njcasType . jcas . throwFeatMissing ( \"concept\" , \"edu.cmu.lti.oaqa.type.kb.ConceptMention\" ) ; \n} \nreturn ( Concept ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ConceptMention_Type ) jcasType ) . casFeatCode_concept ) ) ) ; \n} \n} \n"}
{"9852": "public class ConceptMention { \npublic double getScore ( ) { \nif ( ConceptMention_Type . featOkTst && ( ( ConceptMention_Type ) jcasType ) . casFeat_score == null ) { \njcasType . jcas . throwFeatMissing ( \"score\" , \"edu.cmu.lti.oaqa.type.kb.ConceptMention\" ) ; \n} \nreturn jcasType . ll_cas . ll_getDoubleValue ( addr , ( ( ConceptMention_Type ) jcasType ) . casFeatCode_score ) ; \n} \n} \n"}
{"9853": "public class CandidateAnswerOccurrence { \npublic String getText ( ) { \nif ( CandidateAnswerOccurrence_Type . featOkTst && ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeat_text == null ) { \njcasType . jcas . throwFeatMissing ( \"text\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerOccurrence\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeatCode_text ) ; \n} \n} \n"}
{"9854": "public class CandidateAnswerOccurrence { \npublic void setText ( String v ) { \nif ( CandidateAnswerOccurrence_Type . featOkTst && ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeat_text == null ) { \njcasType . jcas . throwFeatMissing ( \"text\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerOccurrence\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeatCode_text , v ) ; \n} \n} \n"}
{"9855": "public class ConceptType { \npublic String getId ( ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) { \njcasType . jcas . throwFeatMissing ( \"id\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id ) ; \n} \n} \n"}
{"9856": "public class ConceptType { \npublic void setId ( String v ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) { \njcasType . jcas . throwFeatMissing ( \"id\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id , v ) ; \n} \n} \n"}
{"9857": "public class ConceptType { \npublic String getName ( ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_name == null ) { \njcasType . jcas . throwFeatMissing ( \"name\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_name ) ; \n} \n} \n"}
{"9858": "public class ConceptType { \npublic String getAbbreviation ( ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_abbreviation == null ) { \njcasType . jcas . throwFeatMissing ( \"abbreviation\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation ) ; \n} \n} \n"}
{"9859": "public class ConceptType { \npublic void setAbbreviation ( String v ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_abbreviation == null ) { \njcasType . jcas . throwFeatMissing ( \"abbreviation\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation , v ) ; \n} \n} \n"}
{"9860": "public class ConceptSearchResult { \npublic void setConcept ( Concept v ) { \nif ( ConceptSearchResult_Type . featOkTst && ( ( ConceptSearchResult_Type ) jcasType ) . casFeat_concept == null ) { \njcasType . jcas . throwFeatMissing ( \"concept\" , \"edu.cmu.lti.oaqa.type.retrieval.ConceptSearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ConceptSearchResult_Type ) jcasType ) . casFeatCode_concept , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9861": "public class Answer { \npublic FSList getVariants ( ) { \nif ( Answer_Type . featOkTst && ( ( Answer_Type ) jcasType ) . casFeat_variants == null ) { \njcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Answer\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Answer_Type ) jcasType ) . casFeatCode_variants ) ) ) ; \n} \n} \n"}
{"9862": "public class Answer { \npublic void setVariants ( FSList v ) { \nif ( Answer_Type . featOkTst && ( ( Answer_Type ) jcasType ) . casFeat_variants == null ) { \njcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Answer\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Answer_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9863": "public class QueryConcept { \npublic StringList getNamedEntityTypes ( ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) { \njcasType . jcas . throwFeatMissing ( \"namedEntityTypes\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes ) ) ) ; \n} \n} \n"}
{"9864": "public class QueryConcept { \npublic void setNamedEntityTypes ( StringList v ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) { \njcasType . jcas . throwFeatMissing ( \"namedEntityTypes\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9865": "public class QueryConcept { \npublic String getConceptType ( ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_conceptType == null ) { \njcasType . jcas . throwFeatMissing ( \"conceptType\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType ) ; \n} \n} \n"}
{"9866": "public class QueryConcept { \npublic void setConceptType ( String v ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_conceptType == null ) { \njcasType . jcas . throwFeatMissing ( \"conceptType\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType , v ) ; \n} \n} \n"}
{"9867": "public class CandidateAnswerVariant { \npublic FSList getOccurrences ( ) { \nif ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) { \njcasType . jcas . throwFeatMissing ( \"occurrences\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences ) ) ) ; \n} \n} \n"}
{"9868": "public class CandidateAnswerVariant { \npublic void setOccurrences ( FSList v ) { \nif ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) { \njcasType . jcas . throwFeatMissing ( \"occurrences\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9869": "public class AbstractQuery { \npublic FSList getConcepts ( ) { \nif ( AbstractQuery_Type . featOkTst && ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) { \njcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts ) ) ) ; \n} \n} \n"}
{"9870": "public class AbstractQuery { \npublic void setConcepts ( FSList v ) { \nif ( AbstractQuery_Type . featOkTst && ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) { \njcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9871": "public class AtomicQueryConcept { \npublic String getOriginalText ( ) { \nif ( AtomicQueryConcept_Type . featOkTst && ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) { \njcasType . jcas . throwFeatMissing ( \"originalText\" , \"edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText ) ; \n} \n} \n"}
{"9872": "public class AtomicQueryConcept { \npublic void setOriginalText ( String v ) { \nif ( AtomicQueryConcept_Type . featOkTst && ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) { \njcasType . jcas . throwFeatMissing ( \"originalText\" , \"edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText , v ) ; \n} \n} \n"}
{"9873": "public class QueryOperator { \npublic StringList getArgs ( ) { \nif ( QueryOperator_Type . featOkTst && ( ( QueryOperator_Type ) jcasType ) . casFeat_args == null ) { \njcasType . jcas . throwFeatMissing ( \"args\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryOperator\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args ) ) ) ; \n} \n} \n"}
{"9874": "public class QueryOperator { \npublic void setArgs ( StringList v ) { \nif ( QueryOperator_Type . featOkTst && ( ( QueryOperator_Type ) jcasType ) . casFeat_args == null ) { \njcasType . jcas . throwFeatMissing ( \"args\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryOperator\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9875": "public class SemanticRole { \npublic String getLabel ( ) { \nif ( SemanticRole_Type . featOkTst && ( ( SemanticRole_Type ) jcasType ) . casFeat_label == null ) { \njcasType . jcas . throwFeatMissing ( \"label\" , \"edu.cmu.lti.oaqa.type.nlp.SemanticRole\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( SemanticRole_Type ) jcasType ) . casFeatCode_label ) ; \n} \n} \n"}
{"9876": "public class SemanticRole { \npublic void setLabel ( String v ) { \nif ( SemanticRole_Type . featOkTst && ( ( SemanticRole_Type ) jcasType ) . casFeat_label == null ) { \njcasType . jcas . throwFeatMissing ( \"label\" , \"edu.cmu.lti.oaqa.type.nlp.SemanticRole\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SemanticRole_Type ) jcasType ) . casFeatCode_label , v ) ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nint i = index >> 6 ; \nif ( i >= wlen ) { \nreturn - 1 ; \n} \nint subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \n} \nwhile ( ++ i < wlen ) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nwhile ( unfinishedBusiness . size ( ) > 0 ) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) { \nnonCycles = nonCycles . cons ( p ) ; \n} \nif ( p . isMinimalCycle ( ) ) { \ncycles = cycles . cons ( p ) ; \n} \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) { \nunfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \n} \n} \n"}
{"9923": "public class API { \npublic void return_ ( final Integer request_type , final String name , final String pattern , final byte [ ] response_info , final byte [ ] response , final Integer timeout , final byte [ ] trans_id , final OtpErlangPid pid ) throws ReturnAsyncException , ReturnSyncException , InvalidInputException { \nif ( request_type == API . ASYNC ) { \nreturn_async ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \n} \nelse if ( request_type == API . SYNC ) { \nreturn_sync ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \n} \nelse { \nthrow new InvalidInputException ( ) ; \n} \n} \n} \n"}
{"9925": "public class API { \npublic boolean poll ( final int timeout ) throws InvalidInputException , MessageDecodingException , TerminateException { \nif ( Boolean . TRUE == poll_request ( timeout , true ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"9928": "public class ForkJoinPool { \nprivate void unlockRunState ( int oldRunState , int newRunState ) { \nif ( ! U . compareAndSwapInt ( this , RUNSTATE , oldRunState , newRunState ) ) { \nObject lock = stealCounter ; \nrunState = newRunState ; \nif ( lock != null ) { \nsynchronized ( lock ) { \nlock . notifyAll ( ) ; \n} \n} \n} \n} \n} \n"}
{"9930": "public class ForkJoinPool { \nprivate void tryAddWorker ( long c ) { \nboolean add = false ; \ndo { \nlong nc = ( ( AC_MASK & ( c + AC_UNIT ) ) | ( TC_MASK & ( c + TC_UNIT ) ) ) ; \nif ( ctl == c ) { \nint rs , stop ; \nif ( ( stop = ( rs = lockRunState ( ) ) & STOP ) == 0 ) { \nadd = U . compareAndSwapLong ( this , CTL , c , nc ) ; \n} \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \nif ( stop != 0 ) { \nbreak ; \n} \nif ( add ) { \ncreateWorker ( ) ; \nbreak ; \n} \n} \n} \nwhile ( ( ( c = ctl ) & ADD_WORKER ) != 0L && ( int ) c == 0 ) ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) { \nwt . setUncaughtExceptionHandler ( handler ) ; \n} \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) { \nws [ idx ] = null ; \n} \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) { \nbreak ; \n} \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) { \nbreak ; \n} \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse { \nbreak ; \n} \n} \nif ( ex == null ) { \nForkJoinTask . helpExpungeStaleExceptions ( ) ; \n} \nelse { \nForkJoinTask . rethrow ( ex ) ; \n} \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nint sp , i ; \nWorkQueue v ; \nThread p ; \nwhile ( ( c = ctl ) < 0L ) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \n} \nbreak ; \n} \nif ( ws == null ) { \nbreak ; \n} \nif ( ws . length <= ( i = sp & SMASK ) ) { \nbreak ; \n} \nif ( ( v = ws [ i ] ) == null ) { \nbreak ; \n} \nint vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nint d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) { \nU . unpark ( p ) ; \n} \nbreak ; \n} \nif ( q != null && q . base == q . top ) { \nbreak ; \n} \n} \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nint seed = w . hint ; \nint r = ( seed == 0 ) ? 1 : seed ; \nfor ( ForkJoinTask < ? > t ; \n; \n) { \nif ( ( t = scan ( w , r ) ) != null ) { \nw . runTask ( t ) ; \n} \nelse if ( ! awaitWork ( w , r ) ) { \nbreak ; \n} \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) { \nreturn false ; \n} \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) { \nbreak ; \n} \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) { \nspins = SPINS ; \n} \n} \n} \nelse if ( w . qlock < 0 ) { \nreturn false ; \n} \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) { \nreturn false ; \n} \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) { \nreturn false ; \n} \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse { \nprevctl = parkTime = deadline = 0L ; \n} \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) { \nU . park ( false , parkTime ) ; \n} \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) { \nbreak ; \n} \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"9939": "public class ForkJoinPool { \npublic < T > ForkJoinTask < T > submit ( ForkJoinTask < T > task ) { \nif ( task == null ) { \nthrow new NullPointerException ( ) ; \n} \nexternalPush ( task ) ; \nreturn task ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nint parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) { \nparallelism = Integer . parseInt ( pp ) ; \n} \nif ( fp != null ) { \nfactory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \n} \nif ( hp != null ) { \nhandler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \n} \nif ( mp != null ) { \ncommonMaxSpares = Integer . parseInt ( mp ) ; \n} \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) { \nif ( System . getSecurityManager ( ) == null ) { \nfactory = defaultForkJoinWorkerThreadFactory ; \n} \nelse { \nfactory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \n} \n} \nif ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) { \nparallelism = 1 ; \n} \nif ( parallelism > MAX_CAP ) { \nparallelism = MAX_CAP ; \n} \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) { \nthrow new InterruptedException ( ) ; \n} \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( status >= 0 ) { \nwait ( ms ) ; \n} \nelse { \nnotifyAll ( ) ; \n} \n} \n} \n} \n} \n} \nif ( s >= 0 ) { \ns = status ; \n} \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) { \nthrow new CancellationException ( ) ; \n} \nif ( s != EXCEPTIONAL ) { \nthrow new TimeoutException ( ) ; \n} \nif ( ( ex = getThrowableException ( ) ) != null ) { \nthrow new ExecutionException ( ex ) ; \n} \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9952": "public class AListMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > AListMap < K , V > empty ( AEquality equality ) { \nif ( equality == AEquality . EQUALS ) { \nreturn ( AListMap < K , V > ) emptyEquals ; \n} \nif ( equality == AEquality . IDENTITY ) { \nreturn ( AListMap < K , V > ) emptyIdentity ; \n} \nreturn new AListMap < > ( equality ) ; \n} \n} \n"}
{"9971": "public class SecurityKit { \npublic static < T extends Model > T getLoginWithDb ( HttpServletRequest req , HttpServletResponse response , Function < Long , T > function ) { \nT loginUser = getLoginUser ( req ) ; \nif ( loginUser == null ) { \nCookieUser cookie_user = getUserFromCookie ( req ) ; \nif ( cookie_user == null ) { \nreturn null ; \n} \nT user = CacheKit . get ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) ) ; \nif ( user == null ) { \nuser = function . apply ( cookie_user . getId ( ) ) ; \nCacheKit . put ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) , user ) ; \n} \nif ( user != null && StringUtils . equalsIgnoreCase ( user . getStr ( \"password\" ) , cookie_user . getPassword ( ) ) ) { \nsetLoginMember ( req , response , user , true ) ; \nreturn user ; \n} \nelse { \nreturn null ; \n} \n} \nelse { \nreturn loginUser ; \n} \n} \n} \n"}
{"10000": "public class ExtensionList { \npublic List < T > list ( Injector injector ) { \nList < T > r = new ArrayList < T > ( ) ; \nfor ( Injector i = injector ; \ni != null ; \ni = i . getParent ( ) ) { \nfor ( Entry < Key < ? > , Binding < ? > > e : i . getBindings ( ) . entrySet ( ) ) { \nif ( e . getKey ( ) . getTypeLiteral ( ) . equals ( type ) ) { \nr . add ( ( T ) e . getValue ( ) . getProvider ( ) . get ( ) ) ; \n} \n} \n} \nreturn r ; \n} \n} \n"}
{"10019": "public class PermissionDialogFragment { \npublic static PermissionDialogFragment getInstance ( PermBean bean , int requestCode ) { \nif ( bean == null ) { \nthrow new NullPointerException ( \"Permission Beans cannot be null !\" ) ; \n} \nBundle extras = new Bundle ( 3 ) ; \nHashMap < Permission , String > map = ( HashMap < Permission , String > ) bean . getPermissions ( ) ; \nextras . putSerializable ( PERMISSION , map ) ; \nextras . putInt ( REQUEST , requestCode ) ; \nPermissionDialogFragment fragment = new PermissionDialogFragment ( ) ; \nfragment . setArguments ( extras ) ; \nreturn fragment ; \n} \n} \n"}
{"10035": "public class IO { \npublic static void write ( byte [ ] data , File file ) { \nOutputStream os = null ; \ntry { \nos = new FileOutputStream ( file ) ; \nos . write ( data ) ; \nos . flush ( ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \nfinally { \ntry { \nif ( os != null ) { \nos . close ( ) ; \n} \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n"}
{"10053": "public class PermBean { \npublic PermBean put ( Permission permission , String message ) { \nif ( permission == null ) { \nthrow new IllegalArgumentException ( \"Permission can't be null\" ) ; \n} \nmPermissions . put ( permission , message ) ; \nreturn this ; \n} \n} \n"}
{"10090": "public class AppRunner { \npublic String getProperty ( String key ) { \nif ( m_properties == null ) { \nreturn null ; \n} \nreturn m_properties . getProperty ( key ) ; \n} \n} \n"}
{"10091": "public class AppRunner { \npublic void setProperty ( String key , String value ) { \nif ( m_properties == null ) { \nm_properties = new Properties ( ) ; \n} \nm_properties . setProperty ( key , value ) ; \n} \n} \n"}
{"10100": "public class URI { \nprivate void initializeScheme ( String p_uriSpec ) throws MalformedURIException { \nint uriSpecLen = p_uriSpec . length ( ) ; \nint index = p_uriSpec . indexOf ( ':' ) ; \nif ( index < 1 ) { \nthrow new MalformedURIException ( \"No scheme found in URI.\" ) ; \n} \nif ( index == uriSpecLen - 1 ) { \nthrow new MalformedURIException ( \"A bare scheme name is not a URI.\" ) ; \n} \nsetScheme ( p_uriSpec . substring ( 0 , index ) ) ; \n} \n} \n"}
{"10112": "public class MuffinManager { \npublic String getMuffin ( String strParam ) { \ntry { \nURL url = new URL ( m_strCodeBase + strParam ) ; \nFileContents fc = m_ps . get ( url ) ; \nif ( fc == null ) { \nreturn null ; \n} \nbyte [ ] buf = new byte [ ( int ) fc . getLength ( ) ] ; \nInputStream is = fc . getInputStream ( ) ; \nint pos = 0 ; \nwhile ( ( pos = is . read ( buf , pos , buf . length - pos ) ) > 0 ) { \n} \nis . close ( ) ; \nString strValue = new String ( buf , ENCODING ) ; \nreturn strValue ; \n} \ncatch ( Exception ex ) { \n} \nreturn null ; \n} \n} \n"}
{"10113": "public class MuffinManager { \npublic void setMuffin ( String strParam , String strValue ) { \nFileContents fc = null ; \nURL url = null ; \ntry { \nurl = new URL ( m_strCodeBase + strParam ) ; \n} \ncatch ( Exception ex ) { \nreturn ; \n} \ntry { \nfc = m_ps . get ( url ) ; \nfc . getMaxLength ( ) ; \n} \ncatch ( Exception ex ) { \nfc = null ; \n} \ntry { \nif ( fc == null ) { \nm_ps . create ( url , 100 ) ; \nfc = m_ps . get ( url ) ; \n} \nif ( strValue != null ) { \nOutputStream os = fc . getOutputStream ( false ) ; \nbyte [ ] buf = strValue . getBytes ( ENCODING ) ; \nos . write ( buf ) ; \nos . close ( ) ; \nm_ps . setTag ( url , PersistenceService . DIRTY ) ; \n} \nelse { \nm_ps . delete ( url ) ; \n} \n} \ncatch ( Exception ex ) { \nex . printStackTrace ( ) ; \n} \n} \n} \n"}
{"10114": "public class MuffinManager { \npublic Transferable getClipboardContents ( ) { \nif ( ( clipboardReadStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) { \nreturn null ; \n} \nclipboardReadStatus = CLIPBOARD_DISABLED ; \nif ( cs == null ) { \ntry { \ncs = ( ClipboardService ) ServiceManager . lookup ( \"javax.jnlp.ClipboardService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \ncs = null ; \n} \n} \nif ( cs != null ) { \nTransferable tr = cs . getContents ( ) ; \nif ( tr != null ) { \nclipboardReadStatus = CLIPBOARD_ENABLED ; \n} \nreturn tr ; \n} \nreturn null ; \n} \n} \n"}
{"10115": "public class MuffinManager { \npublic boolean setClipboardContents ( Transferable data ) { \nif ( data == null ) { \nreturn false ; \n} \nif ( ( clipboardWriteStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) { \nreturn false ; \n} \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \nif ( cs == null ) { \ntry { \ncs = ( ClipboardService ) ServiceManager . lookup ( \"javax.jnlp.ClipboardService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \ncs = null ; \n} \n} \nif ( cs != null ) { \ntry { \ncs . setContents ( data ) ; \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \nreturn true ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10117": "public class ServiceManager { \npublic static < T extends Service > Map < String , T > loadServicesByType ( Class < T > clazz ) { \nServiceLoader < T > loader = ServiceLoader . load ( clazz ) ; \nIterator < T > it = loader . iterator ( ) ; \nMap < String , T > ret = new HashMap < String , T > ( ) ; \nwhile ( it . hasNext ( ) ) { \nT op = it . next ( ) ; \nret . put ( op . getId ( ) , op ) ; \nif ( op instanceof ParametrizedOperation ) { \naddParametrizedService ( op . getId ( ) , ( ParametrizedOperation ) op ) ; \n} \nif ( op instanceof ScriptObject ) { \naddScriptObject ( ( ( ScriptObject ) op ) . getVarName ( ) , ( ScriptObject ) op ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"10120": "public class ServiceManager { \npublic static ParametrizedOperation findParmetrizedService ( String id ) { \nif ( parametrizedServices == null ) { \nreturn null ; \n} \nelse { \nreturn parametrizedServices . get ( id ) ; \n} \n} \n} \n"}
{"10121": "public class ServiceManager { \npublic static < T > T findByClass ( Collection < ? > services , Class < T > clazz ) { \nfor ( Object serv : services ) { \nif ( clazz . isInstance ( serv ) ) { \nreturn clazz . cast ( serv ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) { \nstrExtension = name . substring ( iLastDot + 1 ) ; \n} \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"10154": "public class ClassUtil { \npublic static Method [ ] getDeclaredMethods ( Class < ? > clazz , boolean recursively ) { \nList < Method > methods = new LinkedList < Method > ( ) ; \nMethod [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; \nCollections . addAll ( methods , declaredMethods ) ; \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null && recursively ) { \nMethod [ ] declaredMethodsOfSuper = getDeclaredMethods ( superClass , true ) ; \nif ( declaredMethodsOfSuper . length > 0 ) { \nCollections . addAll ( methods , declaredMethodsOfSuper ) ; \n} \n} \nreturn methods . toArray ( new Method [ methods . size ( ) ] ) ; \n} \n} \n"}
{"10156": "public class ClassUtil { \npublic static Method [ ] getAnnotatedDeclaredMethods ( Class < ? > clazz , Class < ? extends Annotation > annotationClass , boolean recursively ) { \nMethod [ ] allMethods = getDeclaredMethods ( clazz , recursively ) ; \nList < Method > annotatedMethods = new LinkedList < Method > ( ) ; \nfor ( Method method : allMethods ) { \nif ( method . isAnnotationPresent ( annotationClass ) ) { \nannotatedMethods . add ( method ) ; \n} \n} \nreturn annotatedMethods . toArray ( new Method [ annotatedMethods . size ( ) ] ) ; \n} \n} \n"}
{"10157": "public class ClassUtil { \npublic static Constructor < ? > [ ] getAnnotatedDeclaredConstructors ( Class < ? > clazz , Class < ? extends Annotation > annotationClass , boolean recursively ) { \nConstructor < ? > [ ] allConstructors = getDeclaredConstructors ( clazz , recursively ) ; \nList < Constructor < ? > > annotatedConstructors = new LinkedList < Constructor < ? > > ( ) ; \nfor ( Constructor < ? > field : allConstructors ) { \nif ( field . isAnnotationPresent ( annotationClass ) ) { \nannotatedConstructors . add ( field ) ; \n} \n} \nreturn annotatedConstructors . toArray ( new Constructor < ? > [ annotatedConstructors . size ( ) ] ) ; \n} \n} \n"}
{"10172": "public class BaseSourceFile { \npublic InputStream makeInStream ( ) { \nif ( m_InputStream != null ) { \nreturn m_InputStream ; \n} \ntry { \nreturn new FileInputStream ( m_inputFile ) ; \n} \ncatch ( FileNotFoundException ex ) { \nSystem . out . println ( \"Warning: scanned file does not exist: \" + m_inputFile . getPath ( ) ) ; \n} \nreturn null ; \n} \n} \n"}
{"10173": "public class AppUtilities { \npublic static Properties parseArgs ( Properties properties , String [ ] args ) { \nif ( properties == null ) { \nproperties = new Properties ( ) ; \n} \nif ( args == null ) { \nreturn properties ; \n} \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nAppUtilities . addParam ( properties , args [ i ] , false ) ; \n} \nreturn properties ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < col ; \ni ++ ) { \nofs += cols [ i ] ; \n} \nreturn ofs ; \n} \nelse if ( col == width ) { \nreturn abspos . getWidth ( ) ; \n} \nelse { \nthrow new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < row ; \ni ++ ) { \nofs += rows [ i ] ; \n} \nreturn ofs ; \n} \nelse if ( row == height ) { \nreturn abspos . getHeight ( ) ; \n} \nelse { \nthrow new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) { \ncnt ++ ; \n} \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) { \nminindent = maxindent ; \n} \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) { \npos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) { \ncols [ cnt ] = abspos . getX2 ( ) - last ; \n} \nif ( minindent == - 1 ) { \nminindent = 0 ; \n} \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) { \ncnt ++ ; \n} \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) { \npos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) { \nrows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) { \nresult . append ( Character . toUpperCase ( nextChar ) ) ; \n} \nelse { \nresult . append ( Character . toLowerCase ( nextChar ) ) ; \n} \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \ni < value . length ( ) ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10536": "public class PTStemmer { \nprotected synchronized ptstemmer . Stemmer getActualStemmer ( ) throws PTStemmerException { \nif ( m_ActualStemmer == null ) { \nif ( m_Stemmer == STEMMER_ORENGO ) { \nm_ActualStemmer = new OrengoStemmer ( ) ; \n} \nelse if ( m_Stemmer == STEMMER_PORTER ) { \nm_ActualStemmer = new PorterStemmer ( ) ; \n} \nelse if ( m_Stemmer == STEMMER_SAVOY ) { \nm_ActualStemmer = new SavoyStemmer ( ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Unhandled stemmer type: \" + m_Stemmer ) ; \n} \nif ( ! m_NamedEntities . isDirectory ( ) ) { \nm_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_NamedEntities . getAbsolutePath ( ) ) ) ; \n} \nif ( ! m_Stopwords . isDirectory ( ) ) { \nm_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_Stopwords . getAbsolutePath ( ) ) ) ; \n} \nif ( m_Cache > 0 ) { \nm_ActualStemmer . enableCaching ( m_Cache ) ; \n} \nelse { \nm_ActualStemmer . disableCaching ( ) ; \n} \n} \nreturn m_ActualStemmer ; \n} \n} \n"}
{"10631": "public class Type1UUID { \nstatic long getTime ( ) { \nif ( RANDOM == null ) { \ninitializeForType1 ( ) ; \n} \nlong newTime = getUUIDTime ( ) ; \nif ( newTime <= _lastMillis ) { \nincrementSequence ( ) ; \nnewTime = getUUIDTime ( ) ; \n} \n_lastMillis = newTime ; \nreturn newTime ; \n} \n} \n"}
{"10634": "public class Player { \n@ SuppressWarnings ( \"unused\" ) public void updatePlayInfo ( Playlist playlist , Progress progress , Volume volume ) { \nif ( playlist != null ) { \nthis . playlist = playlist ; \n} \nif ( progress != null ) { \nthis . progress = progress ; \n} \nif ( volume != null ) { \nthis . volume = volume ; \n} \nupdatePlayInfo ( playlist , progress , null , volume ) ; \n} \n} \n"}
{"10659": "public class Event { \n@ SuppressWarnings ( \"unused\" ) public Event addEventLifeCycleListener ( EventLifeCycle eventLifeCycle , Consumer < EventLifeCycle > cycleCallback ) { \nlifeCycleListeners . compute ( eventLifeCycle , ( unused , list ) -> { \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \n} \nlist . add ( cycleCallback ) ; \nreturn list ; \n} \n) ; \nreturn this ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) { \nthrow new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \n} \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) { \nthrow new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \n} \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) { \nreturn false ; \n} \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nif ( buffer1 . get ( ) != buffer2 . get ( ) ) { \nreturn false ; \n} \n} \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) { \ntry { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) { \nchannel2 . close ( ) ; \n} \nthrow e ; \n} \n} \nif ( channel2 != null ) { \nchannel2 . close ( ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10662": "public class Files { \npublic static void cleanDirectByteBuffer ( final ByteBuffer byteBuffer ) { \nif ( byteBuffer == null ) { \nreturn ; \n} \nif ( ! byteBuffer . isDirect ( ) ) { \nthrow new IllegalArgumentException ( \"byteBuffer isn't direct!\" ) ; \n} \nAccessController . doPrivileged ( new PrivilegedAction < Void > ( ) { \npublic Void run ( ) { \ntry { \nMethod cleanerMethod = byteBuffer . getClass ( ) . getMethod ( \"cleaner\" ) ; \ncleanerMethod . setAccessible ( true ) ; \nObject cleaner = cleanerMethod . invoke ( byteBuffer ) ; \nMethod cleanMethod = cleaner . getClass ( ) . getMethod ( \"clean\" ) ; \ncleanMethod . setAccessible ( true ) ; \ncleanMethod . invoke ( cleaner ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nthrow new RuntimeException ( \"Could not clean MappedByteBuffer -- File may still be locked!\" ) ; \n} \nreturn null ; \n} \n} \n) ; \n} \n} \n"}
{"10663": "public class TransactionalHashMap { \nprivate boolean validEntry ( final Entry < K , V > entry ) { \nif ( auto_commit || entry == null ) { \nreturn ( entry != null ) ; \n} \nString id = getCurrentThreadId ( ) ; \nreturn ! ( ( entry . is ( Entry . DELETED , id ) ) || ( entry . is ( Entry . ADDED , null ) && entry . is ( Entry . NO_CHANGE , id ) ) ) ; \n} \n} \n"}
{"10666": "public class TransactionalHashMap { \nEntry < K , V > getEntry ( Object key ) { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > e = table [ i ] ; \nwhile ( e != null && ! ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) ) { \ne = e . next ; \n} \nreturn e ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nint numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) { \nreturn ; \n} \nif ( numKeysToBeAdded > threshold ) { \nint targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( targetCapacity > MAXIMUM_CAPACITY ) { \ntargetCapacity = MAXIMUM_CAPACITY ; \n} \nint newCapacity = table . length ; \nwhile ( newCapacity < targetCapacity ) { \nnewCapacity <<= 1 ; \n} \nif ( newCapacity > table . length ) { \nresize ( newCapacity ) ; \n} \n} \nfor ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) { \nthrow new ConcurrentModificationException ( ) ; \n} \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) { \ntable [ i ] = next ; \n} \nelse { \nprev . next = next ; \n} \nreturn e ; \n} \nelse { \ne . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) { \nreturn null ; \n} \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) { \ntable [ i ] = next ; \n} \nelse { \nprev . next = next ; \n} \n} \nelse { \ne . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \nreturn e ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10672": "public class TransactionalHashMap { \nvoid addEntry ( int hash , K key , V value , int bucketIndex ) { \ntable [ bucketIndex ] = new Entry < K , V > ( hash , key , value , table [ bucketIndex ] ) ; \nif ( ! auto_commit ) { \ntable [ bucketIndex ] . setStatus ( Entry . ADDED , getCurrentThreadId ( ) ) ; \n} \nif ( size ++ >= threshold ) { \nresize ( 2 * table . length ) ; \n} \n} \n} \n"}
{"10679": "public class CommandHandler { \npublic void setTrackSelectorController ( Consumer < TrackInfo > controller ) { \nif ( controller == null ) { \nreturn ; \n} \nselectTrack = controller ; \ncapabilities . setAbleToSelectTrack ( true ) ; \n} \n} \n"}
{"10680": "public class CommandHandler { \npublic void setJumpProgressController ( Consumer < Progress > controller ) { \nif ( controller == null ) { \nreturn ; \n} \njumpProgress = controller ; \ncapabilities . setAbleToJump ( true ) ; \n} \n} \n"}
{"10681": "public class CommandHandler { \npublic void setPlaybackChangeableController ( Consumer < String > controller ) { \nif ( controller == null ) { \nreturn ; \n} \nchangePlayback = controller ; \ncapabilities . setPlaybackChangeable ( true ) ; \n} \n} \n"}
{"10682": "public class CommandHandler { \npublic void setVolumeChangeableController ( Consumer < Volume > controller ) { \nif ( controller == null ) { \nreturn ; \n} \nchangeVolume = controller ; \ncapabilities . setChangeVolume ( true ) ; \n} \n} \n"}
{"10683": "public class CommandHandler { \npublic void broadcastAvailablePlaylists ( Supplier < List < String > > availablePlaylist , Function < String , Playlist > playlistForNameFunction ) { \nif ( availablePlaylist == null || playlistForNameFunction == null ) { \nreturn ; \n} \nthis . availablePlaylist = availablePlaylist ; \nthis . playlistForNameFunction = playlistForNameFunction ; \ncapabilities . setBroadcasting ( true ) ; \n} \n} \n"}
{"10684": "public class CommandHandler { \npublic void handleCommandResources ( EventModel eventModel ) { \nList < ResourceModel < String > > resourceModels = eventModel . getListResourceContainer ( ) . provideResource ( CommandResource . ResourceID ) . stream ( ) . filter ( resourceModel -> resourceModel . getResource ( ) instanceof String ) . map ( resourceModel -> { \ntry { \nreturn ( ResourceModel < String > ) resourceModel ; \n} \ncatch ( ClassCastException e ) { \nreturn null ; \n} \n} \n) . filter ( Objects :: nonNull ) . collect ( Collectors . toList ( ) ) ; \nfor ( ResourceModel < String > resourceModel : resourceModels ) { \nif ( ! CommandResource . verifyCommand ( resourceModel . getResource ( ) ) ) { \ncontinue ; \n} \nif ( ! CommandResource . verifyCapabilities ( resourceModel . getResource ( ) , capabilities ) ) { \nmusicHelper . playerError ( PlayerError . ERROR_NOT_ABLE + \"command: \" + resourceModel . getResource ( ) , resourceModel . getProvider ( ) ) ; \ncontinue ; \n} \nswitch ( resourceModel . getResource ( ) ) { \ncase CommandResource . PLAY : if ( ! musicProvider . isPlaying ( ) ) { \nplayPause . accept ( resourceModel . getResource ( ) ) ; \n} \nbreak ; \ncase CommandResource . PAUSE : if ( musicProvider . isPlaying ( ) ) { \nplayPause . accept ( resourceModel . getResource ( ) ) ; \n} \nbreak ; \ncase CommandResource . SELECT_TRACK : handleSelectTrack ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . NEXT : nextPrevious . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . PREVIOUS : nextPrevious . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . JUMP : handleJump ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . CHANGE_PLAYBACK : changePlayback . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . CHANGE_VOLUME : handleVolume ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . STOP : stopCallback . run ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"10696": "public class AbstractDao { \n@ Override public void updateOne ( E object , String ... properties ) { \nif ( object . getId ( ) == null ) { \nthrow new RuntimeException ( \"Not a Persisted entity\" ) ; \n} \nif ( properties == null || properties . length == 0 ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"Update \" + clazz . getName ( ) + \" SET \" ) ; \nMap < String , Object > cache = new HashMap < String , Object > ( ) ; \nfor ( String prop : properties ) { \ntry { \nField field = object . getClass ( ) . getDeclaredField ( prop ) ; \nfield . setAccessible ( true ) ; \nObject value = field . get ( object ) ; \nif ( value instanceof Collection ) { \nthrow new RuntimeException ( \"Collection property is not suppotred.\" ) ; \n} \ncache . put ( prop , value ) ; \nif ( cache . size ( ) > 1 ) { \nsb . append ( \" ,\" ) ; \n} \nsb . append ( prop ) ; \nsb . append ( \" = :\" ) ; \nsb . append ( prop ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( cache . size ( ) == 0 ) { \nreturn ; \n} \nsb . append ( \" WHERE id = \" + object . getId ( ) ) ; \nQuery query = entityManager . createQuery ( sb . toString ( ) ) ; \nfor ( Entry < String , Object > entry : cache . entrySet ( ) ) { \nquery . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nquery . executeUpdate ( ) ; \n} \n} \n"}
{"10697": "public class KeepAliveManager { \npublic void setPingInterval ( long newPingInterval ) { \nif ( pingInterval == newPingInterval ) { \nreturn ; \n} \nif ( newPingInterval > 0 ) { \nenableExecutorService ( ) ; \n} \npingInterval = newPingInterval ; \nif ( pingInterval < 0 ) { \nstopPinging ( ) ; \n} \nelse { \nschedulePingServerTask ( ) ; \n} \n} \n} \n"}
{"10706": "public class XMPPConnection { \nprivate XMPPInputOutputStream maybeGetCompressionHandler ( ) { \nif ( compressionMethods != null ) { \nfor ( XMPPInputOutputStream handler : compressionHandlers ) { \nif ( ! handler . isSupported ( ) ) { \ncontinue ; \n} \nString method = handler . getCompressionMethod ( ) ; \nif ( compressionMethods . contains ( method ) ) { \nreturn handler ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10709": "public class XMPPConnection { \nsynchronized void notifyConnectionError ( Exception e ) { \nif ( ( packetReader == null || packetReader . done ) && ( packetWriter == null || packetWriter . done ) ) { \nreturn ; \n} \nif ( packetReader != null ) { \npacketReader . done = true ; \n} \nif ( packetWriter != null ) { \npacketWriter . done = true ; \n} \nshutdown ( new Presence ( Presence . Type . unavailable ) ) ; \nfor ( ConnectionListener listener : getConnectionListeners ( ) ) { \ntry { \nlistener . connectionClosedOnError ( e ) ; \n} \ncatch ( Exception e2 ) { \ne2 . printStackTrace ( ) ; \n} \n} \n} \n} \n"}
{"10713": "public class EventBehaviourController { \n@ Override public HashMap < Integer , List < Identification > > getOutputPluginBehaviour ( List < Identification > identifications ) { \nif ( outputPluginBehaviour == null ) { \nreturn new HashMap < > ( ) ; \n} \nreturn outputPluginBehaviour . apply ( identifications ) ; \n} \n} \n"}
{"10739": "public class EventPropertiesAssistant { \npublic void unregisterEventID ( String eventKey ) { \nproperties . remove ( eventKey + \"_DESCRIPTION\" ) ; \nproperties . remove ( eventKey ) ; \nFileOutputStream out = null ; \nBufferedReader reader = null ; \nBufferedWriter writer = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nfinal File tempFile = new File ( eventPropertiesPath + \"temp.properties\" ) ; \nfinal BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; \nfinal BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( eventKey ) != null ) { \nreturn ; \n} \ntry { \nString currentLine = readerFinal . readLine ( ) ; \nwhile ( currentLine != null ) { \nString trimmedLine = currentLine . trim ( ) ; \nif ( trimmedLine . equals ( eventKey + \"_DESCRIPTION\" ) || trimmedLine . equals ( eventKey ) ) { \ncontinue ; \n} \nwriterFinal . write ( currentLine + System . getProperty ( \"line.separator\" ) ) ; \ncurrentLine = readerFinal . readLine ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \nreader = readerFinal ; \nwriter = writerFinal ; \ntempFile . renameTo ( new File ( eventPropertiesPath ) ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) { \nout . close ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nif ( reader != null ) { \nreader . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10742": "public class PlayerError { \npublic static Optional < PlayerError > createMusicPlayerError ( Identification source , String error ) { \nif ( error == null || error . isEmpty ( ) ) { \nreturn Optional . empty ( ) ; \n} \ntry { \nPlayerError playerError = new PlayerError ( source ) ; \nplayerError . addResource ( new MusicErrorResource ( source , error ) ) ; \nreturn Optional . of ( playerError ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10755": "public class LaunchNakamura { \nprivate void isStartupFinished ( ) { \nboolean started = false ; \ntry { \nwhile ( ! started ) { \nif ( exists ( localhostURL ) ) { \nstarted = true ; \n} \nThread . sleep ( 5 * 1000 ) ; \n} \n} \ncatch ( InterruptedException e ) { \ne . printStackTrace ( ) ; \n} \nif ( started ) { \nstatusLabel . setText ( \"Nakamura is running.\" ) ; \nstatusLabel . setForeground ( Color . green ) ; \nlaunchButton . setEnabled ( false ) ; \nbrowserButton . setEnabled ( true ) ; \n} \n} \n} \n"}
{"10760": "public class IntArray { \npublic IntArray with ( int ... values ) { \nif ( values . length != this . length ) { \nthrow new IllegalArgumentException ( \"Array size mismatch\" ) ; \n} \nvalue = values . clone ( ) ; \nreturn this ; \n} \n} \n"}
{"10803": "public class PropertiesAssistant { \npublic void registerUpdateListener ( Consumer < PropertiesAssistant > listener ) { \nif ( listener != null ) { \nlisteners . add ( new WeakReference < > ( listener ) ) ; \n} \n} \n} \n"}
{"10804": "public class PropertiesAssistant { \npublic void initProperties ( ) { \npropertiesPath = getContext ( ) . getFiles ( ) . getPropertiesLocation ( ) + File . separator + getContext ( ) . getAddOns ( ) . getAddOn ( ) . getID ( ) + \".properties\" ; \nthis . propertiesFile = new File ( propertiesPath ) ; \nif ( ! this . propertiesFile . exists ( ) ) { \ntry { \nthis . propertiesFile . createNewFile ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to create the new Properties file\" , e ) ; \n} \n} \ntry { \nBufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( this . propertiesFile ) , \"UTF8\" ) ) ; \ntry { \nproperties . load ( in ) ; \n} \ncatch ( IOException e ) { \nerror ( \"unable to load the InputStream for the PropertiesFile\" , e ) ; \n} \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nerror ( \"Error while trying to read Properties-File\" , e ) ; \n} \nif ( defaultPropertiesPath != null && new File ( defaultPropertiesPath ) . exists ( ) ) { \n@ SuppressWarnings ( \"unchecked\" ) Enumeration < String > keys = ( Enumeration < String > ) properties . propertyNames ( ) ; \nif ( ! keys . hasMoreElements ( ) ) { \ntry { \ncreateDefaultPropertyFile ( defaultPropertiesPath ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to copy the Default-Properties File\" , e ) ; \n} \nif ( new File ( defaultPropertiesPath ) . exists ( ) && ! writeToPropertiesFile ( defaultPropertiesPath ) ) { \nreturn ; \n} \nreloadProperties ( ) ; \n} \n} \n} \n} \n"}
{"10805": "public class PropertiesAssistant { \nprivate void reloadProperties ( ) { \nProperties temp = new Properties ( ) ; \nBufferedReader bufferedReader = null ; \ntry { \nFile properties = new File ( propertiesPath ) ; \nbufferedReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( properties ) , \"UTF8\" ) ) ; \ntemp . load ( bufferedReader ) ; \nthis . properties = temp ; \nlisteners . removeIf ( weakReference -> weakReference . get ( ) == null ) ; \nlisteners . forEach ( weakReference -> { \nConsumer < PropertiesAssistant > consumer = weakReference . get ( ) ; \nif ( consumer != null ) { \nconsumer . accept ( this ) ; \n} \n} \n) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to load the Properties-File: \" + propertiesPath , e ) ; \n} \nfinally { \nif ( bufferedReader != null ) { \ntry { \nbufferedReader . close ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close input stream\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"10811": "public class StartMusicRequest { \npublic static boolean verify ( EventModel eventModel , Capabilities capabilities , Identifiable player , List < Identifiable > activators ) { \nif ( ! eventModel . containsDescriptor ( StartMusicRequest . ID ) ) { \nreturn false ; \n} \nif ( ! capabilities . handlesPlayRequestFromOutside ( ) ) { \nif ( activators . stream ( ) . noneMatch ( identifiable -> identifiable . isOwner ( eventModel . getSource ( ) ) ) ) { \nreturn false ; \n} \n} \nif ( ! PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> playlist . verify ( capabilities ) ) . orElse ( true ) ) { \nreturn false ; \n} \nreturn SelectorResource . isTarget ( eventModel , player ) . orElse ( false ) ; \n} \n} \n"}
{"10812": "public class PlaybackStateResource { \npublic static Optional < PlaybackState > getPlaybackStateFromResource ( ResourceModel x ) { \nif ( ! x . getResourceID ( ) . equals ( ID ) ) { \nreturn Optional . empty ( ) ; \n} \nObject resource = x . getResource ( ) ; \nif ( resource instanceof String ) { \nString state = ( String ) resource ; \ntry { \nreturn Optional . of ( PlaybackState . valueOf ( state ) ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \nelse { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10823": "public class PresenceConstant { \npublic void setPresence ( boolean present ) { \nif ( this . present == present ) { \nreturn ; \n} \nthis . present = present ; \nupdateVague ( ) ; \nif ( present ) { \nfirePresence ( true ) ; \n} \nelse { \nfireLeaving ( ) ; \n} \n} \n} \n"}
{"10835": "public class StopMusic { \npublic static Optional < StopMusic > createStopMusic ( Identification source , Identification target ) { \nif ( target == null || target . equals ( source ) ) { \nreturn Optional . empty ( ) ; \n} \ntry { \nStopMusic stopRequest = new StopMusic ( source ) ; \nstopRequest . addResource ( new SelectorResource ( source , target ) ) ; \nreturn Optional . of ( stopRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10836": "public class StopMusic { \npublic static boolean verify ( EventModel eventModel , Identifiable player ) { \nif ( ! eventModel . containsDescriptor ( StopMusic . ID ) ) { \nreturn false ; \n} \nreturn SelectorResource . isTarget ( eventModel , player ) . orElse ( true ) ; \n} \n} \n"}
{"10846": "public class TransactionalBidiTreeMap { \nprotected String getCurrentThreadId ( ) { \nString attach_id = ( String ) ThreadSession . getValue ( getThreadSessionKey ( ) ) ; \nif ( attach_id != null ) { \nreturn attach_id ; \n} \nThread thread = Thread . currentThread ( ) ; \nreturn thread . toString ( ) + \"(\" + thread . hashCode ( ) + \")\" ; \n} \n} \n"}
{"10847": "public class TransactionalBidiTreeMap { \nprivate boolean validNode ( final Node < K , V > node , final String thread_id ) { \nif ( auto_commit || node == null ) { \nreturn ( node != null ) ; \n} \nreturn ! ( ( node . is ( Node . DELETED , thread_id ) ) || ( node . is ( Node . ADDED , null ) && node . is ( Node . NO_CHANGE , thread_id ) ) ) ; \n} \n} \n"}
{"10852": "public class TransactionalBidiTreeMap { \nprivate int compare ( final int o1_status , final Object o1 , final int o2_status , final Object o2 , final int index ) { \nif ( comparators [ index ] == null ) { \nif ( o1 instanceof TransactionalComparable ) { \nreturn ( ( TransactionalComparable ) o1 ) . compareTo ( o1_status , o2 , o2_status ) ; \n} \nelse { \nreturn ( ( Comparable ) o1 ) . compareTo ( o2 ) ; \n} \n} \nelse { \nreturn comparators [ index ] . compare ( o1 , o2 ) ; \n} \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) { \nthrow new ConcurrentModificationException ( ) ; \n} \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n} \n"}
{"10875": "public class TransactionalBidiTreeMap { \n@ Override public void clear ( ) { \nif ( auto_commit ) { \nmodify ( ) ; \nnodeCount = 0 ; \nrootNode [ KEY ] = null ; \nrootNode [ VALUE ] = null ; \n} \nelse { \nString thread_id = getCurrentThreadId ( ) ; \nArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; \nfor ( Iterator < Entry < K , V > > i = list . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nNode < K , V > node = ( Node < K , V > ) i . next ( ) ; \nif ( node . is ( Node . ADDED , thread_id ) ) { \ndoRedBlackDelete ( node ) ; \n} \nelse { \nnode . setStatus ( Node . DELETED , thread_id ) ; \n} \n} \n} \n} \n} \n"}
{"10895": "public class MuteEvent { \npublic static Optional < MuteEvent > createMuteEvent ( Identification source , Identification target ) { \nif ( target == null || target . equals ( source ) ) { \nreturn Optional . empty ( ) ; \n} \ntry { \nMuteEvent muteRequest = new MuteEvent ( source ) ; \nmuteRequest . addResource ( new SelectorResource ( source , target ) ) ; \nreturn Optional . of ( muteRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10896": "public class MuteEvent { \npublic static Optional < MuteEvent > createMuteEvent ( Identification source ) { \nif ( source == null ) { \nreturn Optional . empty ( ) ; \n} \ntry { \nMuteEvent muteRequest = new MuteEvent ( source ) ; \nreturn Optional . of ( muteRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10905": "public class EventListener { \npublic static Optional < EventListener > createEventListener ( String descriptor , String description , String descriptorID , Identifiable identifiable ) throws IllegalArgumentException { \nif ( ! descriptorID . matches ( \"[\\\\w\\\\-_]+\" ) ) { \nthrow new IllegalArgumentException ( \"descriptorID: \" + descriptorID + \" contains illegal characters\" ) ; \n} \nreturn IdentificationManagerM . getInstance ( ) . getIdentification ( identifiable ) . flatMap ( id -> Event . createEvent ( CommonEvents . Type . NOTIFICATION_TYPE , id , Collections . singletonList ( descriptor ) ) ) . map ( event -> new EventListener ( event , descriptor , description , descriptorID ) ) ; \n} \n} \n"}
{"10908": "public class IterativeCallback { \nprivate R doIteration ( Iterator < ? extends T > it ) { \nstate . i = it ; \nstate . iterations = 0 ; \nif ( state . do_break == true ) { \nreturn state . return_object ; \n} \nwhile ( state . i . hasNext ( ) ) { \nT o = state . i . next ( ) ; \nif ( delegate != null ) { \ndelegate . delegate ( o ) ; \n} \nelse { \niterateObject ( o ) ; \n} \nif ( state . do_break == true ) { \nreturn state . return_object ; \n} \n} \nreturn state . amended_object ; \n} \n} \n"}
{"10936": "public class PresenceNonConstant { \n@ SuppressWarnings ( \"unused\" ) public void userEncountered ( ) { \nList < String > descriptors = new ArrayList < > ( ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nboolean known = ! fireUnknownIfNotPresent || present ; \nboolean firstPresent = ( ! strict && ! present ) || ( strict && ! strictPresent ) ; \nlong lastSeen = this . lastSeen . until ( LocalDateTime . now ( ) , ChronoUnit . SECONDS ) ; \nOptional < Event > presenceEvent = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( id -> PresenceEvent . createPresenceEvent ( id , strict , known , firstPresent , descriptors , lastSeen ) ) . map ( event -> event . addEventLifeCycleListener ( EventLifeCycle . APPROVED , lifeCycle -> { \nif ( known ) { \nthis . lastSeen = LocalDateTime . now ( ) ; \nif ( strict ) { \nthis . strictPresent = true ; \n} \npresent = true ; \n} \n} \n) ) ; \nif ( ! presenceEvent . isPresent ( ) ) { \nerror ( \"unable to create PresenceEvent\" ) ; \n} \nelse { \nfire ( presenceEvent . get ( ) , 5 ) ; \n} \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) { \npresent = false ; \n} \nstrictPresent = false ; \n} \n) ; \n} \n} \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) { \nstrictPresent = true ; \n} \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) { \nlastSeen = LocalDateTime . now ( ) ; \n} \n} \n} \n} \n"}
