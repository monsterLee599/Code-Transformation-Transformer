{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten = this . contentWritten + contentLengthToWrite ; \nboolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; \nint bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; \nif ( isBodyFullyWritten || requiresFlush ) { \ndoOnResponseCommitted ( ) ; \n} \n} \n} \n"}
{"136": "public class EncodingUtils { \npublic static byte [ ] concatenate ( byte [ ] ... arrays ) { \nint length = 0 ; \nfor ( byte [ ] array : arrays ) { \nlength = length + array . length ; \n} \nbyte [ ] newArray = new byte [ length ] ; \nint destPos = 0 ; \nfor ( byte [ ] array : arrays ) { \nSystem . arraycopy ( array , 0 , newArray , destPos , array . length ) ; \ndestPos = destPos + array . length ; \n} \nreturn newArray ; \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nint value = 0 ; \nfor ( int i = 0 ; \ni < bs . length ( ) ; \n++ i ) { \nif ( bs . get ( i ) ) { \nvalue = value + 1 << i ; \n} \n} \nif ( bs . length ( ) > 7 ) { \nthrow new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nreturn ( byte ) value ; \n} \n} \n"}
{"483": "public class Draft_6455 { \nprivate ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { \nlong totalSize = 0 ; \nByteBuffer resultingByteBuffer ; \nsynchronized ( byteBufferList ) { \nfor ( ByteBuffer buffer : byteBufferList ) { \ntotalSize = totalSize + buffer . limit ( ) ; \n} \ncheckBufferLimit ( ) ; \nresultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; \nfor ( ByteBuffer buffer : byteBufferList ) { \nresultingByteBuffer . put ( buffer ) ; \n} \n} \nresultingByteBuffer . flip ( ) ; \nreturn resultingByteBuffer ; \n} \n} \n"}
{"484": "public class Draft_6455 { \nprivate long getByteBufferListSize ( ) { \nlong totalSize = 0 ; \nsynchronized ( byteBufferList ) { \nfor ( ByteBuffer buffer : byteBufferList ) { \ntotalSize = totalSize + buffer . limit ( ) ; \n} \n} \nreturn totalSize ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( part1 == null || part1 . length ( ) == 0 ) path = \"/\" ; \nelse path = part1 ; \nif ( part2 != null ) path = path + '?' + part2 ; \nint port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) { \nfor ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \n} \nengine . startHandshake ( handshake ) ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost = cost + 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \nfor ( int i = 0 ; \ncls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; \ni ++ ) { \nif ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost = cost + 0.1f ; \nif ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { \ncls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \n} \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( int i = 0 ; \ni < normalArgsLen ; \ni ++ ) { \ntotalCost = totalCost + getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost = totalCost + getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost = totalCost + getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \nfor ( int i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost = totalCost + getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"651": "public class MemberUtils { \nprivate static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { \nif ( destClass . isPrimitive ( ) ) { \nreturn getPrimitivePromotionCost ( srcClass , destClass ) ; \n} \nfloat cost = 0.0f ; \nwhile ( srcClass != null && ! destClass . equals ( srcClass ) ) { \nif ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { \ncost = cost + 0.25f ; \nbreak ; \n} \ncost ++ ; \nsrcClass = srcClass . getSuperclass ( ) ; \n} \nif ( srcClass == null ) { \ncost = cost + 1.5f ; \n} \nreturn cost ; \n} \n} \n"}
{"672": "public class TinyBitSet { \npublic int cardinality ( ) { \nint w = value ; \nint c = 0 ; \nwhile ( w != 0 ) { \nc = c + T [ w & 255 ] ; \nw >>= 8 ; \n} \nreturn c ; \n} \n} \n"}
{"690": "public class HttpRequest { \npublic HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { \nquery ( name1 , value1 == null ? null : value1 . toString ( ) ) ; \nfor ( int i = 0 ; \ni < parameters . length ; \ni = i + 2 ) { \nString name = parameters [ i ] . toString ( ) ; \nString value = parameters [ i + 1 ] . toString ( ) ; \nquery . add ( name , value ) ; \n} \nreturn this ; \n} \n} \n"}
{"696": "public class HttpRequest { \npublic HttpRequest setHostHeader ( ) { \nString hostPort = this . host ; \nif ( port != Defaults . DEFAULT_PORT ) { \nhostPort = hostPort + StringPool . COLON + port ; \n} \nheaderOverwrite ( HEADER_HOST , hostPort ) ; \nreturn this ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) { \nrootPath = rootPath + File . separatorChar ; \n} \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nwhile ( ( file = ff . nextFile ( ) ) != null ) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { \nscanClassFile ( filePath , rootPath , file , true ) ; \n} \nelse if ( includeResources ) { \nscanClassFile ( filePath , rootPath , file , false ) ; \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nthrow rex ; \n} \n} \n} \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \nfor ( int cc = 0 , eLen = ( len / 3 ) * 3 ; \nd < eLen ; \n) { \nint i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( sepCnt > 0 && ++ cc == 19 ) { \nsndx = sndx + 2 ; \ncc = 0 ; \n} \n} \nif ( d < len ) { \nint i = 0 ; \nfor ( int j = 0 ; \nsndx <= endx - pad ; \nj ++ ) { \ni |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \n} \nfor ( int r = 16 ; \nd < len ; \nr = r - 8 ) { \ndest [ d ++ ] = ( byte ) ( i >> r ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"786": "public class ProxettaAsmUtil { \npublic static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { \nvarOffset = varOffset + methodInfo . getAllArgumentsSize ( ) ; \nswitch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { \ncase 'V' : mv . visitInsn ( ACONST_NULL ) ; \nbreak ; \ncase 'B' : AsmUtil . valueOfByte ( mv ) ; \nbreak ; \ncase 'C' : AsmUtil . valueOfCharacter ( mv ) ; \nbreak ; \ncase 'S' : AsmUtil . valueOfShort ( mv ) ; \nbreak ; \ncase 'I' : AsmUtil . valueOfInteger ( mv ) ; \nbreak ; \ncase 'Z' : AsmUtil . valueOfBoolean ( mv ) ; \nbreak ; \ncase 'J' : AsmUtil . valueOfLong ( mv ) ; \nbreak ; \ncase 'F' : AsmUtil . valueOfFloat ( mv ) ; \nbreak ; \ncase 'D' : AsmUtil . valueOfDouble ( mv ) ; \nbreak ; \n} \n} \n} \n"}
{"818": "public class PropsData { \npublic Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { \nif ( target == null ) { \ntarget = new HashMap ( ) ; \n} \nif ( prefix != null ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { \nprefix = prefix + StringPool . DOT ; \n} \n} \nif ( profiles != null ) { \nfor ( String profile : profiles ) { \nwhile ( true ) { \nfinal Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; \nif ( map != null ) { \nextractMap ( target , map , profiles , wildcardPatterns , prefix ) ; \n} \nfinal int ndx = profile . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nprofile = profile . substring ( 0 , ndx ) ; \n} \n} \n} \nextractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; \nreturn target ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset = currentAttributeOffset + 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( bootstrapMethodCount > 0 ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \nfor ( int i = 0 ; \ni < bootstrapMethodCount ; \ni ++ ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset = currentOffset + 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset = currentOffset + 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( numBootstrapArguments -- > 0 ) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset = currentOffset + 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \n} \n} \n"}
{"855": "public class SymbolTable { \nprivate Symbol addConstantLongOrDouble ( final int tag , final long value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nint index = constantPoolCount ; \nconstantPool . putByte ( tag ) . putLong ( value ) ; \nconstantPoolCount = constantPoolCount + 2 ; \nreturn put ( new Entry ( index , tag , value , hashCode ) ) ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( c >= 'A' && c <= 'Z' ) { \nc = c + 32 ; \n} \n} \nh = 31 * h + c ; \n} \nif ( h > 0 ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"891": "public class Buffer { \npublic Buffer append ( final Buffer buffer ) { \nif ( buffer . list . isEmpty ( ) ) { \nreturn buffer ; \n} \nlist . addAll ( buffer . list ) ; \nlast = buffer . last ; \nsize = size + buffer . size ; \nreturn this ; \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( offset < bytes . length ) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset = offset + chunk ; \nstep = step + chunk ; \ncount = count + chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep = step - callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining = remaining - chunk ; \nstep = step + chunk ; \ncount = count + chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep = step - callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"919": "public class ProxettaFactory { \nprotected void dumpClassInDebugFolder ( final byte [ ] bytes ) { \nFile debugFolder = proxetta . getDebugFolder ( ) ; \nif ( debugFolder == null ) { \nreturn ; \n} \nif ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { \nlog . warn ( \"Invalid debug folder: \" + debugFolder ) ; \n} \nString fileName = proxyClassName ; \nif ( fileName == null ) { \nfileName = \"proxetta-\" + System . currentTimeMillis ( ) ; \n} \nfileName = fileName + \".class\" ; \nFile file = new File ( debugFolder , fileName ) ; \ntry { \nFileUtil . writeBytes ( file , bytes ) ; \n} \ncatch ( IOException ioex ) { \nlog . warn ( \"Error writing class as \" + file , ioex ) ; \n} \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nint i = 0 ; \nwhile ( i < value . length ( ) ) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni ++ ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) { \nvalue = value . substring ( 1 ) ; \n} \nelse { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = path + '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( value . length ( ) > 0 ) { \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath = path + value ; \n} \nelse { \npath = path + '.' + value ; \n} \n} \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] = ksd [ i ] + t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] = ksd [ i ] + t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] = ksd [ i ] + s ; \n} \n} \n} \n} \n"}
{"950": "public class Threefish { \nprotected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { \nlong [ ] result = new long [ size >> 3 ] ; \nint i8 = offset ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) { \nresult [ i ] = Bits . getLong ( ba , i8 ) ; \ni8 = i8 + 8 ; \n} \nreturn result ; \n} \n} \n"}
{"958": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . toString ( ) ) ; \n} \nif ( path == null ) { \npath = file . getName ( ) ; \n} \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { \npath = path . substring ( 1 ) ; \n} \nboolean isDir = file . isDirectory ( ) ; \nif ( isDir ) { \nif ( ! StringUtil . endsWithChar ( path , '/' ) ) { \npath = path + '/' ; \n} \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( file . lastModified ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nif ( isDir ) { \nzipEntry . setSize ( 0 ) ; \nzipEntry . setCrc ( 0 ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nif ( ! isDir ) { \nInputStream is = new FileInputStream ( file ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \n} \nzos . closeEntry ( ) ; \nif ( recursive && file . isDirectory ( ) ) { \nboolean noRelativePath = StringUtil . isEmpty ( path ) ; \nfinal File [ ] children = file . listFiles ( ) ; \nif ( children != null && children . length != 0 ) { \nfor ( File child : children ) { \nString childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; \naddToZip ( zos , child , childRelativePath , comment , recursive ) ; \n} \n} \n} \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset = currentOffset + 2 ; \nif ( named ) { \nwhile ( numElementValuePairs -- > 0 ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nelse { \nwhile ( numElementValuePairs -- > 0 ) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"972": "public class ClassReader { \nprivate int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { \nint currentOffset = verificationTypeInfoOffset ; \nint tag = b [ currentOffset ++ ] & 0xFF ; \nswitch ( tag ) { \ncase Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; \nbreak ; \ncase Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; \nbreak ; \ncase Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; \nbreak ; \ncase Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; \nbreak ; \ncase Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; \nbreak ; \ncase Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; \nbreak ; \ncase Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; \ncurrentOffset = currentOffset + 2 ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; \ncurrentOffset = currentOffset + 2 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"973": "public class ClassReader { \nprivate int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { \nchar [ ] charBuffer = new char [ maxStringLength ] ; \nint currentAttributeOffset = getFirstAttributeOffset ( ) ; \nint [ ] currentBootstrapMethodOffsets = null ; \nfor ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; \nint attributeLength = readInt ( currentAttributeOffset + 2 ) ; \ncurrentAttributeOffset = currentAttributeOffset + 6 ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \ncurrentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; \nint currentBootstrapMethodOffset = currentAttributeOffset + 2 ; \nfor ( int j = 0 ; \nj < currentBootstrapMethodOffsets . length ; \n++ j ) { \ncurrentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; \ncurrentBootstrapMethodOffset = currentBootstrapMethodOffset + 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; \n} \nreturn currentBootstrapMethodOffsets ; \n} \ncurrentAttributeOffset = currentAttributeOffset + attributeLength ; \n} \nreturn null ; \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nint argumentsSize = 1 ; \nint currentOffset = 1 ; \nint currentChar = methodDescriptor . charAt ( currentOffset ) ; \nwhile ( currentChar != ')' ) { \nif ( currentChar == 'J' || currentChar == 'D' ) { \ncurrentOffset ++ ; \nargumentsSize = argumentsSize + 2 ; \n} \nelse { \nwhile ( methodDescriptor . charAt ( currentOffset ) == '[' ) { \ncurrentOffset ++ ; \n} \nif ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { \ncurrentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \n} \nargumentsSize = argumentsSize + 1 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( currentChar == 'V' ) { \nreturn argumentsSize << 2 ; \n} \nelse { \nint returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \n} \n} \n"}
{"1035": "public class Pathref { \nprotected void append ( final String methodName ) { \nif ( path . length ( ) != 0 ) { \npath = path + StringPool . DOT ; \n} \nif ( methodName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ) { \npath = StringUtil . substring ( path , 0 , - 1 ) ; \n} \npath = path + methodName ; \n} \n} \n"}
{"1040": "public class Format { \npublic static String convertTabsToSpaces ( final String line , final int tabWidth ) { \nint tab_index , tab_size ; \nint last_tab_index = 0 ; \nint added_chars = 0 ; \nif ( tabWidth == 0 ) { \nreturn StringUtil . remove ( line , '\\t' ) ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nwhile ( ( tab_index = line . indexOf ( '\\t' , last_tab_index ) ) != - 1 ) { \ntab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; \nif ( tab_size == 0 ) { \ntab_size = tabWidth ; \n} \nadded_chars = added_chars + tab_size - 1 ; \nresult . append ( line , last_tab_index , tab_index ) ; \nresult . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; \nlast_tab_index = tab_index + 1 ; \n} \nif ( last_tab_index == 0 ) { \nreturn line ; \n} \nresult . append ( line . substring ( last_tab_index ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1042": "public class Format { \npublic static String unescapeJava ( final String str ) { \nchar [ ] chars = str . toCharArray ( ) ; \nStringBuilder sb = new StringBuilder ( str . length ( ) ) ; \nfor ( int i = 0 ; \ni < chars . length ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( c != '\\\\' ) { \nsb . append ( c ) ; \ncontinue ; \n} \ni ++ ; \nc = chars [ i ] ; \nswitch ( c ) { \ncase 'b' : sb . append ( '\\b' ) ; \nbreak ; \ncase 't' : sb . append ( '\\t' ) ; \nbreak ; \ncase 'n' : sb . append ( '\\n' ) ; \nbreak ; \ncase 'f' : sb . append ( '\\f' ) ; \nbreak ; \ncase 'r' : sb . append ( '\\r' ) ; \nbreak ; \ncase '\"' : sb . append ( '\\\"' ) ; \nbreak ; \ncase '\\\\' : sb . append ( '\\\\' ) ; \nbreak ; \ncase 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; \nsb . append ( hex ) ; \ni = i + 4 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1091": "public class StringUtil { \npublic static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { \nint ndx = offset ; \nint [ ] res = new int [ 4 ] ; \nndx = string . indexOf ( leftBoundary , ndx ) ; \nif ( ndx == - 1 ) { \nreturn null ; \n} \nres [ 0 ] = ndx ; \nndx = ndx + leftBoundary . length ( ) ; \nres [ 1 ] = ndx ; \nndx = string . indexOf ( rightBoundary , ndx ) ; \nif ( ndx == - 1 ) { \nreturn null ; \n} \nres [ 2 ] = ndx ; \nres [ 3 ] = ndx + rightBoundary . length ( ) ; \nreturn res ; \n} \n} \n"}
{"1096": "public class StringUtil { \npublic static String surround ( String string , final String prefix , final String suffix ) { \nif ( ! string . startsWith ( prefix ) ) { \nstring = prefix + string ; \n} \nif ( ! string . endsWith ( suffix ) ) { \nstring = string + suffix ; \n} \nreturn string ; \n} \n} \n"}
{"1098": "public class StringUtil { \npublic static String suffix ( String string , final String suffix ) { \nif ( ! string . endsWith ( suffix ) ) { \nstring = string + suffix ; \n} \nreturn string ; \n} \n} \n"}
{"1103": "public class StringUtil { \npublic static String cutSurrounding ( final String string , final String prefix , final String suffix ) { \nint start = 0 ; \nint end = string . length ( ) ; \nif ( string . startsWith ( prefix ) ) { \nstart = prefix . length ( ) ; \n} \nif ( string . endsWith ( suffix ) ) { \nend = end - suffix . length ( ) ; \n} \nif ( end <= start ) { \nreturn StringPool . EMPTY ; \n} \nreturn string . substring ( start , end ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength = length - suffix . length ( ) ; \nif ( s . length ( ) > length ) { \nfor ( int j = length ; \nj >= 0 ; \nj -- ) { \nif ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ni < textLength ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \ncontinue ; \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount = strippedCharsCount + textLength - ndx ; \n} \nelse { \nstrippedCharsCount = strippedCharsCount + textLength ; \n} \n} \n} \n"}
{"1148": "public class CSSellyLexer { \nprivate boolean zzRefill ( ) { \nif ( zzBuffer == null ) { \nzzBuffer = zzChars ; \nzzEndRead = zzEndRead + zzChars . length ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nint from = 0 ; \nint fromCount = 1 ; \nint selectCount = 0 ; \nint lastNdx = 0 ; \nwhile ( true ) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount = selectCount + StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( fromCount >= selectCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount ++ ; \n} \nreturn sql ; \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nint ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) { \nreturn html ; \n} \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nint lastIndex = 0 ; \nint len = html . length ( ) ; \nmainloop : while ( ndx != - 1 ) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nwhile ( html . charAt ( lastIndex ) != ';' ) { \nlastIndex ++ ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( html . charAt ( ndx + 1 ) == '#' ) { \nchar c = html . charAt ( ndx + 2 ) ; \nint radix ; \nif ( ( c == 'x' ) || ( c == 'X' ) ) { \nradix = 16 ; \nndx = ndx + 3 ; \n} \nelse { \nradix = 10 ; \nndx = ndx + 2 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nint i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex ++ ; \n} \nelse { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( replacement == null ) { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \nelse { \nresult . append ( replacement ) ; \nlastIndex ++ ; \n} \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1155": "public class HsqlDbPager { \n@ Override protected String buildOrderSql ( String sql , final String column , final boolean ascending ) { \nsql = sql + \" order by \" + column ; \nif ( ! ascending ) { \nsql = sql + \" desc\" ; \n} \nreturn sql ; \n} \n} \n"}
{"1165": "public class StringBand { \npublic StringBand append ( String s ) { \nif ( s == null ) { \ns = StringPool . NULL ; \n} \nif ( index >= array . length ) { \nexpandCapacity ( ) ; \n} \narray [ index ++ ] = s ; \nlength = length + s . length ( ) ; \nreturn this ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nint len = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) { \nlen = len + array [ i ] . length ( ) ; \n} \nreturn len ; \n} \n} \n"}
{"1178": "public class FieldWriter { \nint computeFieldInfoSize ( ) { \nint size = 8 ; \nif ( constantValueIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; \nsize = size + 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { \nsymbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; \nsize = size + 6 ; \n} \nif ( signatureIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; \nsize = size + 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; \nsize = size + 6 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nsize = size + lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nsize = size + lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nsize = size + lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nsize = size + lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( firstAttribute != null ) { \nsize = size + firstAttribute . computeAttributesSize ( symbolTable ) ; \n} \nreturn size ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \n++ attributesCount ; \n} \nif ( signatureIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( firstAttribute != null ) { \nattributesCount = attributesCount + firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nint lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) { \nif ( reqProxyClassName . startsWith ( DOT ) ) { \nname = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \n} \nelse if ( reqProxyClassName . endsWith ( DOT ) ) { \nname = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \n} \nelse { \nname = reqProxyClassName . replace ( '.' , '/' ) ; \n} \n} \nif ( suffix != null ) { \nname = name + suffix ; \n} \nthis . thisReference = name ; \nthis . superReference = this . superName ; \n} \n} \n"}
{"1215": "public class PropsParser { \nprotected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { \nif ( operator == Operator . COPY ) { \nHashMap < String , Object > target = new HashMap < > ( ) ; \nString [ ] profiles = null ; \nif ( keyProfiles != null ) { \nprofiles = keyProfiles . toArray ( new String [ 0 ] ) ; \n} \nString [ ] sources = StringUtil . splitc ( value , ',' ) ; \nfor ( String source : sources ) { \nsource = source . trim ( ) ; \nString [ ] lookupProfiles = profiles ; \nString lookupProfilesString = null ; \nint leftIndex = source . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = source . indexOf ( '>' ) ; \nlookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; \nsource = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nString [ ] wildcards = new String [ ] { \nsource + \".*\" } \n; \npropsData . extract ( target , lookupProfiles , wildcards , null ) ; \nfor ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { \nString entryKey = entry . getKey ( ) ; \nString suffix = entryKey . substring ( source . length ( ) ) ; \nString newKey = key + suffix ; \nString newValue = \"${\" + entryKey ; \nif ( lookupProfilesString != null ) { \nnewValue = newValue + \"<\" + lookupProfilesString + \">\" ; \n} \nnewValue = newValue + \"}\" ; \nif ( profiles == null ) { \npropsData . putBaseProperty ( newKey , newValue , false ) ; \n} \nelse { \nfor ( final String p : profiles ) { \npropsData . putProfileProperty ( newKey , newValue , p , false ) ; \n} \n} \n} \n} \nreturn ; \n} \nboolean append = operator == Operator . QUICK_APPEND ; \nif ( keyProfiles == null ) { \npropsData . putBaseProperty ( key , value , append ) ; \nreturn ; \n} \nfor ( final String p : keyProfiles ) { \npropsData . putProfileProperty ( key , value , p , append ) ; \n} \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni = i - 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1234": "public class NaturalOrderComparator { \nprivate char fixAccent ( final char c ) { \nfor ( int i = 0 ; \ni < ACCENT_CHARS . length ; \ni = i + 2 ) { \nfinal char accentChar = ACCENT_CHARS [ i ] ; \nif ( accentChar == c ) { \nreturn ACCENT_CHARS [ i + 1 ] ; \n} \n} \nreturn c ; \n} \n} \n"}
{"1243": "public class ByteVector { \npublic ByteVector putByteArray ( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { \nif ( length + byteLength > data . length ) { \nenlarge ( byteLength ) ; \n} \nif ( byteArrayValue != null ) { \nSystem . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; \n} \nlength = length + byteLength ; \nreturn this ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = content . length + 1 ; \nint blockCount = length / blockSizeInBytes ; \nint remaining = length ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount ; \ni ++ ) { \nif ( remaining == blockSizeInBytes ) { \nbreak ; \n} \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset = offset + blockSizeInBytes ; \nremaining = remaining - blockSizeInBytes ; \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount - 1 ; \ni ++ ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset = offset + blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nwhile ( ndx >= 0 ) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1342": "public class FileUploadHeader { \nprivate String getContentType ( final String dataHeader ) { \nString token = \"Content-Type:\" ; \nint start = dataHeader . indexOf ( token ) ; \nif ( start == - 1 ) { \nreturn StringPool . EMPTY ; \n} \nstart = start + token . length ( ) ; \nreturn dataHeader . substring ( start ) . trim ( ) ; \n} \n} \n"}
{"1413": "public class LoopIterator { \npublic boolean next ( ) { \nif ( ! looping ) { \nreturn false ; \n} \nif ( last ) { \nreturn false ; \n} \nif ( count == 0 ) { \nvalue = start ; \nfirst = true ; \n} \nelse { \nvalue = value + step ; \nfirst = false ; \n} \ncount ++ ; \nlast = isLastIteration ( value + step ) ; \nreturn true ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark = mark + MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark = mark + MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark = mark + MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark = mark + MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) { \nreturn queryMap ; \n} \nint lastNdx = 0 ; \nwhile ( lastNdx < query . length ( ) ) { \nint ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) { \nndx = query . length ( ) ; \n} \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ndx == - 1 ) { \nqueryMap . add ( paramAndValue , null ) ; \n} \nelse { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) { \nname = URLDecoder . decodeQuery ( name ) ; \n} \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) { \nvalue = URLDecoder . decodeQuery ( value ) ; \n} \nqueryMap . add ( name , value ) ; \n} \nlastNdx = lastNdx + paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1471": "public class ClassUtil { \npublic static JarFile jarFileOf ( final Class < ? > klass ) { \nURL url = klass . getResource ( \"/\" + klass . getName ( ) . replace ( '.' , '/' ) + \".class\" ) ; \nif ( url == null ) { \nreturn null ; \n} \nString s = url . getFile ( ) ; \nint beginIndex = s . indexOf ( \"file:\" ) + \"file:\" . length ( ) ; \nint endIndex = s . indexOf ( \".jar!\" ) ; \nif ( endIndex == - 1 ) { \nreturn null ; \n} \nendIndex = endIndex + \".jar\" . length ( ) ; \nString f = s . substring ( beginIndex , endIndex ) ; \nf = URLDecoder . decode ( f , \"UTF-8\" ) ; \nFile file = new File ( f ) ; \ntry { \nreturn file . exists ( ) ? new JarFile ( file ) : null ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"1489": "public class MemoryFileUpload { \n@ Override public void processStream ( ) throws IOException { \nFastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; \nsize = 0 ; \nif ( maxFileSize == - 1 ) { \nsize = size + input . copyAll ( out ) ; \n} \nelse { \nsize = size + input . copyMax ( out , maxFileSize + 1 ) ; \nif ( size > maxFileSize ) { \nfileTooBig = true ; \nvalid = false ; \ninput . skipToBoundary ( ) ; \nreturn ; \n} \n} \ndata = out . toByteArray ( ) ; \nsize = data . length ; \nvalid = true ; \n} \n} \n"}
{"1493": "public class ArraysUtil { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { \nif ( arrays . length == 1 ) { \nreturn arrays [ 0 ] ; \n} \nint length = 0 ; \nfor ( T [ ] array : arrays ) { \nlength = length + array . length ; \n} \nT [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; \nlength = 0 ; \nfor ( T [ ] array : arrays ) { \nSystem . arraycopy ( array , 0 , result , length , array . length ) ; \nlength = length + array . length ; \n} \nreturn result ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( int i = 0 , sourcesArrayLength = sourcesArray . length ; \ni < sourcesArrayLength ; \ni ++ ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId = bundleId + '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1519": "public class HtmlStaplerBundlesManager { \nprotected String createDigest ( final String source ) { \nfinal DigestEngine digestEngine = DigestEngine . sha256 ( ) ; \nfinal byte [ ] bytes = digestEngine . digest ( CharUtil . toSimpleByteArray ( source ) ) ; \nString digest = Base32 . encode ( bytes ) ; \nif ( uniqueDigestKey != null ) { \ndigest = digest + uniqueDigestKey ; \n} \nreturn digest ; \n} \n} \n"}
{"1520": "public class HtmlStaplerBundlesManager { \nprotected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { \nfinal File bundleFile = createBundleFile ( bundleId ) ; \nif ( bundleFile . exists ( ) ) { \nreturn ; \n} \nStringBand sb = new StringBand ( sources . size ( ) * 2 ) ; \nfor ( String src : sources ) { \nif ( sb . length ( ) != 0 ) { \nsb . append ( StringPool . NEWLINE ) ; \n} \nString content ; \nif ( isExternalResource ( src ) ) { \ncontent = downloadString ( src ) ; \n} \nelse { \nif ( ! downloadLocal ) { \nString localFile = webRoot ; \nif ( src . startsWith ( contextPath + '/' ) ) { \nsrc = src . substring ( contextPath . length ( ) ) ; \n} \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalFile = localFile + src ; \n} \nelse { \nlocalFile = localFile + '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; \n} \nint qmndx = localFile . indexOf ( '?' ) ; \nif ( qmndx != - 1 ) { \nlocalFile = localFile . substring ( 0 , qmndx ) ; \n} \ntry { \ncontent = FileUtil . readString ( localFile ) ; \n} \ncatch ( IOException ioex ) { \nif ( notFoundExceptionEnabled ) { \nthrow ioex ; \n} \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( ioex . getMessage ( ) ) ; \n} \ncontent = null ; \n} \n} \nelse { \nString localUrl = localAddressAndPort ; \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalUrl = localUrl + contextPath + src ; \n} \nelse { \nlocalUrl = localUrl + contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; \n} \ncontent = downloadString ( localUrl ) ; \n} \nif ( content != null ) { \nif ( isCssResource ( src ) ) { \ncontent = fixCssRelativeUrls ( content , src ) ; \n} \n} \n} \nif ( content != null ) { \ncontent = onResourceContent ( content ) ; \nsb . append ( content ) ; \n} \n} \nFileUtil . writeString ( bundleFile , sb . toString ( ) ) ; \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"Bundle created: \" + bundleId ) ; \n} \n} \n} \n"}
{"1538": "public class PropertiesUtil { \npublic static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { \nif ( StringUtil . isBlank ( prefix ) ) { \nreturn p ; \n} \nif ( ! prefix . endsWith ( StringPool . DOT ) ) { \nprefix = prefix + '.' ; \n} \nProperties result = new Properties ( ) ; \nint baseLen = prefix . length ( ) ; \nfor ( Object o : p . keySet ( ) ) { \nString key = ( String ) o ; \nif ( key . startsWith ( prefix ) ) { \nresult . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \nfor ( int i = 0 ; \ni < mappings . length ; \ni ++ ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) { \nfound = true ; \n} \nelse { \nmapping = mapping + StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal int proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nint index = 0 ; \nbuf [ index ++ ] = 4 ; \nbuf [ index ++ ] = 1 ; \nbuf [ index ++ ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index ++ ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index ++ ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex = index + user . length ( ) ; \n} \nbuf [ index ++ ] = 0 ; \nout . write ( buf , 0 , index ) ; \nint len = 6 ; \nint s = 0 ; \nwhile ( s < len ) { \nint i = in . read ( buf , s , len - s ) ; \nif ( i <= 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \n} \ns = s + i ; \n} \nif ( buf [ 0 ] != 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \n} \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1602": "public class Attribute { \nfinal int getAttributeCount ( ) { \nint count = 0 ; \nAttribute attribute = this ; \nwhile ( attribute != null ) { \ncount = count + 1 ; \nattribute = attribute . nextAttribute ; \n} \nreturn count ; \n} \n} \n"}
{"1619": "public class Frame { \nprivate void pop ( final int elements ) { \nif ( outputStackTop >= elements ) { \noutputStackTop = outputStackTop - elements ; \n} \nelse { \noutputStackStart = outputStackStart - elements - outputStackTop ; \noutputStackTop = 0 ; \n} \n} \n} \n"}
{"1635": "public class ActionRequest { \nprotected ActionWrapper [ ] createExecutionArray ( ) { \nint totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; \nint totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; \nActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; \nint index = 0 ; \nif ( totalFilters > 0 ) { \nSystem . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; \nindex = index + totalFilters ; \n} \nexecutionArray [ index ++ ] = actionRequest -> { \nObject actionResult = actionRequest . invoke ( ) ; \nActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; \nreturn actionResult ; \n} \n; \nif ( totalInterceptors > 0 ) { \nSystem . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; \nindex = index + totalInterceptors ; \n} \nexecutionArray [ index ] = actionRequest -> { \nactionResult = invokeActionMethod ( ) ; \nreturn actionResult ; \n} \n; \nreturn executionArray ; \n} \n} \n"}
{"1650": "public class Props { \n@ SuppressWarnings ( \"unchecked\" ) public Props load ( final Map < ? , ? > map , final String prefix ) { \nString realPrefix = prefix ; \nrealPrefix = realPrefix + '.' ; \nfor ( final Map . Entry entry : map . entrySet ( ) ) { \nfinal String name = entry . getKey ( ) . toString ( ) ; \nfinal Object value = entry . getValue ( ) ; \nif ( value == null ) { \ncontinue ; \n} \ndata . putBaseProperty ( realPrefix + name , value . toString ( ) , false ) ; \n} \nreturn this ; \n} \n} \n"}
{"1658": "public class Props { \npublic void addInnerMap ( String prefix , final Map < ? , ? > map , final String profile ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { \nprefix = prefix + StringPool . DOT ; \n} \nfor ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { \nString key = entry . getKey ( ) . toString ( ) ; \nkey = prefix + key ; \nsetValue ( key , entry . getValue ( ) . toString ( ) , profile ) ; \n} \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( i < ranges . length ) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen = len + gap ; \nlens [ i ] = len ; \ni = i + 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count -- > 0 ) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \ni < ranges . length ; \ni = i + 2 ) { \nif ( r < lens [ i ] ) { \nr = r + ranges [ i ] ; \nif ( i != 0 ) { \nr = r - lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1711": "public class NetUtil { \npublic static int getIpAsInt ( final String ipAddress ) { \nint ipIntValue = 0 ; \nString [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; \nfor ( String token : tokens ) { \nif ( ipIntValue > 0 ) { \nipIntValue <<= 8 ; \n} \nipIntValue = ipIntValue + Integer . parseInt ( token ) ; \n} \nreturn ipIntValue ; \n} \n} \n"}
{"1749": "public class DispatcherUtil { \npublic static String getUrl ( final HttpServletRequest request ) { \nString servletPath = request . getServletPath ( ) ; \nString query = request . getQueryString ( ) ; \nif ( ( query != null ) && ( query . length ( ) != 0 ) ) { \nservletPath = servletPath + '?' + query ; \n} \nreturn servletPath ; \n} \n} \n"}
{"1778": "public class JulianDate { \npublic long toMilliseconds ( ) { \ndouble then = ( fraction - JD_1970 . fraction ) * MILLIS_IN_DAY ; \nthen = then + ( integer - JD_1970 . integer ) * MILLIS_IN_DAY ; \nthen = then + then > 0 ? 1.0e-6 : - 1.0e-6 ; \nreturn ( long ) then ; \n} \n} \n"}
{"1781": "public class JulianDate { \nprivate void set ( final int i , double f ) { \ninteger = i ; \nint fi = ( int ) f ; \nf = f - fi ; \ninteger = integer + fi ; \nif ( f < 0 ) { \nf = f + 1 ; \ninteger -- ; \n} \nthis . fraction = f ; \n} \n} \n"}
{"1793": "public class ModuleWriter { \nint computeAttributesSize ( ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE ) ; \nint size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \nif ( packageCount > 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; \nsize = size + 8 + packageIndex . length ; \n} \nif ( mainClassIndex > 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; \nsize = size + 8 ; \n} \nreturn size ; \n} \n} \n"}
{"1822": "public class ReplayMerge { \npublic int doWork ( ) { \nint workCount = 0 ; \nswitch ( state ) { \ncase AWAIT_INITIAL_RECORDING_POSITION : workCount = workCount + awaitInitialRecordingPosition ( ) ; \nbreak ; \ncase AWAIT_REPLAY : workCount = workCount + awaitReplay ( ) ; \nbreak ; \ncase AWAIT_CATCH_UP : workCount = workCount + awaitCatchUp ( ) ; \nbreak ; \ncase AWAIT_CURRENT_RECORDING_POSITION : workCount = workCount + awaitUpdatedRecordingPosition ( ) ; \nbreak ; \ncase AWAIT_STOP_REPLAY : workCount = workCount + awaitStopReplay ( ) ; \nbreak ; \n} \nreturn workCount ; \n} \n} \n"}
{"1834": "public class BufferBuilder { \npublic BufferBuilder append ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { \nensureCapacity ( length ) ; \nbuffer . putBytes ( limit , srcBuffer , srcOffset , length ) ; \nlimit = limit + length ; \nreturn this ; \n} \n} \n"}
{"1870": "public class TermScanner { \npublic static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { \nfinal int limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; \nint available = 0 ; \nint padding = 0 ; \ndo { \nfinal int termOffset = offset + available ; \nfinal int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; \nif ( frameLength <= 0 ) { \nbreak ; \n} \nint alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nif ( isPaddingFrame ( termBuffer , termOffset ) ) { \npadding = alignedFrameLength - HEADER_LENGTH ; \nalignedFrameLength = HEADER_LENGTH ; \n} \navailable = available + alignedFrameLength ; \nif ( available > limit ) { \navailable = available - alignedFrameLength ; \npadding = 0 ; \nbreak ; \n} \n} \nwhile ( 0 == padding && available < limit ) ; \nreturn pack ( padding , available ) ; \n} \n} \n"}
{"1872": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder validate ( ) { \nif ( null == media ) { \nthrow new IllegalStateException ( \"media type is mandatory\" ) ; \n} \nif ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) { \nthrow new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; \n} \nint count = 0 ; \ncount = count + null == initialTermId ? 0 : 1 ; \ncount = count + null == termId ? 0 : 1 ; \ncount = count + null == termOffset ? 0 : 1 ; \nif ( count > 0 ) { \nif ( count < 3 ) { \nthrow new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; \n} \nif ( termId - initialTermId < 0 ) { \nthrow new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; \n} \nif ( null != termLength && termOffset > termLength ) { \nthrow new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1886": "public class ChannelEndpointStatus { \npublic static AtomicCounter allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final String channel ) { \nfinal int keyLength = tempBuffer . putStringWithoutLengthAscii ( CHANNEL_OFFSET + SIZE_OF_INT , channel , 0 , MAX_CHANNEL_LENGTH ) ; \ntempBuffer . putInt ( CHANNEL_OFFSET , keyLength ) ; \nint labelLength = 0 ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , name ) ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , \": \" ) ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , channel , 0 , MAX_LABEL_LENGTH - labelLength ) ; \nreturn countersManager . newCounter ( typeId , tempBuffer , 0 , keyLength , tempBuffer , keyLength , labelLength ) ; \n} \n} \n"}
{"1889": "public class DirectBufferVector { \npublic static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { \nint messageLength = 0 ; \nfor ( final DirectBufferVector vector : vectors ) { \nvector . validate ( ) ; \nmessageLength = messageLength + vector . length ; \nif ( messageLength < 0 ) { \nthrow new IllegalStateException ( \"length overflow: \" + Arrays . toString ( vectors ) ) ; \n} \n} \nreturn messageLength ; \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote || member . candidateTermId != candidateTermId ) { \nreturn false ; \n} \nvotes = votes + member . vote ? 1 : 0 ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( members . length ) ; \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal int serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( keyLength > MAX_KEY_LENGTH ) { \nthrow new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \n} \nfor ( int i = 0 ; \ni < serviceCount ; \ni ++ ) { \ntempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \n} \nfinal int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength = labelLength + tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength = labelLength + tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1970": "public class ServiceHeartbeat { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final int serviceId ) { \ntempBuffer . putInt ( SERVICE_ID_OFFSET , serviceId ) ; \nfinal int labelOffset = BitUtil . align ( KEY_LENGTH , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength = labelLength + tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength = labelLength + tempBuffer . putIntAscii ( labelOffset + labelLength , serviceId ) ; \nreturn aeron . addCounter ( SERVICE_HEARTBEAT_TYPE_ID , tempBuffer , 0 , KEY_LENGTH , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( bytesUsed == 0 ) { \nnextSlabSize = initialSlabSize ; \n} \nelse if ( bytesUsed > maxCapacityHint / 5 ) { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = bytesUsed ; \n} \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated = this . bytesAllocated + nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( index < bytesUsed , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \nfor ( int i = 0 ; \ni < slabs . size ( ) ; \ni ++ ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( index < seen + slab . limit ( ) ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen = seen + slab . limit ( ) ; \n} \n} \n} \n"}
{"1978": "public class ColumnIndexBuilder { \npublic void add ( Statistics < ? > stats ) { \nif ( stats . hasNonNullValue ( ) ) { \nnullPages . add ( false ) ; \nObject min = stats . genericGetMin ( ) ; \nObject max = stats . genericGetMax ( ) ; \naddMinMax ( min , max ) ; \npageIndexes . add ( nextPageIndex ) ; \nminMaxSize = minMaxSize + sizeOf ( min ) ; \nminMaxSize = minMaxSize + sizeOf ( max ) ; \n} \nelse { \nnullPages . add ( true ) ; \n} \nnullCounts . add ( stats . getNumNulls ( ) ) ; \n++ nextPageIndex ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations = totalAllocations + allocation ; \n} \nif ( totalAllocations <= totalMemoryPool ) { \nscale = 1.0 ; \n} \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"1998": "public class ParquetFileWriter { \npublic void writeDictionaryPage ( DictionaryPage dictionaryPage ) throws IOException { \nstate = state . write ( ) ; \nLOG . debug ( \"{}: write dictionary page: {} values\" , out . getPos ( ) , dictionaryPage . getDictionarySize ( ) ) ; \ncurrentChunkDictionaryPageOffset = out . getPos ( ) ; \nint uncompressedSize = dictionaryPage . getUncompressedSize ( ) ; \nint compressedPageSize = ( int ) dictionaryPage . getBytes ( ) . size ( ) ; \nmetadataConverter . writeDictionaryPageHeader ( uncompressedSize , compressedPageSize , dictionaryPage . getDictionarySize ( ) , dictionaryPage . getEncoding ( ) , out ) ; \nlong headerSize = out . getPos ( ) - currentChunkDictionaryPageOffset ; \nthis . uncompressedLength = this . uncompressedLength + uncompressedSize + headerSize ; \nthis . compressedLength = this . compressedLength + compressedPageSize + headerSize ; \nLOG . debug ( \"{}: write dictionary page content {}\" , out . getPos ( ) , compressedPageSize ) ; \ndictionaryPage . getBytes ( ) . writeAllTo ( out ) ; \nencodingStatsBuilder . addDictEncoding ( dictionaryPage . getEncoding ( ) ) ; \ncurrentEncodings . add ( dictionaryPage . getEncoding ( ) ) ; \n} \n} \n"}
{"2000": "public class ParquetFileWriter { \nvoid writeColumnChunk ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName , DictionaryPage dictionaryPage , BytesInput bytes , long uncompressedTotalPageSize , long compressedTotalPageSize , Statistics < ? > totalStats , ColumnIndexBuilder columnIndexBuilder , OffsetIndexBuilder offsetIndexBuilder , Set < Encoding > rlEncodings , Set < Encoding > dlEncodings , List < Encoding > dataEncodings ) throws IOException { \nstartColumn ( descriptor , valueCount , compressionCodecName ) ; \nstate = state . write ( ) ; \nif ( dictionaryPage != null ) { \nwriteDictionaryPage ( dictionaryPage ) ; \n} \nLOG . debug ( \"{}: write data pages\" , out . getPos ( ) ) ; \nlong headersSize = bytes . size ( ) - compressedTotalPageSize ; \nthis . uncompressedLength = this . uncompressedLength + uncompressedTotalPageSize + headersSize ; \nthis . compressedLength = this . compressedLength + compressedTotalPageSize + headersSize ; \nLOG . debug ( \"{}: write data pages content\" , out . getPos ( ) ) ; \nfirstPageOffset = out . getPos ( ) ; \nbytes . writeAllTo ( out ) ; \nencodingStatsBuilder . addDataEncodings ( dataEncodings ) ; \nif ( rlEncodings . isEmpty ( ) ) { \nencodingStatsBuilder . withV2Pages ( ) ; \n} \ncurrentEncodings . addAll ( rlEncodings ) ; \ncurrentEncodings . addAll ( dlEncodings ) ; \ncurrentEncodings . addAll ( dataEncodings ) ; \ncurrentStatistics = totalStats ; \nthis . columnIndexBuilder = columnIndexBuilder ; \nthis . offsetIndexBuilder = offsetIndexBuilder ; \nendColumn ( ) ; \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nwhile ( bytesCopied < length ) { \nlong bytesLeft = length - bytesCopied ; \nint bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( bytesRead < 0 ) { \nthrow new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \n} \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied = bytesCopied + bytesRead ; \n} \n} \n} \n"}
{"2016": "public class ColumnWriterBase { \nvoid writePage ( ) { \nif ( valueCount == 0 ) { \nthrow new ParquetEncodingException ( \"writing empty page\" ) ; \n} \nthis . rowsWrittenSoFar = this . rowsWrittenSoFar + pageRowCount ; \nif ( DEBUG ) LOG . debug ( \"write page\" ) ; \ntry { \nwritePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; \n} \ncatch ( IOException e ) { \nthrow new ParquetEncodingException ( \"could not write page for \" + path , e ) ; \n} \nrepetitionLevelColumn . reset ( ) ; \ndefinitionLevelColumn . reset ( ) ; \ndataColumn . reset ( ) ; \nvalueCount = 0 ; \nresetStatistics ( ) ; \npageRowCount = 0 ; \n} \n} \n"}
{"2078": "public class ByteBasedBitPackingEncoder { \npublic void writeInt ( int value ) throws IOException { \ninput [ inputSize ] = value ; \n++ inputSize ; \nif ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { \npack ( ) ; \nif ( packedPosition == slabSize ) { \nslabs . add ( BytesInput . from ( packed ) ) ; \ntotalFullSlabSize = totalFullSlabSize + slabSize ; \nif ( slabSize < bitWidth * MAX_SLAB_SIZE_MULT ) { \nslabSize = slabSize * 2 ; \n} \ninitPackedSlab ( ) ; \n} \n} \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \nfor ( int i = pos ; \ni < idx ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset = incompleteMultiLineOffset + incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \ni < chunkLines . size ( ) ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \nelse { \nif ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime = waitTime * 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \n} \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2348": "public class CollectdParser { \nprivate int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { \nint offset = startOffset ; \nint type = buf . getUnsignedShort ( offset ) ; \noffset = offset + 2 ; \nfinal int length = buf . getUnsignedShort ( offset ) ; \noffset = offset + 2 ; \nswitch ( type ) { \ncase HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; \noffset = offset + length - 4 ; \nbreak ; \ncase TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES || ! excludeInterval ) { \nlong value = parseNumeric ( offset , buf ) ; \nif ( convertTime ) { \nvalue = value * ( Math . pow ( 2 , - 30 ) * 1000 ) ; \ntype = type == TIME_HIRES ? TIME : INTERVAL ; \n} \nfields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; \n} \noffset = offset + 8 ; \nbreak ; \ncase TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL || ! excludeInterval ) { \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; \n} \noffset = offset + 8 ; \nbreak ; \ncase VALUES : offset = parseValues ( offset , buf ) ; \nstartNewRecord ( ) ; \nbreak ; \ncase SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) { \nthrow new OnRecordErrorException ( Errors . COLLECTD_02 ) ; \n} \noffset = offset + length - 4 ; \nbreak ; \ncase ENCRYPTION : String user = parseUser ( offset , buf ) ; \noffset = offset + ( 2 + user . length ( ) ) ; \nbyte [ ] iv = parseIv ( offset , buf ) ; \noffset = offset + 16 ; \ndecrypt ( offset , length , buf , user , iv ) ; \noffset = offset + 20 ; \nbreak ; \ndefault : LOG . warn ( \"Unrecognized part type: {}\" , type ) ; \noffset = offset + length - 4 ; \nbreak ; \n} \nreturn offset ; \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nint offset = startOffset ; \nint numValues = buf . getUnsignedShort ( offset ) ; \noffset = offset + 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nwhile ( numValues -- > 0 ) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset = offset + 1 ; \n} \nfor ( int i = 0 ; \ni < types . size ( ) ; \ni ++ ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset = offset + 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset = offset + 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset = offset + 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset = offset + 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2406": "public class SobjectRecordCreator { \nprotected String fixOffset ( String offsetColumn , String offset ) { \ncom . sforce . soap . partner . Field sfdcField = getFieldMetadata ( sobjectType , offsetColumn ) ; \nif ( SobjectRecordCreator . DECIMAL_TYPES . contains ( sfdcField . getType ( ) . toString ( ) ) && offset . contains ( \"E\" ) ) { \nBigDecimal val = new BigDecimal ( offset ) ; \noffset = val . toPlainString ( ) ; \nif ( val . compareTo ( MAX_OFFSET_INT ) > 0 && ! offset . contains ( \".\" ) ) { \noffset = offset + \".0\" ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nwhile ( pending > 0 || sendEverything ) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nint read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( read <= 0 ) { \nbreak ; \n} \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) { \nthis . data . close ( ) ; \n} \n} \nif ( ! sendEverything ) { \npending = pending - read ; \n} \n} \n} \n} \n"}
{"2877": "public class Utils { \npublic static void skip ( InputStream is , long amount ) throws IOException { \nlong leftToSkip = amount ; \nlong amountSkipped = 0 ; \nwhile ( leftToSkip > 0 && amountSkipped >= 0 ) { \namountSkipped = is . skip ( leftToSkip ) ; \nleftToSkip = leftToSkip - amountSkipped ; \n} \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) { \ncount = count / 2 ; \n} \nif ( count < threshold ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) { \nnMatchingKeys ++ ; \n} \nelse { \nbreak ; \n} \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nif ( conditionEstimation > count ) { \nreturn count ; \n} \nindexesCount = indexesCount + conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2912": "public class OReflectionHelper { \nprivate static List < Class < ? > > findClasses ( final File iDirectory , String iPackageName , ClassLoader iClassLoader ) throws ClassNotFoundException { \nfinal List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; \nif ( ! iDirectory . exists ( ) ) return classes ; \niPackageName = iPackageName + \".\" + iDirectory . getName ( ) ; \nString className ; \nfinal File [ ] files = iDirectory . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \nif ( file . isDirectory ( ) ) { \nif ( file . getName ( ) . contains ( \".\" ) ) continue ; \nclasses . addAll ( findClasses ( file , iPackageName , iClassLoader ) ) ; \n} \nelse if ( file . getName ( ) . endsWith ( CLASS_EXTENSION ) ) { \nclassName = file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - CLASS_EXTENSION . length ( ) ) ; \nclasses . add ( Class . forName ( iPackageName + '.' + className , true , iClassLoader ) ) ; \n} \n} \nreturn classes ; \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) host = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \nif ( host . contains ( \"/\" ) ) host = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \nif ( ! host . contains ( \":\" ) ) host = host + \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse if ( host . split ( \":\" ) . length < 2 || host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) host = host + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \ni < 4 ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor = cursor + 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse ++ columnNumber ; \nreturn ( char ) c ; \n} \n} \n"}
{"2982": "public class OMemoryStream { \npublic void fill ( final int iLength , final byte iFiller ) { \nassureSpaceFor ( iLength ) ; \nArrays . fill ( buffer , position , position + iLength , iFiller ) ; \nposition = position + iLength ; \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nint count = 0 ; \nfor ( int i = 0 ; \ni < table . length ; \ni ++ ) { \ncount = count + Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \n} \n} \n"}
{"3021": "public class FrequencySketch { \nprivate int indexOf ( final int item , final int i ) { \nlong hash = SEED [ i ] * item ; \nhash = hash + hash >> 32 ; \nreturn ( ( int ) hash ) & tableMask ; \n} \n} \n"}
{"3057": "public class OSessionStoragePerformanceStatistic { \npublic void stopWriteCacheFlushTimer ( int pagesFlushed ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . flushOperationsCount ++ ; \nwritCacheCountersHolder . amountOfPagesFlushed = writCacheCountersHolder . amountOfPagesFlushed + pagesFlushed ; \nwritCacheCountersHolder . flushOperationsTime = writCacheCountersHolder . flushOperationsTime + timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3058": "public class OSessionStoragePerformanceStatistic { \npublic void stopFuzzyCheckpointTimer ( ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . fuzzyCheckpointCount ++ ; \nwritCacheCountersHolder . fuzzyCheckpointTime = writCacheCountersHolder . fuzzyCheckpointTime + timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3059": "public class OSessionStoragePerformanceStatistic { \npublic void stopFullCheckpointTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( storageCountersHolder == null ) storageCountersHolder = new StorageCountersHolder ( ) ; \nstorageCountersHolder . fullCheckpointOperationsCount ++ ; \nstorageCountersHolder . fullCheckpointOperationsTime = storageCountersHolder . fullCheckpointOperationsTime + timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3060": "public class OSessionStoragePerformanceStatistic { \npublic void stopCommitTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nperformanceCountersHolder . commitTime = performanceCountersHolder . commitTime + timeDiff ; \nperformanceCountersHolder . commitCount ++ ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . logRecordCount ++ ; \nwalCountersHolder . logRecordTime = walCountersHolder . logRecordTime + timeDiff ; \nif ( isStartRecord ) { \nwalCountersHolder . startRecordCount ++ ; \nwalCountersHolder . startRecordTime = walCountersHolder . startRecordTime + timeDiff ; \n} \nelse if ( isStopRecord ) { \nwalCountersHolder . stopRecordCount ++ ; \nwalCountersHolder . stopRecordTime = walCountersHolder . stopRecordTime + timeDiff ; \n} \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3062": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALFlushTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . flushCount ++ ; \nwalCountersHolder . flushTime = walCountersHolder . flushTime + timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3156": "public class OSBTreeRidBag { \nprivate int updateSize ( ) { \nint size = 0 ; \nif ( collectionPointer != null ) { \nfinal OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; \nif ( tree == null ) { \nthrow new IllegalStateException ( \"RidBag is not properly initialized, can not load tree implementation\" ) ; \n} \ntry { \nsize = tree . getRealBagSize ( changes ) ; \n} \nfinally { \nreleaseTree ( ) ; \n} \n} \nelse { \nfor ( Change change : changes . values ( ) ) { \nsize = size + change . applyTo ( 0 ) ; \n} \n} \nfor ( OModifiableInteger diff : newEntries . values ( ) ) { \nsize = size + diff . getValue ( ) ; \n} \nthis . size = size ; \nreturn size ; \n} \n} \n"}
{"3157": "public class OHashIndexBucket { \npublic V getValue ( int index ) { \nint entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; \nentryPosition = entryPosition + OLongSerializer . LONG_SIZE ; \nif ( encryption == null ) { \nentryPosition = entryPosition + getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; \n} \nelse { \nfinal int encryptedLength = getIntValue ( entryPosition ) ; \nentryPosition = entryPosition + encryptedLength + OIntegerSerializer . INT_SIZE ; \n} \nreturn deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; \n} \n} \n"}
{"3220": "public class OHttpRequestWrapper { \npublic int hasParameters ( final String ... iNames ) { \nint found = 0 ; \nif ( iNames != null && request . parameters != null ) for ( String name : iNames ) found = found + request . parameters . containsKey ( name ) ? 1 : 0 ; \nreturn found ; \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nint currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nwhile ( pos >= ( currentSize = currentSize + binaryDataChunks . get ( currentChunkIndex ) . length ) ) currentChunkIndex ++ ; \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize = currentSize - currentChunk . length ; \nint relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3341": "public class OMemoryInputStream { \npublic int getAsByteArrayOffset ( ) { \nif ( position >= length ) return - 1 ; \nfinal int begin = position ; \nfinal int size = OBinaryProtocol . bytes2int ( buffer , position ) ; \nposition = position + OBinaryProtocol . SIZE_INT + size ; \nreturn begin ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos = pos + i ; \navail = avail - i ; \nread = read + i ; \nremaining = remaining - i ; \nif ( remaining == 0 ) { \nreadBytes = readBytes + read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes = readBytes + read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes = readBytes + read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes = readBytes + read ; \n} \nelse readBytes = readBytes + read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes = readBytes + read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes = readBytes + read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes = readBytes + read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nint len ; \nwhile ( toSkip > 0 ) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( len > 0 ) toSkip = toSkip - len ; \nelse break ; \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos = pos + m ; \navail = avail - m ; \nreadBytes = readBytes + n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \nelse toSkip = toSkip - result ; \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes = readBytes + t ; \nreturn t ; \n} \n} \n"}
{"3354": "public class HashCommon { \npublic static int murmurHash3 ( int x ) { \nx ^= x >>> 16 ; \nx = x * 0x85ebca6b ; \nx ^= x >>> 13 ; \nx = x * 0xc2b2ae35 ; \nx ^= x >>> 16 ; \nreturn x ; \n} \n} \n"}
{"3355": "public class HashCommon { \npublic static long murmurHash3 ( long x ) { \nx ^= x >>> 33 ; \nx = x * 0xff51afd7ed558ccdL ; \nx ^= x >>> 33 ; \nx = x * 0xc4ceb9fe1a85ec53L ; \nx ^= x >>> 33 ; \nreturn x ; \n} \n} \n"}
{"3356": "public class InspectableFileCachedInputStream { \n@ Override public int write ( final ByteBuffer byteBuffer ) throws IOException { \nensureOpen ( ) ; \nfinal int remaining = byteBuffer . remaining ( ) ; \nif ( inspectable < buffer . length ) { \nfinal int toBuffer = Math . min ( buffer . length - inspectable , remaining ) ; \nbyteBuffer . get ( buffer , inspectable , toBuffer ) ; \ninspectable = inspectable + toBuffer ; \n} \nif ( byteBuffer . hasRemaining ( ) ) { \nfileChannel . position ( writePosition ) ; \nwritePosition = writePosition + fileChannel . write ( byteBuffer ) ; \n} \nreturn remaining ; \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nint numLongs = dis . readInt ( ) ; \nint currentOrdinal = 0 ; \nfor ( int i = 0 ; \ni < numLongs ; \ni ++ ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal = currentOrdinal + 64 ; \n} \n} \n} \n"}
{"3376": "public class SegmentedByteArray { \npublic int copy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nwhile ( length > 0 ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \nSystem . arraycopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition = dataPosition + bytesToCopyFromSegment ; \nsrcPos = srcPos + bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength = length - bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nint segmentLength = 1 << log2OfSegmentSize ; \nint currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nint segmentStartPos = ( int ) ( destPos & bitmask ) ; \nint remainingBytesInSegment = segmentLength - segmentStartPos ; \nwhile ( length > 0 ) { \nint bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nint copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos = srcPos + copiedBytes ; \nlength = length - copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment ++ ; \n} \n} \n} \n"}
{"3379": "public class SegmentedByteArray { \npublic int orderedCopy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nwhile ( length > 0 ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \norderedCopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition = dataPosition + bytesToCopyFromSegment ; \nsrcPos = srcPos + bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength = length - bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nwhile ( length > 0 ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesCopied < bytesToCopy ) { \nbytesCopied = bytesCopied + is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength = length - bytesCopied ; \n} \n} \n} \n"}
{"3381": "public class SegmentedByteArray { \npublic void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nlong remainingBytesInCopy = len ; \nwhile ( remainingBytesInCopy > 0 ) { \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; \nos . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; \nstartPosition = startPosition + bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nremainingBytesInCopy = remainingBytesInCopy - bytesToCopyFromSegment ; \n} \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( int i = 0 ; \ni < elementArray . numLists ( ) ; \ni ++ ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; \nfor ( int j = 0 ; \nj < predictedBuckets ; \nj ++ ) selectArray [ j ] = - 1 ; \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets = totalBuckets + HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) maxSize = setSize ; \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3394": "public class HollowPrefixIndex { \nprivate void initialize ( ) { \nString lastRefType = this . fieldPath . getLastRefTypeInPath ( ) ; \ntotalWords = readStateEngine . getTypeState ( lastRefType ) . getPopulatedOrdinals ( ) . cardinality ( ) ; \naverageWordLen = 0 ; \ndouble avg = 0 ; \nHollowObjectTypeReadState objectTypeReadState = ( HollowObjectTypeReadState ) readStateEngine . getTypeState ( lastRefType ) ; \nBitSet keyBitSet = objectTypeReadState . getPopulatedOrdinals ( ) ; \nint ordinal = keyBitSet . nextSetBit ( 0 ) ; \nwhile ( ordinal != - 1 ) { \navg = avg + ( ( double ) objectTypeReadState . readString ( ordinal , 0 ) . length ( ) ) / ( ( double ) objectTypeReadState . maxOrdinal ( ) ) ; \nordinal = keyBitSet . nextSetBit ( ordinal + 1 ) ; \n} \naverageWordLen = ( int ) Math . ceil ( avg ) ; \nHollowObjectTypeReadState valueState = ( HollowObjectTypeReadState ) readStateEngine . getTypeDataAccess ( type ) ; \nmaxOrdinalOfType = valueState . maxOrdinal ( ) ; \nbuild ( ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \nfor ( int i = 0 ; \ni < numThreads ; \ni ++ ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \nfor ( int i = threadNumber ; \ni < matcher . getMatchedOrdinals ( ) . size ( ) ; \ni = i + numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInFrom ( ) . size ( ) ; \ni = i + numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInTo ( ) . size ( ) ; \ni = i + numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3411": "public class HollowMetrics { \nvoid calculateTypeMetrics ( HollowReadStateEngine hollowReadStateEngine ) { \nCollection < HollowTypeReadState > typeStates = hollowReadStateEngine . getTypeStates ( ) ; \nif ( typeStates == null ) return ; \ntotalHeapFootprint = 0L ; \ntotalPopulatedOrdinals = 0 ; \nfor ( HollowTypeReadState typeState : typeStates ) { \nlong heapCost = typeState . getApproximateHeapFootprintInBytes ( ) ; \ntotalHeapFootprint = totalHeapFootprint + heapCost ; \nint populatedOrdinals = typeState . getPopulatedOrdinals ( ) . cardinality ( ) ; \ntotalPopulatedOrdinals = totalPopulatedOrdinals + populatedOrdinals ; \nString type = typeState . getSchema ( ) . getName ( ) ; \ntypeHeapFootprint . put ( type , heapCost ) ; \ntypePopulatedOrdinals . put ( type , populatedOrdinals ) ; \n} \n} \n} \n"}
{"3417": "public class SetMapKeyHasher { \npublic static int hash ( Object key [ ] , FieldType fieldType [ ] ) { \nint hash = 0 ; \nfor ( int i = 0 ; \ni < key . length ; \ni ++ ) { \nhash = hash * 31 ; \nhash ^= hash ( key [ i ] , fieldType [ i ] ) ; \n} \nreturn hash ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \nreturn false ; \n} \nposition = position + VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( int i = 0 ; \ni < sizeOfData ; \ni ++ ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3424": "public class ByteArrayOrdinalMap { \nprivate int rehashPreviouslyAddedData ( long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nposition = position + VarInt . sizeOfVInt ( sizeOfData ) ; \nreturn HashCodes . hashCode ( byteData . getUnderlyingArray ( ) , position , sizeOfData ) ; \n} \n} \n"}
{"3507": "public class IoUtil { \npublic static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { \nlog . progressStart ( ) ; \ntry { \nOkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; \nRequest request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; \nResponse response = client . newCall ( request ) . execute ( ) ; \ntry ( OutputStream out = new FileOutputStream ( target ) ; \nInputStream im = response . body ( ) . byteStream ( ) ) { \nlong length = response . body ( ) . contentLength ( ) ; \nInputStream in = response . body ( ) . byteStream ( ) ; \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong readBytes = 0 ; \nwhile ( true ) { \nint len = in . read ( buffer ) ; \nreadBytes = readBytes + len ; \nlog . progressUpdate ( target . getName ( ) , \"Downloading\" , getProgressBar ( readBytes , length ) ) ; \nif ( len <= 0 ) { \nout . flush ( ) ; \nbreak ; \n} \nout . write ( buffer , 0 , len ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Failed to download URL \" + downloadUrl + \" to  \" + target + \": \" + e , e ) ; \n} \nfinally { \nlog . progressFinished ( ) ; \n} \n} \n} \n"}
{"3595": "public class H264Utils { \npublic static ByteBuffer joinNALUnits ( List < ByteBuffer > nalUnits ) { \nint size = 0 ; \nfor ( ByteBuffer nal : nalUnits ) { \nsize = size + 4 + nal . remaining ( ) ; \n} \nByteBuffer allocate = ByteBuffer . allocate ( size ) ; \njoinNALUnitsToBuffer ( nalUnits , allocate ) ; \nreturn allocate ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum = sum + taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix = sumFix + out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] = taps [ i ] + out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] = taps [ i ] - 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos = pos + buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3601": "public class ImageSequenceDemuxer { \npublic int getMaxAvailableFrame ( ) { \nif ( maxAvailableFrame == - 1 ) { \nint firstPoint = 0 ; \nfor ( int i = MAX_MAX ; \ni > 0 ; \ni = i / 2 ) { \nif ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { \nfirstPoint = i ; \nbreak ; \n} \n} \nint pos = firstPoint ; \nfor ( int interv = firstPoint / 2 ; \ninterv > 1 ; \ninterv = interv / 2 ) { \nif ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) { \npos = pos + interv ; \n} \n} \nmaxAvailableFrame = pos ; \nLogger . info ( \"Max frame found: \" + maxAvailableFrame ) ; \n} \nreturn Math . min ( maxAvailableFrame , maxFrames ) ; \n} \n} \n"}
{"3604": "public class QTTimeUtil { \npublic static long getEditedDuration ( TrakBox track ) { \nList < Edit > edits = track . getEdits ( ) ; \nif ( edits == null ) return track . getDuration ( ) ; \nlong duration = 0 ; \nfor ( Edit edit : edits ) { \nduration = duration + edit . getDuration ( ) ; \n} \nreturn duration ; \n} \n} \n"}
{"3605": "public class QTTimeUtil { \npublic static long frameToTimevalue ( TrakBox trak , int frameNumber ) { \nTimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) ; \nTimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; \nlong pts = 0 ; \nint sttsInd = 0 , sttsSubInd = frameNumber ; \nwhile ( sttsSubInd >= timeToSamples [ sttsInd ] . getSampleCount ( ) ) { \nsttsSubInd = sttsSubInd - timeToSamples [ sttsInd ] . getSampleCount ( ) ; \npts = pts + timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; \nsttsInd ++ ; \n} \nreturn pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; \n} \n} \n"}
{"3606": "public class QTTimeUtil { \npublic static int timevalueToFrame ( TrakBox trak , long tv ) { \nTimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) . getEntries ( ) ; \nint frame = 0 ; \nfor ( int i = 0 ; \ntv > 0 && i < tts . length ; \ni ++ ) { \nlong rem = tv / tts [ i ] . getSampleDuration ( ) ; \ntv = tv - tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; \nframe = frame + tv > 0 ? tts [ i ] . getSampleCount ( ) : rem ; \n} \nreturn frame ; \n} \n} \n"}
{"3607": "public class QTTimeUtil { \npublic static long mediaToEdited ( TrakBox trak , long mediaTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return mediaTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nif ( mediaTv < edit . getMediaTime ( ) ) return accum ; \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( edit . getMediaTime ( ) != - 1 && ( mediaTv >= edit . getMediaTime ( ) && mediaTv < edit . getMediaTime ( ) + duration ) ) { \naccum = accum + mediaTv - edit . getMediaTime ( ) ; \nbreak ; \n} \naccum = accum + duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3608": "public class QTTimeUtil { \npublic static long editedToMedia ( TrakBox trak , long editedTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return editedTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( accum + duration > editedTv ) { \nreturn edit . getMediaTime ( ) + editedTv - accum ; \n} \naccum = accum + duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3612": "public class QTTimeUtil { \npublic static String formatTimecode ( TrakBox timecodeTrack , int counter ) { \nTimecodeSampleEntry tmcd = NodeBox . findFirstPath ( timecodeTrack , TimecodeSampleEntry . class , Box . path ( \"mdia.minf.stbl.stsd.tmcd\" ) ) ; \nbyte nf = tmcd . getNumFrames ( ) ; \nString tc = String . format ( \"%02d\" , counter % nf ) ; \ncounter = counter / nf ; \ntc = String . format ( \"%02d\" , counter % 60 ) + \":\" + tc ; \ncounter = counter / 60 ; \ntc = String . format ( \"%02d\" , counter % 60 ) + \":\" + tc ; \ncounter = counter / 60 ; \ntc = String . format ( \"%02d\" , counter ) + \":\" + tc ; \nreturn tc ; \n} \n} \n"}
{"3618": "public class BitStream { \nprotected int readCache ( boolean peek ) throws AACException { \nint i ; \nif ( pos > buffer . length - WORD_BYTES ) throw AACException . endOfStream ( ) ; \nelse i = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; \nif ( ! peek ) pos = pos + WORD_BYTES ; \nreturn i ; \n} \n} \n"}
{"3620": "public class WavHeader { \npublic static WavHeader multiChannelWav ( WavHeader [ ] headers ) { \nWavHeader w = emptyWavHeader ( ) ; \nint totalSize = 0 ; \nfor ( int i = 0 ; \ni < headers . length ; \ni ++ ) { \nWavHeader wavHeader = headers [ i ] ; \ntotalSize = totalSize + wavHeader . dataSize ; \n} \nw . dataSize = totalSize ; \nFmtChunk fmt = headers [ 0 ] . fmt ; \nint bitsPerSample = fmt . bitsPerSample ; \nint bytesPerSample = bitsPerSample / 8 ; \nint sampleRate = ( int ) fmt . sampleRate ; \nw . fmt . bitsPerSample = ( short ) bitsPerSample ; \nw . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; \nw . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; \nw . fmt . numChannels = ( short ) headers . length ; \nw . fmt . sampleRate = sampleRate ; \nreturn w ; \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange = range - rangeLps ; \noffset = offset + rangeLps ; \nif ( range < 0x8000 ) { \nwhile ( range < 0x8000 ) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nwhile ( range < 0x8000 ) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n"}
{"3626": "public class SampleBuffer { \npublic void setBigEndian ( boolean bigEndian ) { \nif ( bigEndian != this . bigEndian ) { \nbyte tmp ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 2 ) { \ntmp = data [ i ] ; \ndata [ i ] = data [ i + 1 ] ; \ndata [ i + 1 ] = tmp ; \n} \nthis . bigEndian = bigEndian ; \n} \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( sinkColor != null ) { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nelse { \ntoEncode = new LoanerPicture ( pic , 0 ) ; \n} \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; \ntimestamp = timestamp + fps . getDen ( ) ; \nframeNo ++ ; \n} \n} \n"}
{"3631": "public class FLVWriter { \npublic void addPacket ( FLVTag pkt ) throws IOException { \nif ( ! writePacket ( writeBuf , pkt ) ) { \nwriteBuf . flip ( ) ; \nstartOfLastPacket = startOfLastPacket - out . write ( writeBuf ) ; \nwriteBuf . clear ( ) ; \nif ( ! writePacket ( writeBuf , pkt ) ) throw new RuntimeException ( \"Unexpected\" ) ; \n} \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nint bin ; \nint qIdx = ( range >> 6 ) & 0x3 ; \nint rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange = range - rLPS ; \nint rs8 = range << 8 ; \nif ( code < rs8 ) { \nif ( cm [ 0 ] [ m ] < 62 ) cm [ 0 ] [ m ] ++ ; \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nelse { \nrange = rLPS ; \ncode = code - rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3638": "public class SparseIDCT { \npublic static final void start ( int [ ] block , int dc ) { \ndc <<= DC_SHIFT ; \nfor ( int i = 0 ; \ni < 64 ; \ni = i + 4 ) { \nblock [ i + 0 ] = dc ; \nblock [ i + 1 ] = dc ; \nblock [ i + 2 ] = dc ; \nblock [ i + 3 ] = dc ; \n} \n} \n} \n"}
{"3639": "public class SparseIDCT { \npublic static final void coeff ( int [ ] block , int ind , int level ) { \nfor ( int i = 0 ; \ni < 64 ; \ni = i + 4 ) { \nblock [ i ] = block [ i ] + COEFF [ ind ] [ i ] * level ; \nblock [ i + 1 ] = block [ i + 1 ] + COEFF [ ind ] [ i + 1 ] * level ; \nblock [ i + 2 ] = block [ i + 2 ] + COEFF [ ind ] [ i + 2 ] * level ; \nblock [ i + 3 ] = block [ i + 3 ] + COEFF [ ind ] [ i + 3 ] * level ; \n} \n} \n} \n"}
{"3640": "public class SparseIDCT { \npublic static final void finish ( int block [ ] ) { \nfor ( int i = 0 ; \ni < 64 ; \ni = i + 4 ) { \nblock [ i ] = div ( block [ i ] ) ; \nblock [ i + 1 ] = div ( block [ i + 1 ] ) ; \nblock [ i + 2 ] = div ( block [ i + 2 ] ) ; \nblock [ i + 3 ] = div ( block [ i + 3 ] ) ; \n} \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) return ; \nint al = a . bufa ; \nint ah = a . bufb ; \nint bl , bh ; \nif ( len > 32 ) { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nelse { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen = len + a . len ; \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni ++ ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk = k + ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx = x + xDir ; \ny = y + yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead = bytesRead + videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset = offset + bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead = bytesRead + audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset = offset + bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3721": "public class Node { \npublic List < Transaction > getAddressTransactions ( String address , int limit , String after ) throws IOException { \nString requestUrl = String . format ( \"/transactions/address/%s/limit/%d\" , address , limit ) ; \nif ( after != null ) { \nrequestUrl = requestUrl + String . format ( \"?after=%s\" , after ) ; \n} \nreturn wavesJsonMapper . < List < List < Transaction > > > convertValue ( send ( requestUrl ) , new TypeReference < List < List < Transaction > > > ( ) { \n} \n) . get ( 0 ) ; \n} \n} \n"}
{"3752": "public class MBOut { \npublic void writeRaw ( byte [ ] bufferedName , int i , int length ) { \nif ( pos + length >= bytez . length - 1 ) { \nresize ( ) ; \n} \nSystem . arraycopy ( bufferedName , i , bytez , pos , length ) ; \npos = pos + length ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) { \nsumLen = sumLen + changeLength [ i ] ; \n} \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \nfor ( int ii = 0 ; \nii < len ; \nii ++ ) { \nsnapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \n} \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3767": "public class BinaryQueue { \npublic void back ( int len ) { \nif ( pollIndex >= len ) pollIndex = pollIndex - len ; \nelse pollIndex = pollIndex + capacity ( ) - len ; \n} \n} \n"}
{"3789": "public class MathUtils { \npublic static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { \nint count = 0 ; \nList < List < Double > > ret = new ArrayList < List < Double > > ( ) ; \nwhile ( count < arr . size ( ) ) { \nList < Double > sublist = arr . subList ( count , count + chunk ) ; \ncount = count + chunk ; \nret . add ( sublist ) ; \n} \nfor ( List < Double > lists : ret ) { \nif ( lists . size ( ) < chunk ) ret . remove ( lists ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3800": "public class BaseNDArrayFactory { \n@ Override public INDArray toFlattened ( Collection < INDArray > matrices ) { \nint length = 0 ; \nfor ( INDArray m : matrices ) length = length + m . length ( ) ; \nINDArray ret = Nd4j . create ( 1 , length ) ; \nint linearIndex = 0 ; \nfor ( INDArray d : matrices ) { \nret . put ( new INDArrayIndex [ ] { \nNDArrayIndex . interval ( linearIndex , linearIndex + d . length ( ) ) } \n, d ) ; \nlinearIndex = linearIndex + d . length ( ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3815": "public class DataSet { \n@ Override public long getMemoryFootprint ( ) { \nlong reqMem = features . lengthLong ( ) * Nd4j . sizeOfDataType ( ) ; \nreqMem = reqMem + labels == null ? 0 : labels . lengthLong ( ) * Nd4j . sizeOfDataType ( ) ; \nreqMem = reqMem + featuresMask == null ? 0 : featuresMask . lengthLong ( ) * Nd4j . sizeOfDataType ( ) ; \nreqMem = reqMem + labelsMask == null ? 0 : labelsMask . lengthLong ( ) * Nd4j . sizeOfDataType ( ) ; \nreturn reqMem ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc = exSc - exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex = pex * 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse if ( x . doubleValue ( ) > 1.5 ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \nn < 5 ; \nn ++ ) { \npsi = psi + zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \nfor ( int k = 1 ; \nk < 10 ; \nk ++ ) { \nx = x + a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \n} \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nint kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps = eps / kmax ; \nBigDecimal res = BigDecimal . ZERO ; \nfor ( int c = 0 ; \n; \nc ++ ) { \nRational r = new Rational ( ) ; \nfor ( int k = 0 ; \nk < 8 ; \nk ++ ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nint pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \n} \nif ( Math . abs ( r . doubleValue ( ) ) < eps ) { \nbreak ; \n} \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nint addPrecision = this . precision ; \nwhile ( addPrecision > 0 ) { \nthis . scientificFormat = this . scientificFormat + \"#\" ; \naddPrecision = addPrecision - 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . scientificFormat . length ( ) + 2 > this . padding ) this . padding = this . scientificFormat . length ( ) + 2 ; \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize && arr . length ( ) > 1000 ) return format ( arr , 0 , true ) ; \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) { \nquery = params ; \n} \nelse { \nquery = query + \"&\" + params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) { \npairsIterator . remove ( ) ; \n} \nelse if ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( vel > 0f ) { \nmAngularVelocity = mAngularVelocity - velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; \n} \nelse if ( vel < 0f ) { \nmAngularVelocity = mAngularVelocity - velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; \n} \nif ( mAngularVelocity != 0f ) { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \nelse { \nmRequiresUpdate = false ; \n} \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nfor ( int k = 0 ; \nk < s . length ( ) && k < strlen ; \nk ++ ) cdata [ start + k ] = s . charAt ( k ) ; \nstart = start + strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4269": "public class WFSGetCapabilitiesWriter { \nprivate void writeAConstraint ( String name , boolean isImplemented ) { \nString defValue ; \nif ( isImplemented ) defValue = \"TRUE\" ; \nelse defValue = \"FALSE\" ; \nfileOutput = fileOutput + \"<ows:Constraint name=\\\"\" + name + \"\\\"> \" + \"<ows:NoValues/> \" + \"<ows:DefaultValue>\" + defValue + \"</ows:DefaultValue> \" + \"</ows:Constraint>\" ; \n} \n} \n"}
{"4270": "public class WFSGetCapabilitiesWriter { \nprivate void writeHeadersAndSS ( ) { \nfileOutput = fileOutput + \"<wfs:WFS_Capabilities xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:ows=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ows/1.1\\\" xmlns:wfs=\\\"http://opengis.net/wfs/2.0\" ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\">\" ; \nwriteServiceInfo ( ) ; \n} \n} \n"}
{"4271": "public class WFSGetCapabilitiesWriter { \npublic void writeOperations ( ) { \nfileOutput = fileOutput + \"<ows:OperationsMetadata> \" ; \nfor ( WFSRequestType rt : operationList ) { \nwriteAOperation ( rt ) ; \n} \nfileOutput = fileOutput + \"<ows:Parameter name=\\\"AcceptVersions\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>2.0.0</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput = fileOutput + \"<ows:Parameter name=\\\"AcceptFormats\\\">\" + \"<ows:AllowedValues> \" + \"<ows:Value>text/xml</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput = fileOutput + \"<ows:Parameter name=\\\"Sections\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>ServiceIdentification</ows:Value> \" + \"<ows:Value>ServiceProvider</ows:Value> \" + \"<ows:Value>OperationsMetadata</ows:Value> \" + \"<ows:Value>FeatureTypeList</ows:Value> \" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput = fileOutput + \"<ows:Parameter name=\\\"version\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>2.0.0</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nwriteAConstraint ( \"ImplementsBasicWFS\" , true ) ; \nwriteAConstraint ( \"ImplementsTransactionalWFS\" , false ) ; \nwriteAConstraint ( \"ImplementsLockingWFS\" , false ) ; \nwriteAConstraint ( \"KVPEncoding\" , false ) ; \nwriteAConstraint ( \"XMLEncoding\" , true ) ; \nwriteAConstraint ( \"SOAPEncoding\" , false ) ; \nwriteAConstraint ( \"ImplementsInheritance\" , false ) ; \nwriteAConstraint ( \"ImplementsRemoteResolve\" , false ) ; \nwriteAConstraint ( \"ImplementsResultPaging\" , false ) ; \nwriteAConstraint ( \"ImplementsStandardJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsSpatialJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsTemporalJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsFeatureVersioning\" , false ) ; \nwriteAConstraint ( \"ManageStoredQueries\" , false ) ; \nwriteAConstraint ( \"PagingIsTransactionSafe\" , false ) ; \nwriteAConstraint ( \"QueryExpressions\" , false ) ; \nfileOutput = fileOutput + \"</ows:OperationsMetadata>\" ; \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total = stat . total + total ; \nstat . passed = stat . passed + count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( length <= ilenhd ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse if ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword = isword + ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \ni < kxky ; \ni ++ ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft = jshft - 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit = ibit + nbits ; \nif ( ibit > 32 ) { \nibit = ibit - 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4313": "public class MFlowLayout { \npublic Dimension preferredLayoutSize ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nDimension dim = new Dimension ( 0 , 0 ) ; \nfor ( int i = 0 ; \ni < target . getComponentCount ( ) ; \ni ++ ) { \nComponent m = target . getComponent ( i ) ; \nif ( m . isVisible ( ) ) { \nDimension d = m . getPreferredSize ( ) ; \nPoint p = m . getLocation ( ) ; \ndim . width = Math . max ( dim . width , p . x + d . width ) ; \ndim . height = Math . max ( dim . height , p . y + d . height ) ; \n} \n} \nInsets insets = target . getInsets ( ) ; \ndim . width = dim . width + insets . left + insets . right + getHgap ( ) * 2 ; \ndim . height = dim . height + insets . top + insets . bottom + getVgap ( ) * 2 ; \nreturn dim ; \n} \n} \n} \n"}
{"4329": "public class SigmetIOServiceProvider { \nstatic float calcAz ( short az0 , short az1 ) { \nfloat azim0 = calcAngle ( az0 ) ; \nfloat azim1 = calcAngle ( az1 ) ; \nfloat d = 0.0f ; \nd = Math . abs ( azim0 - azim1 ) ; \nif ( ( az0 < 0 ) & ( az1 > 0 ) ) { \nd = Math . abs ( 360.0f - azim0 ) + Math . abs ( azim1 ) ; \n} \ndouble temp = azim0 + d * 0.5 ; \nif ( temp > 360.0 ) { \ntemp = temp - 360.0 ; \n} \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) { \nsequenceOffset [ i ] = total ; \ntotal = total + sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4343": "public class Format { \npublic static String formatByteSize ( double size ) { \nString unit = null ; \nif ( size > 1.0e15 ) { \nunit = \"Pbytes\" ; \nsize = size * 1.0e-15 ; \n} \nelse if ( size > 1.0e12 ) { \nunit = \"Tbytes\" ; \nsize = size * 1.0e-12 ; \n} \nelse if ( size > 1.0e9 ) { \nunit = \"Gbytes\" ; \nsize = size * 1.0e-9 ; \n} \nelse if ( size > 1.0e6 ) { \nunit = \"Mbytes\" ; \nsize = size * 1.0e-6 ; \n} \nelse if ( size > 1.0e3 ) { \nunit = \"Kbytes\" ; \nsize = size * 1.0e-3 ; \n} \nelse { \nunit = \"bytes\" ; \n} \nreturn Format . d ( size , 4 ) + \" \" + unit ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nint savepos = buf0 . position ( ) ; \nint limit0 = buf0 . limit ( ) ; \nint skipcount = 0 ; \nif ( limit0 > MAXLIMIT ) limit0 = MAXLIMIT ; \nif ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount = skipcount + 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . println ( \"order=\" + buf0 . order ( ) ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) radius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \nif ( ! Double . isNaN ( radius_spherical_earth ) ) { \nif ( radius_spherical_earth < 10000.00 ) radius_spherical_earth = radius_spherical_earth * 1000.0 ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \nelse { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \nif ( ! Double . isNaN ( major_axis ) && ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn true ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) Lo2 = Lo2 + 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4389": "public class DummySink { \npublic void write ( byte [ ] b , int off , int len ) throws IOException { \ncount = count + len ; \nsuper . write ( b , off , len ) ; \n} \n} \n"}
{"4397": "public class AWIPSConvention { \nprivate void createNewVariables ( NetcdfDataset ds , Variable ncVar , List < Dimension > newDims , Dimension levelDim ) throws InvalidRangeException { \nList < Dimension > dims = ncVar . getDimensions ( ) ; \nint newDimIndex = dims . indexOf ( levelDim ) ; \nint [ ] origin = new int [ ncVar . getRank ( ) ] ; \nint [ ] shape = ncVar . getShape ( ) ; \nint count = 0 ; \nfor ( Dimension dim : newDims ) { \nString name = ncVar . getShortName ( ) + \"-\" + dim . getShortName ( ) ; \norigin [ newDimIndex ] = count ; \nshape [ newDimIndex ] = dim . getLength ( ) ; \nVariable varNew = ncVar . section ( new Section ( origin , shape ) ) ; \nvarNew . setName ( name ) ; \nvarNew . setDimension ( newDimIndex , dim ) ; \nString long_name = ds . findAttValueIgnoreCase ( ncVar , CDM . LONG_NAME , ncVar . getShortName ( ) ) ; \nlong_name = long_name + \"-\" + dim . getShortName ( ) ; \nds . addVariableAttribute ( varNew , new Attribute ( CDM . LONG_NAME , long_name ) ) ; \nds . addVariable ( null , varNew ) ; \nparseInfo . format ( \"Created New Variable as section = \" ) ; \nvarNew . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \ncount = count + dim . getLength ( ) ; \n} \n} \n} \n"}
{"4412": "public class Index { \npublic long index ( ) { \nlong offset = 0 ; \nfor ( int i = 0 ; \ni < this . indices . length ; \ni ++ ) { \noffset = offset * this . dimsizes [ i ] ; \noffset = offset + this . indices [ i ] ; \n} \nreturn offset ; \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange = range + ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range = range + ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { \nfac = 30.0 * 24.0 ; \n} \nelse if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \nreturn fac * range ; \n} \n} \n"}
{"4488": "public class ProxyReader2D { \n@ Override public Array reallyRead ( Variable mainv , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nFmrcInvLite . Gridset . Grid gridLite = ( FmrcInvLite . Gridset . Grid ) mainv . getSPobject ( ) ; \nDataType dtype = ( mainv instanceof VariableDS ) ? ( ( VariableDS ) mainv ) . getOriginalDataType ( ) : mainv . getDataType ( ) ; \nArray allData = Array . factory ( dtype , section . getShape ( ) ) ; \nint destPos = 0 ; \nList < Range > ranges = section . getRanges ( ) ; \nRange runRange = ranges . get ( 0 ) ; \nRange timeRange = ranges . get ( 1 ) ; \nList < Range > innerSection = ranges . subList ( 2 , ranges . size ( ) ) ; \nHashMap < String , NetcdfDataset > openFilesRead = new HashMap < > ( ) ; \ntry { \nfor ( int runIdx : runRange ) { \nfor ( int timeIdx : timeRange ) { \nArray result = null ; \nTimeInventory . Instance timeInv = gridLite . getInstance ( runIdx , timeIdx ) ; \nif ( timeInv != null ) { \nif ( debugRead ) System . out . printf ( \"HIT %d %d \" , runIdx , timeIdx ) ; \nresult = read ( timeInv , gridLite . name , innerSection , openFilesRead ) ; \nresult = MAMath . convert ( result , dtype ) ; \n} \nif ( result == null ) { \nint [ ] shape = new Section ( innerSection ) . getShape ( ) ; \nresult = ( ( VariableDS ) mainv ) . getMissingDataArray ( shape ) ; \nif ( debugRead ) System . out . printf ( \"MISS %d %d \" , runIdx , timeIdx ) ; \n} \nif ( debugRead ) System . out . printf ( \"%d %d reallyRead %s %d bytes start at %d total size is %d%n\" , runIdx , timeIdx , mainv . getFullName ( ) , result . getSize ( ) , destPos , allData . getSize ( ) ) ; \nArray . arraycopy ( result , 0 , allData , destPos , ( int ) result . getSize ( ) ) ; \ndestPos = destPos + result . getSize ( ) ; \n} \n} \nreturn allData ; \n} \nfinally { \ncloseAll ( openFilesRead ) ; \n} \n} \n} \n"}
{"4517": "public class GempakParameterTable { \nprivate byte [ ] readBytes ( InputStream is ) throws IOException { \nint totalRead = 0 ; \nbyte [ ] content = new byte [ 1000000 ] ; \nwhile ( true ) { \nint howMany = is . read ( content , totalRead , content . length - totalRead ) ; \nif ( howMany < 0 ) { \nbreak ; \n} \nif ( howMany == 0 ) { \ncontinue ; \n} \ntotalRead = totalRead + howMany ; \nif ( totalRead >= content . length ) { \nbyte [ ] tmp = content ; \nint newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; \ncontent = new byte [ newLength ] ; \nSystem . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; \n} \n} \nis . close ( ) ; \nbyte [ ] results = new byte [ totalRead ] ; \nSystem . arraycopy ( content , 0 , results , 0 , totalRead ) ; \nreturn results ; \n} \n} \n"}
{"4537": "public class IospHelper { \nstatic public Object readDataFill ( LayoutBB layout , DataType dataType , Object fillValue ) throws java . io . IOException { \nlong size = layout . getTotalNelems ( ) ; \nif ( dataType == DataType . STRUCTURE ) size = size * layout . getElemSize ( ) ; \nObject arr = ( fillValue == null ) ? makePrimitiveArray ( ( int ) size , dataType ) : makePrimitiveArray ( ( int ) size , dataType , fillValue ) ; \nreturn readData ( layout , dataType , arr ) ; \n} \n} \n"}
{"4559": "public class CFLine { \npublic double [ ] getBBUpper ( ) { \ndouble [ ] bbUpper = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbUpper [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbUpper [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbUpper [ 0 ] < pt . getX ( ) ) { \nbbUpper [ 0 ] = pt . getX ( ) ; \n} \nif ( bbUpper [ 1 ] < pt . getY ( ) ) { \nbbUpper [ 1 ] = pt . getY ( ) ; \n} \n} \nbbUpper [ 0 ] = bbUpper [ 0 ] + 10 ; \nbbUpper [ 1 ] = bbUpper [ 1 ] + 10 ; \nreturn bbUpper ; \n} \n} \n"}
{"4560": "public class CFLine { \npublic double [ ] getBBLower ( ) { \ndouble [ ] bbLower = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbLower [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbLower [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbLower [ 0 ] > pt . getX ( ) ) { \nbbLower [ 0 ] = pt . getX ( ) ; \n} \nif ( bbLower [ 1 ] > pt . getY ( ) ) { \nbbLower [ 1 ] = pt . getY ( ) ; \n} \n} \nbbLower [ 0 ] = bbLower [ 0 ] - 10 ; \nbbLower [ 1 ] = bbLower [ 1 ] - 10 ; \nreturn bbLower ; \n} \n} \n"}
{"4583": "public class GEOSTransform { \npublic double [ ] satToEarth ( double x , double y ) { \nif ( scan_geom . equals ( GOES ) ) { \ndouble [ ] lambda_theta_geos = GOES_to_GEOS ( x , y ) ; \nx = lambda_theta_geos [ 0 ] ; \ny = lambda_theta_geos [ 1 ] ; \n} \ndouble c1 = ( h * Math . cos ( x ) * Math . cos ( y ) ) * ( h * Math . cos ( x ) * Math . cos ( y ) ) ; \ndouble c2 = ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) * d ; \nif ( c1 < c2 ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble s_d = Math . sqrt ( c1 - c2 ) ; \ndouble s_n = ( h * Math . cos ( x ) * Math . cos ( y ) - s_d ) / ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) ; \ndouble s_1 = h - s_n * Math . cos ( x ) * Math . cos ( y ) ; \ndouble s_2 = s_n * Math . sin ( x ) * Math . cos ( y ) ; \ndouble s_3 = - s_n * Math . sin ( y ) ; \ndouble s_xy = Math . sqrt ( s_1 * s_1 + s_2 * s_2 ) ; \ndouble geographic_lon = Math . atan ( s_2 / s_1 ) + sub_lon ; \ndouble geographic_lat = Math . atan ( - fp * ( s_3 / s_xy ) ) ; \ndouble lonDegrees = RAD_TO_DEG * geographic_lon ; \ndouble latDegrees = RAD_TO_DEG * geographic_lat ; \nif ( lonDegrees < - 180.0 ) lonDegrees = lonDegrees + 360.0 ; \nif ( lonDegrees > 180.0 ) lonDegrees = lonDegrees - 360.0 ; \nreturn new double [ ] { \nlonDegrees , latDegrees } \n; \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nwhile ( count > 0 ) { \nif ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos = pos + red ; \ncount = count - red ; \nthis . avail = this . avail - red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) { \nreturn previousEnd + 1 ; \n} \nint newBeginning = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) { \nnewBeginning = newBeginning + getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) { \nreturn previousBegin - 1 ; \n} \nint new_end = 0 ; \nfor ( int i = 0 ; \ni < index + 1 ; \ni ++ ) { \nnew_end = new_end + getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4628": "public class Cosmic1Convention { \npublic static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { \ndouble longitude = Math . atan2 ( y , x ) ; \ndouble ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; \ndouble p = Math . sqrt ( x * x + y * y ) ; \ndouble theta = Math . atan ( ( z * a ) / ( p * b ) ) ; \ndouble sineTheta = Math . sin ( theta ) ; \ndouble cosTheta = Math . cos ( theta ) ; \ndouble f = 1 / 298.257223563 ; \ndouble e2 = 2 * f - f * f ; \ndouble top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; \ndouble bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; \ndouble geodeticLat = Math . atan ( top / bottom ) ; \ndouble sineLat = Math . sin ( geodeticLat ) ; \ndouble N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; \ndouble altitude = ( p / Math . cos ( geodeticLat ) ) - N ; \nif ( longitude > Math . PI ) { \nlongitude = longitude - 2 * Math . PI ; \n} \nelse if ( longitude < - Math . PI ) { \nlongitude = longitude + 2 * Math . PI ; \n} \nreturn new double [ ] { \ngeodeticLat , longitude , altitude } \n; \n} \n} \n"}
{"4676": "public class Navigation { \npublic void pan ( double deltax , double deltay ) { \nzoom . push ( ) ; \npix_x0 = pix_x0 - deltax ; \npix_y0 = pix_y0 - deltay ; \nfireMapAreaEvent ( ) ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) System . out . println ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" ) ; \nif ( ( width < 5 ) || ( height < 5 ) ) return ; \nzoom . push ( ) ; \npix_x0 = pix_x0 - startx + width / 2 - pwidth / 2 ; \npix_y0 = pix_y0 - starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4699": "public class BitReader { \npublic long bits2UInt ( int nb ) throws IOException { \nassert nb <= 64 ; \nassert nb >= 0 ; \nlong result = 0 ; \nint bitsLeft = nb ; \nwhile ( bitsLeft > 0 ) { \nif ( bitPos == 0 ) { \nbitBuf = nextByte ( ) ; \nbitPos = BIT_LENGTH ; \n} \nint size = Math . min ( bitsLeft , bitPos ) ; \nint myBits = bitBuf >> ( bitPos - size ) ; \nmyBits &= BYTE_BITMASK ; \nmyBits &= ~ ( BYTE_BITMASK << size ) ; \nint shift = bitsLeft - size ; \nassert shift >= 0 ; \nresult |= myBits << shift ; \nbitsLeft = bitsLeft - size ; \nbitPos = bitPos - size ; \n} \nreturn result ; \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nint selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse if ( selIndex > 0 ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) ce = ce + \",\" ; \nce = ce + localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce = ce + \"&\" ; \nce = ce + selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce = ce + \"&\" ; \nce = ce + localSelString ; \n} \nif ( ce . length ( ) > 0 ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni = i + 2 ; \n} \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy = shiftBy + 8 , i ++ ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \n} \nreturn accum ; \n} \n} \n"}
{"4721": "public class Swap { \nstatic public double swapDouble ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy = shiftBy + 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn Double . longBitsToDouble ( accum ) ; \n} \n} \n"}
{"4730": "public class WFSDescribeFeatureTypeWriter { \npublic void startXML ( ) { \nfileOutput = fileOutput + \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" ; \nfileOutput = fileOutput + \"<schema \" + \"xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" \" + \"xmlns=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"targetNamespace=\\\"\" + server + \"\\\" elementFormDefault=\\\"qualified\\\" \" + \"version=\\\"0.1\\\">\" ; \nfileOutput = fileOutput + \"<xsd:import namespace=\\\"http://www.opengis.net/gml\\\" \" + \"schemaLocation=\\\"http://schemas.opengis.net/gml/2.1.2/feature.xsd\\\"/>\" ; \n} \n} \n"}
{"4731": "public class WFSDescribeFeatureTypeWriter { \npublic void writeFeatures ( ) { \nfor ( WFSFeature feat : featureList ) { \nfileOutput = fileOutput + \"<xsd:complexType name=\\\"\" + feat . getTitle ( ) + \"\\\">\" ; \nfileOutput = fileOutput + \"<xsd:complexContent>\" ; \nfileOutput = fileOutput + \"<xsd:extension base=\\\"gml:\" + feat . getType ( ) + \"\\\">\" ; \nfileOutput = fileOutput + \"<xsd:sequence>\" ; \nfor ( WFSFeatureAttribute attribute : feat . getAttributes ( ) ) { \nfileOutput = fileOutput + \"<xsd:element name =\\\"\" + attribute . getName ( ) + \"\\\" type=\\\"\" + attribute . getType ( ) + \"\\\"/>\" ; \n} \nfileOutput = fileOutput + \"</xsd:sequence>\" ; \nfileOutput = fileOutput + \"</xsd:extension>\" ; \nfileOutput = fileOutput + \"</xsd:complexContent>\" ; \nfileOutput = fileOutput + \"</xsd:complexType>\" ; \nfileOutput = fileOutput + \"<xsd:element name =\\\"\" + feat . getName ( ) + \"\\\" type=\\\"tds:\" + feat . getTitle ( ) + \"\\\"/>\" ; \n} \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration = duration / 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \ncleanCache ( file , sbuff , false ) ; \n} \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration = duration / 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"4758": "public class DataDescriptor { \nint countBits ( ) { \nint total_nbits = 0 ; \ntotal_nbytesCDM = 0 ; \nfor ( DataDescriptor dd : subKeys ) { \nif ( dd . subKeys != null ) { \ntotal_nbits = total_nbits + dd . countBits ( ) ; \ntotal_nbytesCDM = total_nbytesCDM + dd . total_nbytesCDM ; \n} \nelse if ( dd . f == 0 ) { \ntotal_nbits = total_nbits + dd . bitWidth ; \ntotal_nbytesCDM = total_nbytesCDM + dd . getByteWidthCDM ( ) ; \n} \n} \nif ( replication > 1 ) { \ntotal_nbits = total_nbits * replication ; \ntotal_nbytesCDM = total_nbytesCDM * replication ; \n} \nreturn total_nbits ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nint paramCount = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni ++ ) paramCount = paramCount + myRADDs [ i ] . getNParams ( ) ; \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nint next = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni ++ ) { \nint nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext = next + nParams ; \n} \nreturn list ; \n} \n} \n"}
{"4861": "public class VariableIndexPartitioned { \nvoid addPartition ( int partno , int groupno , int varno , int ndups , int nrecords , int nmissing , GribCollectionMutable . VariableIndex vi ) { \nif ( partList == null ) partList = new ArrayList < > ( nparts ) ; \npartList . add ( new PartitionForVariable2D ( partno , groupno , varno ) ) ; \nthis . ndups = this . ndups + ndups ; \nthis . nrecords = this . nrecords + nrecords ; \nthis . nmissing = this . nmissing + nmissing ; \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nint sum = 0 ; \nfor ( int i = 0 ; \ni < arr . length ; \ni ++ ) { \nif ( arr [ i ] <= 0 ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum = sum + arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4899": "public class NcStreamWriter { \npublic long sendData2 ( Variable v , Section section , OutputStream out , NcStreamCompression compress ) throws IOException , InvalidRangeException { \nif ( show ) System . out . printf ( \" %s section=%s%n\" , v . getFullName ( ) , section ) ; \nboolean isVlen = v . isVariableLength ( ) ; \nif ( isVlen ) v . read ( section ) ; \nNcStreamDataCol encoder = new NcStreamDataCol ( ) ; \nNcStreamProto . DataCol dataProto = encoder . encodeData2 ( v . getFullName ( ) , isVlen , section , v . read ( section ) ) ; \nlong size = 0 ; \nsize = size + writeBytes ( out , NcStream . MAGIC_DATA2 ) ; \nbyte [ ] datab = dataProto . toByteArray ( ) ; \nsize = size + NcStream . writeVInt ( out , datab . length ) ; \nsize = size + writeBytes ( out , datab ) ; \nreturn size ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nint protosize = 0 ; \nfor ( ; \n; \n) { \nint index = buf . indexOf ( \":\" ) ; \nif ( index < 0 ) break ; \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) break ; \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize = protosize + ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) break ; \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \nfor ( int ii = shape . length - 1 ; \nii >= 0 ; \nii -- ) { \nfinal int thisDim = shape [ ii ] ; \nif ( thisDim < 0 ) continue ; \nstride [ ii ] = ( int ) product ; \nproduct = product * thisDim ; \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset = newindex . offset + stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset = newindex . offset + stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nint value = offset ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( shape [ ii ] < 0 ) break ; \nvalue = value + current [ ii ] * stride [ ii ] ; \n} \nreturn value ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth = depth + n ; \nif ( depth < 0 ) depth = 0 ; \nelse if ( depth > MAXDEPTH ) depth = MAXDEPTH ; \n} \n} \n"}
{"4993": "public class GMLFeatureWriter { \nprivate String writePoint ( Point point ) { \nString xml = \"\" ; \nxml = xml + \"<gml:Point srsName=\\\"http://www.opengis.net/gml/srs/epsg.xml@900913\\\" srsDimension=\\\"2\\\">\" + \"<gml:pos>\" + point . getX ( ) + \" \" + point . getY ( ) + \"</gml:pos>\" + \"</gml:Point>\" ; \nreturn xml ; \n} \n} \n"}
{"4994": "public class GMLFeatureWriter { \nprivate String writeLine ( Line line ) { \nString xml = \"\" ; \nxml = xml + \"<gml:LineString><gml:posList>\" ; \nfor ( Point point : line . getPoints ( ) ) { \nxml = xml + point . getX ( ) + \" \" + point . getY ( ) + \" \" ; \n} \nxml = xml + \"</gml:posList></gml:LineString>\" ; \nreturn xml ; \n} \n} \n"}
{"4995": "public class GMLFeatureWriter { \nprivate String writePolygon ( Polygon poly ) { \nString xml = \"\" ; \nxml = xml + \"<gml:Polygon>\" ; \nPolygon polygon = poly ; \nif ( ! polygon . getInteriorRing ( ) ) { \nxml = xml + \"<gml:exterior><gml:LinearRing><gml:posList>\" ; \nfor ( Point point : polygon . getPoints ( ) ) { \nxml = xml + point . getX ( ) + \" \" + point . getY ( ) + \" \" ; \n} \nxml = xml + \"</gml:posList></gml:LinearRing></gml:exterior>\" ; \n} \nelse { \nxml = xml + \"<gml:interior><gml:LinearRing><gml:posList>\" ; \nfor ( Point point : polygon . getPoints ( ) ) { \nxml = xml + point . getX ( ) + \" \" + point . getY ( ) + \" \" ; \n} \nxml = xml + \"</gml:posList></gml:LinearRing></gml:interior>\" ; \n} \nxml = xml + \"</gml:Polygon>\" ; \nreturn xml ; \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr = subStr + id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) subStr = subStr + \":\" ; \nelse subStr = subStr + ( beginInd + \":\" + endInd ) ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr = subStr + \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse { \nif ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth = width + 360 ; \nlon0 = lon0 - 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk = k + n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk = k + n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse if ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5067": "public class Grib1ParamTables { \npublic static boolean addParameterTableLookup ( String lookupFilename ) throws IOException { \nLookup lookup = new Lookup ( ) ; \nif ( ! lookup . readLookupTable ( lookupFilename ) ) return false ; \nsynchronized ( lock ) { \nstandardLookup . tables . addAll ( standardTablesStart , lookup . tables ) ; \nstandardTablesStart = standardTablesStart + lookup . tables . size ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) { \nvertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \n} \nif ( axisType != null ) { \nvertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \n} \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : for ( int i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \n} \nbreak ; \ncase ( 2 ) : for ( int i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , vert_args [ i ] ) ; \n} \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni ++ ) { \npressures [ 0 ] [ i ] = pressures [ 0 ] [ i ] * 1000 ; \n} \npressures = vert_cs . fromReference ( pressures ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni ++ ) { \ndata . set ( i , pressures [ 0 ] [ i ] ) ; \n} \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( done < want ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) return false ; \ndone = done + got ; \n} \nif ( showRead ) System . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \nbytesRead = bytesRead + done ; \nreturn true ; \n} \n} \n"}
{"5089": "public class HeaderInputStream { \npublic long skip ( long n ) { \nif ( bytesRemaining >= n ) { \nbytesRemaining = bytesRemaining - n ; \nreturn n ; \n} \nelse { \nint oldBytesRemaining = bytesRemaining ; \nbytesRemaining = 0 ; \nreturn oldBytesRemaining ; \n} \n} \n} \n"}
{"5134": "public class Nidsheader { \nbyte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { \nbyte [ ] header = new byte [ offset ] ; \nbuf . position ( 0 ) ; \nbuf . get ( header ) ; \nbyte [ ] out = new byte [ offset + uncomplen ] ; \nSystem . arraycopy ( header , 0 , out , 0 , offset ) ; \nCBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; \nint numCompBytes = buf . remaining ( ) ; \nbyte [ ] bufc = new byte [ numCompBytes ] ; \nbuf . get ( bufc , 0 , numCompBytes ) ; \nByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; \ncbzip2 . setStream ( bis ) ; \nint total = 0 ; \nint nread ; \nbyte [ ] ubuff = new byte [ 40000 ] ; \nbyte [ ] obuff = new byte [ 40000 ] ; \ntry { \nwhile ( ( nread = cbzip2 . read ( ubuff ) ) != - 1 ) { \nif ( total + nread > obuff . length ) { \nbyte [ ] temp = obuff ; \nobuff = new byte [ temp . length * 2 ] ; \nSystem . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; \n} \nSystem . arraycopy ( ubuff , 0 , obuff , total , nread ) ; \ntotal = total + nread ; \n} \nif ( obuff . length >= 0 ) System . arraycopy ( obuff , 0 , out , offset , total ) ; \n} \ncatch ( BZip2ReadException ioe ) { \nlog . warn ( \"Nexrad2IOSP.uncompress \" + raf . getLocation ( ) , ioe ) ; \n} \nreturn out ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword = word + base * bv [ i ] ; \nbase = base * 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nif ( bv [ 0 ] > 127 ) { \nbv [ 0 ] = bv [ 0 ] - 128 ; \nbase = - 1 ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword = word + base * bv [ i ] ; \nbase = base * 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5156": "public class GribNumbers { \npublic static int countBits ( byte [ ] bitmap ) { \nint bits = 0 ; \nfor ( byte b : bitmap ) { \nshort s = DataType . unsignedByteToShort ( b ) ; \nbits = bits + Long . bitCount ( s ) ; \n} \nreturn bits ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( code >= 0x01 && code <= 0x7F ) { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \nelse if ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount = count + 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount = count + 3 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5258": "public class BitCounterCompressed { \npublic int ncounters ( ) { \nif ( nested == null ) return 1 ; \nelse { \nint ncounters = 0 ; \nfor ( BitCounterCompressed [ ] counters : nested ) { \nif ( counters == null ) continue ; \nfor ( BitCounterCompressed counter : counters ) if ( counter != null ) ncounters = ncounters + counter . ncounters ( ) ; \n} \nreturn ncounters ; \n} \n} \n} \n"}
{"5268": "public class WFSGetFeatureWriter { \nprivate void writeHeadersAndBB ( ) { \nfileOutput = fileOutput + \"<wfs:FeatureCollection xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" + namespace + \" \" + server + \"?request=DescribeFeatureType\" + WFSXMLHelper . AMPERSAND + \"service=wfs\" + WFSXMLHelper . AMPERSAND + \"version=2.0.0\" + WFSXMLHelper . AMPERSAND + \"typename=\" + WFSController . TDSNAMESPACE + \"%3A\" + ftName ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml/3.2\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:wfs=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/wfs/2.0\" ) + \" xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\" numberMatched=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \" numberReturned=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \">\" ; \ndouble [ ] boundLower ; \ndouble [ ] boundUpper ; \nif ( geometries . isEmpty ( ) ) { \nboundLower = new double [ 2 ] ; \nboundUpper = new double [ 2 ] ; \nboundLower [ 0 ] = - 180 ; \nboundLower [ 1 ] = - 90 ; \nboundUpper [ 0 ] = 180 ; \nboundUpper [ 1 ] = 90 ; \n} \nelse { \nboundLower = geometries . get ( 0 ) . getBBLower ( ) ; \nboundUpper = geometries . get ( 0 ) . getBBUpper ( ) ; \n} \nfor ( SimpleGeometry item : geometries ) { \ndouble [ ] low = item . getBBLower ( ) ; \nif ( boundLower [ 0 ] > low [ 0 ] ) boundLower [ 0 ] = low [ 0 ] ; \nif ( boundLower [ 1 ] > low [ 1 ] ) boundLower [ 1 ] = low [ 1 ] ; \ndouble [ ] upper = item . getBBUpper ( ) ; \nif ( boundUpper [ 0 ] < upper [ 0 ] ) boundUpper [ 0 ] = upper [ 0 ] ; \nif ( boundUpper [ 1 ] < upper [ 1 ] ) boundUpper [ 1 ] = upper [ 1 ] ; \nboundLower [ 0 ] = boundLower [ 0 ] - 10 ; \nboundLower [ 1 ] = boundLower [ 1 ] - 10 ; \nboundUpper [ 0 ] = boundUpper [ 0 ] + 10 ; \nboundUpper [ 1 ] = boundUpper [ 1 ] + 10 ; \n} \nfileOutput = fileOutput + \"<wfs:boundedBy>\" + \"<wfs:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<wfs:lowerCorner>\" + boundLower [ 0 ] + \" \" + boundLower [ 1 ] + \"</wfs:lowerCorner>\" + \"<wfs:upperCorner>\" + boundUpper [ 0 ] + \" \" + boundUpper [ 1 ] + \"</wfs:upperCorner>\" + \"</wfs:Envelope>\" + \"</wfs:boundedBy>\" ; \n} \n} \n"}
{"5269": "public class WFSGetFeatureWriter { \npublic void writeMembers ( ) { \nint index = 1 ; \nGMLFeatureWriter writer = new GMLFeatureWriter ( ) ; \nfor ( SimpleGeometry geometryItem : geometries ) { \ndouble [ ] lowerCorner = geometryItem . getBBLower ( ) ; \ndouble [ ] upperCorner = geometryItem . getBBUpper ( ) ; \nfileOutput = fileOutput + \"<wfs:member>\" + \"<\" + WFSController . TDSNAMESPACE + \":\" + ftName + \" gml:id=\\\"\" + ftName + \".\" + index + \"\\\">\" + \"<gml:boundedBy>\" + \"<gml:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<gml:lowerCorner>\" + lowerCorner [ 0 ] + \" \" + lowerCorner [ 1 ] + \"</gml:lowerCorner>\" + \"<gml:upperCorner>\" + upperCorner [ 0 ] + \" \" + upperCorner [ 1 ] + \"</gml:upperCorner>\" + \"</gml:Envelope>\" + \"</gml:boundedBy>\" + \"<\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" ; \nfileOutput = fileOutput + writer . writeFeature ( geometryItem ) ; \nfileOutput = fileOutput + \"</\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" + \"</\" + WFSController . TDSNAMESPACE + \":\" + ftName + \">\" + \"</wfs:member>\" ; \nindex ++ ; \n} \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount = count + raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount = count + raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount = count + raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount = count + raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5283": "public class BooleanPrimitiveVector { \npublic PrimitiveVector subset ( int start , int stop , int stride ) { \nBooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; \nstride = Math . max ( stride , 1 ) ; \nstop = Math . max ( start , stop ) ; \nint length = 1 + ( stop - start ) / stride ; \nn . setLength ( length ) ; \nint count = 0 ; \nfor ( int i = start ; \ni <= stop ; \ni = i + stride ) { \nn . setValue ( count , vals [ i ] ) ; \ncount ++ ; \n} \nreturn n ; \n} \n} \n"}
{"5328": "public class BitCounterUncompressed { \npublic void setBitOffset ( DataDescriptor dkey ) { \nif ( bitPosition == null ) bitPosition = new HashMap < DataDescriptor , Integer > ( 2 * parent . getSubKeys ( ) . size ( ) ) ; \nbitPosition . put ( dkey , bitOffset ) ; \nbitOffset = bitOffset + dkey . getBitWidth ( ) ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits = countBits + nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits = countBits + bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \ni >= firstpos ; \ni -- ) { \nif ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] = this . index . indices [ i ] + this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead = totalBytesRead + n ; \nif ( showCopy ) { \ndone = done + n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5349": "public class IO { \nstatic public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { \nint bufferSize = buffer . length ; \nlong want = length ; \nraf . seek ( offset ) ; \nwhile ( want > 0 ) { \nint len = ( int ) Math . min ( want , bufferSize ) ; \nint bytesRead = raf . read ( buffer , 0 , len ) ; \nif ( bytesRead <= 0 ) break ; \nout . write ( buffer , 0 , bytesRead ) ; \nwant = want - bytesRead ; \n} \nout . flush ( ) ; \nreturn length - want ; \n} \n} \n"}
{"5407": "public class Swap { \nstatic public long swapLong ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy = shiftBy + 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn accum ; \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy = shiftBy + 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale = scale * 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \nfor ( int pack = 0 ; \npack < npack ; \npack ++ ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( int idata = 0 ; \nidata < nparms ; \nidata ++ ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) { \ndata [ ir + idata ] = RMISSD ; \n} \nelse { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \n} \nir = ir + nparms ; \nii = ii + nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5505": "public class AccessLogTable { \nprivate void showTimeSeriesAll ( java . util . List < LogReader . Log > logs ) { \nTimeSeries bytesSentData = new TimeSeries ( \"Bytes Sent\" , Minute . class ) ; \nTimeSeries timeTookData = new TimeSeries ( \"Average Latency\" , Minute . class ) ; \nTimeSeries nreqData = new TimeSeries ( \"Number of Requests\" , Minute . class ) ; \nString intervalS = \"5 minute\" ; \nlong period = 1000 * 60 * 5 ; \ntry { \nTimeDuration tu = new TimeDuration ( intervalS ) ; \nperiod = ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"Illegal Time interval=%s %n\" , intervalS ) ; \n} \nlong current = 0 ; \nlong bytes = 0 ; \nlong timeTook = 0 ; \nlong total_count = 0 ; \nlong count = 0 ; \nfor ( LogReader . Log log : logs ) { \nlong msecs = log . date ; \nif ( msecs - current > period ) { \nif ( current > 0 ) { \ntotal_count = total_count + count ; \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \nbytes = 0 ; \ncount = 0 ; \ntimeTook = 0 ; \ncurrent = msecs ; \n} \nbytes = bytes + log . getBytes ( ) ; \ntimeTook = timeTook + log . getMsecs ( ) ; \ncount ++ ; \n} \nif ( count > 0 ) addPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \ntotal_count = total_count + count ; \nSystem . out . printf ( \"showTimeSeriesAll: total_count = %d logs = %d%n\" , total_count , logs . size ( ) ) ; \nMultipleAxisChart mc = new MultipleAxisChart ( \"Access Logs\" , intervalS + \" average\" , \"Mbytes Sent\" , bytesSentData ) ; \nmc . addSeries ( \"Number of Requests\" , nreqData ) ; \nmc . addSeries ( \"Average Latency (secs)\" , timeTookData ) ; \nmc . finish ( new java . awt . Dimension ( 1000 , 1000 ) ) ; \ntimeSeriesPanel . removeAll ( ) ; \ntimeSeriesPanel . add ( mc ) ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nint totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen = totalLen + bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nint pos = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos = pos + bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \nif ( arr . getRank ( ) > 1 ) arr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \n} \n} \n"}
{"5591": "public class RandomAccessFile { \npublic boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { \nlong start = getFilePointer ( ) ; \nlong last = ( maxBytes < 0 ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; \nlong needToScan = last - start ; \nint bytesAvailable = ( int ) ( dataEnd - filePosition ) ; \nif ( bytesAvailable < 1 ) { \nseek ( filePosition ) ; \nbytesAvailable = ( int ) ( dataEnd - filePosition ) ; \n} \nint bufStart = ( int ) ( filePosition - bufferStart ) ; \nint scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; \nint pos = match . indexOf ( buffer , bufStart , scanBytes ) ; \nif ( pos >= 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nint matchLen = match . getMatchLength ( ) ; \nneedToScan = needToScan - scanBytes - matchLen ; \nwhile ( needToScan > matchLen ) { \nreadBuffer ( dataEnd - matchLen ) ; \nscanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; \npos = match . indexOf ( buffer , 0 , scanBytes ) ; \nif ( pos > 0 ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nneedToScan = needToScan - scanBytes - matchLen ; \n} \nseek ( last ) ; \nreturn false ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nint year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; \nint month = getOctet ( startIndex ++ ) ; \nint day = getOctet ( startIndex ++ ) ; \nint hour = getOctet ( startIndex ++ ) ; \nint minute = getOctet ( startIndex ++ ) ; \nint second = getOctet ( startIndex ++ ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) return CalendarDate . UNKNOWN ; \nif ( hour > 23 ) { \nday = day + ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( file . length ( ) + total > maxBytes ) { \ntotal_delete = total_delete + file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) && sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \nelse { \ntotal = total + file . length ( ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset = offset + ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nint dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( gateIdx >= dataCount ) ii . setShortNext ( uf_header2 . missing ) ; \nelse { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nshort value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \n} \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nk < nelems ; \nk ++ ) sum = sum + getDouble ( k ) * v . getDouble ( k ) ; \nreturn sum ; \n} \n} \n"}
{"5738": "public class MAVector { \npublic double norm ( ) { \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nk < nelems ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsum = sum + val * val ; \n} \nreturn Math . sqrt ( sum ) ; \n} \n} \n"}
{"5833": "public class Structure { \npublic void calcElementSize ( ) { \nint total = 0 ; \nfor ( Variable v : members ) { \ntotal = total + v . getElementSize ( ) * v . getSize ( ) ; \n} \nelementSize = total ; \n} \n} \n"}
{"5925": "public class ManualFeatureQuery { \npublic ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { \nList < Long > featureIds = new ArrayList < > ( ) ; \nlong offset = 0 ; \nboolean hasResults = true ; \nminX = minX - tolerance ; \nmaxX = maxX + tolerance ; \nminY = minY - tolerance ; \nmaxY = maxY + tolerance ; \nwhile ( hasResults ) { \nhasResults = false ; \nFeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; \ntry { \nwhile ( featureCursor . moveToNext ( ) ) { \nhasResults = true ; \nFeatureRow featureRow = featureCursor . getRow ( ) ; \nGeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; \nif ( envelope != null ) { \ndouble minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; \ndouble maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; \ndouble minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; \ndouble maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; \nif ( minXMax <= maxXMin && minYMax <= maxYMin ) { \nfeatureIds . add ( featureRow . getId ( ) ) ; \n} \n} \n} \n} \nfinally { \nfeatureCursor . close ( ) ; \n} \noffset = offset + chunkLimit ; \n} \nManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; \nreturn results ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \nfor ( int zoom = minZoom ; \nzoom <= maxZoom ; \nzoom ++ ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \ncount = count + tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"6015": "public class IconCache { \npublic static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { \nBitmap iconImage = null ; \nif ( icon != null ) { \nif ( iconCache != null ) { \niconImage = iconCache . get ( icon . getId ( ) ) ; \n} \nif ( iconImage == null ) { \nBitmapFactory . Options options = icon . getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \ndouble styleWidth = dataWidth ; \ndouble styleHeight = dataHeight ; \ndouble widthDensity = DisplayMetrics . DENSITY_DEFAULT ; \ndouble heightDensity = DisplayMetrics . DENSITY_DEFAULT ; \nif ( icon . getWidth ( ) != null ) { \nstyleWidth = icon . getWidth ( ) ; \ndouble widthRatio = dataWidth / styleWidth ; \nwidthDensity = widthDensity * widthRatio ; \nif ( icon . getHeight ( ) == null ) { \nheightDensity = widthDensity ; \n} \n} \nif ( icon . getHeight ( ) != null ) { \nstyleHeight = icon . getHeight ( ) ; \ndouble heightRatio = dataHeight / styleHeight ; \nheightDensity = heightDensity * heightRatio ; \nif ( icon . getWidth ( ) == null ) { \nwidthDensity = heightDensity ; \n} \n} \noptions = new BitmapFactory . Options ( ) ; \noptions . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; \noptions . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; \niconImage = icon . getDataBitmap ( options ) ; \nif ( widthDensity != heightDensity ) { \nint width = ( int ) ( styleWidth * density + 0.5f ) ; \nint height = ( int ) ( styleHeight * density + 0.5f ) ; \nif ( width != iconImage . getWidth ( ) || height != iconImage . getHeight ( ) ) { \nBitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; \niconImage . recycle ( ) ; \niconImage = scaledBitmap ; \n} \n} \nif ( iconCache != null ) { \niconCache . put ( icon . getId ( ) , iconImage ) ; \n} \n} \n} \nreturn iconImage ; \n} \n} \n"}
{"6080": "public class IconRow { \npublic double [ ] getDerivedDimensions ( ) { \nDouble width = getWidth ( ) ; \nDouble height = getHeight ( ) ; \nif ( width == null || height == null ) { \nBitmapFactory . Options options = getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \nif ( width == null ) { \nwidth = ( double ) dataWidth ; \nif ( height != null ) { \nwidth = width * ( height / dataHeight ) ; \n} \n} \nif ( height == null ) { \nheight = ( double ) dataHeight ; \nif ( width != null ) { \nheight = height * ( width / dataWidth ) ; \n} \n} \n} \nreturn new double [ ] { \nwidth , height } \n; \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \nfor ( int i = 1 ; \nblobChunk . length > 0 ; \ni = i + CHUNK_SIZE ) { \nif ( i > 1 ) { \nbyteStream . write ( blobChunk ) ; \n} \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) { \nblobChunk = blobCursor . getBlob ( 0 ) ; \n} \n} \nfinally { \nblobCursor . close ( ) ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \n} \n} \n"}
{"6213": "public class Introspector { \nstatic public String decapitalize ( String name ) { \nif ( name == null || name . length ( ) == 0 ) { \nreturn name ; \n} \nelse { \nString nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; \nif ( name . length ( ) > 1 ) { \nnm = nm + name . substring ( 1 ) ; \n} \nreturn nm ; \n} \n} \n} \n"}
{"6232": "public class Logger { \npublic void callAppenders ( ILoggingEvent event ) { \nint writes = 0 ; \nfor ( Logger l = this ; \nl != null ; \nl = l . parent ) { \nwrites = writes + l . appendLoopOnAppenders ( event ) ; \nif ( ! l . additive ) { \nbreak ; \n} \n} \nif ( writes == 0 ) { \nloggerContext . noAppenderDefinedWarning ( this ) ; \n} \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) { \nreturn ; \n} \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( asynchronousSending ) { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \nelse { \nsendBuffer ( cbClone , eventObject ) ; \n} \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount ++ ; \nif ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { \naddError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \n} \nif ( eventMarksEndOfLife ( eventObject ) ) { \ncbTracker . endOfLife ( key ) ; \n} \ncbTracker . removeStaleComponents ( now ) ; \nif ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { \ndelayBetweenStatusMessages = delayBetweenStatusMessages * 4 ; \n} \n} \n} \n} \n"}
{"6424": "public class NewJBPMProjectWizard { \nprivate void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) throws CoreException , IOException { \nString fileName = \"org/jbpm/eclipse/wizard/project/\" + exampleType + \".bpmn.template\" ; \nIFolder folder = null ; \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/com/sample\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \nIFile file = folder . getFile ( \"sample.bpmn\" ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \nif ( ! file . exists ( ) ) { \nfile . create ( inputstream , true , monitor ) ; \n} \nelse { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \nfileName = \"org/jbpm/eclipse/wizard/project/ProcessMain-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \nfileName = fileName + \".v5.template\" ; \n} \nelse { \nfileName = fileName + \".template\" ; \n} \nfolder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \npackageFragment . createCompilationUnit ( \"ProcessMain.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \nif ( \"advanced\" . equals ( exampleType ) ) { \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/META-INF\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( \"org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template\" ) ; \nfile = folder . getFile ( \"persistence.xml\" ) ; \nif ( ! file . exists ( ) ) { \nfile . create ( inputstream , true , monitor ) ; \n} \nelse { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \n} \n} \n} \n} \n"}
{"6425": "public class NewJBPMProjectWizard { \nprivate void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) throws JavaModelException , IOException { \nString s = \"org/jbpm/eclipse/wizard/project/ProcessJUnit-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \ns = s + \".v5.template\" ; \n} \nelse { \ns = s + \".template\" ; \n} \nIFolder folder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( s ) ; \npackageFragment . createCompilationUnit ( \"ProcessTest.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { \nif ( contentLength == - 1 ) { \nbytesRead = is . read ( buffer ) ; \n} \nelse { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nif ( bytesRead == - 1 ) { \nif ( contentLength >= 0 ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \nelse { \ntotalBytesRead = totalBytesRead + bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( originalFile != null ) { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nint index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) { \nfileName = fileName . substring ( 0 , index ) ; \n} \nfileName = fileName + \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nelse if ( originalName != null ) { \nresourceGroup . setResource ( originalName ) ; \n} \nsetDialogComplete ( validatePage ( ) ) ; \n} \n} \n"}
{"6538": "public class EntityTag { \npublic static EntityTag generateEntityTag ( ) { \nString xx = basetime + \":\" + Integer . toHexString ( Thread . currentThread ( ) . hashCode ( ) ) ; \nbcnt ++ ; \nxx = xx + \":\" + bcnt ; \nreturn new EntityTag ( xx ) ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn = column + 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize = newSize + _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \nelse newChildren [ j ++ ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( currentBufferIndex < buffers . size ( ) - 1 ) { \nfilledBufferSum = filledBufferSum + currentBuffer . length ; \ncurrentBufferIndex ++ ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \nelse { \nint newBufferSize ; \nif ( currentBuffer == null ) { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \nelse { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum = filledBufferSum + currentBuffer . length ; \n} \ncurrentBufferIndex ++ ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse if ( len == 0 ) { \nreturn ; \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining = remaining - part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6627": "public class ByteArrayOutputStream { \npublic synchronized int write ( InputStream in ) throws IOException { \nint readCount = 0 ; \nint inBufferPos = count - filledBufferSum ; \nint n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \nwhile ( n != - 1 ) { \nreadCount = readCount + n ; \ninBufferPos = inBufferPos + n ; \ncount = count + n ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( currentBuffer . length ) ; \ninBufferPos = 0 ; \n} \nn = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; \n} \nreturn readCount ; \n} \n} \n"}
{"6628": "public class ByteArrayOutputStream { \npublic synchronized void writeTo ( OutputStream out ) throws IOException { \nint remaining = count ; \nfor ( byte [ ] buf : buffers ) { \nint c = Math . min ( buf . length , remaining ) ; \nout . write ( buf , 0 , c ) ; \nremaining = remaining - c ; \nif ( remaining == 0 ) { \nbreak ; \n} \n} \n} \n} \n"}
{"6629": "public class ByteArrayOutputStream { \npublic synchronized byte [ ] toByteArray ( ) { \nint remaining = count ; \nif ( remaining == 0 ) { \nreturn EMPTY_BYTE_ARRAY ; \n} \nbyte newbuf [ ] = new byte [ remaining ] ; \nint pos = 0 ; \nfor ( byte [ ] buf : buffers ) { \nint c = Math . min ( buf . length , remaining ) ; \nSystem . arraycopy ( buf , 0 , newbuf , pos , c ) ; \npos = pos + c ; \nremaining = remaining - c ; \nif ( remaining == 0 ) { \nbreak ; \n} \n} \nreturn newbuf ; \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent = ent - 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6745": "public class ImageUrlRewriter { \nprivate String computeNewImageLocation ( final String cssUri , final String imageUrl ) { \nLOG . debug ( \"cssUri: {}, imageUrl {}\" , cssUri , imageUrl ) ; \nfinal String cleanImageUrl = cleanImageUrl ( imageUrl ) ; \nint idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; \nif ( idxLastSeparator == - 1 ) { \nif ( ClasspathUriLocator . isValid ( cssUri ) ) { \nidxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; \nif ( idxLastSeparator >= 0 ) { \nidxLastSeparator = idxLastSeparator + ClasspathUriLocator . PREFIX . length ( ) - 1 ; \n} \n} \nif ( idxLastSeparator < 0 ) { \nthrow new IllegalStateException ( \"Invalid cssUri: \" + cssUri + \". Should contain at least one '/' character!\" ) ; \n} \n} \nfinal String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; \nfinal String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; \nfinal String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; \nLOG . debug ( \"computedImageLocation: {}\" , computedImageLocation ) ; \nreturn computedImageLocation ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nelse if ( threadCount > 1 ) { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name ; \n} \nif ( todoFlags == RECORD_NONE ) { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels = labels + \"CPU\" ; \nvalues = values + totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse { \nseparator = \"\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels = labels + separator + \"Wall\" ; \nvalues = values + separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels = labels + \"/CPU avg\" ; \nvalues = values + \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels = labels + \"/Wall avg\" ; \nvalues = values + \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels = labels + \"/CPU per thread\" ; \nvalues = values + \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels = labels + \"/Wall per thread\" ; \nvalues = values + \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n} \n"}
{"6847": "public class ClassConclusionTimer { \npublic synchronized void add ( ClassConclusionTimer timer ) { \nthis . timeComposedSubsumers = this . timeComposedSubsumers + timer . timeComposedSubsumers ; \nthis . timeDecomposedSubsumers = this . timeDecomposedSubsumers + timer . timeDecomposedSubsumers ; \nthis . timeBackwardLinks = this . timeBackwardLinks + timer . timeBackwardLinks ; \nthis . timeForwardLinks = this . timeForwardLinks + timer . timeForwardLinks ; \nthis . timeContradictions = this . timeContradictions + timer . timeContradictions ; \nthis . timePropagations = this . timePropagations + timer . timePropagations ; \nthis . timeDisjointSubsumers = this . timeDisjointSubsumers + timer . timeDisjointSubsumers ; \nthis . timeContextInitializations = this . timeContextInitializations + timer . timeContextInitializations ; \nthis . timeSubContextInitializations = this . timeSubContextInitializations + timer . timeSubContextInitializations ; \n} \n} \n"}
{"6848": "public class RuleApplicationTimer { \npublic synchronized void add ( RuleApplicationTimer timer ) { \ntimeOwlThingContextInitRule = timeOwlThingContextInitRule + timer . timeOwlThingContextInitRule ; \ntimeRootContextInitializationRule = timeRootContextInitializationRule + timer . timeRootContextInitializationRule ; \ntimeDisjointSubsumerFromMemberRule = timeDisjointSubsumerFromMemberRule + timer . timeDisjointSubsumerFromMemberRule ; \ntimeContradictionFromNegationRule = timeContradictionFromNegationRule + timer . timeContradictionFromNegationRule ; \ntimeObjectIntersectionFromFirstConjunctRule = timeObjectIntersectionFromFirstConjunctRule + timer . timeObjectIntersectionFromFirstConjunctRule ; \ntimeObjectIntersectionFromSecondConjunctRule = timeObjectIntersectionFromSecondConjunctRule + timer . timeObjectIntersectionFromSecondConjunctRule ; \ntimeSuperClassFromSubClassRule = timeSuperClassFromSubClassRule + timer . timeSuperClassFromSubClassRule ; \ntimePropagationFromExistentialFillerRule = timePropagationFromExistentialFillerRule + timer . timePropagationFromExistentialFillerRule ; \ntimeObjectUnionFromDisjunctRule = timeObjectUnionFromDisjunctRule + timer . timeObjectUnionFromDisjunctRule ; \ntimeBackwardLinkChainFromBackwardLinkRule = timeBackwardLinkChainFromBackwardLinkRule + timer . timeBackwardLinkChainFromBackwardLinkRule ; \ntimeReflexiveBackwardLinkCompositionRule = timeReflexiveBackwardLinkCompositionRule + timer . timeReflexiveBackwardLinkCompositionRule ; \ntimeNonReflexiveBackwardLinkCompositionRule = timeNonReflexiveBackwardLinkCompositionRule + timer . timeNonReflexiveBackwardLinkCompositionRule ; \ntimeSubsumerBackwardLinkRule = timeSubsumerBackwardLinkRule + timer . timeSubsumerBackwardLinkRule ; \ntimeContradictionOverBackwardLinkRule = timeContradictionOverBackwardLinkRule + timer . timeContradictionOverBackwardLinkRule ; \ntimeContradictionPropagationRule = timeContradictionPropagationRule + timer . timeContradictionPropagationRule ; \ntimeContradictionCompositionRule = timeContradictionCompositionRule + timer . timeContradictionCompositionRule ; \ntimeIndexedObjectIntersectionOfDecomposition = timeIndexedObjectIntersectionOfDecomposition + timer . timeIndexedObjectIntersectionOfDecomposition ; \ntimeIndexedObjectSomeValuesFromDecomposition = timeIndexedObjectSomeValuesFromDecomposition + timer . timeIndexedObjectSomeValuesFromDecomposition ; \ntimeIndexedObjectComplementOfDecomposition = timeIndexedObjectComplementOfDecomposition + timer . timeIndexedObjectComplementOfDecomposition ; \ntimeIndexedObjectHasSelfDecomposition = timeIndexedObjectHasSelfDecomposition + timer . timeIndexedObjectHasSelfDecomposition ; \ntimeContradictionFromOwlNothingRule = timeContradictionFromOwlNothingRule + timer . timeContradictionFromOwlNothingRule ; \ntimeSubsumerPropagationRule = timeSubsumerPropagationRule + timer . timeSubsumerPropagationRule ; \ntimePropagationInitializationRule = timePropagationInitializationRule + timer . timePropagationInitializationRule ; \ntimeBackwardLinkFromForwardLinkRule = timeBackwardLinkFromForwardLinkRule + timer . timeBackwardLinkFromForwardLinkRule ; \ntimeComposedFromDecomposedSubsumerRule = timeComposedFromDecomposedSubsumerRule + timer . timeComposedFromDecomposedSubsumerRule ; \ntimeIndexedClassDecompositionRule = timeIndexedClassDecompositionRule + timer . timeIndexedClassDecompositionRule ; \ntimeIndexedClassFromDefinitionRule = timeIndexedClassFromDefinitionRule + timer . timeIndexedClassFromDefinitionRule ; \ntimeEquivalentClassFirstFromSecondRule = timeEquivalentClassFirstFromSecondRule + timer . timeEquivalentClassFirstFromSecondRule ; \ntimeEquivalentClassSecondFromFirstRule = timeEquivalentClassSecondFromFirstRule + timer . timeEquivalentClassSecondFromFirstRule ; \n} \n} \n"}
{"6858": "public class HashGenerator { \npublic static int combineListHash ( int ... hashes ) { \nint hash = 0 ; \nfor ( int h : hashes ) { \nhash = hash + h ; \nhash = hash + ( hash << 10 ) ; \nhash ^= ( hash >> 6 ) ; \n} \nhash = hash + ( hash << 3 ) ; \nhash ^= ( hash >> 11 ) ; \nhash = hash + ( hash << 15 ) ; \nreturn hash ; \n} \n} \n"}
{"6859": "public class IOUtils { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ BUFFER_SIZE ] ; \nBufferedInputStream in = new BufferedInputStream ( input , BUFFER_SIZE ) ; \nBufferedOutputStream out = new BufferedOutputStream ( output , BUFFER_SIZE ) ; \nint count = 0 , n = 0 ; \ntry { \nwhile ( ( n = in . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { \nout . write ( buffer , 0 , n ) ; \ncount = count + n ; \n} \nout . flush ( ) ; \n} \nfinally { \nIOUtils . closeQuietly ( in ) ; \nIOUtils . closeQuietly ( out ) ; \n} \nreturn count ; \n} \n} \n"}
{"6871": "public class ClassConclusionCounter { \npublic synchronized void add ( ClassConclusionCounter counter ) { \nthis . countSubClassInclusionDecomposed = this . countSubClassInclusionDecomposed + counter . countSubClassInclusionDecomposed ; \nthis . countSubClassInclusionComposed = this . countSubClassInclusionComposed + counter . countSubClassInclusionComposed ; \nthis . countBackwardLink = this . countBackwardLink + counter . countBackwardLink ; \nthis . countForwardLink = this . countForwardLink + counter . countForwardLink ; \nthis . countContradiction = this . countContradiction + counter . countContradiction ; \nthis . countPropagation = this . countPropagation + counter . countPropagation ; \nthis . countDisjointSubsumer = this . countDisjointSubsumer + counter . countDisjointSubsumer ; \nthis . countContextInitialization = this . countContextInitialization + counter . countContextInitialization ; \nthis . countSubContextInitialization = this . countSubContextInitialization + counter . countSubContextInitialization ; \n} \n} \n"}
{"6878": "public class RuleCounter { \npublic synchronized void add ( RuleCounter counter ) { \ncountOwlThingContextInitRule = countOwlThingContextInitRule + counter . countOwlThingContextInitRule ; \ncountRootContextInitializationRule = countRootContextInitializationRule + counter . countRootContextInitializationRule ; \ncountDisjointSubsumerFromMemberRule = countDisjointSubsumerFromMemberRule + counter . countDisjointSubsumerFromMemberRule ; \ncountContradictionFromNegationRule = countContradictionFromNegationRule + counter . countContradictionFromNegationRule ; \ncountObjectIntersectionFromFirstConjunctRule = countObjectIntersectionFromFirstConjunctRule + counter . countObjectIntersectionFromFirstConjunctRule ; \ncountObjectIntersectionFromSecondConjunctRule = countObjectIntersectionFromSecondConjunctRule + counter . countObjectIntersectionFromSecondConjunctRule ; \ncountSuperClassFromSubClassRule = countSuperClassFromSubClassRule + counter . countSuperClassFromSubClassRule ; \ncountPropagationFromExistentialFillerRule = countPropagationFromExistentialFillerRule + counter . countPropagationFromExistentialFillerRule ; \ncountObjectUnionFromDisjunctRule = countObjectUnionFromDisjunctRule + counter . countObjectUnionFromDisjunctRule ; \ncountBackwardLinkChainFromBackwardLinkRule = countBackwardLinkChainFromBackwardLinkRule + counter . countBackwardLinkChainFromBackwardLinkRule ; \ncountSubsumerBackwardLinkRule = countSubsumerBackwardLinkRule + counter . countSubsumerBackwardLinkRule ; \ncountContradictionOverBackwardLinkRule = countContradictionOverBackwardLinkRule + counter . countContradictionOverBackwardLinkRule ; \ncountContradictionPropagationRule = countContradictionPropagationRule + counter . countContradictionPropagationRule ; \ncountContradictionCompositionRule = countContradictionCompositionRule + counter . countContradictionCompositionRule ; \ncountNonReflexiveBackwardLinkCompositionRule = countNonReflexiveBackwardLinkCompositionRule + counter . countNonReflexiveBackwardLinkCompositionRule ; \ncountIndexedObjectIntersectionOfDecomposition = countIndexedObjectIntersectionOfDecomposition + counter . countIndexedObjectIntersectionOfDecomposition ; \ncountIndexedObjectSomeValuesFromDecomposition = countIndexedObjectSomeValuesFromDecomposition + counter . countIndexedObjectSomeValuesFromDecomposition ; \ncountIndexedObjectComplementOfDecomposition = countIndexedObjectComplementOfDecomposition + counter . countIndexedObjectComplementOfDecomposition ; \ncountIndexedObjectHasSelfDecomposition = countIndexedObjectHasSelfDecomposition + counter . countIndexedObjectHasSelfDecomposition ; \ncountContradictionFromOwlNothingRule = countContradictionFromOwlNothingRule + counter . countContradictionFromOwlNothingRule ; \ncountSubsumerPropagationRule = countSubsumerPropagationRule + counter . countSubsumerPropagationRule ; \ncountReflexiveBackwardLinkCompositionRule = countReflexiveBackwardLinkCompositionRule + counter . countReflexiveBackwardLinkCompositionRule ; \ncountPropagationInitializationRule = countPropagationInitializationRule + counter . countPropagationInitializationRule ; \ncountBackwardLinkFromForwardLinkRule = countBackwardLinkFromForwardLinkRule + counter . countBackwardLinkFromForwardLinkRule ; \ncountComposedFromDecomposedSubsumerRule = countComposedFromDecomposedSubsumerRule + counter . countComposedFromDecomposedSubsumerRule ; \ncountIndexedClassDecompositionRule = countIndexedClassDecompositionRule + counter . countIndexedClassDecompositionRule ; \ncountIndexedClassFromDefinitionRule = countIndexedClassFromDefinitionRule + counter . countIndexedClassFromDefinitionRule ; \ncountEquivalentClassFirstFromSecondRule = countEquivalentClassFirstFromSecondRule + counter . countEquivalentClassFirstFromSecondRule ; \ncountEquivalentClassSecondFromFirstRule = countEquivalentClassSecondFromFirstRule + counter . countEquivalentClassSecondFromFirstRule ; \n} \n} \n"}
{"6925": "public class PersistentVector { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public PersistentVector < E > append ( E val ) { \nif ( size - tailoff ( ) < MAX_NODE_LENGTH ) { \nE [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; \nSystem . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; \nnewTail [ tail . length ] = val ; \nreturn new PersistentVector < > ( size + 1 , shift , root , newTail ) ; \n} \nNode newroot ; \nNode tailnode = new Node ( root . edit , tail ) ; \nint newshift = shift ; \nif ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) { \nnewroot = new Node ( root . edit ) ; \nnewroot . array [ 0 ] = root ; \nnewroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; \nnewshift = newshift + NODE_LENGTH_POW_2 ; \n} \nelse { \nnewroot = pushTail ( shift , root , tailnode ) ; \n} \nreturn new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { \nval } \n) ; \n} \n} \n"}
{"6991": "public class DeploymentManager { \npublic String showStatus ( ) { \nupdateDeployedComponents ( ) ; \nString output = \"\" ; \noutput = output + \"<p>Deployable Units Waiting For Install:</p>\" ; \nfor ( DeployableUnit waitingDU : waitingForInstallDUs ) { \noutput = output + \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; \nfor ( String dependency : waitingDU . getExternalDependencies ( ) ) { \nif ( ! deployedComponents . contains ( dependency ) ) dependency = dependency + \" <strong>MISSING!</strong>\" ; \noutput = output + \"  +-- depends on \" + dependency + \"<br>\" ; \n} \n} \noutput = output + \"<p>Deployable Units Waiting For Uninstall:</p>\" ; \nfor ( DeployableUnit waitingDU : waitingForUninstallDUs ) { \noutput = output + \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; \n} \nreturn output ; \n} \n} \n"}
{"7040": "public class SLEESubDeployer { \npublic String showStatus ( ) throws DeploymentException { \nString output = \"\" ; \noutput = output + \"<p>Deployable Units List:</p>\" ; \nfor ( String key : deployableUnits . keySet ( ) ) { \noutput = output + \"&lt;\" + key + \"&gt; [\" + deployableUnits . get ( key ) + \"]<br>\" ; \nfor ( String duComponent : deployableUnits . get ( key ) . getComponents ( ) ) { \noutput = output + \"+-- \" + duComponent + \"<br>\" ; \n} \n} \noutput = output + \"<p>To Accept List:</p>\" ; \nfor ( String key : toAccept . keySet ( ) ) { \noutput = output + \"&lt;\" + key + \"&gt; [\" + toAccept . get ( key ) + \"]<br>\" ; \n} \noutput = output + \"<p>Undeployments running:</p>\" ; \nfor ( String undeploy : undeploys ) { \noutput = output + \"+-- \" + undeploy + \"<br>\" ; \n} \noutput = output + \"<p>Deployment Manager Status</p>\" ; \noutput = output + sleeContainerDeployer . getDeploymentManager ( ) . showStatus ( ) ; \nreturn output ; \n} \n} \n"}
{"7087": "public class DeployableUnit { \npublic boolean hasDependenciesSatisfied ( boolean showMissing ) { \nif ( isSelfSufficient ( ) ) return true ; \nCollection < String > externalDependencies = getExternalDependencies ( ) ; \nexternalDependencies . removeAll ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) ) ; \nif ( ! externalDependencies . isEmpty ( ) ) { \nif ( showMissing ) { \nString missingDepList = \"\" ; \nfor ( String missingDep : externalDependencies ) missingDepList = missingDepList + \"\\r\\n +-- \" + missingDep ; \nlogger . info ( \"Missing dependencies for \" + this . diShortName + \":\" + missingDepList ) ; \n} \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody = concreteMethodBody + getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody = concreteMethodBody + SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni ++ ) { \nconcreteMethodBody = concreteMethodBody + \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody = concreteMethodBody + \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl = url + \"?\" ; \n} \nfor ( int i = 1 ; \ni <= numberOfPages ; \ni ++ ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7231": "public class SimpleConcurrentCache { \n@ Override public int size ( ) { \nint size = 0 ; \nfor ( SimpleCache < K , V > cache : cacheRegions ) { \nsize = size + cache . size ( ) ; \n} \nreturn size ; \n} \n} \n"}
{"7242": "public class Dbl { \npublic static double varianceDouble ( double [ ] values , final int start , final int length ) { \ndouble mean = mean ( values , start , length ) ; \ndouble temp = 0 ; \nfor ( int index = start ; \nindex < length ; \nindex ++ ) { \ndouble a = values [ index ] ; \ntemp = temp + ( mean - a ) * ( mean - a ) ; \n} \nreturn temp / length ; \n} \n} \n"}
{"7251": "public class DoubleList { \npublic boolean addArray ( double ... integers ) { \nif ( end + integers . length >= values . length ) { \nvalues = grow ( values , ( values . length + integers . length ) * 2 ) ; \n} \nSystem . arraycopy ( integers , 0 , values , end , integers . length ) ; \nend = end + integers . length ; \nreturn true ; \n} \n} \n"}
{"7273": "public class Str { \npublic static String addObjects ( Object ... objects ) { \nint length = 0 ; \nfor ( Object obj : objects ) { \nif ( obj == null ) { \ncontinue ; \n} \nlength = length + obj . toString ( ) . length ( ) ; \n} \nCharBuf builder = CharBuf . createExact ( length ) ; \nfor ( Object str : objects ) { \nif ( str == null ) { \ncontinue ; \n} \nbuilder . add ( str . toString ( ) ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \nfor ( int index = start ; \nindex < length ; \nindex ++ ) { \nsum = sum + values [ index ] ; \n} \nif ( sum < Integer . MIN_VALUE ) { \ndie ( \"overflow the sum is too small\" , sum ) ; \n} \nif ( sum > Integer . MAX_VALUE ) { \ndie ( \"overflow the sum is too big\" , sum ) ; \n} \nreturn ( int ) sum ; \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred = totalBytesTransferred + size ; \nbytesTransferred = bytesTransferred + size ; \nbytesSinceLastFlush = bytesSinceLastFlush + size ; \nbuffersSent ++ ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n} \n"}
{"7387": "public class CouchDbClientBase { \nvoid validate ( HttpResponse response ) throws IOException { \nfinal int code = response . getStatusLine ( ) . getStatusCode ( ) ; \nif ( code == 200 || code == 201 || code == 202 ) { \nreturn ; \n} \nString reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; \nswitch ( code ) { \ncase HttpStatus . SC_NOT_FOUND : { \nthrow new NoDocumentException ( reason ) ; \n} \ncase HttpStatus . SC_CONFLICT : { \nthrow new DocumentConflictException ( reason ) ; \n} \ndefault : { \nthrow new CouchDbException ( reason = reason + EntityUtils . toString ( response . getEntity ( ) ) ) ; \n} \n} \n} \n} \n"}
{"7477": "public class UtilTrig_F64 { \npublic static void normalize ( GeoTuple3D_F64 p ) { \ndouble n = p . norm ( ) ; \np . x = p . x / n ; \np . y = p . y / n ; \np . z = p . z / n ; \n} \n} \n"}
{"7487": "public class UtilPolygons2D_F64 { \npublic static Point2D_F64 center ( Quadrilateral_F64 quad , Point2D_F64 center ) { \nif ( center == null ) center = new Point2D_F64 ( ) ; \ncenter . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; \ncenter . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; \ncenter . x = center . x / 4.0 ; \ncenter . y = center . y / 4.0 ; \nreturn center ; \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \nfor ( int i = 0 ; \ni < input . size ( ) ; \ni ++ ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x = average . x + v . x ; \naverage . y = average . y + v . y ; \n} \naverage . x = average . x / input . size ( ) ; \naverage . y = average . y / input . size ( ) ; \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( int i = 0 ; \ni < target . size ( ) ; \ni ++ ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength = totalLength + b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \nfor ( int k = 0 ; \nk < numberOfSamples ; \nk ++ ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( location > cornerLocationsB [ cornerB + 1 ] ) { \ncornerB ++ ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < model . size ( ) + 1 ; \ni ++ ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) { \nbest = d ; \n} \n} \nerror = error + best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7495": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineParametric2D_F64 a , LineParametric2D_F64 b , Point2D_F64 ret ) { \ndouble t_b = a . getSlopeX ( ) * ( b . getY ( ) - a . getY ( ) ) - a . getSlopeY ( ) * ( b . getX ( ) - a . getX ( ) ) ; \ndouble bottom = a . getSlopeY ( ) * b . getSlopeX ( ) - b . getSlopeY ( ) * a . getSlopeX ( ) ; \nif ( bottom == 0 ) return null ; \nt_b = t_b / bottom ; \ndouble x = b . getSlopeX ( ) * t_b + b . getX ( ) ; \ndouble y = b . getSlopeY ( ) * t_b + b . getY ( ) ; \nif ( ret == null ) ret = new Point2D_F64 ( ) ; \nret . set ( x , y ) ; \nreturn ret ; \n} \n} \n"}
{"7512": "public class TwistOps_F64 { \npublic static TwistCoordinate_F64 twist ( Se3_F64 motion , TwistCoordinate_F64 twist ) { \nif ( twist == null ) twist = new TwistCoordinate_F64 ( ) ; \nif ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) { \ntwist . w . set ( 0 , 0 , 0 ) ; \ntwist . v . set ( motion . T ) ; \n} \nelse { \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; \ntwist . w . set ( rod . unitAxisRotation ) ; \ndouble theta = rod . theta ; \nDMatrixRMaj A = CommonOps_DDRM . identity ( 3 ) ; \nCommonOps_DDRM . subtract ( A , motion . R , A ) ; \nDMatrixRMaj w_hat = GeometryMath_F64 . crossMatrix ( twist . w , null ) ; \nDMatrixRMaj tmp = A . copy ( ) ; \nCommonOps_DDRM . mult ( tmp , w_hat , A ) ; \nVector3D_F64 w = twist . w ; \nA . data [ 0 ] = A . data [ 0 ] + w . x * w . x * theta ; \nA . data [ 1 ] = A . data [ 1 ] + w . x * w . y * theta ; \nA . data [ 2 ] = A . data [ 2 ] + w . x * w . z * theta ; \nA . data [ 3 ] = A . data [ 3 ] + w . y * w . x * theta ; \nA . data [ 4 ] = A . data [ 4 ] + w . y * w . y * theta ; \nA . data [ 5 ] = A . data [ 5 ] + w . y * w . z * theta ; \nA . data [ 6 ] = A . data [ 6 ] + w . z * w . x * theta ; \nA . data [ 7 ] = A . data [ 7 ] + w . z * w . y * theta ; \nA . data [ 8 ] = A . data [ 8 ] + w . z * w . z * theta ; \nDMatrixRMaj y = new DMatrixRMaj ( 3 , 1 ) ; \ny . data [ 0 ] = motion . T . x ; \ny . data [ 1 ] = motion . T . y ; \ny . data [ 2 ] = motion . T . z ; \nDMatrixRMaj x = new DMatrixRMaj ( 3 , 1 ) ; \nCommonOps_DDRM . solve ( A , y , x ) ; \ntwist . w . scale ( rod . theta ) ; \ntwist . v . x = ( double ) x . data [ 0 ] ; \ntwist . v . y = ( double ) x . data [ 1 ] ; \ntwist . v . z = ( double ) x . data [ 2 ] ; \ntwist . v . scale ( rod . theta ) ; \n} \nreturn twist ; \n} \n} \n"}
{"7515": "public class FitPlane3D_F64 { \npublic boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \noutputCenter . set ( 0 , 0 , 0 ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \noutputCenter . x = outputCenter . x + p . x ; \noutputCenter . y = outputCenter . y + p . y ; \noutputCenter . z = outputCenter . z + p . z ; \n} \noutputCenter . x = outputCenter . x / N ; \noutputCenter . y = outputCenter . y / N ; \noutputCenter . z = outputCenter . z / N ; \nreturn solvePoint ( points , outputCenter , outputNormal ) ; \n} \n} \n"}
{"7523": "public class GeometryMath_F64 { \npublic static void divide ( GeoTuple3D_F64 p , double v ) { \np . x = p . x / v ; \np . y = p . y / v ; \np . z = p . z / v ; \n} \n} \n"}
{"7526": "public class Rodrigues_F64 { \npublic void setParamVector ( double x , double y , double z ) { \ndouble ax = Math . abs ( x ) ; \ndouble ay = Math . abs ( y ) ; \ndouble az = Math . abs ( z ) ; \ndouble max = Math . max ( ax , ay ) ; \nmax = Math . max ( max , az ) ; \nif ( max == 0 ) { \ntheta = 0 ; \nunitAxisRotation . set ( 1 , 0 , 0 ) ; \n} \nelse { \nx = x / max ; \ny = y / max ; \nz = z / max ; \ntheta = Math . sqrt ( x * x + y * y + z * z ) ; \nunitAxisRotation . x = x / theta ; \nunitAxisRotation . y = y / theta ; \nunitAxisRotation . z = z / theta ; \ntheta = theta * max ; \n} \n} \n} \n"}
{"7542": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 , Point3D_F64 ret ) { \nif ( ret == null ) { \nret = new Point3D_F64 ( ) ; \n} \nret . x = l0 . p . x - l1 . p . x ; \nret . y = l0 . p . y - l1 . p . y ; \nret . z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \nif ( bottom == 0 ) return null ; \nt0 = t0 / bottom ; \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \nret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; \nret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; \nret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; \nreturn ret ; \n} \n} \n"}
{"7549": "public class Quadrilateral_F64 { \npublic boolean isEquals ( Quadrilateral_F64 quad , double tol ) { \ntol = tol * tol ; \nif ( a . distance2 ( quad . a ) > tol ) return false ; \nif ( b . distance2 ( quad . b ) > tol ) return false ; \nif ( c . distance2 ( quad . c ) > tol ) return false ; \nreturn d . distance2 ( quad . d ) <= tol ; \n} \n} \n"}
{"7567": "public class GeoTuple_F64 { \npublic double normSq ( ) { \ndouble total = 0 ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \ndouble a = getIdx ( i ) ; \ntotal = total + a * a ; \n} \nreturn total ; \n} \n} \n"}
{"7583": "public class TangentLinesTwoEllipses_F64 { \nboolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , EllipseRotated_F64 ellipse , Point2D_F64 tangent , boolean cross ) { \nif ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) return false ; \ntempLine . a = a ; \ntempLine . b = temp0 ; \nboolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \ntempLine . b = temp1 ; \nboolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \nif ( crossed0 == crossed1 ) throw new RuntimeException ( \"Well this didn't work\" ) ; \nif ( cross == crossed0 ) { \nsumDifference = sumDifference + previousTangent . distance2 ( temp0 ) ; \ntangent . set ( temp0 ) ; \n} \nelse { \nsumDifference = sumDifference + previousTangent . distance2 ( temp1 ) ; \ntangent . set ( temp1 ) ; \n} \nreturn true ; \n} \n} \n"}
{"7584": "public class BoxLength3D_F64 { \npublic Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { \nif ( corner == null ) corner = new Point3D_F64 ( ) ; \ncorner . set ( p ) ; \nif ( ( index & 0x01 ) != 0 ) { \ncorner . x = corner . x + lengthX ; \n} \nif ( ( index & 0x02 ) != 0 ) { \ncorner . y = corner . y + lengthY ; \n} \nif ( ( index & 0x04 ) != 0 ) { \ncorner . z = corner . z + lengthZ ; \n} \nreturn corner ; \n} \n} \n"}
{"7591": "public class Distance2D_F64 { \npublic static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { \ndouble slopeAX = segmentA . slopeX ( ) ; \ndouble slopeAY = segmentA . slopeY ( ) ; \ndouble slopeBX = segmentB . slopeX ( ) ; \ndouble slopeBY = segmentB . slopeY ( ) ; \ndouble ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; \ndouble bottom = slopeBY * slopeAX - slopeAY * slopeBX ; \nif ( bottom != 0 ) { \nta = ta / bottom ; \nif ( ta >= 0 && ta <= 1.0 ) { \ndouble tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; \ntb = tb / slopeAY * slopeBX - slopeBY * slopeAX ; \nif ( tb >= 0 && tb <= 1.0 ) return 0 ; \n} \n} \ndouble closest = Double . MAX_VALUE ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; \nreturn closest ; \n} \n} \n"}
{"7600": "public class ClosestPoint2D_F64 { \npublic static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { \nif ( output == null ) output = new Point2D_F64 ( ) ; \ndouble slopeX = line . b . x - line . a . x ; \ndouble slopeY = line . b . y - line . a . y ; \ndouble t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; \nt = t / slopeX * slopeX + slopeY * slopeY ; \nif ( t < 0 ) t = 0 ; \nelse if ( t > 1 ) t = 1 ; \noutput . x = line . a . x + slopeX * t ; \noutput . y = line . a . y + slopeY * t ; \nreturn output ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \ni < end ; \ni = i + 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nj < numCoefs ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow = pow * x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \ni < numCoefs ; \ni ++ ) { \noutput . set ( i , x . data [ i ] ) ; \n} \nreturn true ; \n} \n} \n"}
{"7606": "public class UtilVector3D_F64 { \npublic static void normalize ( Vector3D_F64 v ) { \ndouble a = v . norm ( ) ; \nv . x = v . x / a ; \nv . y = v . y / a ; \nv . z = v . z / a ; \n} \n} \n"}
{"7611": "public class Quaternion_F64 { \npublic void normalize ( ) { \ndouble n = Math . sqrt ( w * w + x * x + y * y + z * z ) ; \nw = w / n ; \nx = x / n ; \ny = y / n ; \nz = z / n ; \n} \n} \n"}
{"7614": "public class Area2D_F64 { \npublic static double polygonSimple ( Polygon2D_F64 poly ) { \ndouble total = 0 ; \nPoint2D_F64 v0 = poly . get ( 0 ) ; \nPoint2D_F64 v1 = poly . get ( 1 ) ; \nfor ( int i = 2 ; \ni < poly . size ( ) ; \ni ++ ) { \nPoint2D_F64 v2 = poly . get ( i ) ; \ntotal = total + v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \n} \nPoint2D_F64 v2 = poly . get ( 0 ) ; \ntotal = total + v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \nv2 = poly . get ( 1 ) ; \ntotal = total + v1 . x * ( v2 . y - v0 . y ) ; \nreturn Math . abs ( total / 2.0 ) ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) mean = new Point2D_F64 ( ) ; \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx = x + p . getX ( ) ; \ny = y + p . getY ( ) ; \n} \nx = x / length ; \ny = y / length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx = xx + dx * dx ; \nxy = xy + dx * dy ; \nyy = yy + dy * dy ; \n} \nxx = xx / points . size ( ) ; \nxy = xy / points . size ( ) ; \nyy = yy / points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7619": "public class GeoTuple4D_F64 { \npublic void timesIP ( double scalar ) { \nx = x * scalar ; \ny = y * scalar ; \nz = z * scalar ; \nw = w * scalar ; \n} \n} \n"}
{"7626": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( Point3D_F64 p : points ) { \nx = x + p . x ; \ny = y + p . y ; \nz = z + p . z ; \n} \nmean . x = x / points . size ( ) ; \nmean . y = y / points . size ( ) ; \nmean . z = z / points . size ( ) ; \nreturn mean ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nx = x + p . x ; \ny = y + p . y ; \nz = z + p . z ; \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nint distance = 0 ; \nfor ( int i = 0 ; \ni < cells . length ; \ni ++ ) { \ndistance = distance + getDistance ( i , cells [ i ] ) ; \n} \nreturn distance ; \n} \n} \n"}
{"7663": "public class StdRandom { \npublic static int poisson ( double lambda ) { \nif ( ! ( lambda > 0.0 ) ) throw new IllegalArgumentException ( \"Parameter lambda must be positive\" ) ; \nif ( Double . isInfinite ( lambda ) ) throw new IllegalArgumentException ( \"Parameter lambda must not be infinite\" ) ; \nint k = 0 ; \ndouble p = 1.0 ; \ndouble L = Math . exp ( - lambda ) ; \ndo { \nk ++ ; \np = p * uniform ( ) ; \n} \nwhile ( p >= L ) ; \nreturn k - 1 ; \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) { \nlen = len + BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( int i = 1 ; \ni < len - 8 ; \ni ++ ) { \nbuf [ i ] = ( byte ) 0x00 ; \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) { \nreturn false ; \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \nreturn false ; \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert end >= begin ; \nif ( ( end - begin ) < len ) { \nreturn false ; \n} \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \np <= stop && ( i < max || max == Compiler . INFINITY ) ; \np = p + len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni ++ ; \n} \nif ( p != end ) { \nreturn false ; \n} \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nreturn ; \n} \nif ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) { \nswitch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now = v . now + 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now = v . now + 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) { \nreturn ; \n} \nif ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now = v . now + 2 ; \nfor ( ; \n! ateos ( ) && iscalpha ( charAtNow ( ) ) ; \nv . now ++ ) { \nswitch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \n} \nif ( ! next1 ( ')' ) ) { \nthrow new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now ++ ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nv . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \nfor ( int rep = 0 ; \nrep < REPS ; \n++ rep ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) continue ; \nwhile ( optEnd < optCur + len ) opts [ ++ optEnd ] . reset ( ) ; \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( int i = len ; \ni >= MATCH_LEN_MIN ; \n-- i ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \nif ( rep == 0 ) startLen = len + 1 ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice = price + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice = price + getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ ++ optEnd ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( startLen > matches . len [ match ] ) ++ match ; \nfor ( int len = startLen ; \n; \n++ len ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice = price + getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n} \n} \n} \n"}
{"7916": "public class Streams { \npublic static long copy ( final InputStream in , final OutputStream out ) throws IOException { \nObjects . requireNonNull ( in ) ; \nObjects . requireNonNull ( out ) ; \nfinal byte [ ] buffer = new byte [ COPY_BUFFER_SIZE ] ; \nlong result = 0 ; \nint rc ; \nwhile ( ( rc = in . read ( buffer ) ) >= 0 ) { \nresult = result + rc ; \nout . write ( buffer , 0 , rc ) ; \n} \nreturn result ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni = i + 6 ; \n} \nelse if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni = i + 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nelse if ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni = i + 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7964": "public class HC4 { \nprivate int movePos ( ) { \nint avail = movePos ( 4 , 4 ) ; \nif ( avail != 0 ) { \nif ( ++ lzPos == Integer . MAX_VALUE ) { \nint normalizationOffset = Integer . MAX_VALUE - cyclicSize ; \nhash . normalize ( normalizationOffset ) ; \nnormalize ( chain , cyclicSize , normalizationOffset ) ; \nlzPos = lzPos - normalizationOffset ; \n} \nif ( ++ cyclicPos == cyclicSize ) cyclicPos = 0 ; \n} \nreturn avail ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path = path + \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8000": "public class LZEncoder { \npublic static int getMemoryUsage ( int dictSize , int extraSizeBefore , int extraSizeAfter , int matchLenMax , int mf ) { \nint m = getBufSize ( dictSize , extraSizeBefore , extraSizeAfter , matchLenMax ) / 1024 + 10 ; \nswitch ( mf ) { \ncase MF_HC4 : m = m + HC4 . getMemoryUsage ( dictSize ) ; \nbreak ; \ncase MF_BT4 : m = m + BT4 . getMemoryUsage ( dictSize ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn m ; \n} \n} \n"}
{"8001": "public class LZEncoder { \npublic void setPresetDict ( int dictSize , byte [ ] presetDict ) { \nassert ! isStarted ( ) ; \nassert writePos == 0 ; \nif ( presetDict != null ) { \nint copySize = Math . min ( presetDict . length , dictSize ) ; \nint offset = presetDict . length - copySize ; \nSystem . arraycopy ( presetDict , offset , buf , 0 , copySize ) ; \nwritePos = writePos + copySize ; \nskip ( copySize ) ; \n} \n} \n} \n"}
{"8002": "public class LZEncoder { \nprivate void moveWindow ( ) { \nint moveOffset = ( readPos + 1 - keepSizeBefore ) & ~ 15 ; \nint moveSize = writePos - moveOffset ; \nSystem . arraycopy ( buf , moveOffset , buf , 0 , moveSize ) ; \nreadPos = readPos - moveOffset ; \nreadLimit = readLimit - moveOffset ; \nwritePos = writePos - moveOffset ; \n} \n} \n"}
{"8003": "public class LZEncoder { \npublic int fillWindow ( byte [ ] in , int off , int len ) { \nassert ! finishing ; \nif ( readPos >= bufSize - keepSizeAfter ) moveWindow ( ) ; \nif ( len > bufSize - writePos ) len = bufSize - writePos ; \nSystem . arraycopy ( in , off , buf , writePos , len ) ; \nwritePos = writePos + len ; \nif ( writePos >= keepSizeAfter ) readLimit = writePos - keepSizeAfter ; \nprocessPendingBytes ( ) ; \nreturn len ; \n} \n} \n"}
{"8004": "public class LZEncoder { \nprivate void processPendingBytes ( ) { \nif ( pendingSize > 0 && readPos < readLimit ) { \nreadPos = readPos - pendingSize ; \nint oldPendingSize = pendingSize ; \npendingSize = 0 ; \nskip ( oldPendingSize ) ; \nassert pendingSize < oldPendingSize ; \n} \n} \n} \n"}
{"8046": "public class JspUtil { \npublic static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { \nString className = null ; \nint begin = 0 ; \nint index ; \nindex = path . lastIndexOf ( \".tag\" ) ; \nif ( index == - 1 ) { \nerr . jspError ( \"jsp.error.tagfile.badSuffix\" , path ) ; \n} \nindex = path . indexOf ( WEB_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.web.\" ; \nbegin = index + WEB_INF_TAGS . length ( ) ; \n} \nelse { \nindex = path . indexOf ( META_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.meta.\" ; \nbegin = index + META_INF_TAGS . length ( ) ; \n} \nelse { \nerr . jspError ( \"jsp.error.tagfile.illegalPath\" , path ) ; \n} \n} \nclassName = className + makeJavaPackage ( path . substring ( begin ) ) ; \nreturn className ; \n} \n} \n"}
{"8058": "public class MetadataCache { \nprivate String databaseLoad ( Locator locator , String key ) throws CacheException { \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nMap < String , String > metadata = io . getAllValues ( locator ) ; \nif ( metadata == null || metadata . isEmpty ( ) ) { \ncache . put ( cacheKey , NULL ) ; \nreturn NULL ; \n} \nint metadataRowSize = 0 ; \nfor ( Map . Entry < String , String > meta : metadata . entrySet ( ) ) { \nmetadataRowSize = metadataRowSize + meta . getKey ( ) . getBytes ( ) . length + locator . toString ( ) . getBytes ( ) . length ; \nif ( meta . getValue ( ) != null ) metadataRowSize = metadataRowSize + meta . getValue ( ) . getBytes ( ) . length ; \nif ( meta . getKey ( ) . equals ( key ) ) continue ; \nCacheKey metaKey = new CacheKey ( locator , meta . getKey ( ) ) ; \ncache . put ( metaKey , meta . getValue ( ) ) ; \n} \ntotalMetadataSize . update ( metadataRowSize ) ; \nString value = metadata . get ( key ) ; \nif ( value == null ) { \ncache . put ( cacheKey , NULL ) ; \nvalue = NULL ; \n} \nreturn value ; \n} \ncatch ( IOException ex ) { \nthrow new CacheException ( ex ) ; \n} \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors = unexpectedErrors + 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \nelse { \nlog . debug ( \"Download in progress\" ) ; \n} \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition = position + 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition = position + 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition = position + 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition = position + 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8391": "public class HorizontalPicker { \nprivate int getColor ( int scrollX , int position ) { \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nfloat proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; \nif ( proportion > .5 ) { \nproportion = ( proportion - .5f ) ; \n} \nelse { \nproportion = .5f - proportion ; \n} \nproportion = proportion * 2 ; \nint defaultColor ; \nint selectedColor ; \nif ( pressedItem == position ) { \ndefaultColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, textColor . getDefaultColor ( ) ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed , android . R . attr . state_selected } \n, defaultColor ) ; \n} \nelse { \ndefaultColor = textColor . getDefaultColor ( ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_selected } \n, defaultColor ) ; \n} \nreturn ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; \n} \n} \n"}
{"8464": "public class ScreenRegionLatch { \nprotected boolean inRange ( NativeMouseEvent e ) { \nRectangle r = screenRegion . getBounds ( ) ; \nr . x = r . x + screenOffsetX ; \nr . y = r . y + screenOffsetY ; \nint x = e . getX ( ) ; \nint y = e . getY ( ) ; \nreturn r . contains ( x , y ) ; \n} \n} \n"}
{"8642": "public class CellUtility { \npublic static void createOrInsertComment ( final Cell cell , final String commentStr ) { \nXSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nComment comment = cell . getCellComment ( ) ; \nString originStr = \"\" ; \nif ( comment == null ) { \nClientAnchor anchor = createCommentAnchor ( cell , factory ) ; \ncomment = drawing . createCellComment ( anchor ) ; \n} \nelse { \noriginStr = comment . getString ( ) . getString ( ) + \"\\n\" ; \n} \noriginStr = originStr + commentStr ; \nRichTextString str = factory . createRichTextString ( originStr ) ; \ncomment . setString ( str ) ; \ncomment . setAuthor ( \"\" ) ; \ncell . setCellComment ( comment ) ; \ncomment . setColumn ( cell . getColumnIndex ( ) ) ; \ncomment . setRow ( cell . getRowIndex ( ) ) ; \n} \n} \n"}
{"8670": "public class EachCommand { \n@ SuppressWarnings ( \"rawtypes\" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { \nint index = 0 ; \nint insertPosition = atRow ; \nString thisObjClassName = objClassName ; \nfor ( Object obj : itemsCollection ) { \nif ( thisObjClassName == null ) { \nthisObjClassName = obj . getClass ( ) . getName ( ) ; \nconfigBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; \n} \nRowsMapping unitRowsMapping = new RowsMapping ( ) ; \ncontext . put ( var , obj ) ; \nCommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; \nConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; \ncurrentRowsMappingList . add ( unitRowsMapping ) ; \nString unitFullName = fullName + \".\" + index ; \ncurrentRange . getAttrs ( ) . setAllowAdd ( false ) ; \nif ( ( this . allowAdd != null ) && ( \"true\" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { \ncurrentRange . getAttrs ( ) . setAllowAdd ( true ) ; \nconfigBuildRef . setBodyAllowAdd ( true ) ; \n} \nconfigBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; \nint length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; \ncurrentRange . getAttrs ( ) . setFinalLength ( length ) ; \ninsertPosition = insertPosition + length ; \ncurrentRowsMappingList . remove ( unitRowsMapping ) ; \nindex ++ ; \ncontext . remove ( var ) ; \n} \nreturn insertPosition ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \nfor ( int col = cell . getColumnIndex ( ) ; \ncol < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; \ncol ++ ) { \ncellWidth = cellWidth + sheet1 . getColumnWidthInPixels ( col ) ; \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( int rowIndex = cell . getRowIndex ( ) ; \nrowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; \nrowIndex ++ ) { \ncellHeight = cellHeight + WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \nfor ( short col = anchor . getCol1 ( ) ; \ncol < anchor . getCol2 ( ) ; \ncol ++ ) { \npicWidth = picWidth + sheet1 . getColumnWidthInPixels ( col ) ; \n} \nfor ( int rowindex = anchor . getRow1 ( ) ; \nrowindex < anchor . getRow2 ( ) ; \nrowindex ++ ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight = picHeight + WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nint totalHeight = additionalHeight ; \nfor ( int i = firstRow ; \ni <= lastRow ; \ni ++ ) { \ntotalHeight = totalHeight + sheet1 . getRow ( i ) . getHeight ( ) ; \n} \nreturn totalHeight ; \n} \n} \n"}
{"8744": "public class WebSheetUtility { \npublic static int convertColToInt ( final String col ) { \nString name = col . toUpperCase ( ) ; \nint number = 0 ; \nint pow = 1 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nnumber = number + ( name . charAt ( i ) - 'A' + 1 ) * pow ; \npow = pow * TieConstants . EXCEL_LETTER_NUMBERS ; \n} \nreturn number - 1 ; \n} \n} \n"}
{"8746": "public class WebSheetUtility { \npublic static int heightUnits2Pixel ( final short heightUnits ) { \nint pixels = heightUnits / EXCEL_ROW_HEIGHT_FACTOR ; \nint offsetHeightUnits = heightUnits % EXCEL_ROW_HEIGHT_FACTOR ; \npixels = pixels + Math . round ( ( float ) offsetHeightUnits / ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH / 2 ) ) ; \npixels = pixels + ( Math . floor ( pixels / PIXEL_HEIGHT_ASPC_ADJUST ) + 1 ) * 4 ; \nreturn pixels ; \n} \n} \n"}
{"8776": "public class WebSheetLoader { \nprivate String getHeaderColumnStyle ( final Workbook wb , final Cell cell , final double colWidth , final double totalWidth ) { \nString columnstyle = \"\" ; \nif ( cell != null ) { \ncolumnstyle = columnstyle + CellStyleUtility . getCellStyle ( wb , cell , \"\" ) + CellStyleUtility . getCellFontStyle ( wb , cell ) ; \n} \ncolumnstyle = columnstyle + getWidthStyle ( colWidth , totalWidth ) ; \nreturn columnstyle ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \n} \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nlong total = 0 ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( l < 0 ) { \nreturn - 1 ; \n} \ntotal = total + l ; \n} \ntotal = total + EXTRA_BYTES . length ; \ntotal = total + partBoundary . length ; \ntotal = total + EXTRA_BYTES . length ; \ntotal = total + CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8883": "public class Statistics { \npublic double getEstimate ( AttributeValues wordform ) { \ndouble estimate = 0.1 ; \nString endingIdStr = wordform . getValue ( AttributeNames . i_EndingID ) ; \nint endingId = ( endingIdStr == null ) ? - 1 : Integer . parseInt ( endingIdStr ) ; \nif ( endingFrequency . get ( endingId ) != null ) estimate = estimate + endingFrequency . get ( endingId ) ; \nString lexemeIdStr = wordform . getValue ( AttributeNames . i_LexemeID ) ; \nint lexemeId = ( lexemeIdStr == null ) ? - 1 : Integer . parseInt ( lexemeIdStr ) ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) estimate = estimate + lexemeFrequency . get ( lexemeId ) * lexemeWeight ; \nreturn estimate ; \n} \n} \n"}
{"9004": "public class IntPower { \npublic static double raise ( final double px , final int pexponent ) { \ndouble x = px ; \nint exponent = pexponent ; \nif ( exponent < 0 ) return 1 / raise ( x , - exponent ) ; \ndouble power = 1 ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) power = power * x ; \nx = x * x ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9012": "public class BigFunctions { \nprivate static BigDecimal _arctanTaylor ( final BigDecimal x , final int scale ) { \nfinal int sp1 = scale + 1 ; \nint i = 3 ; \nboolean addFlag = false ; \nBigDecimal power = x ; \nBigDecimal sum = x ; \nBigDecimal term ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \ndo { \npower = power . multiply ( x ) . multiply ( x ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nterm = power . divide ( BigDecimal . valueOf ( i ) , sp1 , RoundingMode . HALF_EVEN ) ; \nsum = addFlag ? sum . add ( term ) : sum . subtract ( term ) ; \ni = i + 2 ; \naddFlag = ! addFlag ; \nThread . yield ( ) ; \n} \nwhile ( term . compareTo ( tolerance ) > 0 ) ; \nreturn sum ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex = index + 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( int c = 0 ; \nc < m . m_nCols ; \n++ c ) { \nfloat dot = 0 ; \nfor ( int k = 0 ; \nk < m_nCols ; \n++ k ) { \ndot = dot + m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \n} \npv [ r ] [ c ] = dot ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9045": "public class InvertibleMatrix { \npublic float determinant ( ) throws MatrixException { \ndecompose ( ) ; \nfloat determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; \nfor ( int i = 0 ; \ni < m_nRows ; \n++ i ) { \nfinal int pi = m_aPermutation [ i ] ; \ndeterminant = determinant * m_aLU . at ( pi , i ) ; \n} \nreturn determinant ; \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum = sum + v * v ; \n} \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( int rPivot = 0 ; \nrPivot < m_nRows - 1 ; \n++ rPivot ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \nfor ( int r = rPivot ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( int r = rPivot + 1 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \nfor ( int c = rPivot + 1 ; \nc < m_nCols ; \n++ c ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt = elmt - multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = 0 ; \nc < r ; \n++ c ) { \ndot = dot + m_aLU . at ( pr , c ) * y . at ( c ) ; \n} \ny . set ( r , b . at ( pr ) - dot ) ; \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \nfor ( int r = m_nRows - 1 ; \nr >= 0 ; \n-- r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = r + 1 ; \nc < m_nRows ; \n++ c ) { \ndot = dot + m_aLU . at ( pr , c ) * x . at ( c ) ; \n} \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) largestX = absX ; \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( int iter = 0 ; \niter < MAX_ITER ; \n++ iter ) { \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \ndouble dot = 0 ; \nfor ( int c = 0 ; \nc < m_nRows ; \n++ c ) { \nfinal double elmt = at ( r , c ) ; \ndot = dot + elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) largestDiff = diff ; \n} \nif ( largestDiff < largestX * TOLERANCE ) return ; \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9061": "public class ModuloArithmetic { \npublic static int multiply ( final int pa , final int pb , final int m ) { \nint a = pa ; \nint b = pb ; \nint product = 0 ; \nwhile ( a > 0 ) { \nif ( ( a & 1 ) == 1 ) { \nproduct = product + b ; \nproduct = product % m ; \n} \nb <<= 1 ; \nb = b % m ; \na >>= 1 ; \n} \nreturn product ; \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \nfor ( int j = 0 ; \nj < 12 ; \n++ j ) sum = sum + GENERATOR . nextFloat ( ) ; \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( int i = 2 ; \ni <= n ; \n++ i ) sieve [ i ] = true ; \nint prime = 2 ; \nwhile ( prime < halfN ) { \nfor ( int composite = prime << 1 ; \ncomposite <= n ; \ncomposite = composite + prime ) sieve [ composite ] = false ; \nwhile ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( int factor = 2 ; \nn > 1 ; \n++ factor ) { \nif ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn = n / factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \nfor ( int i = 0 ; \ni < v . size ( ) ; \n++ i ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n} \nreturn factors ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( int count = 0 ; \ncount < bytes . length ; \ncount ++ ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { \nnewRef = newRef + encodedByte ( ch ) ; \n} \nelse { \nnewRef = newRef + ( char ) bytes [ count ] ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9318": "public class NotifyingBufferedOutputStream { \npublic void checkNotification ( int result ) { \nchunk = chunk + result ; \nif ( chunk >= chunkSize ) { \nif ( listener != null ) listener . onStreamNotification ( this , chunk ) ; \nchunk = 0 ; \n} \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult = result + children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9394": "public class PublicId { \nprivate static String stringReplace ( String str , String oldStr , String newStr ) { \nString result = \"\" ; \nint pos = str . indexOf ( oldStr ) ; \nwhile ( pos >= 0 ) { \nresult = result + str . substring ( 0 , pos ) ; \nresult = result + newStr ; \nstr = str . substring ( pos + 1 ) ; \npos = str . indexOf ( oldStr ) ; \n} \nreturn result + str ; \n} \n} \n"}
{"9396": "public class StopWatch { \npublic long stop ( ) { \nlong lap = 0 ; \nif ( running ) { \ncount ++ ; \nstop = System . currentTimeMillis ( ) ; \nlap = stop - start ; \ntotal = total + lap ; \nrunning = false ; \n} \nreturn lap ; \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) { \nthrow new IllegalArgumentException ( \"type is not a primitive class\" ) ; \n} \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni = i + 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \n} \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni = i + 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime = time + System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \n} \n} \n"}
{"9507": "public class Chunk { \npublic int getSumDegree ( ) { \nif ( sumDegree < 0 ) { \nint sum = 0 ; \nfor ( Word word : words ) { \nif ( word != null && word . getDegree ( ) > - 1 ) { \nsum = sum + word . getDegree ( ) ; \n} \n} \nsumDegree = sum ; \n} \nreturn sumDegree ; \n} \n} \n"}
{"9556": "public class PlanBindings { \npublic void add ( Plan plan , Set < Belief > planBindings ) { \nif ( plan == null ) { \nreturn ; \n} \nif ( this . bindings . containsKey ( plan ) ) { \nSet < Belief > oldBindings = this . bindings . remove ( plan ) ; \nif ( oldBindings == null || oldBindings . isEmpty ( ) ) { \ncachedsize -- ; \n} \nelse { \ncachedsize = cachedsize - oldBindings . size ( ) ; \n} \n} \nthis . bindings . put ( plan , planBindings ) ; \nif ( planBindings == null || planBindings . isEmpty ( ) ) { \ncachedsize ++ ; \n} \nelse { \ncachedsize = cachedsize + planBindings . size ( ) ; \n} \n} \n} \n"}
{"9558": "public class PlanBindings { \nprivate Plan selectPlanAtRandom ( ) { \nPlan plan = null ; \nSet < Belief > vars = null ; \nint index = rand . nextInt ( size ( ) ) ; \nint idx = 0 ; \nboolean bindingsExist = false ; \nfor ( Plan p : bindings . keySet ( ) ) { \nvars = bindings . get ( p ) ; \nbindingsExist = ( vars != null && ! vars . isEmpty ( ) ) ; \nidx = idx + bindingsExist ? vars . size ( ) : 1 ; \nif ( idx > index ) { \nplan = p ; \nif ( bindingsExist ) { \nindex = index - ( idx - vars . size ( ) ) ; \nsetPlanVariables ( plan . getAgent ( ) , plan , vars , index ) ; \n} \nbreak ; \n} \n} \nreturn plan ; \n} \n} \n"}
{"9612": "public class Main { \npublic static boolean init ( Config config ) { \nif ( config . isDoPauseForUserInput ( ) ) { \nProgram . pauseForUserInput ( ) ; \n} \nLog . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; \nlogger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; \nint numAgents = 0 ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nnumAgents = numAgents + agentType . getCount ( ) ; \n} \nfinal int increment = 10000 ; \nGlobalState . reset ( ) ; \nGlobalState . agents = new AObjectCatalog ( \"agents\" , numAgents , increment ) ; \nGlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; \nlong t0 ; \nt0 = System . currentTimeMillis ( ) ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nif ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) { \nreturn false ; \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Created \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nProgram . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; \nif ( config . getProgramOutputFile ( ) != null ) { \ntry { \nwriter = new PrintStream ( config . getProgramOutputFile ( ) , \"UTF-8\" ) ; \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nlogger . error ( \"Could not open program outout file \" + config . getProgramOutputFile ( ) , e ) ; \n} \n} \nelse { \nwriter = System . out ; \n} \nProgram . initIntentionSelectionThreads ( config ) ; \nreturn true ; \n} \n} \n"}
{"9897": "public class HELM2Notation { \npublic String toHELM2 ( ) { \nString output = \"\" ; \noutput = output + polymerToHELM2 ( ) + \"$\" ; \noutput = output + connectionToHELM2 ( ) + \"$\" ; \noutput = output + groupingToHELM2 ( ) + \"$\" ; \noutput = output + annotationToHELM2 ( ) + \"$\" ; \noutput = output + \"V2.0\" ; \nreturn output ; \n} \n} \n"}
{"9917": "public class ADiGraph { \npublic static < N , E extends AEdge < N > > ADiGraph < N , E > create ( Collection < N > nodes , Collection < E > edges ) { \nfinal Object [ ] nodeArr = new Object [ nodes . size ( ) ] ; \nfinal AEdge [ ] edgeArr = new AEdge [ edges . size ( ) ] ; \nint idx = 0 ; \nfor ( N node : nodes ) { \nnodeArr [ idx ] = node ; \nidx = idx + 1 ; \n} \nidx = 0 ; \nfor ( E edge : edges ) { \nedgeArr [ idx ] = edge ; \nidx = idx + 1 ; \n} \nreturn new ADiGraph < N , E > ( nodeArr , edgeArr ) ; \n} \n} \n"}
{"9919": "public class ADiGraph { \npublic List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { \nif ( hasCycles ( ) ) { \nthrow new AGraphCircularityException ( ) ; \n} \nfinal Object [ ] result = new Object [ nodes . length ] ; \nint nextIdx = 0 ; \nfinal Set < N > unprocessed = new HashSet < > ( ) ; \nfor ( Object node : nodes ) { \nunprocessed . add ( ( N ) node ) ; \n} \nwhile ( ! unprocessed . isEmpty ( ) ) { \nfinal Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { \n@ Override public boolean apply ( N n ) { \nfor ( E e : incomingEdges ( n ) ) { \nif ( unprocessed . contains ( e . getFrom ( ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n) ; \nunprocessed . removeAll ( nextBatch ) ; \nfor ( N n : nextBatch ) { \nresult [ nextIdx ] = n ; \nnextIdx = nextIdx + 1 ; \n} \n} \nreturn new ArrayIterable < > ( result ) ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nint s = indexSeed = indexSeed + SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' || ch == ',' ) { \nestimatedSize = estimatedSize + 3 ; \ncontinue ; \n} \n++ estimatedSize ; \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10006": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( true ) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) { \nbreak ; \n} \noutput . write ( buffer , 0 , read ) ; \ncount = count + read ; \n} \nreturn count ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nbyte buffer [ ] = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( byteCount > 0 ) { \nif ( byteCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , byteCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \nbyteCount = byteCount - read ; \ncount = count + read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10009": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output ) throws IOException { \nchar [ ] buffer = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( ( read = input . read ( buffer , 0 , ioBufferSize ) ) >= 0 ) { \noutput . write ( buffer , 0 , read ) ; \ncount = count + read ; \n} \noutput . flush ( ) ; \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( charCount > 0 ) { \nif ( charCount < ioBufferSize ) { \nread = input . read ( buffer , 0 , charCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \ncharCount = charCount - read ; \ncount = count + read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10081": "public class ProtobufSerializerUtils { \npublic static final String getProtobufGetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_GETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( map != null ) { \nif ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) { \nreturn map . get ( fieldName ) ; \n} \n} \nelse { \nmap = new ConcurrentHashMap < > ( ) ; \n} \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString getter = \"get\" + upperCaseFirstFieldName ; \nif ( Collection . class . isAssignableFrom ( field . getType ( ) ) ) { \ngetter = getter + \"List\" ; \n} \nif ( ! protobufAttribute . protobufGetter ( ) . isEmpty ( ) ) { \nreturn protobufAttribute . protobufGetter ( ) ; \n} \nmap . put ( fieldName , getter ) ; \nCLASS_TO_FIELD_GETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn getter ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni = i + name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10158": "public class DebugOutputStream { \nprotected void dumpByte ( int b ) { \nif ( passThrough == true ) { \nSystem . out . print ( '\\t' ) ; \n} \nif ( b < 0 ) { \nb = b + 128 ; \n} \nif ( b < 0x10 ) { \nSystem . out . print ( '0' ) ; \n} \nSystem . out . print ( ' ' ) ; \nSystem . out . print ( Integer . toHexString ( b ) . toUpperCase ( ) ) ; \n} \n} \n"}
{"10175": "public class Rectangular { \npublic void move ( int xofs , int yofs ) { \nx1 = x1 + xofs ; \ny1 = y1 + yofs ; \nx2 = x2 + xofs ; \ny2 = y2 + yofs ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < col ; \ni ++ ) ofs = ofs + cols [ i ] ; \nreturn ofs ; \n} \nelse if ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < row ; \ni ++ ) ofs = ofs + rows [ i ] ; \nreturn ofs ; \n} \nelse if ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi = pi + 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi = pi + 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10189": "public class ByteCodeMonitor { \npublic void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { \nlog . fine ( \"public void onCodeUpdate(ByteBuffer codeBuffer, int start = \" + start + \", int length = \" + length + \", VariableAndFunctorInterner interner, WAMCodeView codeView): called\" ) ; \ncopyAndResizeCodeBuffer ( codeBuffer , start , length ) ; \nSizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; \nMap . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; \nint firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; \nint address = start ; \nint row = firstRow ; \nfor ( WAMInstruction instruction : instructions ) { \naddressToRow . put ( address , row ) ; \nrowToAddress . add ( row , address ) ; \nrow ++ ; \naddress = address + instruction . sizeof ( ) ; \n} \nrenderInstructions ( instructions , firstRow , start ) ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( int i = 2 ; \ni < 32 ; \ni = i * 2 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg = arg + \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg = arg + Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg = arg + Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg = arg + fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg = arg + target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress = address + instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10210": "public class AbstractLearningMethod { \nprotected void initialize ( ) throws LearningFailureException { \nif ( inputExamples . isEmpty ( ) ) { \nthrow new LearningFailureException ( \"No training examples to learn from.\" , null ) ; \n} \nif ( ! outputPropertiesSet ) { \naddGoalProperty ( \"goal\" ) ; \n} \nif ( ! inputPropertiesSet ) { \nState example = inputExamples . iterator ( ) . next ( ) ; \nSet < String > allProperties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \ninputProperties = new HashSet < String > ( allProperties ) ; \ninputProperties . removeAll ( outputProperties ) ; \ninputPropertiesSet = true ; \n} \nfor ( State example : inputExamples ) { \nSet < String > properties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \nString errorMessage = \"\" ; \nfor ( String inputProperty : inputProperties ) { \nif ( ! properties . contains ( inputProperty ) ) { \nerrorMessage = errorMessage + \"The training example, \" + example + \" does not contain the specified input property, \" + inputProperty + \"\\n\" ; \n} \n} \nfor ( String outputProperty : outputProperties ) { \nif ( ! properties . contains ( outputProperty ) ) { \nerrorMessage = errorMessage + \"The training example, \" + example + \" does not contain the specified output property, \" + outputProperty + \"\\n\" ; \n} \n} \nif ( ! \"\" . equals ( errorMessage ) ) { \nthrow new LearningFailureException ( errorMessage , null ) ; \n} \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( delta >= 1 ) { \nindentStack . push ( delta ) ; \n} \nelse if ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent = traceIndent + ( delta < 0 ) ? delta : 0 ; \nfor ( int i = 0 ; \ni < traceIndent ; \ni ++ ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent = traceIndent + ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( diff < 0 ) { \nyear -- ; \n} \nelse if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nyearStart = yearStart + oneYear ; \nif ( yearStart <= ticks ) { \nyear ++ ; \n} \n} \nreturn year ; \n} \n} \n"}
{"10323": "public class InformationTheory { \npublic static double expectedI ( double [ ] probabilities ) { \ndouble result = 0.0d ; \nfor ( double p : probabilities ) { \nif ( p > 0.0d ) { \nresult = result - p * Math . log ( p ) ; \n} \n} \nreturn result / LN2 ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal = total + c ; \n} \nfor ( int i = 0 ; \ni < probabilities . length ; \ni ++ ) { \nif ( total > 0 ) { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \nelse { \nprobabilities [ i ] = 0.0d ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10377": "public class ByteBufferUtils { \npublic static int getIntFromBytes ( byte [ ] buf , int offset ) { \nint result = 0 ; \nresult = result + buf [ offset ++ ] & 0xFF ; \nresult = result + ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; \nresult = result + ( ( buf [ offset ++ ] & 0xFF ) << 16 ) ; \nresult = result + ( ( buf [ offset ] ) << 24 ) ; \nreturn result ; \n} \n} \n"}
{"10380": "public class ByteBufferUtils { \npublic static int get24BitIntFromBytes ( byte [ ] buf , int offset ) { \nint i = 0 ; \noffset ++ ; \ni = i + buf [ offset ++ ] & 0xFF ; \ni = i + ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; \ni = i + ( ( buf [ offset ] & 0xFF ) << 16 ) ; \nreturn i ; \n} \n} \n"}
{"10381": "public class ByteBufferUtils { \npublic static short getShortFromBytes ( byte [ ] buf , int offset ) { \nshort result = 0 ; \nresult = result + buf [ offset ++ ] & 0xFF ; \nresult = result + ( ( buf [ offset ] ) << 8 ) ; \nreturn result ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nresult = result + array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \n} \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \nfor ( int i = 1 ; \ni < parts . length ; \ni ++ ) { \nif ( parts [ i ] . length ( ) > 0 ) { \nresult = result + upperFirstChar ( parts [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nint h = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh = h + diffX + diffY ; \n} \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = integerValue < 0 ; \nint totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nint totalLength = totalDigits ; \nif ( isNeg ) { \ntotalDigits -- ; \n} \nif ( scale > 0 ) { \ntotalLength ++ ; \nif ( scale >= totalDigits ) { \ntotalLength = totalLength + ( scale - totalDigits ) + 1 ; \n} \n} \nelse { \ntotalLength = totalLength - scale ; \n} \nreturn totalLength ; \n} \n} \n"}
{"10420": "public class WAMCompiledQuery { \npublic void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { \nif ( sizeof ( ) > Integer . MAX_VALUE ) { \nthrow new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; \n} \nint length = 0 ; \nfor ( WAMInstruction instruction : instructions ) { \ninstruction . emmitCode ( buffer , machine ) ; \nlength = length + instruction . sizeof ( ) ; \n} \nthis . machine = machine ; \nthis . callPoint = callPoint ; \nthis . status = LinkStatus . Linked ; \n} \n} \n"}
{"10482": "public class JTextGrid { \nprotected Dimension computeGridSize ( ) { \nint cols = model . getWidth ( ) ; \nint rows = model . getHeight ( ) ; \nint horizSeparatorSize = 0 ; \nfor ( int size : model . getHorizontalSeparators ( ) . values ( ) ) { \nhorizSeparatorSize = horizSeparatorSize + size ; \n} \nint vertSeparatorSize = 0 ; \nfor ( int size : model . getVerticalSeparators ( ) . values ( ) ) { \nvertSeparatorSize = vertSeparatorSize + size ; \n} \nreturn new Dimension ( vertSeparatorSize + colToX ( cols ) , horizSeparatorSize + rowToY ( rows ) ) ; \n} \n} \n"}
{"10497": "public class ScriptGenMojo { \nprotected String appendClasspath ( String commandLine , boolean unix ) { \nString pathSeperator ; \nString seperator ; \nif ( unix ) { \npathSeperator = \"/\" ; \nseperator = \":\" ; \n} \nelse { \npathSeperator = \"\\\\\" ; \nseperator = \";\" ; \n} \nfor ( Iterator i = classpathElements . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString cpPath = ( String ) i . next ( ) ; \ncpPath = cpPath . replace ( \"/\" , pathSeperator ) ; \ncommandLine = commandLine + cpPath + ( i . hasNext ( ) ? seperator : \"\" ) ; \n} \nreturn commandLine ; \n} \n} \n"}
{"10524": "public class CommandLineParser { \npublic String getErrors ( ) { \nif ( parsingErrors . isEmpty ( ) ) { \nreturn \"\" ; \n} \nString result = \"\" ; \nfor ( String s : parsingErrors ) { \nresult = result + s ; \n} \nreturn result ; \n} \n} \n"}
{"10525": "public class CommandLineParser { \npublic String getOptionsInForce ( ) { \nif ( parsedProperties == null ) { \nreturn \"\" ; \n} \nString result = \"Options in force:\\n\" ; \nfor ( Map . Entry < Object , Object > property : parsedProperties . entrySet ( ) ) { \nresult = result + property . getKey ( ) + \" = \" + property . getValue ( ) + \"\\n\" ; \n} \nreturn result ; \n} \n} \n"}
{"10526": "public class CommandLineParser { \npublic String getUsage ( ) { \nString result = \"Options:\\n\" ; \nint optionWidth = 0 ; \nint argumentWidth = 0 ; \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nint oWidth = optionInfo . option . length ( ) ; \nint aWidth = ( optionInfo . argument != null ) ? ( optionInfo . argument . length ( ) ) : 0 ; \noptionWidth = ( oWidth > optionWidth ) ? oWidth : optionWidth ; \nargumentWidth = ( aWidth > argumentWidth ) ? aWidth : argumentWidth ; \n} \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nString argString = ( ( optionInfo . argument != null ) ? ( optionInfo . argument ) : \"\" ) ; \nString optionString = optionInfo . option ; \nargString = rightPad ( argString , \" \" , argumentWidth ) ; \noptionString = rightPad ( optionString , \" \" , optionWidth ) ; \nresult = result + \"-\" + optionString + \" \" + argString + \" \" + optionInfo . comment + \"\\n\" ; \n} \nreturn result ; \n} \n} \n"}
{"10532": "public class Comparisons { \npublic static < T , U > String compareIterators ( Iterator < U > iterator , Iterator < T > expectedIterator , Function < U , T > mapping ) { \nString errorMessage = \"\" ; \nwhile ( iterator . hasNext ( ) ) { \nU next = iterator . next ( ) ; \nT nextMapped = mapping . apply ( next ) ; \nT nextExpected = expectedIterator . next ( ) ; \nif ( ! nextMapped . equals ( nextExpected ) ) { \nerrorMessage = errorMessage + \"Expecting \" + nextExpected + \" but got \" + nextMapped ; \n} \n} \nreturn errorMessage ; \n} \n} \n"}
{"10533": "public class PTStemmer { \npublic Enumeration listOptions ( ) { \nVector < Option > result ; \nString desc ; \nSelectedTag tag ; \nint i ; \nresult = new Vector < Option > ( ) ; \ndesc = \"\" ; \nfor ( i = 0 ; \ni < TAGS_STEMMERS . length ; \ni ++ ) { \ntag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; \ndesc = desc + \"\\t\" + tag . getSelectedTag ( ) . getIDStr ( ) + \" = \" + tag . getSelectedTag ( ) . getReadable ( ) + \"\\n\" ; \n} \nresult . addElement ( new Option ( \"\\tThe type of stemmer algorithm to use:\\n\" + desc + \"\\t(default: \" + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + \")\" , \"S\" , 1 , \"-S \" + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the named entities to ignore (optional).\\n\" + \"\\tFile format: simple text file with one entity per line.\\n\" + \"\\t(default: none)\\n\" , \"N\" , 1 , \"-N <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the stopwords (optional).\\n\" + \"\\tFile format: simple text file with one stopword per line.\\n\" + \"\\t(default: none)\\n\" , \"W\" , 1 , \"-W <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe size of the cache. Disable with 0.\\n\" + \"\\t(default: 1000)\\n\" , \"C\" , 1 , \"-C <int>\" ) ) ; \nreturn result . elements ( ) ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nint illegalSwaps = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) { \nfor ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps = illegalSwaps + checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \n} \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) { \nresult = result + new String ( board [ j ] ) + \"\\n\" ; \n} \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10584": "public class Cons { \nprivate String listToString ( VariableAndFunctorInterner interner , boolean isFirst , boolean printVarName , boolean printBindings ) { \nString result = \"\" ; \nif ( isFirst ) { \nresult = result + \"[\" ; \n} \nresult = result + arguments [ 0 ] . toString ( interner , printVarName , printBindings ) ; \nTerm consArgument = arguments [ 1 ] . getValue ( ) ; \nif ( consArgument instanceof Cons ) { \nresult = result + \", \" + ( ( Cons ) consArgument ) . listToString ( interner , false , printVarName , printBindings ) ; \n} \nif ( isFirst ) { \nresult = result + \"]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nint oa ; \nint i ; \nint b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nwhile ( b != 0 ) { \ni = ( i << 1 ) ; \nif ( n >= ( 1 << b ) ) { \nn = n / ( 1 << b ) ; \ni = i | 1 ; \n} \nelse { \nn &= ( 1 << b ) - 1 ; \n} \nb = b / 2 ; \n} \nif ( ( 1 << i ) == oa ) { \nreturn i ; \n} \nelse { \nreturn i + 1 ; \n} \n} \n} \n"}
{"10605": "public class SwingKeyCombinationBuilder { \nprivate String modifiersToString ( int modifiers ) { \nString result = \"\" ; \nif ( ( modifiers & InputEvent . SHIFT_MASK ) != 0 ) { \nresult = result + \"shift \" ; \n} \nif ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) { \nresult = result + \"ctrl \" ; \n} \nif ( ( modifiers & InputEvent . META_MASK ) != 0 ) { \nresult = result + \"meta \" ; \n} \nif ( ( modifiers & InputEvent . ALT_MASK ) != 0 ) { \nresult = result + \"alt \" ; \n} \nif ( ( modifiers & InputEvent . ALT_GRAPH_MASK ) != 0 ) { \nresult = result + \"altGraph \" ; \n} \nreturn result ; \n} \n} \n"}
{"10620": "public class Functor { \nprotected String toStringArguments ( ) { \nString result = \"\" ; \nif ( arity > 0 ) { \nresult = result + \"[ \" ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \nTerm nextArg = arguments [ i ] ; \nresult = result + ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( i < ( arity - 1 ) ) ? \", \" : \" \" ) ; \n} \nresult = result + \" ]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \nposition = position + length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname = name + \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ni < dirs . length ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10778": "public class HashMap3 { \npublic int size ( ) { \nint result = 0 ; \nfor ( Iterator < K1 > keys1 = maps . keySet ( ) . iterator ( ) ; \nkeys1 . hasNext ( ) ; \n) { \nMap2 < K2 , K3 , V > inner_map = maps . get ( keys1 . next ( ) ) ; \nresult = result + inner_map . size ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"10912": "public class FireREST { \npublic BufferedImage errorImage ( String ... lines ) { \nif ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth || imageBuffer . getHeight ( ) != imageHeight ) { \nimageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; \n} \nGraphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; \ng . setBackground ( new Color ( 64 , 32 , 32 ) ) ; \ng . setColor ( new Color ( 255 , 64 , 64 ) ) ; \ng . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; \nint maxLen = 0 ; \nfor ( String line : lines ) { \nif ( line != null ) { \nfor ( String innerLine : line . split ( \"\\n\" ) ) { \nmaxLen = Math . max ( innerLine . length ( ) , maxLen ) ; \n} \n} \n} \nint padding = 20 ; \nfloat sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; \nfloat sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; \nfloat lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; \nfloat fontSize = 0.8f * lineHeight ; \nFont font = g . getFont ( ) . deriveFont ( fontSize ) ; \ng . setFont ( font ) ; \nfloat y = fontSize + padding ; \nfor ( String line : lines ) { \nif ( line != null ) { \ng . drawString ( line , padding , y ) ; \ny = y + lineHeight ; \n} \n} \nreturn imageBuffer ; \n} \n} \n"}
{"10944": "public class AbstractHashedMap { \nprotected int hash ( Object key ) { \nint h = key . hashCode ( ) ; \nh = h + ~ ( h << 9 ) ; \nh ^= ( h >>> 14 ) ; \nh = h + ( h << 4 ) ; \nh ^= ( h >>> 10 ) ; \nreturn h ; \n} \n} \n"}
